<?xml version="1.0" encoding="utf-8"?><?xml-stylesheet type="text/xsl" href="https://liuyueyi.github.io/tutorial/atom.xsl"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="zh-CN">
  <id>https://liuyueyi.github.io/tutorial/</id>
  <title>一灰灰的站点</title>
  <subtitle>一灰灰的全网知识站点</subtitle>
  <author>
    <name>一灰灰blog</name>
    <uri>https://hhui.top</uri>
  </author>
  <logo>https://liuyueyi.github.io/tutorial/logo.svg</logo>
  <rights>Copyright by 一灰灰blog</rights>
  <updated>2023-02-16T06:48:27.641Z</updated>
  <generator>vuepress-plugin-feed2</generator>
  <link rel="self" href="https://liuyueyi.github.io/tutorial/atom.xml"/>
  <link rel="alternate" href="https://liuyueyi.github.io/tutorial/"/>
  <category term="Java"/>
  <category term="编程技巧"/>
  <category term="JDK"/>
  <category term="SpringCloud"/>
  <category term="Eureka系列"/>
  <category term="Feign系列"/>
  <category term="采坑记录"/>
  <category term="SpringBoot"/>
  <category term="运维系列"/>
  <category term="Docker"/>
  <category term="中间件"/>
  <category term="Email"/>
  <category term="Prometheus"/>
  <category term="ZooKeeper"/>
  <category term="MQ系列"/>
  <category term="RabbitMq"/>
  <category term="搜索系列"/>
  <category term="ElasticSearch"/>
  <category term="Solr"/>
  <category term="SpringSecurity"/>
  <category term="WEB系列"/>
  <category term="Request"/>
  <category term="Response"/>
  <category term="RestTemplate"/>
  <category term="WebClient"/>
  <contributor>
    <name>一灰灰blog</name>
    <uri>https://hhui.top</uri>
  </contributor>
  <entry>
    <title type="text">Java系列专栏</title>
    <id>https://liuyueyi.github.io/tutorial/java/</id>
    <link href="https://liuyueyi.github.io/tutorial/java/"/>
    <updated>2023-02-16T06:42:50.000Z</updated>
    <summary type="html"><![CDATA[<h2> Java专栏</h2>
<ul>
<li><a href="/tutorial/java/skill/" target="blank">精选实战系列</a></li>
</ul>
]]></summary>
    <content type="html"><![CDATA[<h2> Java专栏</h2>
<ul>
<li><a href="/tutorial/java/skill/" target="blank">精选实战系列</a></li>
</ul>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2023-02-16T06:42:50.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">实战系列</title>
    <id>https://liuyueyi.github.io/tutorial/java/skill/</id>
    <link href="https://liuyueyi.github.io/tutorial/java/skill/"/>
    <updated>2023-02-16T06:42:50.000Z</updated>
    <summary type="html"><![CDATA[<p>实战小技巧，可用于实际编码过程中的 <code>code snippets</code> 带你再日常得编码中写得更加顺畅</p>
]]></summary>
    <content type="html"><![CDATA[<p>实战小技巧，可用于实际编码过程中的 <code>code snippets</code> 带你再日常得编码中写得更加顺畅</p>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2023-02-16T06:42:50.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">10.不可变容器</title>
    <id>https://liuyueyi.github.io/tutorial/java/skill/%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%9710%EF%BC%9A%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%AE%B9%E5%99%A8.html</id>
    <link href="https://liuyueyi.github.io/tutorial/java/skill/%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%9710%EF%BC%9A%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%AE%B9%E5%99%A8.html"/>
    <updated>2023-02-16T06:42:50.000Z</updated>
    <summary type="html"><![CDATA[<h1> 实战10：<code>不可变容器</code></h1>
<p>不可变容器，看着好像在实际的业务中不怎么会用到，但实则不然，相信每个小伙伴都用过，或者看到过下面的代码</p>
<div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">emptyList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">emptyMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>今天我们来介绍一下如何使用不可变容器，以及使用时的注意事项</p>
]]></summary>
    <content type="html"><![CDATA[<h1> 实战10：<code>不可变容器</code></h1>
<p>不可变容器，看着好像在实际的业务中不怎么会用到，但实则不然，相信每个小伙伴都用过，或者看到过下面的代码</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>今天我们来介绍一下如何使用不可变容器，以及使用时的注意事项</p>
<!-- more -->
<h2> 1. 不可变容器</h2>
<h3> 1.1. JDK不可变容器</h3>
<p>java原生提供了一些不可变容器，它们最大的特点就是不支持添加、删除、修改容器内的值</p>
<p><code>Collections.emptyXxx</code>空容器</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面三个是最常用的几个了，通常当我们一个方法的返回结果定义为容器类型时，可能为了避免npe，在返回空容器时，会如此使用</p>
<p>除了上面这几个空的不可变容器之外，还有</p>
<ul>
<li><code>UnmodifiableList</code></li>
<li><code>UnmodifiableMap</code></li>
<li><code>UnmodifiableSet</code></li>
</ul>
<p>它们的使用姿势，通常是借助<code>Collections</code>来实现</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>如上面创建的List，就不支持set/remove等修改操作</p>
<p>使用不可变容容器，最大的好处就是基于它的不可修改特性，来实现公用，且不会被污染</p>
<ul>
<li>所以一个自然而然能想到的应用场景就是 <code>全局共享的配置</code></li>
</ul>
<h3> 1.2. Guava不可变容器</h3>
<p>上面是jdk提供的不可变容器，相比较与它们，在实际的项目中，使用Gauva的不可变容器的可能更多</p>
<ul>
<li><code>ImmutableXxx</code>；不可变容器</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面是最常见的三个容器对应的不可变型</p>
<p>从使用角度来看，初始化非常方便（相比较与jdk版而言）</p>
<h2> 2. 注意事项</h2>
<p>不可变容器虽好，但是使用不当也是很坑的；就我个人的一个观点</p>
<ul>
<li>如果是应用内的接口方法，容器传参，返回容器时，尽量不要使用不可变容器；因为你没办法保证别人拿到你的返回容器之后，会对它进行什么操作</li>
<li>如果是对外提供返回结果，特别是null的场景，使用不可变的空容器优于返回null</li>
<li>不可变容器，用于全局公用资源，共享配置参数；多线程的数据传递时，属于比较合适的场景</li>
</ul>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="Java"/>
    <category term="编程技巧"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2021-08-20T17:59:24.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">11.Map转换的几种方式</title>
    <id>https://liuyueyi.github.io/tutorial/java/skill/%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%9711%EF%BC%9AMap%E8%BD%AC%E6%8D%A2%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F.html</id>
    <link href="https://liuyueyi.github.io/tutorial/java/skill/%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%9711%EF%BC%9AMap%E8%BD%AC%E6%8D%A2%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F.html"/>
    <updated>2023-02-16T06:42:50.000Z</updated>
    <summary type="html"><![CDATA[<h1> 实战11：<code>Map转换Map的几种方式</code></h1>
<p>在日常开发过程中，从一个Map转换为另外一个Map属于基本操作了，那么我们一般怎么去实现这种场景呢？有什么更简洁省事的方法么？</p>
]]></summary>
    <content type="html"><![CDATA[<h1> 实战11：<code>Map转换Map的几种方式</code></h1>
<p>在日常开发过程中，从一个Map转换为另外一个Map属于基本操作了，那么我们一般怎么去实现这种场景呢？有什么更简洁省事的方法么？</p>
<!-- more -->
<h2> 1.Map互转</h2>
<h3> 1.1 实例场景</h3>
<p>现在我们给一个简单的实例</p>
<p>希望将一个<code>Map&lt;String, Integer&gt;</code> 转换成 <code>Map&lt;String, String&gt;</code>，接下来看一下有哪些实现方式，以及各自的优缺点</p>
<p>首先提供一个创建Map的公共方法</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 1.1.1 基本的for循环转换</h4>
<p>这种方式是最容易想到和实现的，直接for循环来转换即可</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这种方式的优点很明显，实现容易，业务直观；</p>
<p>缺点就是可复用性较差，代码量多（相比于下面的case）</p>
<h4> 1.1.2 容器的流式使用</h4>
<p>在jdk1.8提供了流式操作，同样也可以采用这种方式来实现转换</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用stream的方式，优点就是链式，代码量少；缺点是相较于上面的阅读体验会差一些（当然这个取决于个人，有些小伙伴就更习惯看这种链式的代码）</p>
<h4> 1.1.3 Guava的trasform方式</h4>
<p>从代码层面来看，上面两个都不够直观，如果对guava熟悉的小伙伴对下面的代码可能就很熟悉了</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>核心逻辑就一行 <code>Maps.transformValues(map, String::valueOf)</code>，实现了我们的Map转换的诉求</p>
<p>很明显，这种方式的优点就是间接、直观；当然缺点就是需要引入guava，并且熟悉guava</p>
<h3> 1.2 最后一问，这篇文章目的是啥？</h3>
<p>既然我们的标题是实战小技巧，本文除了给大家介绍可以使用guava的<code>Maps.transformValues</code>来实现map转换之外，更主要的一个目的是如果让我们自己来实现一个工具类，来支持这个场景，应该怎么做？</p>
<p>直接提供一个转换方法？</p>
<p><strong>第一步：一个泛型的转换接口</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>定义上面这个接口之后，自然而然想到的缺点就是差一个value的转换实现</p>
<p><strong>第二步：value转换的定义</strong></p>
<p>这里采用Function接口思想来定义转换类</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>当然到这里我们就需要注意jdk1.8以下是不支持函数编程的，那么我们可以怎么来实现呢？</p>
<p>这个时候再对照一下guava的实现，然后再手撸一个，知识点就到手了</p>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="Java"/>
    <category term="编程技巧"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2021-11-02T19:43:19.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">12.巧用函数方法实现二维数组遍历</title>
    <id>https://liuyueyi.github.io/tutorial/java/skill/%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%9712%EF%BC%9A%E5%B7%A7%E7%94%A8%E5%87%BD%E6%95%B0%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E9%81%8D%E5%8E%86.html</id>
    <link href="https://liuyueyi.github.io/tutorial/java/skill/%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%9712%EF%BC%9A%E5%B7%A7%E7%94%A8%E5%87%BD%E6%95%B0%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E9%81%8D%E5%8E%86.html"/>
    <updated>2023-02-16T06:42:50.000Z</updated>
    <summary type="html"><![CDATA[<h1> 实战12：巧用函数方法实现二维数组遍历</h1>
<p>对于数组遍历，基本上每个开发者都写过，遍历本身没什么好说的，但是当我们在遍历的过程中，有一些复杂的业务逻辑时，将会发现代码的层级会逐渐加深</p>
]]></summary>
    <content type="html"><![CDATA[<h1> 实战12：巧用函数方法实现二维数组遍历</h1>
<p>对于数组遍历，基本上每个开发者都写过，遍历本身没什么好说的，但是当我们在遍历的过程中，有一些复杂的业务逻辑时，将会发现代码的层级会逐渐加深</p>
<!-- more -->
<p>如一个简单的case，将一个二维数组中的偶数找出来，保存到一个列表中</p>
<p>二维数组遍历，每个元素判断下是否为偶数，很容易就可以写出来，如</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这个实现没啥问题，但是这个代码的深度很容易就有三层了；当上面这个if中如果再有其他的判定条件，那么这个代码层级很容易增加了；二维数组还好，如果是三维数组，一个遍历就是三层；再加点逻辑，四层、五层不也是分分钟的事情么</p>
<p>那么问题来了，代码层级变多之后会有什么问题呢？</p>
<blockquote>
<p>只要代码能跑，又能有什么问题呢？！</p>
</blockquote>
<h2> 1. 函数方法消减代码层级</h2>
<p>由于多维数组的遍历层级天然就很深，那么有办法进行消减么？</p>
<p>要解决这个问题，关键是要抓住重点，遍历的重点是什么？获取每个元素的坐标！那么我们可以怎么办？</p>
<blockquote>
<p>定义一个函数方法，输入的就是函数坐标，在这个函数体中执行我们的遍历逻辑即可</p>
</blockquote>
<p>基于上面这个思路，相信我们可以很容易写一个二维的数组遍历通用方法</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>主要上面的实现，函数方法直接使用了JDK默认提供的BiConsumer，两个传参，都是int 数组下表；无返回值</p>
<p>那么上面这个怎么用呢？</p>
<p>同样是上面的例子，改一下之后，如</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>相比于前面的，貌似也就少了一层而已，好像也没什么了不起的</p>
<p>但是，当数组变为三维、四维、无维时，这个改动的写法层级都不会变哦</p>
<h2> 2. 遍历中return支持</h2>
<p>前面的实现对于正常的遍历没啥问题；但是当我们在遍历过程中，遇到某个条件直接返回，能支持么？</p>
<p>如一个遍历二维数组，我们希望判断其中是否有偶数，那么可以怎么整？</p>
<p>仔细琢磨一下我们的scan方法，希望可以支持return，主要的问题点就是这个函数方法执行之后，我该怎么知道是继续循环还是直接return呢?</p>
<p>很容易想到的就是执行逻辑中，添加一个额外的返回值，用于标记是否中断循环直接返回</p>
<p>基于此思路，我们可以实现一个简单的demo版本</p>
<p>定义一个函数方法，接受循环的下标 + 返回值</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>循环通用方法就可以相应的改成</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>基于上面这种思路，我们的实际使用姿势如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这个实现可满足我们的需求，唯一有个别扭的地方就是返回，总有点不太优雅；那么除了这种方式之外，还有其他的方式么？</p>
<p>既然考虑了返回值，那么再考虑一下传参呢？通过一个定义的参数来装在是否中断以及返回结果，是否可行呢？</p>
<p>基于这个思路，我们可以先定义一个参数包装类</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们希望通过Ans这个类来记录循环结果，其中tag=true，则表示不用继续循环了，直接返回ans结果吧</p>
<p>与之对应的方法改造及实例如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样看起来就比前面的要好一点了</p>
<p>实际跑一下，看下输出是否和我们预期的一致；</p>
<figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/546a699ae4334df4b6525332da4e5770~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="Java"/>
    <category term="编程技巧"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2022-08-09T18:35:40.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">13.List转Map List的几种姿势</title>
    <id>https://liuyueyi.github.io/tutorial/java/skill/%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%9713%EF%BC%9AList%E8%BD%ACMap-List%E7%9A%84%E5%87%A0%E7%A7%8D%E5%A7%BF%E5%8A%BF.html</id>
    <link href="https://liuyueyi.github.io/tutorial/java/skill/%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%9713%EF%BC%9AList%E8%BD%ACMap-List%E7%9A%84%E5%87%A0%E7%A7%8D%E5%A7%BF%E5%8A%BF.html"/>
    <updated>2023-02-16T06:42:50.000Z</updated>
    <summary type="html"><![CDATA[<h1> 实战13：List转Map List的几种姿势</h1>
<p>今天介绍一个实用的小知识点，如何将List转为<code>Map&lt;Object, List&lt;Object&gt;&gt;</code></p>
]]></summary>
    <content type="html"><![CDATA[<h1> 实战13：List转Map List的几种姿势</h1>
<p>今天介绍一个实用的小知识点，如何将List转为<code>Map&lt;Object, List&lt;Object&gt;&gt;</code></p>
<!-- more -->
<h2> 1. 转换方式</h2>
<h3> 1.1. 基本写法</h3>
<p>最开始介绍的当然是最常见、最直观的写法，当然也是任何限制的写法</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对于jdk8+，上面for循环中的内容可以利用<code>Map.computeIfAbsent</code>来替换，具体写法如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当然既然已经是jdk1.8了，借助Stream的流处理，可以将上面的更一步进行简化，如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 1.2. 通用方法</h3>
<p>上面是针对特定的列表，针对业务进行开发转换，那么我们接下来尝试构建一个通用的工具类</p>
<p>这里我们主要借助的知识点就是泛型，一个重要的点就是如何获取Map中的key</p>
<p>对于jdk &lt; 1.8的写法，通过接口来定义实现key的获取姿势</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用demo如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来再看一下jdk1.8之后的写法，结合stream + 函数方法来实现</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其对应的使用方式则如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1.3. 工具类</h3>
<p>上一节介绍了基于泛型 + jdk8 Stream + 函数方法来实现通用转换工具类的实现姿势，接下来我们小结一下，输出一个适用于1.8之后的工具类</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1.4.guava HashMultimap扩展知识点</h3>
<p>最后再介绍一个扩展知识点，Gauva工具包中提供了一个<code>HashMultimap</code>的工具类，他的使用姿势和我们平常的Map并无差别，但是需要在注意的是，它的value是个集合</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>实际输出如下，验证了value实际上是个集合（on只有一个，如果是我们上面的工具类，会输出两个）</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div>]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="Java"/>
    <category term="编程技巧"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2022-05-17T19:44:20.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">14.分页遍历的两种使用姿势</title>
    <id>https://liuyueyi.github.io/tutorial/java/skill/%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%9714%EF%BC%9A%E5%88%86%E9%A1%B5%E9%81%8D%E5%8E%86%E7%9A%84%E4%B8%A4%E7%A7%8D%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF.html</id>
    <link href="https://liuyueyi.github.io/tutorial/java/skill/%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%9714%EF%BC%9A%E5%88%86%E9%A1%B5%E9%81%8D%E5%8E%86%E7%9A%84%E4%B8%A4%E7%A7%8D%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF.html"/>
    <updated>2023-02-16T06:42:50.000Z</updated>
    <summary type="html"><![CDATA[<h1> 实战14：分页遍历得两种实现策略</h1>
<p>在日常开发中，分页遍历迭代的场景可以说非常普遍了，比如扫表，每次捞100条数据，然后遍历这100条数据，依次执行某个业务逻辑；这100条执行完毕之后，再加载下一百条数据，直到扫描完毕</p>
<p>那么要实现上面这种分页迭代遍历的场景，我们可以怎么做呢</p>
<p>本文将介绍两种使用姿势</p>
<ul>
<li>常规的使用方法</li>
<li>借助Iterator的使用姿势</li>
</ul>
]]></summary>
    <content type="html"><![CDATA[<h1> 实战14：分页遍历得两种实现策略</h1>
<p>在日常开发中，分页遍历迭代的场景可以说非常普遍了，比如扫表，每次捞100条数据，然后遍历这100条数据，依次执行某个业务逻辑；这100条执行完毕之后，再加载下一百条数据，直到扫描完毕</p>
<p>那么要实现上面这种分页迭代遍历的场景，我们可以怎么做呢</p>
<p>本文将介绍两种使用姿势</p>
<ul>
<li>常规的使用方法</li>
<li>借助Iterator的使用姿势</li>
</ul>
<!-- more -->
<h2> 1. 实现方式</h2>
<h3> 1.1. 数据查询模拟</h3>
<p>首先mock一个分页获取数据的逻辑，直接随机生成数据，并且控制最多返回三页</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1.2. 基本实现方式</h3>
<p>针对这种场景，最常见也是最简单直观的实现方式</p>
<ul>
<li>while死循环</li>
<li>内部遍历</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1.3. 迭代器实现方式</h3>
<p>接下来介绍一种更有意思的方式，借助迭代器的遍历特性来实现，首先自定义一个通用分页迭代器</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来借助上面的迭代器可以比较简单的实现我们的需求了</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>那么问题来了，上面这种使用方式比前面的优势体现再哪儿呢？</p>
<ul>
<li>双层循环改为单层循环</li>
</ul>
<p>接下来接入重点了，在jdk1.8引入了函数方法 + lambda之后，又提供了一个更简洁的使用姿势</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在jdk1.8及之后的使用姿势，一行代码即可</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这次对比效果是不是非常显眼了，从此以后分页迭代遍历再也不用冗长的双重迭代了</p>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="Java"/>
    <category term="JDK"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2021-02-25T08:05:07.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">15.数组拷贝</title>
    <id>https://liuyueyi.github.io/tutorial/java/skill/%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%9715%EF%BC%9A%E6%95%B0%E7%BB%84%E6%8B%B7%E8%B4%9D.html</id>
    <link href="https://liuyueyi.github.io/tutorial/java/skill/%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%9715%EF%BC%9A%E6%95%B0%E7%BB%84%E6%8B%B7%E8%B4%9D.html"/>
    <updated>2023-02-16T06:42:50.000Z</updated>
    <summary type="html"><![CDATA[<h1> 实战15：<strong><code>数组拷贝</code></strong></h1>
<p>说实话，在实际的业务开发中，基本上很少很少很少...会遇到数组拷贝的场景，甚至是我们一般都不怎么用数组，List它不香嘛，为啥要用数组</p>
<p>现在问题来了，要实现数组拷贝，怎么整？</p>
]]></summary>
    <content type="html"><![CDATA[<h1> 实战15：<strong><code>数组拷贝</code></strong></h1>
<p>说实话，在实际的业务开发中，基本上很少很少很少...会遇到数组拷贝的场景，甚至是我们一般都不怎么用数组，List它不香嘛，为啥要用数组</p>
<p>现在问题来了，要实现数组拷贝，怎么整？</p>
<!-- more -->
<h2> 1. 实现方式</h2>
<h3> 1.1. 基础写法</h3>
<p>最简单直接的写法，那就是新建一个数组，一个一个拷贝进去，不就完事了么</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1.2. 借用容器中转</h3>
<p>数组用起来有点麻烦，还是用容器舒爽，借助List来实现数组的拷贝，也就几行代码</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1.3. Array.copy</h3>
<p>上面这个有点绕得远了， 直接使用Array.copy</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1.4. System.arraycopy</h3>
<p>除了上面的，还可以使用更基础的用法</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果有看过jdk源码的小伙伴，上面这个用法应该不会陌生，特别是在容器类，这种数组拷贝的方式比比可见</p>
<p>参数说明:</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>src : 原数组</li>
<li>srcPos: 原数组用于拷贝的起始下标</li>
<li>dest: 拷贝后的数组</li>
<li>destPos: 目标数组的小标</li>
<li>length: 原数组中拷贝过去的数组长度</li>
</ul>
<p>从上面的描述也能看出来，这个方法不仅能实现数组拷贝，还可以实现数组内指定片段的拷贝</p>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="Java"/>
    <category term="编程技巧"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2021-08-21T06:56:34.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">16.如何判断类为基础类型or基础类型的包装类</title>
    <id>https://liuyueyi.github.io/tutorial/java/skill/%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%9716%EF%BC%9A%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E7%B1%BB%E4%B8%BA%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8Bor%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8C%85%E8%A3%85%E7%B1%BB.html</id>
    <link href="https://liuyueyi.github.io/tutorial/java/skill/%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%9716%EF%BC%9A%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E7%B1%BB%E4%B8%BA%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8Bor%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8C%85%E8%A3%85%E7%B1%BB.html"/>
    <updated>2023-02-16T06:42:50.000Z</updated>
    <summary type="html"><![CDATA[<blockquote>
<h1> 实战16：<strong><code>判断类为基础类型or基础类型的包装类</code></strong></h1>
</blockquote>
<p>判断一个类是否为基础类型属于常规操作了，一般我们遇到这种case，要怎么处理呢？</p>
<p>一个一个的if/else判断? 还是其他的操作姿势？</p>
]]></summary>
    <content type="html"><![CDATA[<blockquote>
<h1> 实战16：<strong><code>判断类为基础类型or基础类型的包装类</code></strong></h1>
</blockquote>
<p>判断一个类是否为基础类型属于常规操作了，一般我们遇到这种case，要怎么处理呢？</p>
<p>一个一个的if/else判断? 还是其他的操作姿势？</p>
<!-- more -->
<h2> 1. 基础类型判断</h2>
<p>基础类型可以借助class类的<code>isPrimitive</code>方法来实现判定，使用姿势也简单</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>如果返回true，那么这个对象就是基本类型</p>
<ul>
<li>boolean</li>
<li>char</li>
<li>byte</li>
<li>short</li>
<li>int</li>
<li>long</li>
<li>float</li>
<li>double</li>
<li>void</li>
</ul>
<p>但是请注意，对于封装类型，比如Long，访问isPrimitive返回的是false</p>
<h2> 2. 封装类型判断</h2>
<p>那么封装类型可以怎么判断呢？难道一个一个的判定不成？</p>
<p>首先我们注意到<code>Class#isPrimitive</code>的方法签名，如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的注释中，提到了Boolean#Type之类的静态成员，也就是说包装类型，都有一个TYPE的静态成员</p>
<p>比如boolean的是这个</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>所以我们可以通过这个TYPE来判定，当前对象是否为封装对象</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果Class对象没有TYPE字段，那么就不是封装类，直接抛异常，返回false；当然这种通过异常的方式来判定，并不优雅；但是写法上比我们一个一个的if/else进行对比，要好得多了</p>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="Java"/>
    <category term="编程技巧"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2021-09-03T19:36:52.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">17.Java对象内存地址输出</title>
    <id>https://liuyueyi.github.io/tutorial/java/skill/%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%9717%EF%BC%9AJava%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80%E8%BE%93%E5%87%BA.html</id>
    <link href="https://liuyueyi.github.io/tutorial/java/skill/%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%9717%EF%BC%9AJava%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80%E8%BE%93%E5%87%BA.html"/>
    <updated>2023-02-16T06:42:50.000Z</updated>
    <summary type="html"><![CDATA[<h1> 实战17：<strong>Java对象内存地址输出</strong></h1>
<h2> 输出对象地址</h2>
<p>当一个对象没有重写<code>hascode</code>方法时，它返回的内存地址，当覆盖之后，我们有什么办法获取对象的内存地址么?</p>
<ul>
<li>使用 <code>System.identityHashCode()</code> 输出内存地址</li>
</ul>
]]></summary>
    <content type="html"><![CDATA[<h1> 实战17：<strong>Java对象内存地址输出</strong></h1>
<h2> 输出对象地址</h2>
<p>当一个对象没有重写<code>hascode</code>方法时，它返回的内存地址，当覆盖之后，我们有什么办法获取对象的内存地址么?</p>
<ul>
<li>使用 <code>System.identityHashCode()</code> 输出内存地址</li>
</ul>
<!-- more -->
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果如:</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这个有啥用？</p>
<ul>
<li>判断两个对象是否为同一个对象时，可以借用（我是在验证Mybatis的一级缓存的，判断返回的Entity是否确实是同一个的时候以此来判定的）</li>
</ul>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="Java"/>
    <category term="JDK"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2021-01-29T10:37:36.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">18.随机数生成怎么选</title>
    <id>https://liuyueyi.github.io/tutorial/java/skill/%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%9718%EF%BC%9A%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%94%9F%E6%88%90%E6%80%8E%E4%B9%88%E9%80%89.html</id>
    <link href="https://liuyueyi.github.io/tutorial/java/skill/%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%9718%EF%BC%9A%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%94%9F%E6%88%90%E6%80%8E%E4%B9%88%E9%80%89.html"/>
    <updated>2023-02-16T06:42:50.000Z</updated>
    <summary type="html"><![CDATA[<h1> 实战18：<strong><code>随机数生成怎么选</code></strong></h1>
<p>随机数生成，java中有一个专门的Random类来实现，除此之外，使用<code>Math.random</code>的也比较多，接下来我们简单学习下，随机数的使用姿势</p>
]]></summary>
    <content type="html"><![CDATA[<h1> 实战18：<strong><code>随机数生成怎么选</code></strong></h1>
<p>随机数生成，java中有一个专门的Random类来实现，除此之外，使用<code>Math.random</code>的也比较多，接下来我们简单学习下，随机数的使用姿势</p>
<!-- more -->
<h2> 1.随机数生成</h2>
<h3> 1.1. Math.random</h3>
<p>jdk提供的基础工具类Math中封装一些常用的基础方法，比如我们今天的主题，生成随机数，使用姿势如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>使用起来比较简单，生成的是[0,1)之间的浮点数，但是不要以为它就真的只能生成0-1之间的随机数，举例如下</p>
<p>如果想利用它，生成一个 <code>[120, 500]</code> 这个区间的随机数，怎么整？</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>为啥上面的可行？</p>
<p>将上面的代码翻译一下，取值区间如</p>
<p><code>Math.random() * 381 + 120</code> 取值范围如下</p>
<ul>
<li>[0, 1) * 381 + 120</li>
<li>[0, 381) + 120</li>
<li>[120, 501)</li>
</ul>
<p>借助<code>Math.ceil</code>只取浮点数中的整数部分，这样我们的取值范围就是 [120, 500]了，和我们的预期一致</p>
<p>最后简单来看下，<code>Math.random()</code>是怎么实现随机数的</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>请注意上面的实现，原来底层依然使用的是<code>Random</code>类来生成随机数，而且上面这种写法属于非常经典的单例模式写法（不同于我们常见的双重判定方式，这种属于内部类的玩法，后面再说为啥可以这么用）</p>
<h3> 1.2. Random</h3>
<p>除了使用上面的Math.random来获取随机数之外，直接使用Random类也是很常见的case；接下来先简单看一下Random的使用姿势</p>
<p><strong>创建Random对象</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>生成随机数</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>伪随机高斯分布双精度数</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>随机类的nextGaussian()方法返回下一个伪随机数，即与随机数生成器序列的平均值为0.0，标准差为1.0的高斯(正态)分布双精度值</p>
<p>这种使用场景可能用在更专业的场景，至少我接触过的业务开发中，没有用过这个😂</p>
<h3> 1.3. Math.random 与 Random如何选</h3>
<p>上面两个都可以用来生成随机数，那么在实际使用的时候，怎么选择呢？</p>
<p>从前面的描述也可以知道，它们两没啥本质区别，底层都是用的Random类，在实际的运用过程中，如果我们希望可以场景复现，比如测试中奖概率的场景下，选择Random类，指定随机种子可能更友好；如果只是简单的随机数生成使用，那么选择<code>Math.random</code>即可，至少使用起来一行代码即可</p>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="Java"/>
    <category term="编程技巧"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2021-09-03T19:40:13.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">19.数字格式化</title>
    <id>https://liuyueyi.github.io/tutorial/java/skill/%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%9719%EF%BC%9A%E6%95%B0%E5%AD%97%E6%A0%BC%E5%BC%8F%E5%8C%96.html</id>
    <link href="https://liuyueyi.github.io/tutorial/java/skill/%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%9719%EF%BC%9A%E6%95%B0%E5%AD%97%E6%A0%BC%E5%BC%8F%E5%8C%96.html"/>
    <updated>2023-02-16T06:42:50.000Z</updated>
    <summary type="html"><![CDATA[<h1> 实战19：<strong><code>数字格式化</code></strong></h1>
<p>数字的格式化场景，更多的是在日志输出、金额计算相关的领域中会用到，平常我们可能更多使用<code>String.format</code>来格式化，但是请注意，数字格式化是有一个<code>DecimalFormat</code>，专门来针对数字进行格式化</p>
<p>今天我们的知识点就是DecimalFormat来实现数字格式化</p>
]]></summary>
    <content type="html"><![CDATA[<h1> 实战19：<strong><code>数字格式化</code></strong></h1>
<p>数字的格式化场景，更多的是在日志输出、金额计算相关的领域中会用到，平常我们可能更多使用<code>String.format</code>来格式化，但是请注意，数字格式化是有一个<code>DecimalFormat</code>，专门来针对数字进行格式化</p>
<p>今天我们的知识点就是DecimalFormat来实现数字格式化</p>
<!-- more -->
<h2> 1. 格式化</h2>
<h3> 1.1. DecimalFormat使用说明</h3>
<p>对于DecimalFormat的使用比较简单，主要是借助两个占位<code>0</code>与<code>#</code>，区别在于当格式化的占位数，多余实际数的时候，占位<code>0</code>的场景下，会用前缀0来补齐；而<code>#</code>则不需要补齐</p>
<p>上面这个可能不太好理解，举例说明如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面两个都是只输出整数，但是输出结果不同，如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>简单来说，就是<code>0</code>，主要用于定长的输出，对于不足的，前缀补0</p>
<p><strong>整数#小数</strong></p>
<p>除了上面的基本姿势之外，更常见的是设置整数、小数的位数</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>百分比</strong></p>
<p>百分比的输出也属于常见的case，使用DecimalFormat就很简单</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>输出如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>科学计数</strong></p>
<p>非专业场景下，科学技术的可能性比较小</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>金钱样式输出</strong></p>
<p>金融相关的钱输出时，非常有意思的是每三位加一个逗号分隔，如果想实现这个效果，也可以很简单完成</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>嵌入模板输出</strong></p>
<p>格式化模板，除了基础的<code>000, ###</code>之外，还可以直接放在一个字符串中，实现类似<code>String.format</code>的效果</p>
<p>比如显示余额</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div>]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="Java"/>
    <category term="编程技巧"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2021-08-25T19:12:33.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">1.字符串占位替换</title>
    <id>https://liuyueyi.github.io/tutorial/java/skill/%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%971%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8D%A0%E4%BD%8D%E6%9B%BF%E6%8D%A2.html</id>
    <link href="https://liuyueyi.github.io/tutorial/java/skill/%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%971%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8D%A0%E4%BD%8D%E6%9B%BF%E6%8D%A2.html"/>
    <updated>2023-02-16T06:42:50.000Z</updated>
    <summary type="html"><![CDATA[<h1> 实战系列1：字符串占位替换</h1>
<p>字符串占位替换，相信没有小伙伴是陌生的，这东西可以说是伴随着我们所有的项目工程，编码过程；别不相信，如</p>
<ul>
<li>String.format</li>
<li>sql参数拼接的占位</li>
<li>log日志输出</li>
</ul>
<p>接下来我们看一下在我们的日常工作生涯中，经常涉及到的几种占位替换方式</p>
]]></summary>
    <content type="html"><![CDATA[<h1> 实战系列1：字符串占位替换</h1>
<p>字符串占位替换，相信没有小伙伴是陌生的，这东西可以说是伴随着我们所有的项目工程，编码过程；别不相信，如</p>
<ul>
<li>String.format</li>
<li>sql参数拼接的占位</li>
<li>log日志输出</li>
</ul>
<p>接下来我们看一下在我们的日常工作生涯中，经常涉及到的几种占位替换方式</p>
<!-- more -->
<h2> 1. String.format</h2>
<p>这种可以说是最原始最基础的方式了，基本上在最开始学习java这门语言的时候就会涉及到，语法也比较简单</p>
<p>举例如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>使用<code>%</code>来表示占位，后面跟上不同的标识符，用于限定这个占位处的参数类型</p>
<p>这种使用姿势，由jdk原生提供支持，下表为不同的转换符对应的说明</p>
<table>
<thead>
<tr>
<th>转换符</th>
<th>说明</th>
<th>参数实例</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>%s</code></td>
<td>字符串替换</td>
<td>"一灰灰"</td>
</tr>
<tr>
<td><code>%c</code></td>
<td>字符类型</td>
<td>'a'</td>
</tr>
<tr>
<td><code>%b</code></td>
<td>布尔类型</td>
<td>true/false</td>
</tr>
<tr>
<td><code>%d</code></td>
<td>整数，十进制</td>
<td>10</td>
</tr>
<tr>
<td><code>%x</code></td>
<td>整数，十六进制</td>
<td>0x12</td>
</tr>
<tr>
<td><code>%o</code></td>
<td>整数，八进制</td>
<td>012</td>
</tr>
<tr>
<td><code>%f</code></td>
<td>浮点</td>
<td>0.12f</td>
</tr>
<tr>
<td><code>%e</code></td>
<td>指数</td>
<td>2e2</td>
</tr>
<tr>
<td><code>%g</code></td>
<td>通用浮点型</td>
<td></td>
</tr>
<tr>
<td><code>%h</code></td>
<td>散列</td>
<td></td>
</tr>
<tr>
<td><code>%%</code></td>
<td>百分比</td>
<td></td>
</tr>
<tr>
<td><code>%n</code></td>
<td>换行</td>
<td></td>
</tr>
<tr>
<td><code>%tx</code></td>
<td>日期与时间类型（x代表不同的日期与时间转换符</td>
<td></td>
</tr>
</tbody>
</table>
<p>虽然上面表中列出了很多，但实际使用时，<code>%s</code>, <code>%d</code>, <code>%f</code> 这三个就足以应付绝大部分的场景了；使用姿势和上面的实例参不多，第一个参数为字符串模板，后面的可变参数为待替换的值</p>
<p>下面是在实际使用过程中的注意事项</p>
<h3> 1.1 类型不匹配</h3>
<p>上面的表中介绍了不同的转换符，要求的参数类型，如果没有对应上，会怎样</p>
<p><strong><code>%s</code>，传入非字符串类型</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>也就是说，<code>%s</code>的占位标记，传参如果不是String类型，那么实际替换的是 <code>arg.toString()</code> (所以数组输出的是地址，而list输出了内容)</p>
<p><strong><code>%d</code>，传入非整数</strong></p>
<p>与字符串的不一样的是，如果我们定义要求替换的参数类型为整数，那么传参不是整数，就会抛异常</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这两个，一个传入的参数为浮点，一个传入的是字符串，在实际替换的时候，可不会调用<code>Integer.valufOf(String.valueOf(xxx))</code>来强转，而是采用更直接的方式，抛异常</p>
<p>关键的提示信息如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>因此在实际使用这种方式进行替换时，推荐选择 <code>%s</code>，毕竟兼容性更好</p>
<h3> 1.2 参数个数不匹配</h3>
<p>我们会注意到,<code>String.format</code>接收的参数是不定长的，那么就可能存在字符串模板中预留的占位与实际传入的参数个数不匹配的场景，那么出现这种场景时，会怎样</p>
<p><strong>参数缺少</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面的例子中，模板要求两个，实际只传入一个参数，会直接抛异常<code>MissingFormatArgumentException</code></p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>参数过多</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>执行正常，多余的参数不会被替换</p>
<p>因此，我们在使用<code>String.format</code>进行字符串替换时，请确保传参不要少于实际定义的参数个数；多了还好，少了就会抛异常</p>
<h2> 2. MessageFormat</h2>
<p>上面介绍的String.format虽说简单好用，但我们用多之后，自然会遇到，一个参数，需要替换模板中多个占位的场景，针对这种场景，更友好的方式是<code>MessageFormat</code>，这个也是jdk原生提供的</p>
<p>我们来简单看一下它的使用姿势</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>使用<code>{数字}</code>来表示占位，其中数字对应的是传参的下标，因此当一个参数需要复用时，使用MessageFormat就可以比较简单的实现了，上面就是一个实例，替换之后的字符串为</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>接下来说一下它使用时的注意事项</p>
<h3> 2.1 {}成对出现</h3>
<p>如果字符串中，只出现一个<code>{</code>，而没有配套的<code>}</code>，会抛异常</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>注意上面两种case，上面一个是有<code>}</code>而缺少<code>{</code>，这样是没有问题的；而下面那个则会抛异常</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>如果字符串中却是希望输出<code>{</code>，可以使用单引号来处理</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 2.2 单引号</h3>
<p>上面提到需要转移时，可以用单引号进行处理，在字符串模板的定义中，如果有单引号，需要各位注意</p>
<p><strong>只有一个单引号，会导致后面所有占位都不生效</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面这个输出结果可能和我们实际希望的不一致</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>要解决上面这个，就是使用两个单引号</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这样输出的就是我们预期的</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 2.3 序号省略</h3>
<p>上面的定义中，已经明确要求我们在<code>{}</code>中指定参数的序号，如果模板中没有指定会怎样?</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>直接抛异常</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2> 3. 小结</h2>
<p>本文介绍的实战小技巧属于是jdk原生提供的两种实现字符串占位替换的方式，除了这两个之外，我们日常开发中还会遇到其他的占位替换方式</p>
<p>比如sql的<code>?</code>替换，mybatis中sql参数组装使用<code>${paramName}</code>，或者logback日志输出中的<code>{}</code>来表示占位，spring的@Value注解声明的配置注入方式<code>${name:defaultValue}</code>，这些也都属于占位替换的范畴，那么它们又是怎么实现的呢？</p>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="Java"/>
    <category term="编程技巧"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2021-08-09T08:53:46.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">20.进制转换很简单</title>
    <id>https://liuyueyi.github.io/tutorial/java/skill/%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%9720%EF%BC%9A%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2%E5%BE%88%E7%AE%80%E5%8D%95.html</id>
    <link href="https://liuyueyi.github.io/tutorial/java/skill/%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%9720%EF%BC%9A%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2%E5%BE%88%E7%AE%80%E5%8D%95.html"/>
    <updated>2023-02-16T06:42:50.000Z</updated>
    <summary type="html"><![CDATA[<h1> 实战20：<strong><code>进制转换很简单</code></strong></h1>
<p>进制转换，属于基本技能了，在java中要实现进制转换很简单，可以非常简单的实现，接下来我们来看下它的使用姿势</p>
]]></summary>
    <content type="html"><![CDATA[<h1> 实战20：<strong><code>进制转换很简单</code></strong></h1>
<p>进制转换，属于基本技能了，在java中要实现进制转换很简单，可以非常简单的实现，接下来我们来看下它的使用姿势</p>
<!-- more -->
<h2> 1. 进制转换</h2>
<h3> 1.1. toString实现进制转换</h3>
<p>Integer/Long#toString(int i, int radix) 可以将任一进制的整数，转换为其他任意进制的整数</p>
<ul>
<li>第一个参数：待转换的数字</li>
<li>第二个参数：转换后的进制位</li>
</ul>
<p><strong>十六进制转十进制</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>八进制转是十进制</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>八进制转二进制</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 1.2. 十进制转二进制</h3>
<p>除了使用上面的姿势之外，可以直接使用<code>toBinaryString</code>来实现转二进制</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1.3. 十进制转八进制</h3>
<p><code>Integer/Long#toOctalString</code>: 转八进制</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 1.4. 十进制转十六进制</h3>
<p><code>Integer/Long#toHexString</code>: 转十六进制</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div>]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="Java"/>
    <category term="编程技巧"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2021-08-26T18:24:38.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">21.配置文件Properties</title>
    <id>https://liuyueyi.github.io/tutorial/java/skill/%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%9721%EF%BC%9A%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6Properties.html</id>
    <link href="https://liuyueyi.github.io/tutorial/java/skill/%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%9721%EF%BC%9A%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6Properties.html"/>
    <updated>2023-02-16T06:42:50.000Z</updated>
    <summary type="html"><![CDATA[<h1> 实战21：<strong><code>Properties配置文件</code></strong></h1>
<p>properties配置文件，相信各位小伙伴都不会太陌生，常用Spring的可能会经常看到它，虽说现在更推荐的是使用Yaml配置文件，但是properties配置文件的使用频率也不低</p>
<p>在jdk中有一个直接关连的类Properties，接下来我们来看一下它的用法</p>
]]></summary>
    <content type="html"><![CDATA[<h1> 实战21：<strong><code>Properties配置文件</code></strong></h1>
<p>properties配置文件，相信各位小伙伴都不会太陌生，常用Spring的可能会经常看到它，虽说现在更推荐的是使用Yaml配置文件，但是properties配置文件的使用频率也不低</p>
<p>在jdk中有一个直接关连的类Properties，接下来我们来看一下它的用法</p>
<!-- more -->
<h2> 1. Properties配置类</h2>
<h3> 1.1. 配置文件</h3>
<p>properties文件的格式比较简单</p>
<ul>
<li><code>key = value</code>: 等号左边的为配置key，右边的为配置value（value值会去除前后的空格）</li>
<li><code>#</code>：以<code>#</code>来区分注释</li>
</ul>
<p>一个基础的配置文件如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1.2. 配置文件加载</h3>
<p>对于Properties配置文件，我们可以非常简单的借助<code>Properties</code>类，来实现配置的加载</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>直接使用<code>Properties#config</code>就可以读取配置文件内容，并赋值到java对象</p>
<p><strong>重点注意：</strong></p>
<p>重点看一下Properties类的继承关系，它的父类是Hashtable, 也就是说它的本质是Map对象</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1.3. Properties对象使用</h3>
<p>因为<code>Properties</code>是继承自Hashtable，而Hashtable是线程安全的Map容器，因此Properties也是线程安全的，同样的，在多线程并发获取配置的时候，它的性能表现也就不咋地了，why?</p>
<p>首先看一下配置获取</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面两个方法的使用频率很高，从签名上也很容易知道使用姿势；接下来需要看一下的为啥说并发效率很低</p>
<p>关键点就在第一个方法的<code>super.get()</code>，它对应的源码正是</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>方法签名上有<code>synchronized</code>，所以为啥说并发环境下的性能表现不会特别好也就知道原因了</p>
<p>除了获取配置之外，另外一个常用的就是更新配置</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 2. 小结</h2>
<p>本文介绍的知识点主要是properties配置文件的处理，使用同名的java类来操作；需要重点注意的是Properties类属于Hashtable的子类，同样属于容器的范畴</p>
<p>最后提一个扩展的问题，在SpringBoot的配置自动装载中，可以将配置内容自动装载到配置类中，简单来讲就是支持配置到java bean的映射，如果现在让我们来实现这个，可以怎么整？</p>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="Java"/>
    <category term="编程技巧"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2021-08-30T09:34:18.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">22.Properties配置文件自动装载JavaBean</title>
    <id>https://liuyueyi.github.io/tutorial/java/skill/%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%9722%EF%BC%9AProperties%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%87%AA%E5%8A%A8%E8%A3%85%E8%BD%BDJavaBean.html</id>
    <link href="https://liuyueyi.github.io/tutorial/java/skill/%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%9722%EF%BC%9AProperties%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%87%AA%E5%8A%A8%E8%A3%85%E8%BD%BDJavaBean.html"/>
    <updated>2023-02-16T06:42:50.000Z</updated>
    <summary type="html"><![CDATA[<h1> 实战22：<strong><code>Properties配置文件自动装载JavaBean</code></strong></h1>
<p>SpringBoot的配置自动装载，使用起来还是很舒爽的，可以非常简单的将properties配置文件的内容，填充到Java bean对象中，如果我们现在是一个脱离于Springboot框架的项目，想实现上面这个功能，可以怎么来做呢？</p>
]]></summary>
    <content type="html"><![CDATA[<h1> 实战22：<strong><code>Properties配置文件自动装载JavaBean</code></strong></h1>
<p>SpringBoot的配置自动装载，使用起来还是很舒爽的，可以非常简单的将properties配置文件的内容，填充到Java bean对象中，如果我们现在是一个脱离于Springboot框架的项目，想实现上面这个功能，可以怎么来做呢？</p>
<!-- more -->
<h2> 1.配置封装</h2>
<h3> 1.1. 配置文件自动装载</h3>
<p>前面介绍了Properties文件的读取以及基本使用姿势，通过上篇博文已知Properties类的本质是一个Map，所以我们需要干的就是将Map容器的值，赋值到JavaBean的成员属性中</p>
<p>要实现这个功能，自然而然会想到的就是利用反射（考虑到我们赋值的通常为标准的java bean，使用内省是个更好的选择）</p>
<p>接下来我们需要实现的也比较清晰了，第一步获取成员属性，两种方式</p>
<ul>
<li>内省: <code>BeanInfo bean = Introspector.getBeanInfo(clz); PropertyDescriptor[] propertyDescriptors = bean.getPropertyDescriptors();</code></li>
<li>反射: <code>Field[] fields = clz.getDeclaredFields();</code></li>
</ul>
<p>第二步遍历成员属性，进行赋值</p>
<ul>
<li>内省：借助前面获取的<code>PropertyDescriptor</code>对象，拿到set方法，进行赋值
<ul>
<li><code>descriptor.getWriteMethod().invoke(obj, value)</code></li>
</ul>
</li>
<li>反射：适应<code>Field.set</code>来赋值
<ul>
<li><code>field.set(obj, value);</code></li>
</ul>
</li>
</ul>
<p><strong>注意</strong></p>
<ul>
<li>上面的两种赋值方式，都要求我们传入的value对象类型与定义类型一直，否则会抛类型转换异常</li>
</ul>
<p>为了避免复杂的类型转换与判定，我们这里介绍下apache的<code>commons-beanutils</code>来实现属性拷贝</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来核心的实现逻辑如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意上面的实现，首先通过内省的方式获取所有的成员，然后进行遍历，借助<code>BeanUtils.setProperty</code>来实现属性值设置</p>
<p>这里面有两个知识点</p>
<ul>
<li><code>BeanUtil</code> 还是 <code>PropertyUtil</code>
<ul>
<li>它们两都有个设置属性的方法，但是BeanUtil支持简单类型的自动转换；而后者不行，要求类型完全一致</li>
</ul>
</li>
<li>非简单类型
<ul>
<li>对于非简单类型，上面采用了递归的调用方式来处理；请注意，这里并不完善，比如BigDecimal, Date, List, Map这些相对基础的类型，是不太适用的哦</li>
</ul>
</li>
</ul>
<h3> 1.2. 功能测试</h3>
<p>最后针对上面的实现功能，简单的测试一下，是否可行</p>
<p>配置文件<code>mail.properties</code></p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>两个Java Bean</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>转换测试类</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果如下：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div>]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="Java"/>
    <category term="编程技巧"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2021-09-03T19:38:55.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">23.基于引入包选择具体实现类</title>
    <id>https://liuyueyi.github.io/tutorial/java/skill/%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%9722%EF%BC%9A%E5%9F%BA%E4%BA%8E%E5%BC%95%E5%85%A5%E5%8C%85%E9%80%89%E6%8B%A9%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0%E7%B1%BB.html</id>
    <link href="https://liuyueyi.github.io/tutorial/java/skill/%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%9722%EF%BC%9A%E5%9F%BA%E4%BA%8E%E5%BC%95%E5%85%A5%E5%8C%85%E9%80%89%E6%8B%A9%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0%E7%B1%BB.html"/>
    <updated>2023-02-16T06:42:50.000Z</updated>
    <summary type="html"><![CDATA[<h1> 实战23：<strong>基于引入包选择具体实现类</strong></h1>
<p>最近遇到一个需求场景，开源的工具包，新增了一个高级特性，会依赖json序列化工具，来做一些特殊操作；但是，这个辅助功能并不是必须的，也就是说对于使用这个工具包的业务方而言，正常使用完全不需要json相关的功能；如果我强引用某个json工具，一是对于不适用高级特性的用户而言没有必要；二则是我引入的json工具极有可能与使用者的不一致，会增加使用者的成本</p>
<p>因此我希望这个工具包对外提供时，并不会引入具体的json工具依赖；也就是说maven依赖中的<code>&lt;scope&gt;</code>设置为<code>provided</code>；具体的json序列化的实现，则取决于调用方自身引入了什么json工具包</p>
<p>那么可以怎么实现上面这个方式呢？</p>
]]></summary>
    <content type="html"><![CDATA[<h1> 实战23：<strong>基于引入包选择具体实现类</strong></h1>
<p>最近遇到一个需求场景，开源的工具包，新增了一个高级特性，会依赖json序列化工具，来做一些特殊操作；但是，这个辅助功能并不是必须的，也就是说对于使用这个工具包的业务方而言，正常使用完全不需要json相关的功能；如果我强引用某个json工具，一是对于不适用高级特性的用户而言没有必要；二则是我引入的json工具极有可能与使用者的不一致，会增加使用者的成本</p>
<p>因此我希望这个工具包对外提供时，并不会引入具体的json工具依赖；也就是说maven依赖中的<code>&lt;scope&gt;</code>设置为<code>provided</code>；具体的json序列化的实现，则取决于调用方自身引入了什么json工具包</p>
<p>那么可以怎么实现上面这个方式呢？</p>
<!-- more -->
<h2> 1.实现方式</h2>
<h3> 1.1. 任务说明</h3>
<p>上面的简单的说了一下我们需要做的事情，接下来我们重点盘一下，我们到底是要干什么</p>
<p>核心诉求相对清晰</p>
<ol>
<li>不强引入某个json工具</li>
<li>若需要使用高级特性，则直接使用当前环境中已集成的json序列化工具；若没有提供，则抛异常，不支持</li>
</ol>
<p>对于上面这个场景，常年使用Spring的我们估计不会陌生，Spring集成了很多的第三方开源组件，根据具体的依赖来选择最终的实现，比如日志，可以是logback，也可以是log4j；比如redis操作，可以是jedis，也可以是lettuce</p>
<p>那么Spring是怎么实现的呢？</p>
<h3> 1.2.具体实现</h3>
<p>在Spring中有个注解名为<code>ConditionalOnClass</code>，表示当某个类存在时，才会干某些事情（如初始化bean对象）</p>
<p>它是怎么是实现的呢？（感兴趣的小伙伴可以搜索一下，或者重点关注下 <code>SpringBootCondition</code> 的实现）</p>
<p>这里且抛开Spring的实现姿势，我们采用传统的实现方式，直接判断是否有加载对应的类，来判断有没有引入相应的工具包</p>
<p>如需要判断是否引入了gson包，则判断ClassLoader是否有加载<code>com.google.gson.Gson</code>类</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这种实现方式就可以达到我们的效果了；接下来我们参考下Spring的ClassUtils实现，做一个简单的封装，以判断是否存在某个类</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>工具类存在之后，我们实现一个简单的json工具类，根据已有的json包来选择具体的实现</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的实现中，根据已有的json序列化工具，选择具体的实现类，我们定义了一个JsonApi接口，然后分别gson,jackson,fastjson给出默认的实现类</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>最后的问题来了，如果调用方并没有使用上面三个序列化工具，而是使用其他的呢，可以支持么？</p>
<p>既然我们定义了一个JsonApi，那么是不是可以由用户自己来实现接口，然后自动选择它呢？</p>
<p>现在的问题就是如何找到用户自定义的接口实现了</p>
<h3> 1.3. 扩展机制</h3>
<p>对于SPI机制比较熟悉的小伙伴可能非常清楚，可以通过在配置目录<code>META-INF/services/</code>下新增接口文件，内容为实现类的全路径名称，然后通过 <code>ServiceLoader.load(JsonApi.class)</code> 的方式来获取所有实现类</p>
<p>除了SPI的实现方式之外，另外一个策略则是上面提到的Spring的实现原理，借助字节码来处理（详情原理后面专文说明）</p>
<p>当然也有更容易想到的策略，扫描包路径下的class文件，遍历判断是否为实现类(额外注意jar包内的实现类场景)</p>
<p>接下来以SPI的方式来介绍下扩展实现方式，首先初始化JsonApi的方式改一下，优先使用用户自定义实现</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对于使用者而言，首先是实现接口</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接着就是实现定义, <code>resources/META-INF/services/</code> 目录下，新建文件名为 <code>com.github.hui.quick.plugin.qrcode.util.json.JsonApi</code></p>
<p>内容如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>然后完工~</p>
<h2> 2. 小结</h2>
<p>主要介绍一个小的知识点，如何根据应用已有的jar包来选择具体的实现类的方式；本文介绍的方案是通过ClassLoader来尝试加载对应的类，若能正常加载，则认为有；否则认为没有；这种实现方式虽然非常简单，但是请注意，它是有缺陷的，至于缺陷是啥...</p>
<p>除此之外，也可以考虑通过字节码的方式来判断是否有某个类，或者获取某个接口的实现；文中最后抛出了一个问题，如何获取接口的所有实现类</p>
<p>常见的方式有下面三类（具体介绍了SPI的实现姿势，其他的两种感兴趣的可以搜索一下）</p>
<ul>
<li>SPI定义方式</li>
<li>扫描包路径</li>
<li>字节码方式(如Spring，如Tomcat的<code>@HandlesTypes</code>)</li>
</ul>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="Java"/>
    <category term="编程技巧"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2022-08-24T18:54:08.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">2. 数组与list互转</title>
    <id>https://liuyueyi.github.io/tutorial/java/skill/%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%972%EF%BC%9A%E6%95%B0%E7%BB%84%E4%B8%8Elist%E4%BA%92%E8%BD%AC.html</id>
    <link href="https://liuyueyi.github.io/tutorial/java/skill/%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%972%EF%BC%9A%E6%95%B0%E7%BB%84%E4%B8%8Elist%E4%BA%92%E8%BD%AC.html"/>
    <updated>2023-02-16T06:42:50.000Z</updated>
    <summary type="html"><![CDATA[<h1> 实战系列2：数组与list互转</h1>
<p>这个考题比较常见，也比较简单，难道就这也有什么可以说到的门路不成？</p>
<p>接下来本文好好的说一说它的几种实现姿势，总有一款你喜欢的</p>
<h2> 1.数组转List</h2>
<h3> 1.1. Array.asList</h3>
<p>这个考题太简单了，直接使用<code>Array.asList</code>不就完事了么，比如</p>
<div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@Test</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">ary2list</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> ary <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span> <span class="token string">"1"</span><span class="token punctuation">,</span> <span class="token string">"a"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token punctuation">(</span>ary<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></summary>
    <content type="html"><![CDATA[<h1> 实战系列2：数组与list互转</h1>
<p>这个考题比较常见，也比较简单，难道就这也有什么可以说到的门路不成？</p>
<p>接下来本文好好的说一说它的几种实现姿势，总有一款你喜欢的</p>
<h2> 1.数组转List</h2>
<h3> 1.1. Array.asList</h3>
<p>这个考题太简单了，直接使用<code>Array.asList</code>不就完事了么，比如</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>数组转list，so easy!!!</p>
<p>真的就这么简单么？？？</p>
<p>且看下面这一段代码</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>直接抛出了异常<code>java.lang.UnsupportedOperationException</code></p>
<p>有兴趣的小伙伴可以看一下源码实现方式，通过<code>Arrays.asList</code>创建的List，虽说也命名是<code>ArrayList</code>，但是它的全路径为 <code>java.util.Arrays.ArrayList</code>， 不支持<code>add</code>, <code>remove</code>等操作（所以下次再有面试官问ArrayList的知识点时，就可以反问一句，老哥你指的是哪个ArrayList😝，逼格是不是立马拉起来）</p>
<p><strong>知识点</strong></p>
<ul>
<li>通过<code>Arrays.asList</code>创建的列表，不允许新增，删除元素；但是可以更新列表中元素的值</li>
</ul>
<h3> 1.2. new ArrayList</h3>
<p>上面的数组转list方式虽然是最简单的，但不一定是合适的，特别是当我们可能对转换后的list进行操作时，可能埋坑（而且这种坑还非常隐晦，代码层面上很难发现）</p>
<p>为了减少在代码里面下毒的可能性，不妨使用下面这种方式<code>new ArrayList&lt;&gt;(Arrays.asList(ary))</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过上面这种方式创建的List，就是我们熟知的<code>ArrayList</code>了</p>
<p><strong>避雷预警</strong></p>
<p>看到上面这个使用姿势，就很容易想到一个常见的踩雷点，比如我们的应用中，有一个全局共享的配置列表，张三需要拿id为奇数的配置，李四拿id为偶数的配置，然后他们都是这么做的</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>然后跑了一次之后发现这个全局的列表清空了，这就是典型的没有做好资源隔离的case了，针对这种场景，要么是限制使用方，直接针对全局的资源进行修改，要么就是使用方拿到的是一个隔离的备份</p>
<p><strong>禁止修改：</strong></p>
<ul>
<li>使用不可变的容器，如前面提到的<code>java.util.Arrays.ArrayList</code> ()</li>
<li>使用<code>Collections.unmodifiableList</code>创建</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>列表拷贝</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>（上面这种属于深拷贝的实现，具体可以看一下jdk的源码实现）</p>
<h3> 1.3. Collections.addAll</h3>
<p>第三种方式借助jdk提供的容器工具类<code>Collections</code>来实现</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>原则上是比较推荐这种方式来实现的，至于为啥？看下源码实现</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码的实现是不是非常眼熟，如果让我们自己来写，也差不多会写成这样吧，简单直观高效，完美</p>
<h2> 2. 列表转数组</h2>
<p>不同于数组转列表的几种玩法，列表转数组就简单多了，直接调用<code>List.toArray</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 3. 小结</h2>
<p>今天的博文主题是数组与列表的互转，虽说题目简单，但是实现方式也是多种，需要搞清楚它们之间的本质区别，一不小心就可能采坑，而最简单的地方掉坑里，往往是最难发现和爬出来的</p>
<p>核心知识点小结如下</p>
<p><strong>数组转list：</strong></p>
<ul>
<li><code>Arrays.asList(xxx)</code>：创建的是不可变列表，不能删除和新增元素</li>
<li><code>new ArrayList&lt;&gt;(Arrays.asList(xxx)</code>: 相当于用列表创建列表，属于深拷贝的一种表现，获取到的列表支持新增、删除</li>
<li>推荐写法 <code>Collections.addAll()</code></li>
</ul>
<p><strong>列表转数组</strong></p>
<ul>
<li><code>list.toArray</code>: 如果需要指定数组类型，则传参指定</li>
</ul>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="Java"/>
    <category term="编程技巧"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2021-08-10T08:42:44.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">3.字符串与容器互转</title>
    <id>https://liuyueyi.github.io/tutorial/java/skill/%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%973%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8E%E5%AE%B9%E5%99%A8%E4%BA%92%E8%BD%AC.html</id>
    <link href="https://liuyueyi.github.io/tutorial/java/skill/%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%973%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8E%E5%AE%B9%E5%99%A8%E4%BA%92%E8%BD%AC.html"/>
    <updated>2023-02-16T06:42:50.000Z</updated>
    <summary type="html"><![CDATA[<h1> 实战3：<strong>字符串与Collection的互转</strong></h1>
<p>将字符串转换为List，这种业务场景可以说非常非常常见了，实现方式也比较简单</p>
<div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> <span class="token function">str2list</span><span class="token punctuation">(</span><span class="token class-name">String</span> str<span class="token punctuation">,</span> <span class="token class-name">String</span> split<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> cells <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span>split<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span>cells<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>那么除了上面这种实现方式之外，还有其他的么？</p>
]]></summary>
    <content type="html"><![CDATA[<h1> 实战3：<strong>字符串与Collection的互转</strong></h1>
<p>将字符串转换为List，这种业务场景可以说非常非常常见了，实现方式也比较简单</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>那么除了上面这种实现方式之外，还有其他的么？</p>
<!-- more -->
<h2> 1. 字符串转列表</h2>
<p>上面的实现姿势相当于字符串先转数组，然后在通过数组转列表，所以可以沿用前一篇字数组转list的几种方式</p>
<h3> 1.1. jdk支持方式</h3>
<p>借助<code>Collections.addAll</code>来实现</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这种方式适用于输出String的列表，如果我希望转成int列表呢？可以采用下面的方式</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>直接将数组转换为流，然后基于jdk8的特性，来实现转换为int列表</p>
<h3> 1.2. guava方式</h3>
<p>引入依赖</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>除了使用jdk原生的方式之外，借助guava也是非常常见的的case了，主要通过Splitter来实现，写法看起来非常秀</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>简单直接的一行代码搞定，如果我们希望是对输出的列表类型进行指定，也可以如下操作</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1.3. apache-commons</h3>
<p>引入依赖</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面流的方式就很赞了，但是注意它是有jdk版本限制的，虽说现在基本上都是1.8以上的环境进行开发，但也不排除有上古的代码，比如我现在手上的项目，spring还是3...</p>
<p>如果我们不能使用流的方式，那么有什么简单的方式来实现字符串转换为指定类型的列表么？</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这个实现也没有多优雅，不过这里有个编程小技巧可以学习，<code>new Transformer(){}</code>的传参方式，这种实现方式有点像回调的写法，虽然他们有本质的区别，此外就是jdk8之后的函数方法，就充分的体现这种设计思路，比如上面的换成jdk8的写法，直接简化为</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 2. 列表转字符串</h2>
<h3> 2.1. StringBuilder</h3>
<p>最容易想到的，直接使用StringBuilder来实现拼接</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意两点：</p>
<ul>
<li>使用StringBuilder而不是StringBuffer (why?)</li>
<li>注意最后一个拼接符号不要</li>
</ul>
<h3> 2.2. String.join</h3>
<p>一个更简单的实现方式如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当然上面这个的缺点就是列表必须是字符串列表，如果换成int列表，则不行</p>
<h3> 2.3. gauva</h3>
<p>guava也提供了列表转String的方式，同样很简单，而且还没有列表类型的限制</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 3. 小结</h2>
<p>本文的考题也非常常见，列表与字符串的互转，这里介绍了多种实现方式，有jdk原生的case（如果没有什么限制，推荐使用它， <code>String.split</code>除外，原因后面再说），如果有更高级的定制场景，如非String类型类表，则可以考虑guava的Splitter/Joinner来实现</p>
<p>在上面的实现中，也提供了几种有意思的编程方式</p>
<ul>
<li>Stream: 流，jdk8之后非常常见了</li>
<li>函数方法，回调写法case</li>
</ul>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="Java"/>
    <category term="编程技巧"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2021-08-11T08:32:54.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">4.优雅的实现字符串拼接</title>
    <id>https://liuyueyi.github.io/tutorial/java/skill/%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%974%EF%BC%9A%E4%BC%98%E9%9B%85%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5.html</id>
    <link href="https://liuyueyi.github.io/tutorial/java/skill/%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%974%EF%BC%9A%E4%BC%98%E9%9B%85%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5.html"/>
    <updated>2023-02-16T06:42:50.000Z</updated>
    <summary type="html"><![CDATA[<h1> 实战4：<strong><code>字符串拼接</code></strong></h1>
<p>相信没有小伙伴没有写过这样的代码，比如说现在让我们来实现一个字符串拼接的场景，怎样的实现才算是优雅的呢？</p>
]]></summary>
    <content type="html"><![CDATA[<h1> 实战4：<strong><code>字符串拼接</code></strong></h1>
<p>相信没有小伙伴没有写过这样的代码，比如说现在让我们来实现一个字符串拼接的场景，怎样的实现才算是优雅的呢？</p>
<!-- more -->
<p>以将int数组转为英文逗号分隔的字符串为例进行演示</p>
<h2> 1. 实现</h2>
<h3> 1.1. 普通写法</h3>
<p>直接使用StringBuilder来拼接</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这种写法相信比较常见，相对来说不太顺眼的地方就是最后的toString，需要将最后的一个英文逗号给干掉</p>
<p>当然也可以用下面这种事前判断方式，避免最终的字符串截取</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1.2. StringJoiner</h3>
<p>上面实现中，干掉最后的一个分隔符实在不是很优雅，那么有更好一点的用法么，接下来看一下使用<code>StringJoiner</code>的方式</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>StringJoiner由jdk1.8提供，除了上面的基础玩法之外，结合jdk1.8带来的流操作方式，可以更简洁的实现</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>怎么样，上面这个实现比起前面的代码是不是要简洁多了，一行代码完事</p>
<h3> 1.3. guava joiner</h3>
<p>如果使用的jdk还不是1.8版本，不能使用上面的StringJoiner，没关系，还有guava的Joiner也可以实现</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>注意</strong></p>
<ul>
<li>接收的参数类型为: 数组/Iterable/Iterator/可变参数, 基本上可以覆盖我们日常的业务场景</li>
</ul>
<h2> 2. 小结</h2>
<p>本篇文章的主题是一个非常非常常见的字符串拼接，一般来讲，我们在做字符串拼接时，最麻烦的事情就是分隔符的处理，要么就是分隔符前置添加，每次循环都需要判断是否为开头；要么就是后置，最后取字符串时，干掉最后一个分隔符</p>
<p>本文提供了一个非常使用的方式<code>StringJoiner</code>，完全解决了上面的分隔符问题，它的使用有两种场景</p>
<ul>
<li>简单的容器转String：直接借助Stream的<code>Collectors.joining</code>来实现</li>
<li>for循环 （这种场景一般是for循环内的逻辑不仅仅包括字符串拼接，还包括其他的业务逻辑）： 循环内直接执行<code>stringJoiner.add()</code>添加</li>
</ul>
<p>对于jdk1.8及以上的版本，优先推荐使用上面说的StringJoiner来实现字符串拼接；至于jdk1.8之下，那么Guava就是一个不错的选择了，使用姿势也很很简单</p>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="Java"/>
    <category term="编程技巧"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2021-08-12T07:39:11.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">5.驼峰与下划线互转</title>
    <id>https://liuyueyi.github.io/tutorial/java/skill/%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%975%EF%BC%9A%E9%A9%BC%E5%B3%B0%E4%B8%8E%E4%B8%8B%E5%88%92%E7%BA%BF%E4%BA%92%E8%BD%AC.html</id>
    <link href="https://liuyueyi.github.io/tutorial/java/skill/%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%975%EF%BC%9A%E9%A9%BC%E5%B3%B0%E4%B8%8E%E4%B8%8B%E5%88%92%E7%BA%BF%E4%BA%92%E8%BD%AC.html"/>
    <updated>2023-02-16T06:42:50.000Z</updated>
    <summary type="html"><![CDATA[<h1> 实战5：<code>驼峰与下划线划转</code></h1>
<p>这个考题非常实用，特别是对于我们这些号称只需要CURD的后端开发来说，驼峰与下划线互转，这不是属于日常任务么；一般来讲db中的列名，要求是下划线格式（why? 阿里的数据库规范是这么定义的，就我感觉驼峰也没毛病），而java实体命名则是驼峰格式，所以它们之间的互转，就必然存在一个驼峰与下划线的互转</p>
<p>今天我们就来看一下，这两个的互转支持方式</p>
]]></summary>
    <content type="html"><![CDATA[<h1> 实战5：<code>驼峰与下划线划转</code></h1>
<p>这个考题非常实用，特别是对于我们这些号称只需要CURD的后端开发来说，驼峰与下划线互转，这不是属于日常任务么；一般来讲db中的列名，要求是下划线格式（why? 阿里的数据库规范是这么定义的，就我感觉驼峰也没毛病），而java实体命名则是驼峰格式，所以它们之间的互转，就必然存在一个驼峰与下划线的互转</p>
<p>今天我们就来看一下，这两个的互转支持方式</p>
<!-- more -->
<h2> 1.实现</h2>
<h3> 1.1. Gauva</h3>
<p>一般来讲遇到这种普适性的问题，大部分都是有现成的工具类可以来直接使用的；在java生态中，说到好用的工具百宝箱，guava可以说是排列靠前的</p>
<p>接下来我们看一下如何使用Gauva来实现我们的目的</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这里主要使用的是<code>CaseFormat</code>来实现互转，guava的CaseFormat还提供了其他几种方式</p>
<p>上面这个虽然可以实现互转，但是如果我们有一个字符串为 <code>helloWorld_Case</code></p>
<p>将其他转换输出结果如下:</p>
<ul>
<li>下划线：<code>hello_world__case</code></li>
<li>驼峰：<code>helloworldCase</code></li>
</ul>
<p>这种输出，和标准的驼峰/下划线不太一样了（当然原因是由于输入也不标准）</p>
<h3> 1.2. Hutool</h3>
<p>除了上面的guava，hutool的使用也非常广，其中包含很多工具类，其<code>StrUtil</code>也提供了下划线与驼峰的互转支持</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>同样的我们再来看一下特殊的case</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果如下</p>
<ul>
<li>驼峰：<code>helloworldCase</code></li>
<li>下划线: <code>hello_world_case</code></li>
</ul>
<p>相比较上面的guava的场景，下划线这个貌似还行</p>
<h3> 1.3. 自定义实现</h3>
<p>接下来为了满足我们希望转换为标砖的驼峰/下划线输出方式的需求，我们自己来手撸一个</p>
<p><strong>下划线转驼峰:</strong></p>
<ul>
<li>关键点就是找到下划线，然后去掉它，下一个字符转大写续上（如果下一个还是下划线，那继续找下一个）</li>
</ul>
<p>根据上面这个思路来实现，如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>驼峰转下划线</strong></p>
<ul>
<li>关键点：大写的，则前位补一个下划线，当前字符转小写（如果前面已经是一个下划线了，那前面不补，直接转小写即可）</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>再次测试<code>helloWorld_Case</code>，输出如下</p>
<ul>
<li>驼峰：<code>helloWorldCase</code></li>
<li>下划线: <code>hello_world_case</code></li>
</ul>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="Java"/>
    <category term="编程技巧"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2021-08-14T11:17:19.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">6.枚举的特殊用法</title>
    <id>https://liuyueyi.github.io/tutorial/java/skill/%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%976%EF%BC%9A%E6%9E%9A%E4%B8%BE%E7%9A%84%E7%89%B9%E6%AE%8A%E7%94%A8%E6%B3%95.html</id>
    <link href="https://liuyueyi.github.io/tutorial/java/skill/%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%976%EF%BC%9A%E6%9E%9A%E4%B8%BE%E7%9A%84%E7%89%B9%E6%AE%8A%E7%94%A8%E6%B3%95.html"/>
    <updated>2023-02-16T06:42:50.000Z</updated>
    <summary type="html"><![CDATA[<h1> 实战6：<code>枚举的特殊用法</code></h1>
<p>难道我们日常使用的枚举还有什么特殊的玩法不成？没错，还真有，本文主要介绍枚举的两种不那么常见的使用姿势</p>
<ul>
<li>利用枚举来实现单例模式</li>
<li>利用枚举来实现策略模式</li>
</ul>
]]></summary>
    <content type="html"><![CDATA[<h1> 实战6：<code>枚举的特殊用法</code></h1>
<p>难道我们日常使用的枚举还有什么特殊的玩法不成？没错，还真有，本文主要介绍枚举的两种不那么常见的使用姿势</p>
<ul>
<li>利用枚举来实现单例模式</li>
<li>利用枚举来实现策略模式</li>
</ul>
<!-- more -->
<h2> 1. 使用场景</h2>
<h3> 1.1. 单例模式</h3>
<p>单例模式可以说是每个java开发者必须掌握的一个设计模式了，通常我们说它的实现，有饱汉式和饿汉式，也有经常说的双重判断，今天我们介绍另外一种方式，借助枚举来实现</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用枚举来实现单例模式非常非常简单，将类声明为枚举，内部只定义一个值即可</p>
<p>为什么可以这样做？</p>
<ul>
<li>枚举类不能<code>new</code>，因此保证单例</li>
<li>枚举类不能被继承</li>
<li>类不加载时，不会实例化</li>
</ul>
<p>使用枚举类创建的单例有一个好处，就是即使用反射，也无法打破它的单例性质，这是相比较于其他的实现方式的一个优点</p>
<p>那么，为啥在实际的项目中，不太常见这种写法？</p>
<ul>
<li>就我个人的一点认知（不保证准确）：这个与我们对枚举的认知有一定关系，在 《Effect in java》一书中，推荐我们使用这种方式来实现单例，但是在实际的项目开发中，我们更多的将枚举作为常量来使用，很少在枚举类中，添加复杂的业务逻辑</li>
</ul>
<h3> 1.2. 策略模式</h3>
<p>枚举除了很容易就实现上面的单例模式之外，还可以非常简单的实现策略模式</p>
<p>举一个简单的例子，我现在有一个接口，通过接受的参数，来决定最终的数据存在什么地方</p>
<p>如果按照正常的写法，可能就是很多的if/else</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这种写法虽说简单直观，但是当type类型一多了之后，这个if/else的代码行数就会很多很多了，而且看起来也不美观</p>
<p>接下来我们介绍一种利用枚举，基于策略模式的思想来解决上面的if/else问题</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的实现，主要利用的是<code>抽象类 + 枚举</code>来完成不同的策略具体实现</p>
<p>这种实现方式，相比较与前面的单例模式，还是更常见一点，虽然整体看下来没有什么难度，但是仔细看一看，会发现几个知识点</p>
<ul>
<li>抽象方法的使用 （在模板设计模式中，更能体会抽象方法的使用妙处）</li>
<li>利用枚举原生提供的<code>values()</code>，来实现遍历，找到目标</li>
</ul>
<h2> 2. 小结</h2>
<p>枚举虽然说是jdk原生提供的一个基础数据类型，但是它的使用姿势除了我们熟知的常量之外，还可以有效的运用在设计模式中，让我们的代码实现更优雅</p>
<p>比如使用枚举来实现单例模式，就不用再面对让人烦躁的双重判断/内部类的方式了</p>
<p>使用枚举的策略模式，也可以有效解决我们类中大量的if/else</p>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="Java"/>
    <category term="编程技巧"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2021-08-16T09:54:23.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">7.排序比较要慎重</title>
    <id>https://liuyueyi.github.io/tutorial/java/skill/%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%977%EF%BC%9A%E6%8E%92%E5%BA%8F%E6%AF%94%E8%BE%83%E8%A6%81%E6%85%8E%E9%87%8D.html</id>
    <link href="https://liuyueyi.github.io/tutorial/java/skill/%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%977%EF%BC%9A%E6%8E%92%E5%BA%8F%E6%AF%94%E8%BE%83%E8%A6%81%E6%85%8E%E9%87%8D.html"/>
    <updated>2023-02-16T06:42:50.000Z</updated>
    <summary type="html"><![CDATA[<h1> 实战7：<code>排序比较要慎重</code></h1>
<p>今天介绍的又是一个非常非常基本的基本知识点，为啥要单独拎出来？还是因为这个东西虽然非常简单，但是很容易掉坑，我已经遇到几次不严谨的写法了</p>
]]></summary>
    <content type="html"><![CDATA[<h1> 实战7：<code>排序比较要慎重</code></h1>
<p>今天介绍的又是一个非常非常基本的基本知识点，为啥要单独拎出来？还是因为这个东西虽然非常简单，但是很容易掉坑，我已经遇到几次不严谨的写法了</p>
<!-- more -->
<h2> 1.排序</h2>
<h3> 1.1. Comparator 与 Comparable</h3>
<p>输掉排序，这两个接口好像不太容易绕过去，我们简单介绍下它们的区别</p>
<ul>
<li>如果你有一个类，希望支持同类型的自定义比较策略，可以实现接口<code>Compareable</code></li>
<li>如果某个类，没有实现<code>Compareable</code>接口，但是又希望对它进行比较，则可以自自定义一个<code>Comparator</code>，来定义这个类的比较规则</li>
</ul>
<p>通过一个简单的实例进行演示说明</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的实现中，重点关注 Demo类，实现了<code>Comparable</code>接口，因此可以直接调用<code>list.sort(null)</code>来进行比较；</p>
<p>但是如果我们现在需求改变了，希望实现针对demo类的age字段，进行升序排列，那么就可以利用<code>Comparator</code>来实现了</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1.2. 踩坑预告</h3>
<p>再上面的compare方法实现中，我们可以发现里面的实现有点不太美观，我们最终的目的是什么？</p>
<ul>
<li>如果左边的小于右边的，返回 -1</li>
<li>如果左边的大于右边的，返回 0</li>
<li>如果左边的等于右边的，返回 1</li>
</ul>
<p>基于此，经常可以看到的实现如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这个实现虽然简洁了，但是有一个致命的问题，可能溢出!!!</p>
<p>所以请注意，千万千万不要用上面这种写法</p>
<p>那么有没有更优雅的方式呢？</p>
<ul>
<li>有，使用基础类的<code>compare</code>方法</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这一段代码，再jdk1.8中，可以简化为下面一句</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>再扩展一下，如果希望倒排呢？</p>
<ul>
<li>第一种实现方式，调换位置</li>
<li>Jdk1.8方式，使用负数</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 2. 小结</h2>
<p>今天主要介绍的知识点是排序，再我们日常使用中，如果一个类希望支持排序，最好的方式就是让它实现<code>Comparable</code>接口，然后自定义排序方式</p>
<p>这样再容器中，如果需要排序，直接调用 <code>list.sort(null)</code> 或者 <code>CollectionUtils.sort(list)</code></p>
<p>如果目标类没有实现排序接口，或者希望使用另外一种排序方式，则通过自定义的<code>Comparator</code>来实现</p>
<p>最后关于<code>compare</code>方法的实现，设计到两个类的比较，这种最终的落脚地，多半是基础类型的比较</p>
<ul>
<li>o1 与 o2 比较，返回负数，则最终的结果中o1再前面（即升序排列）</li>
<li>不要直接使用 <code>o1-o2</code>会溢出，推荐使用 <code>Integer.compare(o1, o2);</code></li>
</ul>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="Java"/>
    <category term="编程技巧"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2021-08-17T14:22:52.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">8.容器的初始化大小指定</title>
    <id>https://liuyueyi.github.io/tutorial/java/skill/%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%978%EF%BC%9A%E5%AE%B9%E5%99%A8%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%A4%A7%E5%B0%8F%E6%8C%87%E5%AE%9A.html</id>
    <link href="https://liuyueyi.github.io/tutorial/java/skill/%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%978%EF%BC%9A%E5%AE%B9%E5%99%A8%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%A4%A7%E5%B0%8F%E6%8C%87%E5%AE%9A.html"/>
    <updated>2023-02-16T06:42:50.000Z</updated>
    <summary type="html"><![CDATA[<h1> 实战8：<code>容器的初始化大小指定</code></h1>
<p>容器可以说是我们日常开发中，除了基本对象之外，使用最多的类了，那么平时在使用的时候，是否有主意到良好编程习惯的大佬，在创建容器的时候，一般会设置size；那么他们为什么要这么干呢？是出于什么进行考量的呢？</p>
<p>今天我们将针对最常见的List/Map/Set三种容器类型的初始化值选择，进行说明</p>
]]></summary>
    <content type="html"><![CDATA[<h1> 实战8：<code>容器的初始化大小指定</code></h1>
<p>容器可以说是我们日常开发中，除了基本对象之外，使用最多的类了，那么平时在使用的时候，是否有主意到良好编程习惯的大佬，在创建容器的时候，一般会设置size；那么他们为什么要这么干呢？是出于什么进行考量的呢？</p>
<p>今天我们将针对最常见的List/Map/Set三种容器类型的初始化值选择，进行说明</p>
<!-- more -->
<h2> 1. 容器初始化</h2>
<h3> 1.1. List</h3>
<p>列表，在我们日常使用过程中，会接触到下面几个</p>
<ul>
<li>ArrayList: 最常见的数组列表</li>
<li>LinkedList: 基于链表的列表</li>
<li>CopyOnWriteArrayList: 线程安全的数组列表</li>
</ul>
<p>接下来逐一进行说明</p>
<h4> 1.1.1 ArrayList</h4>
<p>现在以ArrayList为例，进行源码分析，当我们不指定列表大小，直接创建时</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面是内部实现，其中<code>elementData</code>就是列表中存数据的数组，初始化为默认数组</p>
<p>当我们第一次添加一个元素时，发现数组为默认值，会触发一次数组扩容，新的数组大小为10 （详情看源码）</p>
<p>其次就是数组的库容机制，通过源码/网上分享知识点可以知道，这个扩容的实现如下</p>
<ul>
<li>当新添加的元素，数组放不下时，实现扩容</li>
<li><code>扩容后的大小</code> = <code>扩容前大小</code> + max(<code>添加元素个数</code>, 1/2 * <code>扩容前大小</code>)</li>
</ul>
<p>基于上面的知识点，大致可以得出指定列表长度的好处</p>
<ul>
<li>节省空间（用多少申请多少，避免浪费）</li>
<li>减少扩容带来的拷贝（扩容一次就会带来一次数组拷贝，如果已知列表很大，结果还使用默认的10，这会产生很多可避免的扩容开销）</li>
</ul>
<h4> 1.1.2 LinkedList</h4>
<p>基于链表的列表，不同于上面的数组列表，它没有提供指定大小的构造方法，why?</p>
<p>因为链表本身的数据结构的特点，它就像糖葫芦一样，一个串一个，有数据，才有接上的可能，因此不需要指定大小</p>
<h4> 1.1.3 CopyOnWriteArrayList</h4>
<p>这个又非常有意思，它同样不能指定大小，但是原因与前面不同，主要在于它保证线程安全的实现方式</p>
<ul>
<li>每次新增/修改(加锁，保证单线程访问)，都是在拷贝的数组操作；完成之后，用新的替换旧的</li>
</ul>
<p>所以说，每次变更，都会存在数组拷贝，因此就没有必要提前指定数组大小</p>
<p>那么它的初始化每次都使用默认的么?</p>
<p>并不是这样的，当我们已知这个列表中的值时，推荐使用下面这种方式</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>将初始化值，放在一个普通的列表中，然后利用普通列表来初始化<code>CopyOnWriteArrayList</code></li>
</ul>
<h3> 1.2.Map</h3>
<p>常见的map容器使用，大多是下面几个</p>
<ul>
<li><code>HashMap</code></li>
<li><code>LinkedHashMap</code>: 有序的hashmap</li>
<li><code>TreeMap</code>: 有序的hashmap</li>
<li><code>ConcurrentHashMap</code>: 线程安全的map</li>
</ul>
<h4> 1.2.1 HashMap</h4>
<p>HashMap的底层数据结构是 <code>数组 + 链表/红黑树</code>，关于这个就不细说了</p>
<p>我们在初始化时，若不指定size，则数组的默认长度为8（请注意，Map的数组长度是2的倍数）</p>
<p>与ArrayList的扩容时机不一样的是，默认情况下，Map容量没满就会触发一次扩容</p>
<p>默认是数量达到 <code>size * 0.75</code>(0.75为扩容因子，可以在创建时修改)，就会触发一次扩容</p>
<p>why?</p>
<ul>
<li>主要是为了减少hash冲突</li>
</ul>
<p>同样的为了减少冲突，在初始化时，我们需要指定一个合适大小</p>
<p>比如我们</p>
<ul>
<li>已知map的数量为2，这个时候Map的大小选择因该是4</li>
<li>map数量为6，这个时候Map的大小选择是16</li>
</ul>
<p>有时候让我们自己来计算这个值，就有些麻烦了，这个时候，可以直接使用Guava的工具类来完成这个目的</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4> 1.2.2 LinkedHashMap</h4>
<p>初始化方式同上，略</p>
<h4> 1.2.3 ConcurrentHashMap</h4>
<p>初始化方式同上，略</p>
<h4> 1.2.4 TreeMap</h4>
<p>不同于上面几个的是treeMap，没有提供指定容器大小的构造方法</p>
<p>原因和前面说到的LinkedList有些类似，TreeMap的底层数据结构为Tree，所以新增数据是挂在树的一个节点下面，无需指定容量大小</p>
<h3> 1.3. Set</h3>
<p>集合用的最多应该就是<code>HashSet</code>了，底层结构模型复用，所以初始化大小指定与HashMap一致，也不需要多说</p>
<h2> 2. 小结</h2>
<p>今天这篇博文主要介绍的是三种常见的容器，在创建时，如何指定容量大小</p>
<p>首先明确一点，指定容量大小是为了</p>
<ul>
<li>减少扩容带来的额外开销</li>
<li>指定容量代销，可以减少无效的内存开销</li>
</ul>
<p>初始化值设置的关键点:</p>
<ul>
<li>ArrayList: 数据有多少个，初始化值就是多少</li>
<li>HashMap: 考虑到扩容因子，初始化大小 = <code>(size / 0.75 + 1)</code></li>
</ul>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="Java"/>
    <category term="编程技巧"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2021-08-18T14:11:05.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">9.List.subList使用不当StackOverflowError</title>
    <id>https://liuyueyi.github.io/tutorial/java/skill/%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%979%EF%BC%9AList-subList%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%BD%93StackOverflowError.html</id>
    <link href="https://liuyueyi.github.io/tutorial/java/skill/%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%979%EF%BC%9AList-subList%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%BD%93StackOverflowError.html"/>
    <updated>2023-02-16T06:42:50.000Z</updated>
    <summary type="html"><![CDATA[<h1> 实战9：<code>List.subList使用不当StackOverflowError</code></h1>
<p>相信每个小伙伴都使用过<code>List.subList</code>来获取子列表，日常使用可能没啥问题，但是，请注意，它的使用，很可能一不小心就可能导致oom</p>
]]></summary>
    <content type="html"><![CDATA[<h1> 实战9：<code>List.subList使用不当StackOverflowError</code></h1>
<p>相信每个小伙伴都使用过<code>List.subList</code>来获取子列表，日常使用可能没啥问题，但是，请注意，它的使用，很可能一不小心就可能导致oom</p>
<!-- more -->
<h2> 1.实例说明</h2>
<h3> 1.1. subList</h3>
<p>场景复现，如基于list实现一个小顶堆</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这个执行完毕之后，居然出现栈溢出</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从实现来看，感觉也没啥问题啊， 我们稍微改一下上面的返回</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>再次执行，却没有异常；所以关键点就在与</p>
<ul>
<li>list.subList的使用上</li>
</ul>
<h3> 1.2. StackOverflowError分析</h3>
<p>接下来我们主要看一下<code>list.subList</code>的实现</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面返回的子列表是ArrayList的一个内部类<code>SubList</code>，它拥有一个指向父列表的成员<code>parrent</code></p>
<p>也就是说，从源头的ArryList开始，后面每次调用<code>subList</code>，这个指代关系就深一层</p>
<p>然后它的add方法也很有意思</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>重点看 <code>parent.add(parentOffset + index, e);</code>，添加的数据实际上是加在最源头的ArrayList上的，也就是说，虽然你现在拿到的SubList，只有几个元素，但是它对应的数组，可能超乎你的想象</p>
<p>当然上面这个异常主要是以为调用栈溢出（一直往上找parent）</p>
<p>这里反应的另外一个重要问题则是内存泄漏，就不继续说了</p>
<p>如果需要解决上面这个问题，改造方法如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 2. 小结</h2>
<p>jdk提供的原生方法虽然非常好用，但是在使用的时候，也需要多家注意，一不小心就可能掉进坑里；这也告诉我们多看源码是有必要的</p>
<p>最后一句关键知识点小结：</p>
<ul>
<li><code>ArrayList.subList</code> 返回的是内部类，与原ArrayList公用一个数组，只是限定了这个数组的起始下标和结束下标而已</li>
<li>在使用<code>subList</code>，请注意是否会存在内存泄露和栈溢出的问题</li>
</ul>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="Java"/>
    <category term="编程技巧"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2021-08-19T14:13:42.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">1.Eureka注册中心初体验</title>
    <id>https://liuyueyi.github.io/tutorial/spring/cloud/Eureka/01.200513-SpringCloud%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B9%8BEureka%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E5%88%9D%E4%BD%93%E9%AA%8C.html</id>
    <link href="https://liuyueyi.github.io/tutorial/spring/cloud/Eureka/01.200513-SpringCloud%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B9%8BEureka%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E5%88%9D%E4%BD%93%E9%AA%8C.html"/>
    <updated>2023-02-10T04:50:05.000Z</updated>
    <summary type="html"><![CDATA[<p>在SpringCloud微服务体系中，有几个比较重要的组件，如注册中心，配置中心，网关，安全、负载均衡、监控等等，接下来我们将来看一下这些常用的组件有什么用，在微服务架构下的该怎么用。</p>
<p>本文为为第一篇，注册中心Eureka的使用说明</p>
]]></summary>
    <content type="html"><![CDATA[<p>在SpringCloud微服务体系中，有几个比较重要的组件，如注册中心，配置中心，网关，安全、负载均衡、监控等等，接下来我们将来看一下这些常用的组件有什么用，在微服务架构下的该怎么用。</p>
<p>本文为为第一篇，注册中心Eureka的使用说明</p>
<!-- more -->
<h2> I. 基本介绍</h2>
<h3> 1. 注册中心</h3>
<p>注册中心，主要的核心点是服务的注册与发现。</p>
<p>简单来讲，就是我们的所有服务都会在注册中心上标识自己，注册中心统一管理所有的服务名与具体的应用之间的映射关系，这样微服务之间的访问，就可以直接通过服务名来相互通信，相比较于直接通过ip端口的访问，这样的好处是当某个服务下线、新增或者换了机器，对调用者而言，只要维持一份注册中心的最新映射表即可，不需要其他任何改动逻辑。</p>
<p>我们通常可用的注册中心有 <code>Eureka</code>, <code>Consul</code>, <code>Zookeeper</code>, <code>nacos</code>等，在我们后续的教程中会逐一进行介绍</p>
<blockquote>
<p>Eureka2.x 闭源，1.x虽然可用，但新项目的话不建议再使用它，比如<code>Consul</code>, <code>nacos</code> 都是不错的选择</p>
<p>如果出于学习的目的，或者由于历史原因（比如我），学习了解一下Eureka知识点也没什么坏处</p>
</blockquote>
<h3> 2. Eureka</h3>
<p>Eureka是Netflix开源的服务发现组件，本身是一个基于REST的服务，通常包含Server和Client端</p>
<p><strong>原理如下图</strong></p>
<figure><img src="/imgs/200513/00.jpg" alt="来源于网络" tabindex="0" loading="lazy"><figcaption>来源于网络</figcaption></figure>
<ul>
<li>server: 提供服务注册，并在服务注册表中存储所有可用服务节点的信息</li>
<li>client: 简化与Server之间的交互，比如封装了发送心跳，获取注册信息表等基本操作</li>
</ul>
<h2> II. 实例演示</h2>
<h3> 1. 版本说明</h3>
<p>后续的演示项目中，我们的环境与版本信息如下</p>
<ul>
<li>开发环境: IDEA + maven</li>
<li>SpringBoot: <code>2.2.1.RELEASE</code></li>
<li>SpringCloud: <code>Hoxton.M2</code></li>
</ul>
<h3> 2. Eureka Server端</h3>
<p>Eureka区分了Server和Client两端，即我们有一个独立的注册中心服务，其他的微服务则作为Client端</p>
<p>Server端核心依赖如下</p>
<div class="language-pom line-numbers-mode" data-ext="pom"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后在配置文件中，添加一些基本信息</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>请注意，上面的<code>registerWithEureka</code>这个配置，设置为false，不像自己注册服务（后续会介绍多个Eureka实例时，可以如何配置）</p>
<p>然后再启动类上，添加注解<code>@EnableEurekaServer</code>来申明Eureka服务</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>到此，一个Eureka服务端已经完成，此时我们可以直接访问<code>http://localhost:8081</code>，会看到一个自带的控制台，会提供一些基本信息</p>
<h3> 3. Eureka 客户端</h3>
<p>我们这里设计两个客户端，一个提供服务，另外一个调用，演示一下Eureka的基本功能</p>
<h4> a. 客户端 eureka-service-provider</h4>
<p>客户端需要在pom文件中，添加下面的关键依赖</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来需要在配置文件中，指定注册中心的地址，以及服务名（请注意，这个服务名是重要线索，后面会用到！！！）</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>同样的需要在启动类上，通过<code>@EnableEurekaClient</code>来标注客户端</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们在这个项目中，写一个基本REST接口，供后面的服务进行调用</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>再看一下上面的实现，你会发现和平时写的Controller没有任何的区别</p>
<p>到这里第一个Eureka客户端已经完成，并提供了一个REST接口，接下来我们开始写第二个Eureka客户端，用来访问上面的REST服务</p>
<h4> b. 客户端 eureka-service-consumer</h4>
<p>基本的流程和上面没有任何区别，只是将配置文件稍微改一下</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>那么在这个服务中，如何访问 <code>eureka-service-provider</code> 提供的服务呢？</p>
<ul>
<li>通过<code>RestTemplate</code>来实现</li>
</ul>
<p>请注意，这个RestTemplate和我们普通的<code>new RestTemplate()</code>创建的不一样哦，我们是通过如下方式获取实例</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>重点关注方法上的<code>@LoadBalanced</code>注解，这个会在后续的Ribbon的章节中深入介绍，在这里只需要知道通过它生成的<code>RestTemplate</code>，在发起访问时，会借助Eureka的注册信息表，将服务名翻译为对应的<code>ip+端口号</code></p>
<p>接下来就是我们的访问环节，写法如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>请着重看一下访问的url: <code>"http://eureka-service-provider/userService/getUserById?userId=" + userId</code>,这里没有域名，没有ip，是直接通过服务名进行访问的</p>
<h3> 4. 测试与小结</h3>
<p>我们依次将上面的Server和两个Client启动，然后访问<code>http://localhost:8081</code>，查看Eureka控制台，可以看到如下界面，两个客户端都已经注册好了</p>
<figure><img src="/imgs/200513/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>然后再测试一下通过consumer访问provider的服务</p>
<figure><img src="/imgs/200513/02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>到此Eureka的核心功能已经演示完毕，当然如果仅仅只是这样，这个学习成本好像很低了，作为一个有思考的小青年，看了上面的流程自然会有几个疑问</p>
<ul>
<li>安全问题
<ul>
<li>注册中心控制台直接访问，这要是暴露出去了...</li>
<li>一个Eureka实例，单点故障怎么解</li>
</ul>
</li>
<li>服务注册多久生效？服务下线多久会从注册信息表中摘除？服务存活判断是怎样的？</li>
<li>通过<code>RestTemplate</code>方式使用，很不优雅啊，有没有类似rmi的通过类调用的方式呢？</li>
</ul>
<h2> II. 其他</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：
<ul>
<li><a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-cloud/eurka-server" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-cloud/eurka-server</a></li>
<li><a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-cloud/eurka-service-consumer" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-cloud/eurka-service-consumer</a></li>
<li><a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-cloud/eurka-service-provider" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-cloud/eurka-service-provider</a></li>
</ul>
</li>
</ul>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="SpringCloud"/>
    <category term="Eureka系列"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2020-05-13T09:14:47.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">Eureka</title>
    <id>https://liuyueyi.github.io/tutorial/spring/cloud/Eureka/</id>
    <link href="https://liuyueyi.github.io/tutorial/spring/cloud/Eureka/"/>
    <updated>2023-02-10T04:50:05.000Z</updated>
    <summary type="html"><![CDATA[<p>注册中心Eureka全知道</p>
]]></summary>
    <content type="html"><![CDATA[<p>注册中心Eureka全知道</p>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2023-02-10T04:50:05.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">1.Feign请求参数包装异常问题定位</title>
    <id>https://liuyueyi.github.io/tutorial/spring/cloud/Feign/01.190306-SpringCloud%E4%B9%8BFeign%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E5%8C%85%E8%A3%85%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D.html</id>
    <link href="https://liuyueyi.github.io/tutorial/spring/cloud/Feign/01.190306-SpringCloud%E4%B9%8BFeign%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E5%8C%85%E8%A3%85%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D.html"/>
    <updated>2023-02-10T04:50:05.000Z</updated>
    <summary type="html"><![CDATA[<p>通过Feign包装rpc的调用姿势，在使用的版本中发现一个奇怪的bug，大部分场景下请求正常，少数情况下请求返回400，记录下原因</p>
]]></summary>
    <content type="html"><![CDATA[<p>通过Feign包装rpc的调用姿势，在使用的版本中发现一个奇怪的bug，大部分场景下请求正常，少数情况下请求返回400，记录下原因</p>
<!-- more -->
<h2> 场景复现</h2>
<h3> 1. 环境相关版本</h3>
<p>Spring版本如</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>Feign版本</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对应的feign-core版本为</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 服务接口</h3>
<p>接口形如</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用时报400的case</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>简单来说，接口参数为集合的情况下，如果传一个空集合，那么这就会出现400的错误</p>
<p>通过在提供服务的应用中，写一个fitler拦截请求，打印出请求参数</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后发起rpc调用前面的测试用例，通过断点查看请求参数，确实只有两个参数，而我们传入空pairIds集合，直接被吃掉了</p>
<figure><img src="/imgs/190306/00.jpg" alt="filter截图" tabindex="0" loading="lazy"><figcaption>filter截图</figcaption></figure>
<p>再对应到我们的api声明方式，要求三个参数，因此问题就很清晰了，解决办法就是在api中参数的必填设置为false即可</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面只是表层的解决了问题，接下来就需要确定，为什么请求参数会被吃掉，通过浅显的推测，多半原因在feign的请求参数封装上了</p>
<h3> 2. 问题定位</h3>
<p>对于容易复现的问题，最佳的定位方法就是debug了，直接单步进去，找到对应的请求参数封装逻辑，</p>
<p>第一步定位到<code>RequestTemplate</code>的创建</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来深入进去之后，参数解析的位置</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>再进去一步就到了根源点</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>下图是我们最终定位的一个截图，从代码实现来看，feign的设计理念是，如果请求参数为null，空集合，则不会将参数拼接到最终的请求参数中，也就导致最终发起请求时，少了一个参数</p>
<figure><img src="/imgs/190306/01.jpg" alt="debug截图" tabindex="0" loading="lazy"><figcaption>debug截图</figcaption></figure>
<p>问题清晰之后，然后就可以确认下是bug还是就是这么设计的了，最简单的办法就是看最新的代码有没有改掉了，从git上，目前已经更新到10.x；10.x与9.x的差别挺大，底层很多东西重写了，然而官方的<code>Spring-Cloud-openfeing</code>并没有升级到最新，so，只能取看9.7.0版本的实现了，和9.5.2并没有太大的区别；</p>
<p>so，站在feign开发者角度出发，这么设计的理由可能有以下几点</p>
<ul>
<li>既然允许传入空集合、null参数，那么在api的声明时，就有必要加上 <code>require=False</code></li>
<li>对于这种无效的请求参数，也没有太大的必要传过去（虽然从使用者角度来说，你就应该老老实实的把我调用的参数都丢过去）</li>
</ul>
<h3> 3. 小结</h3>
<p>最后小结一下，使用feign作为SpringCloud的rpc封装工具时，请注意，</p>
<ul>
<li>如果api的请求参数允许为null，请在注解中显示声明；</li>
<li>此外请求方传入的null、空集合最终不会拼装的请求参数中，即对于接受者而言，就像没有这个参数一样，对于出现400错误的场景，可以考虑下是否是这种问题导致的</li>
<li>对于复杂的请求参数，推荐使用DTO来替代多参数的类型（因为这样接口的复用性是最佳的，如新增和修改条件时，往往不需要新增api)</li>
</ul>
<h2> II. 其他</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">spring-boot-demo</a></li>
</ul>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="SpringCloud"/>
    <category term="Feign系列"/>
    <category term="采坑记录"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2019-03-06T12:43:08.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">Feign</title>
    <id>https://liuyueyi.github.io/tutorial/spring/cloud/Feign/</id>
    <link href="https://liuyueyi.github.io/tutorial/spring/cloud/Feign/"/>
    <updated>2023-02-10T04:50:05.000Z</updated>
    <summary type="html"><![CDATA[<p>基于Feign实现微服务访问</p>
]]></summary>
    <content type="html"><![CDATA[<p>基于Feign实现微服务访问</p>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2023-02-10T04:50:05.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">1.整合docker镜像打包</title>
    <id>https://liuyueyi.github.io/tutorial/spring/middle/Docker/210304-SpringBoot%E7%B3%BB%E5%88%97%E6%95%B4%E5%90%88docker%E9%95%9C%E5%83%8F%E6%89%93%E5%8C%85.html</id>
    <link href="https://liuyueyi.github.io/tutorial/spring/middle/Docker/210304-SpringBoot%E7%B3%BB%E5%88%97%E6%95%B4%E5%90%88docker%E9%95%9C%E5%83%8F%E6%89%93%E5%8C%85.html"/>
    <updated>2023-02-10T04:50:05.000Z</updated>
    <summary type="html"><![CDATA[<p>SpringBoot项目整合docker，打包镜像工程演示</p>
]]></summary>
    <content type="html"><![CDATA[<p>SpringBoot项目整合docker，打包镜像工程演示</p>
<!-- more -->
<h2> I. 整合步骤</h2>
<h3> 1. 基本环境</h3>
<p>本项目借助<code>SpringBoot 2.2.1.RELEASE</code> + <code>maven 3.5.3</code> + <code>IDEA</code> + <code>MAC</code>进行开发</p>
<p>首先确保本机有安装docker，对于docker基本知识点，可以参考</p>
<ul>
<li><a href="https://blog.hhui.top/hexblog/2019/12/06/191206-Centos%E5%AE%89%E8%A3%85docker%E4%B8%8E%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/" target="_blank" rel="noopener noreferrer">Centos安装docker与使用说明</a></li>
<li><a href="https://blog.hhui.top/hexblog/2019/12/06/191206-Docker-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E9%80%9F%E6%9F%A5%E6%89%8B%E5%86%8C/" target="_blank" rel="noopener noreferrer">Docker 常用命令速查手册</a></li>
</ul>
<h3> 2. pom配置</h3>
<p>创建一个基本的SpringBoot项目之后，关键是设置<code>pom.xml</code>文件，我们主要借助<code>docker-maven-plugin</code>来打镜像包</p>
<p>一个可用的配置如下</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. Dockerfile 文件</h3>
<p>接下需要配置我们自己的dockerfile文件，在项目根目录下，新建文件名<code>Dockerfile</code>，如果路径有修改，需要调整上面pom配置中的<code>dockerDirectory</code>参数</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>关于dockerfile语法，可以参考</p>
<ul>
<li><a href="https://www.runoob.com/docker/docker-dockerfile.html" target="_blank" rel="noopener noreferrer">Docker Dockerfile语法说明</a></li>
</ul>
<p>我们上面的case，就是拉一个jdk8的运行环境，将打的jar包重命名为app.jar到指定目录，同时使用命令<code>java -jar app.jar</code>来启动应用</p>
<h3> 4. 测试demo</h3>
<p>提供一个最基础的demo实例</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>打包命令 <code>mvn clean package docker:build -DskipTests=true</code></p>
<p><strong>注意</strong></p>
<ul>
<li>打包的前提是docker已经启动了</li>
</ul>
<p>打包成功之后，可以看到会多一个docker镜像</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>运行镜像并测试</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/210304/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> II. 其他</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>项目: <a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/400-docker-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/400-docker-demo</a></li>
</ul>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="SpringBoot"/>
    <category term="运维系列"/>
    <category term="Docker"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2021-03-04T19:27:54.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">Docker</title>
    <id>https://liuyueyi.github.io/tutorial/spring/middle/Docker/</id>
    <link href="https://liuyueyi.github.io/tutorial/spring/middle/Docker/"/>
    <updated>2023-02-10T04:50:05.000Z</updated>
    <summary type="html"><![CDATA[<p>SpringBoot配置docker，实现容器化管理部署</p>
]]></summary>
    <content type="html"><![CDATA[<p>SpringBoot配置docker，实现容器化管理部署</p>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2023-02-10T04:50:05.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">1.邮件发送姿势介绍</title>
    <id>https://liuyueyi.github.io/tutorial/spring/middle/Email/210802-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8B%E9%82%AE%E4%BB%B6%E5%8F%91%E9%80%81%E5%A7%BF%E5%8A%BF%E4%BB%8B%E7%BB%8D.html</id>
    <link href="https://liuyueyi.github.io/tutorial/spring/middle/Email/210802-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8B%E9%82%AE%E4%BB%B6%E5%8F%91%E9%80%81%E5%A7%BF%E5%8A%BF%E4%BB%8B%E7%BB%8D.html"/>
    <updated>2023-02-10T04:50:05.000Z</updated>
    <summary type="html"><![CDATA[<p>邮件发送，在实际的项目开发中，可能用的不是特别多，如果没有特定的需求，相信也没有多少小伙伴会特意的去关注，那么如果现在我们希望针对项目做一个异常的报警系统，当出现异常的时候，可以向指定的小伙伴发送邮件提醒，那么让我们来实现这个功能，可以怎么办呢？</p>
<p>这里介绍一下如何使用SpringBoot封装好的MailSender来实现邮件发送</p>
]]></summary>
    <content type="html"><![CDATA[<p>邮件发送，在实际的项目开发中，可能用的不是特别多，如果没有特定的需求，相信也没有多少小伙伴会特意的去关注，那么如果现在我们希望针对项目做一个异常的报警系统，当出现异常的时候，可以向指定的小伙伴发送邮件提醒，那么让我们来实现这个功能，可以怎么办呢？</p>
<p>这里介绍一下如何使用SpringBoot封装好的MailSender来实现邮件发送</p>
<!-- more -->
<h2> I. 项目环境</h2>
<h3> 1. 项目依赖</h3>
<p>本项目借助<code>SpringBoot 2.2.1.RELEASE</code> + <code>maven 3.5.3</code> + <code>IDEA</code>进行开发</p>
<p>开一个web服务用于测试</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 配置</h3>
<p>在开始之前，我们需要先准备一个用于发送邮件的账号，比如我这里使用163的邮箱来发送邮件，需要先到邮箱提供商哪里获取授权码，具体如何获取这个东西，不同的邮箱姿势有些不同，各位小伙伴根据自己的实际情况，搜索一下，相信很快就能get到</p>
<p>这里简单介绍下网易邮箱的获取方式</p>
<figure><img src="/imgs/210802/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>接下来设置发送邮件相关的配置信息，配置文件<code>application.yml</code></p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> II. 邮件发送</h2>
<p>接下来进入正题，我们将从简单基础的文本邮件发送开始，逐渐介绍如何添加附件，使用漂亮的html模板等</p>
<h3> 1. 简单文本邮件发送</h3>
<p>我们这里直接使用<code>JavaMailSender</code>来发送一个基础的文本邮件</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>JavaMailSender: 直接作为一个Spring 的bean对象使用</li>
<li>SimpleMailMessage：简单的邮件对象，里面有一些邮件发送时，关联的基础信息
<ul>
<li>from: 发送方</li>
<li>replyTo: 邮件回复的收件人</li>
<li>to: 收件人</li>
<li>cc: 抄送</li>
<li>bcc: 密送</li>
<li>subject: 主题，也就是邮件标题</li>
<li>text: 邮件正文，文本格式</li>
<li>date: 邮件发送时间</li>
</ul>
</li>
</ul>
<h3> 2. html发送</h3>
<p>对于简单的文本邮件发送，用上面的基本就够了，如果我们希望邮件的内容更美观一点的话，可以借助HTML来实现排版</p>
<p>区别于上面的SimpleMailMessage, 这里使用的是MimeMessage，来实现html内容发送</p>
<p>使用姿势与上面相比差不多，无非就是正文变成了html文本罢了</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>重点注意</strong></p>
<ul>
<li>注意上面的<code>setText</code>方法的第二个参数，必须有，且为true，否则会当成文本内容发送</li>
</ul>
<h3> 3. 添加附件</h3>
<p>邮件中添加附件，我们自己写邮件的时候可以直接选择附件上传，那么代码的实现方式又有什么区别呢？</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意上面的实现，与前面差别不大，关键点在于<code>attachment</code>附件，上面的实现是在附件中添加一个图片，为了简单起见，图片是直接从网络下载的，然后将Stream作为传参</p>
<h3> 4. Freemaker模板</h3>
<p>上面的html发送，会发现需要我们自己来组装html正文，这个操作可能就不是很美好了，借助页面渲染引擎来实现邮件模板支持，可以说是一个比较常见的方案了，这里简单介绍下Freemaker的实现姿势，至于themlaf, beef或者jsp啥的，都没有太大的区别</p>
<p>首先写一个邮件模板 <code>resources/template/mail.ftl</code></p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的模板中，定义了两个变量，一个<code>title</code>，一个<code>content</code>，这个就是我们需要替换的值</p>
<p>接下来是邮件发送实例</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意上面的实现，关键点就利用<code>FreeMarkerTemplateUtils</code>来实现模板的渲染，输出html正文，因此如果想使用其他的模板渲染引擎，就是改这里即可</p>
<h3> 5. 测试与小结</h3>
<p>最后简单的调用一下上面的实现，看下邮件是否可以发送成功</p>
<figure><img src="/imgs/210802/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<figure><img src="/imgs/210802/02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>本篇博文介绍了一下如何发送邮件，并针对简单的文本邮件，html正文，附件等不同的给出了实例；整体看下来使用姿势不难，不过邮件的几个术语可以了解一下</p>
<ul>
<li>to: 接收人，就是邮件发送的目标群众</li>
<li>cc: 抄送，一般来讲抄送的名单，只是让他感知到有这封邮件，属于周知对象</li>
<li>bcc: 密送，与上面两个不一样，接收人和抄送人不知道密送给谁了，这就是最大的区别，说实话这个玩意我从没用过</li>
</ul>
<p>接下来一篇博文，将介绍一下如何将log日志与邮件发送关联起来，当出现异常的时候，邮件发送给开发者</p>
<h2> III. 不能错过的源码和相关知识点</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/</a></li>
</ul>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="SpringBoot"/>
    <category term="中间件"/>
    <category term="Email"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2021-08-02T21:41:28.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">2.实战：基于异常日志的邮件报警</title>
    <id>https://liuyueyi.github.io/tutorial/spring/middle/Email/210803-SpringBoot%E5%AE%9E%E6%88%98%E5%9F%BA%E4%BA%8E%E5%BC%82%E5%B8%B8%E6%97%A5%E5%BF%97%E7%9A%84%E9%82%AE%E4%BB%B6%E6%8A%A5%E8%AD%A6.html</id>
    <link href="https://liuyueyi.github.io/tutorial/spring/middle/Email/210803-SpringBoot%E5%AE%9E%E6%88%98%E5%9F%BA%E4%BA%8E%E5%BC%82%E5%B8%B8%E6%97%A5%E5%BF%97%E7%9A%84%E9%82%AE%E4%BB%B6%E6%8A%A5%E8%AD%A6.html"/>
    <updated>2023-02-10T04:50:05.000Z</updated>
    <summary type="html"><![CDATA[<p>相信所有奋斗在一线的小伙伴，会很关心自己的系统的运行情况，一般来说，基础设施齐全一点的公司都会有完善的报警方案，那么如果我们是一个小公司呢，不能因为基础设施没有，就失去对象的感知能力吧；如果我们的系统大量异常却不能实时的触达给我们，那么也就只会有一个结果--杀个程序猿祭天</p>
<p>本文简单的介绍一种实现思路，基于error日志来实现邮件的报警方案</p>
]]></summary>
    <content type="html"><![CDATA[<p>相信所有奋斗在一线的小伙伴，会很关心自己的系统的运行情况，一般来说，基础设施齐全一点的公司都会有完善的报警方案，那么如果我们是一个小公司呢，不能因为基础设施没有，就失去对象的感知能力吧；如果我们的系统大量异常却不能实时的触达给我们，那么也就只会有一个结果--杀个程序猿祭天</p>
<p>本文简单的介绍一种实现思路，基于error日志来实现邮件的报警方案</p>
<!-- more -->
<h2> I. 项目环境</h2>
<h3> 1. 项目依赖</h3>
<p>本项目借助<code>SpringBoot 2.2.1.RELEASE</code> + <code>maven 3.5.3</code> + <code>IDEA</code>进行开发</p>
<p>开一个web服务用于测试</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 配置</h3>
<p>邮件相关配置如下，注意使用自己的用户名 + 授权码填充下面缺失的配置</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> II. 异常日志的邮件预警</h2>
<h3> 1. 设计思路</h3>
<p>接下来这个方案的主要出发点在于，当程序出现大量的异常，表明应用多半出现了问题，需要立马发送给项目owner</p>
<p>要实现这个方案，关键点就在于异常出现的感知与上报</p>
<ul>
<li>异常的捕获，并输出日志（这个感觉属于标配了吧，别告诉我现在还有应用不输出日志文件的...）
<ul>
<li>对于这个感知，借助logback的扩展机制，可以实现，后面介绍</li>
</ul>
</li>
<li>异常上报：邮件发送</li>
</ul>
<p>关于email的使用姿势，推荐参考博文 <a href="http://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247486591&amp;idx=1&amp;sn=04f18e2f313abd371947f9818e238067&amp;chksm=fce717d3cb909ec575b8e521843eff04edfcf844e59ca976515bc29d8a23782c4d5d30580d0e&amp;token=908878619&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">SpringBoot 系列之邮件发送姿势介绍</a></p>
<h3> 2. 自定义appender</h3>
<p>定义一个用于错误发送的Appender，如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. Spring容器</h3>
<p>上面的邮件发送中，需要使用<code>JavaMailSender</code>，写一个简单的SpringContext工具类，用于获取Bean/Propertiy</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4. logback配置</h3>
<p>接下来就是在日志配置中，使用我们上面定义的Appender</p>
<p><code>logback-spring.xml</code>文件内容如下：</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 5. 测试demo</h3>
<p>接下来演示一下，是否可以达到我们的预期</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/210803/00.gif" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 5.小结</h3>
<p>本篇博文主要提供了一个思路，借助logback的扩展机制，来实现错误日志与预警邮件绑定，实现一个简单的应用异常监控</p>
<p>上面这个实现只算是一个雏形，算是抛砖引玉，有更多可以丰富的细节，比如</p>
<ul>
<li>飞书/钉钉通知（借助飞书钉钉的机器来报警，相比较于邮件感知性更高）</li>
<li>根据异常类型，做预警的区分</li>
<li>更高级的频率限制等</li>
</ul>
<p>在这里推荐一个我之前开源的预警系统，可以实现灵活预警方案配置，频率限制，重要性升级等</p>
<ul>
<li>一个可扩展的报警系统 <a href="https://github.com/liuyueyi/quick-alarm" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/quick-alarm</a></li>
</ul>
<h2> III. 不能错过的源码和相关知识点</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-case/430-mail-alarm" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-case/430-mail-alarm</a></li>
</ul>
<p>推荐关联博文</p>
<ul>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247486591&amp;idx=1&amp;sn=04f18e2f313abd371947f9818e238067&amp;chksm=fce717d3cb909ec575b8e521843eff04edfcf844e59ca976515bc29d8a23782c4d5d30580d0e&amp;token=908878619&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">SpringBoot 系列之邮件发送姿势介绍</a></li>
</ul>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="SpringBoot"/>
    <category term="中间件"/>
    <category term="Email"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2021-08-03T21:09:39.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">Email</title>
    <id>https://liuyueyi.github.io/tutorial/spring/middle/Email/index.html</id>
    <link href="https://liuyueyi.github.io/tutorial/spring/middle/Email/index.html"/>
    <updated>2023-02-10T04:50:05.000Z</updated>
    <summary type="html"><![CDATA[<p>SpringBoot无障碍使用邮箱服务</p>
]]></summary>
    <content type="html"><![CDATA[<p>SpringBoot无障碍使用邮箱服务</p>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2023-02-10T04:50:05.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">1.Prometheus实现应用监控</title>
    <id>https://liuyueyi.github.io/tutorial/spring/middle/Prometheus/210419-SpringBoot%E6%95%B4%E5%90%88Prometheus%E5%AE%9E%E7%8E%B0%E5%BA%94%E7%94%A8%E7%9B%91%E6%8E%A7.html</id>
    <link href="https://liuyueyi.github.io/tutorial/spring/middle/Prometheus/210419-SpringBoot%E6%95%B4%E5%90%88Prometheus%E5%AE%9E%E7%8E%B0%E5%BA%94%E7%94%A8%E7%9B%91%E6%8E%A7.html"/>
    <updated>2023-02-10T04:50:05.000Z</updated>
    <summary type="html"><![CDATA[<h3> 1. prometheus 安装</h3>
<p>教程文档: <a href="https://www.prometheus.wang/quickstart/install-prometheus-server.html" target="_blank" rel="noopener noreferrer">https://www.prometheus.wang/quickstart/install-prometheus-server.html</a></p>
<h4> 1.1 什么是Prometheus</h4>
<blockquote>
<p>普罗米修斯：Prometheus是一个开放性的监控解决方案，用户可以非常方便的安装和使用Prometheus并且能够非常方便的对其进行扩展</p>
</blockquote>
]]></summary>
    <content type="html"><![CDATA[<h3> 1. prometheus 安装</h3>
<p>教程文档: <a href="https://www.prometheus.wang/quickstart/install-prometheus-server.html" target="_blank" rel="noopener noreferrer">https://www.prometheus.wang/quickstart/install-prometheus-server.html</a></p>
<h4> 1.1 什么是Prometheus</h4>
<blockquote>
<p>普罗米修斯：Prometheus是一个开放性的监控解决方案，用户可以非常方便的安装和使用Prometheus并且能够非常方便的对其进行扩展</p>
</blockquote>
<!-- more -->
<p>下面将实现一个SpringBoot应用接入Prometheus的全过程</p>
<h4> 1.2 安装</h4>
<p>Linux 安装</p>
<ul>
<li>官网指定下载包:  <a href="https://prometheus.io/download/" target="_blank" rel="noopener noreferrer">https://prometheus.io/download/</a></li>
</ul>
<p>下载本地安装启动</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>启动完毕之后，本地访问 <a href="http://127.0.0.1:9090/graph" target="_blank" rel="noopener noreferrer">http://127.0.0.1:9090/graph</a> 可以看到默认提供的界面</p>
<h3> 2. SpringBoot应用接入</h3>
<p>我们演示的SpringBoot为2.0+，因此直接选择<code>io.micrometer</code> 的依赖包来实现；更低版本的不能使用这种姿势，可以直接使用官方提供的client来实现；这里不进行扩展</p>
<h4> 2.1 依赖配置</h4>
<p>借助SpringBoot的actuator来提供扩展端点（所以本文采用的是Prometheus的拉工作模式）</p>
<p>SpringBoot版本为 <code>2.2.1.RELEASE</code></p>
<p>核心依赖</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>yaml配置文件，需要指定Prometheus相关的参数，一个demo如下</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>注意</strong></p>
<ul>
<li><code>management.endpoints.web.exposure.include</code> 这里指定所有的web接口都会上报</li>
<li><code>metrics.tags.application</code> 这个应用所有上报的metrics 都会带上<code>application</code>这个标签</li>
</ul>
<p>上面配置完毕之后，会提供一个 <code>/actuator/prometheus</code>的端点，供prometheus来拉取Metrics信息</p>
<h4> 2.2 应用启动</h4>
<p>对于SpringBoot而言，此时就不需要额外做什么，就可以实现应用的基本信息上报了</p>
<p>一个简单的demo如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>到此，springboot应用的监控就算是完成了；接下来配置一下prometheus的服务端</p>
<h3> 3. prometheus 配置与实测</h3>
<p>在前面下载的包下面，有一个配置文件 <code>prometheus.yml</code>，新增一个Job</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>修改配置之后，需要重启一下，当服务启动之后，可以在控制台上我们的应用信息</p>
<figure><img src="/imgs/210419/00.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>接下来访问Graph，选择metric: <code>http_server_requests_seconds_count</code> 可以看到一条抓起metric的记录</p>
<figure><img src="/imgs/210419/01.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>前面我们定义了一个Controller，接下来简单访问几次，然后再看一下，会发现多一条记录</p>
<figure><img src="/imgs/210419/02.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>这些数据由框架层直接集成，实现REST接口的相关信息上报，借助这个metric，我们可以实现qps的统计</p>
<h4> 3.1 qps统计</h4>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="/imgs/210419/03.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<ul>
<li>rate: 用于统计增长趋势，要求上报的Metric为Counter类型（只增不减）</li>
<li>irate: 与rate相似，区别在于rate统计的是一段时间内的平均增长速率，无法反应这个时间窗口内的突发情况（即瞬时高峰），irate通过区间向量中最后两个样本数据来计算增长速率，但是当选用的区间范围较大时，可能造成不小的偏差</li>
<li>sum: 求和，适用于统计场景</li>
</ul>
<p>更多内置函数，可以参考: <a href="https://www.prometheus.wang/promql/prometheus-promql-functions.html" target="_blank" rel="noopener noreferrer">PromQL内置函数</a></p>
<h4> 3.2 耗时统计</h4>
<p>除了qps，另外一个经常关注的指标就是rt了，如上面接口的平均rt，通过两个Metric的组合来实现</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="/imgs/210419/04.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>将sum聚合去掉之后，则可以看到各接口的访问情况</p>
<figure><img src="/imgs/210419/05.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 4. Grafana 大盘配置</h3>
<p>面板监控，还是Grafana的比较强大，特别是grafana本身提供了很多模板可以直接导入</p>
<blockquote>
<p>安装可以参考: <a href="https://blog.hhui.top/hexblog/2021/03/18/210318-linux-grafana%E5%A4%A7%E7%9B%98%E6%8E%A5%E5%85%A5mysql/" target="_blank" rel="noopener noreferrer">210318-linux grafana大盘接入mysql</a></p>
</blockquote>
<h4> 4.1 大盘配置</h4>
<p>grafana启动之后，配置数据源Promethues</p>
<figure><img src="/imgs/210419/06.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>接下来配置SpringBoot的应用配置面板，可以直接使用现成的模板，比如 12856</p>
<figure><img src="/imgs/210419/07.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>导入完毕之后，大盘展示如下</p>
<figure><img src="/imgs/210419/08.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>可以看一下请求耗时的统计promql</p>
<figure><img src="/imgs/210419/09.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h4> 4.2 大盘模板哪里找</h4>
<p>如何找直接可用的大盘呢？</p>
<ul>
<li>官网的大盘上查找即可</li>
<li>如 <a href="https://grafana.com/grafana/dashboards?dataSource=prometheus&amp;search=spring" target="_blank" rel="noopener noreferrer">https://grafana.com/grafana/dashboards?dataSource=prometheus&amp;search=spring</a></li>
<li>选择一个，点进去之后，右边的<code>Copy ID toClipboard</code> 对应的数字就是我们需要的</li>
</ul>
<figure><img src="/imgs/210419/10.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 5. 小结</h3>
<p>上面整个流程走下来会发现SpringBoot项目接入Prometheus成本很低，基本上没有太多的编码工作，就可以配置给功能集全的监控大盘，简直不要太嗨</p>
<p>高度封装的便捷性再这里体现得非常突出了，但是搞完之后，再回想一下，我get到了什么？</p>
<p>好像什么都没get到，如果我的服务只提供grpc/dubbo接口，现在假设让我们接入监控，好像还是抓瞎，这该怎么玩</p>
<h2> II. 其他</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>项目源码: <a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/420-prometheus-basic" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/420-prometheus-basic</a></li>
</ul>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="SpringBoot"/>
    <category term="中间件"/>
    <category term="Prometheus"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2021-04-19T18:40:03.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">2.自定义埋点上报</title>
    <id>https://liuyueyi.github.io/tutorial/spring/middle/Prometheus/211109-SpringBoot%E4%B9%8BPrometheus%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%8B%E7%82%B9%E4%B8%8A%E6%8A%A5.html</id>
    <link href="https://liuyueyi.github.io/tutorial/spring/middle/Prometheus/211109-SpringBoot%E4%B9%8BPrometheus%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%8B%E7%82%B9%E4%B8%8A%E6%8A%A5.html"/>
    <updated>2023-02-10T04:50:05.000Z</updated>
    <summary type="html"><![CDATA[<p>之前介绍了一篇SpringBoot集成Prometheus实现数据上报的博文，在前面一篇博文中，更多的是一个SpringBoot应用如何最小成本的接入Prometheus，并结合Grafana配置一个完整的应用监控大盘</p>
<p>有看过前文的小伙伴可能知晓，SpringBoot接入Prometheus之后，基本上不用做额外的开发，就已经实现了我们关心的JVM情况、GC情况、HTTP调用请求等信息，然而在实际的业务开发过程中，我们总会遇到一些需要手动上报的场景，那么我们可以怎么处理呢？</p>
<p>本文的核心知识点：</p>
<ul>
<li>通过一个实例演示SpringBoot应用，如何实现自定义的数据上报</li>
</ul>
<p>上篇博文: <a href="https://spring.hhui.top/spring-blog/2021/04/19/210419-SpringBoot%E6%95%B4%E5%90%88Prometheus%E5%AE%9E%E7%8E%B0%E5%BA%94%E7%94%A8%E7%9B%91%E6%8E%A7/" target="_blank" rel="noopener noreferrer">SpringBoot整合Prometheus实现应用监控</a></p>
]]></summary>
    <content type="html"><![CDATA[<p>之前介绍了一篇SpringBoot集成Prometheus实现数据上报的博文，在前面一篇博文中，更多的是一个SpringBoot应用如何最小成本的接入Prometheus，并结合Grafana配置一个完整的应用监控大盘</p>
<p>有看过前文的小伙伴可能知晓，SpringBoot接入Prometheus之后，基本上不用做额外的开发，就已经实现了我们关心的JVM情况、GC情况、HTTP调用请求等信息，然而在实际的业务开发过程中，我们总会遇到一些需要手动上报的场景，那么我们可以怎么处理呢？</p>
<p>本文的核心知识点：</p>
<ul>
<li>通过一个实例演示SpringBoot应用，如何实现自定义的数据上报</li>
</ul>
<p>上篇博文: <a href="https://spring.hhui.top/spring-blog/2021/04/19/210419-SpringBoot%E6%95%B4%E5%90%88Prometheus%E5%AE%9E%E7%8E%B0%E5%BA%94%E7%94%A8%E7%9B%91%E6%8E%A7/" target="_blank" rel="noopener noreferrer">SpringBoot整合Prometheus实现应用监控</a></p>
<!-- more -->
<h2> I. 项目环境搭建</h2>
<p>本文演示的项目主要为SpringBoot2.2.1版本，更高的版本使用姿势没有太大的区别，至于1.x版本的不确保可行（因为我并没有测试）</p>
<h3> 1.依赖</h3>
<p>pom依赖，主要是下面几个包</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 配置信息</h3>
<p>其次是配置文件，注册下Prometheus的相关信息</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面配置中，有两个关键信息，前面博文也有介绍，这里简单说明</p>
<ul>
<li><code>management.endpoints.web.exposure.include</code> 这里指定所有的web接口都会上报</li>
<li><code>metrics.tags.application</code> 这个应用所有上报的metrics 都会带上application这个标签</li>
</ul>
<p>配置完毕之后，会提供一个 <code>/actuator/prometheus</code>的端点，供prometheus来拉取Metrics信息</p>
<h2> II. 自定义上报</h2>
<p>假设我们现在想自己上报http请求的相关信息，当前计划采集下面几个信息</p>
<ul>
<li>总的请求数：采用<code>Counter</code></li>
<li>当前正在处理的请求数：采用<code>Gauge</code></li>
<li>请求耗时直方图: <code>Histogram</code></li>
</ul>
<h3> 1. Prometheus Metric封装</h3>
<p>基于上面的分析，我们这里实现了三种常见的Metric信息上报，这里提供一个统一的封装类，用于获取对应的Metric类型</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意上面的<code>setApplicationContext()</code>的方法实现逻辑，其中在创建<code>Counter/Gauge/Histogram</code>时，使用的是<code>simpleclient</code>包中提供的最基础的用法，并不是<code>micrometer</code>的封装方式，后面一篇博文会介绍到两种的差异性</p>
<p>上面实现的特点在于，创建Metric时，就已经定义好了label标签，这里定义了</p>
<ul>
<li>path: 请求url路径</li>
<li>method: http方法, get/post</li>
<li>code: 状态码，表示请求成功还是异常</li>
</ul>
<h3> 2. 拦截器实现自定义信息采集上报</h3>
<p>接下来我们实现一个自定义的拦截器，拦截所有的http请求，然后上报关键信息</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对于拦截器的知识点这里不进行展开，有兴趣的小伙伴可以查看 <a href="https://spring.hhui.top/spring-blog/2021/08/04/210804-SpringBoot%E7%B3%BB%E5%88%97Web%E7%AF%87%E4%B9%8B%E6%8B%A6%E6%88%AA%E5%99%A8Interceptor%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF%E4%BB%8B%E7%BB%8D/" target="_blank" rel="noopener noreferrer">SpringBoot系列Web篇之拦截器Interceptor使用姿势介绍</a></p>
<p>这里我们主要关心的就两点</p>
<ul>
<li>执行之前（<code>preHandle</code>）： gauge计数+1，开始计时</li>
<li>执行之后 (<code>afterCompletion</code>)： guage计数-1，counter计数+1，计时收集</li>
</ul>
<h3> 3. 测试</h3>
<p>最后我们需要注册上面的拦截器，并写个demo进行测试一下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>应用启动之后，访问几次hello的http接口，然后在查看一下metric信息，看是否有我们刚才上报的数据</p>
<figure><img src="/imgs/211109/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 4. 小结</h3>
<p>这一篇博文算是上一篇的补全，若我们希望自定义上报一些信息，可以使用上面这种方式来支持</p>
<p>当然，上报并不代表结束，接下来配置大盘等信息也非常的关键，特别是直方图如何配置Grafana？怎么查看请求的耗时分布情况，就由下文来介绍了</p>
<h2> III. 不能错过的源码和相关知识点</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/</a></li>
</ul>
<h3> 1. 微信公众号: 一灰灰Blog</h3>
<p>尽信书则不如，以上内容，纯属一家之言，因个人能力有限，难免有疏漏和错误之处，如发现bug或者有更好的建议，欢迎批评指正，不吝感激</p>
<p>下面一灰灰的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛</p>
<ul>
<li>一灰灰Blog个人博客 <a href="https://blog.hhui.top" target="_blank" rel="noopener noreferrer">https://blog.hhui.top</a></li>
<li>一灰灰Blog-Spring专题博客 <a href="http://spring.hhui.top" target="_blank" rel="noopener noreferrer">http://spring.hhui.top</a></li>
</ul>
<figure><img src="https://spring.hhui.top/spring-blog/imgs/info/info.png" alt="一灰灰blog" tabindex="0" loading="lazy"><figcaption>一灰灰blog</figcaption></figure>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="SpringBoot"/>
    <category term="中间件"/>
    <category term="Prometheus"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2021-11-09T18:44:30.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">3.自定义埋点姿势二</title>
    <id>https://liuyueyi.github.io/tutorial/spring/middle/Prometheus/211119-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8BPrometheus%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%8B%E7%82%B9%E5%A7%BF%E5%8A%BF%E4%BA%8C.html</id>
    <link href="https://liuyueyi.github.io/tutorial/spring/middle/Prometheus/211119-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8BPrometheus%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%8B%E7%82%B9%E5%A7%BF%E5%8A%BF%E4%BA%8C.html"/>
    <updated>2023-02-10T04:50:05.000Z</updated>
    <summary type="html"><![CDATA[<p>关于Prometheus的自定义埋点，前一篇博文已经介绍了，为啥这里又来一次？</p>
<p>看过前文的小伙伴可能会知道，之前采用的<code>simpleclient</code>包定义的几个metric来实现的，实际上有更简单方便的姿势，那就是直接借助<code>MeterRegistry</code>来创建Metric来实现数据采集即可</p>
<p>相比较于前文的实现，总的来说简易程度可见一般，上篇文章可以点击下文查看</p>
<ul>
<li><a href="https://spring.hhui.top/spring-blog/2021/11/09/211109-SpringBoot%E4%B9%8BPrometheus%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%8B%E7%82%B9%E4%B8%8A%E6%8A%A5/" target="_blank" rel="noopener noreferrer">【中间件】Prometheus自定义埋点上报 | 一灰灰Blog</a></li>
</ul>
]]></summary>
    <content type="html"><![CDATA[<p>关于Prometheus的自定义埋点，前一篇博文已经介绍了，为啥这里又来一次？</p>
<p>看过前文的小伙伴可能会知道，之前采用的<code>simpleclient</code>包定义的几个metric来实现的，实际上有更简单方便的姿势，那就是直接借助<code>MeterRegistry</code>来创建Metric来实现数据采集即可</p>
<p>相比较于前文的实现，总的来说简易程度可见一般，上篇文章可以点击下文查看</p>
<ul>
<li><a href="https://spring.hhui.top/spring-blog/2021/11/09/211109-SpringBoot%E4%B9%8BPrometheus%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%8B%E7%82%B9%E4%B8%8A%E6%8A%A5/" target="_blank" rel="noopener noreferrer">【中间件】Prometheus自定义埋点上报 | 一灰灰Blog</a></li>
</ul>
<!-- more -->
<h2> I. 自定义上报</h2>
<p>依然是搭建一个基础项目工程，本文演示的项目主要为SpringBoot2.2.1版本，更高的版本使用姿势没有太大的区别，至于1.x版本的不确保可行（因为我并没有测试）</p>
<h3> 1.依赖</h3>
<p>pom依赖，主要是下面几个包</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 配置信息</h3>
<p>其次是配置文件，注册下Prometheus的相关信息</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面配置中，有两个关键信息，前面博文也有介绍，这里简单说明</p>
<ul>
<li><code>management.endpoints.web.exposure.include</code> 这里指定所有的web接口都会上报</li>
<li><code>metrics.tags.application</code> 这个应用所有上报的metrics 都会带上application这个标签</li>
</ul>
<p>配置完毕之后，会提供一个 <code>/actuator/prometheus</code>的端点，供prometheus来拉取Metrics信息</p>
<h3> 3. 自定义拦截器实现采集上报</h3>
<p>实现一个基础的拦截器，用来拦截所有的http请求，然后收集请求信息上报</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意上面的三种Metric的创建方式</p>
<ul>
<li>Counter: 直接使用 <code>meterRegistry.counter()</code>来创建metric并实现计数+1
<ul>
<li>传参中，Tags组成的就是propmetheus中定义的label，kv格式，第一个参数用来定义MetricName</li>
</ul>
</li>
<li>Gauge: 使用姿势与上面基本相同，不过需要注意计数的加减是直接在传参中</li>
<li>Histogram: 它的使用姿势就需要特别注意下了，在preHander中定义的是 <code>Timer.Sampler</code>对象，在 <code>postHandler</code>中实现的数据采集</li>
</ul>
<p>上面短短一点代码，就实现了一个简单的自定义信息上报；接下来就是注册拦截器了</p>
<h3> 4. 注册并测试</h3>
<p>拦截器依赖了Spring的bean对象，因此需要将它定义为bean对象</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>基于此一个简单的自定义采集上报就完成了；项目启动之后，通过访问采集端点查看是否有数据上报</p>
<figure><img src="/imgs/211119/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>最后小结一下，虽然SpringBoot可以非常方便的接入prometheus来采集一些常见的指标，但是当我们有自定义上报指标的需求时，直接使用<code>MeterRegistry</code>来收集信息，创建Metric是个不错的选择，通常我们选择的三种类型作用如下</p>
<ul>
<li>总的请求数：采用<code>Counter</code></li>
<li>当前正在处理的请求数：采用<code>Gauge</code></li>
<li>请求耗时直方图: <code>Histogram</code></li>
</ul>
<h2> II. 不能错过的源码和相关知识点</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/421-prometheus-micro" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/421-prometheus-micro</a></li>
</ul>
<h3> 1. 微信公众号: 一灰灰Blog</h3>
<p>尽信书则不如，以上内容，纯属一家之言，因个人能力有限，难免有疏漏和错误之处，如发现bug或者有更好的建议，欢迎批评指正，不吝感激</p>
<p>下面一灰灰的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛</p>
<ul>
<li>一灰灰Blog个人博客 <a href="https://blog.hhui.top" target="_blank" rel="noopener noreferrer">https://blog.hhui.top</a></li>
<li>一灰灰Blog-Spring专题博客 <a href="http://spring.hhui.top" target="_blank" rel="noopener noreferrer">http://spring.hhui.top</a></li>
</ul>
<figure><img src="https://spring.hhui.top/spring-blog/imgs/info/info.png" alt="一灰灰blog" tabindex="0" loading="lazy"><figcaption>一灰灰blog</figcaption></figure>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="SpringBoot"/>
    <category term="中间件"/>
    <category term="Prometheus"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2021-11-19T19:30:15.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">4.基于AOP实现埋点采集上报</title>
    <id>https://liuyueyi.github.io/tutorial/spring/middle/Prometheus/211222-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8BPrometheus%E5%9F%BA%E4%BA%8EAOP%E5%AE%9E%E7%8E%B0%E5%9F%8B%E7%82%B9%E9%87%87%E9%9B%86%E4%B8%8A%E6%8A%A5.html</id>
    <link href="https://liuyueyi.github.io/tutorial/spring/middle/Prometheus/211222-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8BPrometheus%E5%9F%BA%E4%BA%8EAOP%E5%AE%9E%E7%8E%B0%E5%9F%8B%E7%82%B9%E9%87%87%E9%9B%86%E4%B8%8A%E6%8A%A5.html"/>
    <updated>2023-02-10T04:50:05.000Z</updated>
    <summary type="html"><![CDATA[<p>前面几篇文章介绍了SpringBoot继承Prometheus实现埋点上报，基本上可以非常简单的实现采样收集，对于由SpringBoot搭建的web应用，甚至是可以说是引入依赖，简单的配置下，剩下的啥也不用管，就可以配置一个REST应用的监控大盘</p>
<p>接下来我们通过AOP的方式，来定义一个自定义数据采集的功能，用于实现一些上面覆盖不到的场景（如应用内的定时任务执行情况，三方接口请求监控等）</p>
<!--  more -->
<h2> I. 方案确定与环境搭建</h2>
<h3> 1.metric选择</h3>
<p>通过前面的几篇文章，至少我们会了解到Prometheus的四种Metric，对于自定义的数据采集，根据最终希望监控的指标（每秒请求数 qps, 响应耗时 rt, 可用率 sla, 请求分布），我们这里选择Histogram</p>]]></summary>
    <content type="html"><![CDATA[<p>前面几篇文章介绍了SpringBoot继承Prometheus实现埋点上报，基本上可以非常简单的实现采样收集，对于由SpringBoot搭建的web应用，甚至是可以说是引入依赖，简单的配置下，剩下的啥也不用管，就可以配置一个REST应用的监控大盘</p>
<p>接下来我们通过AOP的方式，来定义一个自定义数据采集的功能，用于实现一些上面覆盖不到的场景（如应用内的定时任务执行情况，三方接口请求监控等）</p>
<!--  more -->
<h2> I. 方案确定与环境搭建</h2>
<h3> 1.metric选择</h3>
<p>通过前面的几篇文章，至少我们会了解到Prometheus的四种Metric，对于自定义的数据采集，根据最终希望监控的指标（每秒请求数 qps, 响应耗时 rt, 可用率 sla, 请求分布），我们这里选择Histogram</p>
<ul>
<li>通过histogram指标中的 count 值来计算qps</li>
<li>通过 sum / count 来计算rt</li>
<li>通过<code>成功数 / 总请求数</code>计算可用率sla</li>
<li>通过histogram的bucket分布来查看请求分布</li>
</ul>
<h3> 2.项目依赖</h3>
<p>本项目借助<code>SpringBoot 2.2.1.RELEASE</code> +  <code>maven 3.5.3</code> + <code>IDEA</code>进行开发</p>
<p>其核心pom依赖，主要是下面几个包</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. 配置信息</h3>
<p>其次是配置文件，注册下Prometheus的相关信息</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面配置中，有两个关键信息，前面博文也有介绍，这里简单说明</p>
<ul>
<li><code>management.endpoints.web.exposure.include</code> 这里指定所有的web接口都会上报</li>
<li><code>metrics.tags.application</code> 这个应用所有上报的metrics 都会带上application这个标签</li>
</ul>
<p>配置完毕之后，会提供一个 <code>/actuator/prometheus</code>的端点，供prometheus来拉取Metrics信息</p>
<h2> II. AOP切面实现埋点上报</h2>
<h3> 1. 切面实现类</h3>
<p>通过切面来拦截目标类的执行，选择三个关键指标</p>
<ul>
<li>service: 表示具体执行的类</li>
<li>method：执行的方法</li>
<li>err: true 表示执行异常/else 表示执行正常</li>
</ul>
<p>直接使用Histogram来实现数据采集上报，直接使用前面博文* <a href="https://spring.hhui.top/spring-blog/2021/11/19/211119-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8BPrometheus%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%8B%E7%82%B9%E5%A7%BF%E5%8A%BF%E4%BA%8C/" target="_blank" rel="noopener noreferrer">【中间件】Prometheus自定义埋点姿势二 | 一灰灰Blog</a> 使用姿势即可</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 测试方法</h3>
<p>这里写两个简单的Service类，作为收集采样的目标</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后我们通过定时任务来不断的访问上面的服务方法，用来模拟请求场景</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. 启动类</h3>
<p>最后就是在启动类中注册一下MeterRegistryCustomizer，为所有的metric携带上<code>application</code>标签</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>应用启动之后，就可以通过<code>http://m-162d9nnes031u:8080/actuator/prometheus</code>来查看收集的采样信息了，如</p>
<figure><img src="/imgs/211222/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 4. 业务大盘配置</h3>
<p>上面基本即实现了一个基于aop的采样收集，接下来重点就是如何将这些收集上来的数据，可视化配置起来</p>
<p>借助Grafana无疑是个比较推荐的case，下一篇博文将详细介绍如何针对上面收集的信息进行友好的配置，欢迎有兴趣的小伙伴关注吐槽</p>
<h2> III. 不能错过的源码和相关知识点</h2>
<h3> 0. 项目源码</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-case/421-prometheus-metric" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-case/421-prometheus-metric</a></li>
</ul>
<p><strong>系列博文：</strong></p>
<ul>
<li><a href="https://spring.hhui.top/spring-blog/2021/11/19/211119-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8BPrometheus%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%8B%E7%82%B9%E5%A7%BF%E5%8A%BF%E4%BA%8C/" target="_blank" rel="noopener noreferrer">【中间件】Prometheus自定义埋点姿势二</a></li>
<li><a href="https://spring.hhui.top/spring-blog/2021/11/09/211109-SpringBoot%E4%B9%8BPrometheus%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%8B%E7%82%B9%E4%B8%8A%E6%8A%A5/" target="_blank" rel="noopener noreferrer">【中间件】Prometheus自定义埋点上报</a></li>
<li><a href="https://spring.hhui.top/spring-blog/2021/04/19/210419-SpringBoot%E6%95%B4%E5%90%88Prometheus%E5%AE%9E%E7%8E%B0%E5%BA%94%E7%94%A8%E7%9B%91%E6%8E%A7/" target="_blank" rel="noopener noreferrer">【中间件】Prometheus实现应用监控</a></li>
</ul>
<h3> 1. 微信公众号: 一灰灰Blog</h3>
<p>尽信书则不如，以上内容，纯属一家之言，因个人能力有限，难免有疏漏和错误之处，如发现bug或者有更好的建议，欢迎批评指正，不吝感激</p>
<p>下面一灰灰的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛</p>
<ul>
<li>一灰灰Blog个人博客 <a href="https://blog.hhui.top" target="_blank" rel="noopener noreferrer">https://blog.hhui.top</a></li>
<li>一灰灰Blog-Spring专题博客 <a href="http://spring.hhui.top" target="_blank" rel="noopener noreferrer">http://spring.hhui.top</a></li>
</ul>
<figure><img src="https://spring.hhui.top/spring-blog/imgs/info/info.png" alt="一灰灰blog" tabindex="0" loading="lazy"><figcaption>一灰灰blog</figcaption></figure>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="SpringBoot"/>
    <category term="中间件"/>
    <category term="Prometheus"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2021-12-22T19:30:15.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">5.Prometheus大盘配置实战</title>
    <id>https://liuyueyi.github.io/tutorial/spring/middle/Prometheus/211223-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8BPrometheus%E5%A4%A7%E7%9B%98%E9%85%8D%E7%BD%AE%E5%AE%9E%E6%88%98.html</id>
    <link href="https://liuyueyi.github.io/tutorial/spring/middle/Prometheus/211223-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8BPrometheus%E5%A4%A7%E7%9B%98%E9%85%8D%E7%BD%AE%E5%AE%9E%E6%88%98.html"/>
    <updated>2023-02-10T04:50:05.000Z</updated>
    <summary type="html"><![CDATA[<p>借助Grafana来实现大盘配置，关于Grafana的启用配置，这里就不详细说明，有兴趣的可以查看前文 * <a href="https://spring.hhui.top/spring-blog/2021/04/19/210419-SpringBoot%E6%95%B4%E5%90%88Prometheus%E5%AE%9E%E7%8E%B0%E5%BA%94%E7%94%A8%E7%9B%91%E6%8E%A7/" target="_blank" rel="noopener noreferrer">【中间件】Prometheus实现应用监控 | 一灰灰Blog</a></p>
<p>接下来主要是针对上一篇 <a href="https://spring.hhui.top/spring-blog/2021/12/22/211222-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8BPrometheus%E5%9F%BA%E4%BA%8EAOP%E5%AE%9E%E7%8E%B0%E5%9F%8B%E7%82%B9%E9%87%87%E9%9B%86%E4%B8%8A%E6%8A%A5/" target="_blank" rel="noopener noreferrer">【中间件】Prometheus基于AOP实现埋点采集上报</a> 上报的Histogram数据，来配置一套相对完整的业务监控大盘</p>
]]></summary>
    <content type="html"><![CDATA[<p>借助Grafana来实现大盘配置，关于Grafana的启用配置，这里就不详细说明，有兴趣的可以查看前文 * <a href="https://spring.hhui.top/spring-blog/2021/04/19/210419-SpringBoot%E6%95%B4%E5%90%88Prometheus%E5%AE%9E%E7%8E%B0%E5%BA%94%E7%94%A8%E7%9B%91%E6%8E%A7/" target="_blank" rel="noopener noreferrer">【中间件】Prometheus实现应用监控 | 一灰灰Blog</a></p>
<p>接下来主要是针对上一篇 <a href="https://spring.hhui.top/spring-blog/2021/12/22/211222-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8BPrometheus%E5%9F%BA%E4%BA%8EAOP%E5%AE%9E%E7%8E%B0%E5%9F%8B%E7%82%B9%E9%87%87%E9%9B%86%E4%B8%8A%E6%8A%A5/" target="_blank" rel="noopener noreferrer">【中间件】Prometheus基于AOP实现埋点采集上报</a> 上报的Histogram数据，来配置一套相对完整的业务监控大盘</p>
<!-- more -->
<h2> I.大盘配置</h2>
<h3> 1. 基本盘选择</h3>
<p>直接到官网查找模板大盘，这里选择SpringBoot搭建的服务器项目，可以输入spring关键字进行检索</p>
<blockquote>
<p>官网：<a href="https://grafana.com/grafana/dashboards?dataSource=prometheus&amp;search=spring" target="_blank" rel="noopener noreferrer">https://grafana.com/grafana/dashboards?dataSource=prometheus&amp;search=spring</a></p>
</blockquote>
<p>比如我们这里选择 <code>6756</code> 作为基础模板；然后在Grafana上导入</p>
<figure><img src="/imgs/211223/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>导入之后，对于变量的依赖顺序根据实际情况调整一下，比如我希望第一个变量是application,在选择应用之后，再选择对应的实例ip；</p>
<p>修改步骤如下：</p>
<ul>
<li>依次选择：dashboard settings -&gt; variables</li>
<li>将application变量前置到instance前</li>
<li>application:
<ul>
<li>修改query为: <code>label_values(jvm_classes_loaded_classes, application)</code></li>
</ul>
</li>
<li>instance:
<ul>
<li>修改query为: <code>label_values(jvm_classes_loaded_classes{application="$application"}, instance)</code></li>
</ul>
</li>
<li>新增service变量
<ul>
<li>query = <code>label_values(micro_service_histogram_seconds_count{application="$application", instance="$instance"}, service)</code></li>
</ul>
</li>
</ul>
<figure><img src="/imgs/211223/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p><strong>注意</strong></p>
<ul>
<li>一个变量的取值依赖另一个变量，请注意将被依赖的变量顺序放在前面</li>
<li>一个变量的取值依赖另一个变量，写法是 <code>metric{tag="$valName"}</code>， 这个变量名前缀是<code>$</code>，且使用双引号包裹</li>
<li>metric的选择，可以通过直接查看目标服务器的metric接口查看，比如service变量选择的metric就是自定义上报的<code>micro_service_histogram_seconds_count</code>，而application与instance则选取的是Prometheus-Spring组件上报的spring应用基础信息中的metric</li>
</ul>
<h3> 2. 业务盘配置</h3>
<p>常见的业务指标，如QPS + RT + TPS + SLA等，接下来看一下如何进行配置</p>
<h4> 2.1 qps 每秒请求数</h4>
<p>主要是借助内置函数<code>rate</code>来计算qps，通过一个计算时间窗口的平均增长速率，来展示接口的qps</p>
<div class="language-PrmomQL line-numbers-mode" data-ext="PrmomQL"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="/imgs/211223/02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>使用rate来计算qps时，会存在一个<code>长尾问题</code>，因为它实际上是根据1min内的所有样本数据，来计算平均增长率，因此当一个时间窗口内，存在瞬时的大数据场景，将不能很好的反应出来</p>
<p>因此更关注瞬时场景时，可以考虑使用<code>irate</code>来代替，它是通过一个时间范围内的区间向量数据中最后两个来计算增长速率的</p>
<h4> 2.2 rt 接口响应平均耗时</h4>
<p>对于耗时的统计，也是比较重要的一个指标，用于判断我们系统的响应情况以及性能表现</p>
<p>核心配置： <code>rate(sum / count)</code></p>
<div class="language-PromQL line-numbers-mode" data-ext="PromQL"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>注意Y轴单位选择 <code>seconds</code></p>
<figure><img src="/imgs/211223/03.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h4> 2.3 接口耗时分布统计</h4>
<p>基于Histogram样本数据，配合Grafana的热点图来配置耗时统计分布</p>
<div class="language-PromQL line-numbers-mode" data-ext="PromQL"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="/imgs/211223/04.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>几个关键的配置</p>
<ul>
<li>配置参数中的Format 选择 Heatmap</li>
<li>面板的Visualization中，选择 Heatmap</li>
<li>面板中的Display，mode选择Opacity</li>
</ul>
<p>根据颜色的深浅，来判断哪个bucket的请求量较多</p>
<h4> 2.4 SLA可用率</h4>
<p>根据成功响应的计数 / 总计数来表征接口请求成功率</p>
<div class="language-PromQL line-numbers-mode" data-ext="PromQL"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="/imgs/211223/05.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 3. 应用维度统计支持</h3>
<p>前面的几个配置，统计面板都是基于某个应用，某个实例中的某个方法的维度进行展示，但实际情况是我们也很关注整体应用维度的表现情况</p>
<p>因此我们需要在变量选择中，支持全部</p>
<ul>
<li>开启变量的include all， 并设置<code>custorm all value = .*</code></li>
</ul>
<figure><img src="/imgs/211223/06.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<figure><img src="/imgs/211223/07.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<ul>
<li>第二步就是修改PromQL，将完全匹配调整为正则匹配 (将<code>=</code>改成<code>=~</code>)</li>
</ul>
<figure><img src="/imgs/211223/08.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 4.小结</h3>
<p>本文主要是通过grafana的大盘配置来展示如何使用Prometheus采集的数据，为了更好的使用采集数据，PromQL又是一个无法避免的知识点，下篇博文将带来PromQL的科普</p>
<h2> II. 不能错过的源码和相关知识点</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-case/421-prometheus-metric" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-case/421-prometheus-metric</a></li>
</ul>
<p><strong>系列博文：</strong></p>
<ul>
<li><a href="https://spring.hhui.top/spring-blog/2021/12/22/211222-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8BPrometheus%E5%9F%BA%E4%BA%8EAOP%E5%AE%9E%E7%8E%B0%E5%9F%8B%E7%82%B9%E9%87%87%E9%9B%86%E4%B8%8A%E6%8A%A5/" target="_blank" rel="noopener noreferrer">【中间件】Prometheus基于AOP实现埋点采集上报</a></li>
<li><a href="https://spring.hhui.top/spring-blog/2021/11/19/211119-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8BPrometheus%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%8B%E7%82%B9%E5%A7%BF%E5%8A%BF%E4%BA%8C/" target="_blank" rel="noopener noreferrer">【中间件】Prometheus自定义埋点姿势二</a></li>
<li><a href="https://spring.hhui.top/spring-blog/2021/11/09/211109-SpringBoot%E4%B9%8BPrometheus%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%8B%E7%82%B9%E4%B8%8A%E6%8A%A5/" target="_blank" rel="noopener noreferrer">【中间件】Prometheus自定义埋点上报</a></li>
<li><a href="https://spring.hhui.top/spring-blog/2021/04/19/210419-SpringBoot%E6%95%B4%E5%90%88Prometheus%E5%AE%9E%E7%8E%B0%E5%BA%94%E7%94%A8%E7%9B%91%E6%8E%A7/" target="_blank" rel="noopener noreferrer">【中间件】Prometheus实现应用监控</a></li>
</ul>
<h3> 1. 微信公众号: 一灰灰Blog</h3>
<p>尽信书则不如，以上内容，纯属一家之言，因个人能力有限，难免有疏漏和错误之处，如发现bug或者有更好的建议，欢迎批评指正，不吝感激</p>
<p>下面一灰灰的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛</p>
<ul>
<li>一灰灰Blog个人博客 <a href="https://blog.hhui.top" target="_blank" rel="noopener noreferrer">https://blog.hhui.top</a></li>
<li>一灰灰Blog-Spring专题博客 <a href="http://spring.hhui.top" target="_blank" rel="noopener noreferrer">http://spring.hhui.top</a></li>
</ul>
<figure><img src="https://spring.hhui.top/spring-blog/imgs/info/info.png" alt="一灰灰blog" tabindex="0" loading="lazy"><figcaption>一灰灰blog</figcaption></figure>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="SpringBoot"/>
    <category term="中间件"/>
    <category term="Prometheus"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2021-12-23T10:17:10.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">Prometheus</title>
    <id>https://liuyueyi.github.io/tutorial/spring/middle/Prometheus/</id>
    <link href="https://liuyueyi.github.io/tutorial/spring/middle/Prometheus/"/>
    <updated>2023-02-10T04:50:05.000Z</updated>
    <summary type="html"><![CDATA[<p>接入Prometheus，搭建应用监控体系</p>
]]></summary>
    <content type="html"><![CDATA[<p>接入Prometheus，搭建应用监控体系</p>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2023-02-10T04:50:05.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">1.基础使用介绍</title>
    <id>https://liuyueyi.github.io/tutorial/spring/middle/ZooKeeper/210414-SpringBoot%E6%95%B4%E5%90%88zookeeper%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D.html</id>
    <link href="https://liuyueyi.github.io/tutorial/spring/middle/ZooKeeper/210414-SpringBoot%E6%95%B4%E5%90%88zookeeper%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D.html"/>
    <updated>2023-02-10T04:50:05.000Z</updated>
    <summary type="html"><![CDATA[<p>ZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，广泛应用于分布式系统中，比如有用它做配置中心，注册中心，也有使用它来实现分布式锁的，作为高并发技术栈中不可或缺的一个基础组件，接下来我们将看一下，zk应该怎么玩，可以怎么玩</p>
<p>本文作为第一篇，将主要介绍基于zk-client的基本使用姿势，以次来了解下zk的基本概念</p>
]]></summary>
    <content type="html"><![CDATA[<p>ZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，广泛应用于分布式系统中，比如有用它做配置中心，注册中心，也有使用它来实现分布式锁的，作为高并发技术栈中不可或缺的一个基础组件，接下来我们将看一下，zk应该怎么玩，可以怎么玩</p>
<p>本文作为第一篇，将主要介绍基于zk-client的基本使用姿势，以次来了解下zk的基本概念</p>
<!-- more -->
<h2> I. 准备</h2>
<h3> 1. zk环境安装</h3>
<p>用于学习试点目的的体验zk功能，安装比较简单，可以参考博文: <a href="https://blog.hhui.top/hexblog/2021/03/10/210310-ZooKeeper%E5%AE%89%E8%A3%85%E5%8F%8A%E5%88%9D%E4%BD%93%E9%AA%8C/" target="_blank" rel="noopener noreferrer">210310-ZooKeeper安装及初体验</a></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 项目环境</h3>
<p>本文演示的是直接使用apache的zookeeper包来操作zk，与是否是SpringBoot环境无关</p>
<p>核心依赖</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>版本说明:</p>
<ul>
<li>zk: 3.6.2</li>
<li>SpringBoot: 2.2.1.RELEASE</li>
</ul>
<h2> II. ZK使用姿势</h2>
<h3> 1. zk基本知识点</h3>
<p>首先介绍下zk的几个主要的知识点，如zk的数据模型，四种常说的节点</p>
<h4> 1.1 数据模型</h4>
<p>zk的数据模型和我们常见的目录树很像，从<code>/</code>开始，每一个层级就是一个节点</p>
<p>每个节点，包含数据 + 子节点</p>
<p>注意：EPHEMERAL节点，不能有子节点（可以理解为这个目录下不能再挂目录）</p>
<p>zk中常说的监听器，就是基于节点的，一般来讲监听节点的创建、删除、数据变更</p>
<h4> 1.2 节点</h4>
<ul>
<li>持久节点 persistent node</li>
<li>持久顺序节点 persistent sequental</li>
<li>临时节点 ephemeral node</li>
<li>临时顺序节点 ephemeral sequental</li>
</ul>
<p><strong>注意：</strong></p>
<ul>
<li>节点类型一经指定，不允许修改</li>
<li>临时节点，当会话结束，会自动删除，且不能有子节点</li>
</ul>
<h3> 2. 节点创建</h3>
<p>接下来我们看一下zk的使用姿势，首先是创建节点，当然创建前提是得先拿到zkClient</p>
<p>初始化连接</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>节点创建方法，下面分别给出两种不同的case</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>节点创建，核心在于 <code>zooKeeper.create(path + "/yes", "保存的数据".getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);</code></p>
<ul>
<li>当节点已存在时，再创建会抛异常 <code>KeeperException.NodeExistsException</code></li>
<li>最后一个参数，来决定我们创建的节点类型</li>
<li>todo: 上面实例中在指定ttl时，没有成功，暂未找到原因，待解决</li>
</ul>
<h3> 3. 节点存在判断</h3>
<p>判断节点是否存在，比较常见了（比如我们在创建之前，可能会先判断一下是否存在）</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>注意</strong></p>
<p>核心用法： <code>zooKeeper.exists(path + "/yes", this);</code></p>
<ul>
<li>当节点存在时，返回Stat对象，包含一些基本信息；如果不存在，则返回null</li>
<li>第二个参数，传入的是事件回调对象，我们的测试类<code>NodeExmaple</code> 实现了接口 <code>Watcher</code>， 所以直接传的是<code>this</code></li>
<li>注册事件监听时，需要注意这个回调只会执行一次，即触发之后就没了；后面再次修改、删除、创建节点都不会再被接收到</li>
</ul>
<h3> 4. 子节点获取</h3>
<p>获取某个节点的所有子节点，这里返回的是当前节点的一级子节点</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 5. 数据获取与修改</h3>
<p>节点上是可以存储数据的，在创建的时候，可以加上数据；后期可以读取，也可以修改</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在设置数据时，可以指定版本，当version &gt; 0时，表示根据版本精确匹配；如果为-1时，则只要节点路径对上就成</p>
<h3> 6. 事件监听</h3>
<p>监听主要是针对节点而言，前面在判断节点是否存在、修改数据时都可以设置监听器，但是他们是一次性的，如果我们希望长久有效，则可以使用下面的<code>addWatch</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面给出了两种case，</p>
<ul>
<li>AddWatchMode.PERSISTENT： 表示只关心当前节点的删除、数据变更，创建，一级子节点的创建、删除；无法感知子节点的子节点创建、删除，无法感知子节点的数据变更</li>
<li>AddWatchMode.PERSISTENT_RECURSIVE: 相当于递归监听，改节点及其子节点的所有变更都监听</li>
</ul>
<h3> 7. 节点删除</h3>
<p>最后再介绍一个基本功能，节点删除，只有子节点都不存在时，才能删除当前节点（和linux的rmdir类似）</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 8. 小结</h3>
<p>本文主要介绍的是java侧对zookeeper的基本操作姿势，可以算是zk的入门，了解下节点的增删改，事件监听；</p>
<p>当然一般更加推荐的是使用Curator来操作zk，相比较于apache的jar包，使用姿势更加顺滑，后面也会做对比介绍</p>
<h2> II. 其他</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>项目源码: <a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/410-zookeeper-basic" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/410-zookeeper-basic</a></li>
</ul>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="SpringBoot"/>
    <category term="中间件"/>
    <category term="ZooKeeper"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2021-04-14T22:45:21.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">2.从0到1实现一个分布式锁</title>
    <id>https://liuyueyi.github.io/tutorial/spring/middle/ZooKeeper/210415-SpringBoot%E6%95%B4%E5%90%88Zookeeper%E4%BB%8E0%E5%88%B01%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81.html</id>
    <link href="https://liuyueyi.github.io/tutorial/spring/middle/ZooKeeper/210415-SpringBoot%E6%95%B4%E5%90%88Zookeeper%E4%BB%8E0%E5%88%B01%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81.html"/>
    <updated>2023-02-10T04:50:05.000Z</updated>
    <summary type="html"><![CDATA[<p>分布式锁，在实际的业务使用场景中算是比较常用的了，而分布式锁的实现，常见的除了redis之外，就是zk的实现了，前面一篇博文介绍了zk的基本概念与使用姿势，那么如果让我们来记住zk的特性来设计一个分布式锁，可以怎么做呢?</p>
]]></summary>
    <content type="html"><![CDATA[<p>分布式锁，在实际的业务使用场景中算是比较常用的了，而分布式锁的实现，常见的除了redis之外，就是zk的实现了，前面一篇博文介绍了zk的基本概念与使用姿势，那么如果让我们来记住zk的特性来设计一个分布式锁，可以怎么做呢?</p>
<!-- more -->
<h2> I. 方案设计</h2>
<h3> 1. 创建节点方式实现</h3>
<p>zk有四种节点，一个最容易想到的策略就是创建节点，谁创建成功了，就表示谁持有了这个锁</p>
<p>这个思路与redis的<code>setnx</code>有点相似，因为zk的节点创建，也只会有一个会话会创建成功，其他的则会抛已存在的异常</p>
<p>借助临时节点，会话丢掉之后节点删除，这样可以避免持有锁的实例异常而没有主动释放导致所有实例都无法持有锁的问题</p>
<p>如果采用这种方案，如果我想实现阻塞获取锁的逻辑，那么其中一个方案就需要写一个while(true)来不断重试</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>另外一个策略则是借助事件监听，当节点存在时，注册一个节点删除的触发器，这样就不需要我自己重试判断了；充分借助zk的特性来实现异步回调</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>那么上面这个实现有什么问题呢？</p>
<p>每次节点的变更，那么所有的都会监听到变动，好处是非公平锁的支持；缺点就是剩下这些唤醒的实例中也只会有一个抢占到锁，无意义的唤醒浪费性能</p>
<h3> 2. 临时顺序节点方式</h3>
<p>接下来这种方案更加常见，晚上大部分的教程也是这种case，主要思路就是创建临时顺序节点</p>
<p>只有序号最小的节点，才表示抢占锁成功；如果不是最小的节点，那么就监听它前面一个节点的删除事件，前面节点删除了，一种可能是他放弃抢锁，一种是他释放自己持有的锁，不论哪种情况，对我而言，我都需要捞一下所有的节点，要么拿锁成功；要么换一个前置节点</p>
<h2> II.分布式锁实现</h2>
<p>接下来我们来一步步看下，基于临时顺序节点，可以怎么实现分布式锁</p>
<p>对于zk，我们依然采用apache的提供的包 <code>zookeeper</code>来操作；后续提供<code>Curator</code>的分布式锁实例</p>
<h3> 1. 依赖</h3>
<p>核心依赖</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>版本说明:</p>
<ul>
<li>zk版本: 3.6.2</li>
<li>SpringBoot: 2.2.1.RELEASE</li>
</ul>
<h3> 2. 简单的分布式锁</h3>
<p>第一步，都是实例创建</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在我们的这个设计中，我们需要持有当前节点和监听前一个节点的变更，所以我们在ZkLock实例中，添加两个成员</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来就是尝试获取锁的逻辑</p>
<ul>
<li>current不存在，在表示没有创建过，就创建一个临时顺序节点，并赋值current</li>
<li>current存在，则表示之前已经创建过了，目前处于等待锁释放过程</li>
<li>接下来根据当前节点顺序是否最小，来表明是否持有锁成功</li>
<li>当顺序不是最小时，找前面那个节点，并赋值 pre；</li>
<li>监听pre的变化</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>请注意上面的实现，这里并没有去监听前一个节点的变更，在设计<code>tryLock</code>，因为是立马返回成功or失败，所以使用这个接口的，不需要注册监听</p>
<p>我们的监听逻辑，放在 <code>lock()</code> 同步阻塞里面</p>
<ul>
<li>尝试抢占锁，成功则直接返回</li>
<li>拿锁失败，则监听前一个节点的删除事件</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>注意：</strong></p>
<ul>
<li>当节点不存在时，或者事件触发回调之后，重新调用<code>lock()</code>，表明我胡汉三又来竞争锁了？</li>
</ul>
<p>为啥不是直接返回 true? 而是需要重新竞争呢？</p>
<ul>
<li>因为前面节点的删除，有可能是因为前面节点的会话中断导致的；但是锁还在另外的实例手中，这个时候我应该做的是重新排队</li>
</ul>
<p>最后别忘了释放锁</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>到此，我们的分布式锁就完成了，接下来我们复盘下实现过程</p>
<ul>
<li>所有知识点来自前一篇的zk基础使用（创建节点，删除节点，获取所有自己点，监听事件）</li>
<li>抢锁过程 =》 创建序号最小的节点</li>
<li>若节点不是最小的，那么就监听前面的节点删除事件</li>
</ul>
<p>这个实现，支持了锁的重入（why? 因为锁未释放时，我们保存了current，当前节点存在时则直接判断是不是最小的；而不是重新创建）</p>
<h3> 3. 测试</h3>
<p>最后写一个测试case，来看下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果如下</p>
<figure><img src="/imgs/210415/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> II. 其他</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>项目源码：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/411-zookeeper-distributelock" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/411-zookeeper-distributelock</a></li>
</ul>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="SpringBoot"/>
    <category term="中间件"/>
    <category term="ZooKeeper"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2021-04-15T20:18:26.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">Zookeeper</title>
    <id>https://liuyueyi.github.io/tutorial/spring/middle/ZooKeeper/</id>
    <link href="https://liuyueyi.github.io/tutorial/spring/middle/ZooKeeper/"/>
    <updated>2023-02-10T04:50:05.000Z</updated>
    <summary type="html"><![CDATA[<p>SpringBoot整合Zookeeper，并通过zk实现分布式锁来实战演示zk在应用中的想象空间</p>
]]></summary>
    <content type="html"><![CDATA[<p>SpringBoot整合Zookeeper，并通过zk实现分布式锁来实战演示zk在应用中的想象空间</p>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2023-02-10T04:50:05.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">1.springboot + rabbitmq初体验</title>
    <id>https://liuyueyi.github.io/tutorial/spring/mq/RabbitMq/200210-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B9%8BRabbitMq%E5%88%9D%E4%BD%93%E9%AA%8C.html</id>
    <link href="https://liuyueyi.github.io/tutorial/spring/mq/RabbitMq/200210-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B9%8BRabbitMq%E5%88%9D%E4%BD%93%E9%AA%8C.html"/>
    <updated>2023-02-10T04:50:05.000Z</updated>
    <summary type="html"><![CDATA[<p>mq在异步解耦削峰的优势非常突出，现在很多的项目都会用到，掌握mq的知识点，了解如何顺畅的使用mq，可以说是一个必备的职业技能点了</p>
<p>接下来我们进入rabbitmq的学习过程</p>
]]></summary>
    <content type="html"><![CDATA[<p>mq在异步解耦削峰的优势非常突出，现在很多的项目都会用到，掌握mq的知识点，了解如何顺畅的使用mq，可以说是一个必备的职业技能点了</p>
<p>接下来我们进入rabbitmq的学习过程</p>
<!-- more -->
<h2> I. 环境准备</h2>
<p>在测试之前，需要安装rabbitmq，下面分别给出mac + centos的安装教程</p>
<h3> 1. mac 安装</h3>
<p>安装命令</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>启动控制台之前需要先开启插件</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>进入控制台: <code>http://localhost:15672/</code></p>
<p>用户名和密码：<code>guest,guest</code></p>
<h3> 2. centos 安装</h3>
<p>安装命令</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>插件开启</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. 配置</h3>
<p>添加账号，设置权限</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4. 项目环境</h3>
<p>接下我们创建一个SpringBoot项目，用于简单的体验一下rabbitmq的发布和消费消息</p>
<ul>
<li>springboot版本为<code>2.2.1.RELEASE</code></li>
<li>rabbitmq 版本为 <code>3.7.5</code></li>
</ul>
<p>依赖配置文件pom.xml</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在<code>application.yml</code>配置文件中，添加rabbitmq的相关属性</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> II. 实例演示</h2>
<p>接下来我们看一个<code>hello world</code>版本的rabbitmq的使用姿势，一个简单发布消息、消费消息</p>
<h3> 1. 发布消息</h3>
<p>消息发布，我们主要借助<code>AmqpTemplate</code>来实现</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的case中，主要方法在于<code>amqpTemplate#convertAndSend</code>，第一个参数为exchangeName, 第二个为routingKey</p>
<p>常量配置如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 消费消息</h3>
<p>消费消息，需要指定Queue，通过routingKey绑定exchange，如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. 测试demo</h3>
<p>写一个简单的rest接口，用于接收参数，发布消息到mq，并被<code>ConsumerDemo</code>消费</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/200210/00.gif" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> II. 其他</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码: <a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/300-rabbitmq" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/300-rabbitmq</a></li>
</ul>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="SpringBoot"/>
    <category term="MQ系列"/>
    <category term="RabbitMq"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2020-02-10T16:04:48.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">2.RabbitMq核心知识点小结</title>
    <id>https://liuyueyi.github.io/tutorial/spring/mq/RabbitMq/200212-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B9%8BRabbitMq%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%E5%B0%8F%E7%BB%93.html</id>
    <link href="https://liuyueyi.github.io/tutorial/spring/mq/RabbitMq/200212-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B9%8BRabbitMq%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%E5%B0%8F%E7%BB%93.html"/>
    <updated>2023-02-10T04:50:05.000Z</updated>
    <summary type="html"><![CDATA[<p>RabbitMQ是一个基于AMQP协议实现的企业级消息系统，想要顺畅的玩耍的前提是得先了解它，本文将主要介绍rabbitmq的一些基本知识点</p>
<ul>
<li>特点</li>
<li>基本概念</li>
<li>消息投递消费的几种姿势</li>
<li>事务</li>
<li>集群</li>
</ul>
]]></summary>
    <content type="html"><![CDATA[<p>RabbitMQ是一个基于AMQP协议实现的企业级消息系统，想要顺畅的玩耍的前提是得先了解它，本文将主要介绍rabbitmq的一些基本知识点</p>
<ul>
<li>特点</li>
<li>基本概念</li>
<li>消息投递消费的几种姿势</li>
<li>事务</li>
<li>集群</li>
</ul>
<!-- more -->
<h2> I. 基本知识点</h2>
<p>它是采用Erlang语言实现的AMQP(Advanced Message Queued Protocol)的消息中间件，最初起源于金融系统，用在分布式系统存储转发消息，目前广泛应用于各类系统用于解耦、削峰</p>
<h3> 1.特点</h3>
<p>首先得了解一下rabbitmq的特点，看看是否满足我们的系统需求（毕竟学习一个框架也是要不少时间的）</p>
<blockquote>
<p>以下内容来自: <a href="https://blog.csdn.net/weixin_40792878/article/details/82555791" target="_blank" rel="noopener noreferrer">MQ和RabbitMQ作用特点</a></p>
</blockquote>
<p>主要特点，大致可以归纳为以下几个</p>
<ul>
<li>可靠性：通过支持消息持久化，支持事务，支持消费和传输的ack等来确保可靠性</li>
<li>路由机制：支持主流的订阅消费模式，如广播，订阅，headers匹配等</li>
<li>扩展性：多个RabbitMQ节点可以组成一个集群，也可以根据实际业务情况动态地扩展集群中节点。</li>
<li>高可用性：队列可以在集群中的机器上设置镜像，使得在部分节点出现问题的情况下队仍然可用。</li>
<li>多种协议：RabbitMQ除了原生支持AMQP协议，还支持STOMP，MQTT等多种消息中间件协议。</li>
<li>多语言客户端：RabbitMQ几乎支持所有常用语言，比如Jav a、Python、Ruby、PHP、C#、JavaScript等。</li>
<li>管理界面：RabbitMQ提供了一个易用的用户界面，使得用户可以监控和管理消息、集群中的节点等。</li>
<li>插件机制：RabbitMQ提供了许多插件，以实现从多方面进行扩展，当然也可以编写自己的插件。</li>
</ul>
<h3> 2. 基本概念</h3>
<p>下图为rabbitmq的内部结构图</p>
<figure><img src="/imgs/200212/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>从上图也可以发现几个基本概念（Message, Publisher, Exchange, Binding, Queue, Channel, Consuer, Virtual host）</p>
<p>下面逐一进行说明</p>
<h4> a. Message</h4>
<p>具体的消息，包含消息头（即附属的配置信息）和消息体（即消息的实体内容）</p>
<p>由发布者，将消息推送到Exchange，由消费者从Queue中获取</p>
<h4> b. Publisher</h4>
<p>消息生产者，负责将消息发布到交换器(Exchange)</p>
<h4> c. Exchange</h4>
<p>交换器，用来接收生产者发送的消息并将这些消息路由给服务器中的队列</p>
<h4> d. Binding</h4>
<p>绑定，用于给Exchange和Queue建立关系，从而决定将这个交换器中的哪些消息，发送到对应的Queue</p>
<h4> e. Queue</h4>
<p>消息队列，用来保存消息直到发送给消费者</p>
<p>它是消息的容器，也是消息的终点</p>
<p>一个消息可投入一个或多个队列</p>
<p>消息一直在队列里面，等待消费者连接到这个队列将其取走</p>
<h4> f. Connection</h4>
<p>连接，内部持有一些channel，用于和queue打交道</p>
<h4> g. Channel</h4>
<p>信道（通道），MQ与外部打交道都是通过Channel来的，发布消息、订阅队列还是接收消息，这些动作都是通过Channel完成；</p>
<p>简单来说就是消息通过Channel塞进队列或者流出队列</p>
<h4> h. Consumer</h4>
<p>消费者，从消息队列中获取消息的主体</p>
<h4> i. Virtual Host</h4>
<p>虚拟主机，表示一批交换器、消息队列和相关对象。</p>
<p>虚拟主机是共享相同的身份认证和加密环境的独立服务器域。</p>
<p>每个 vhost 本质上就是一个 mini 版的 RabbitMQ 服务器，拥有自己的队列、交换器、绑定和权限机制。</p>
<p>vhost 是 AMQP 概念的基础，必须在连接时指定，RabbitMQ 默认的 vhost 是 /</p>
<p><strong>可以理解为db中的数据库的概念，用于逻辑拆分</strong></p>
<h4> j. Broker</h4>
<p>消息队列服务器实体</p>
<h3> 3. 消息投递消费</h3>
<p>从前面的内部结构图可以知晓，消息由生产者发布到Exchange，然后通过路由规则，分发到绑定queue上，供消费者获取消息</p>
<p>接下来我们看一下Exchange支持的四种策略</p>
<h4> a. Direct策略</h4>
<figure><img src="/imgs/200212/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>消息中的路由键（routing key）如果和 Binding 中的 binding key 一致， 交换器就将消息发到对应的队列中</p>
<p>简单来讲，就是<code>rounting key</code>与<code>binding key</code>完全匹配</p>
<ul>
<li>如果一个队列绑定到交换机要求路由键为<code>dog</code></li>
<li>只转发<code>routing key</code> 标记为<code>dog</code>的消息，</li>
<li>不会转发<code>dog.puppy</code>，也不会转发“dog.guard”等等</li>
<li>它是完全匹配、单播的模式</li>
</ul>
<p>举例说明</p>
<figure><img src="/imgs/200212/02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>Exchange和两个队列绑定在一起：</p>
<ul>
<li>Q1的bindingkey是orange</li>
<li>Q2的binding key是black和green.</li>
<li>当Producer 发布一个消息，其<code>routing key</code>是<code>orange</code>时, exchange会把它放到Q1上, 如果是<code>black</code>或<code>green</code>就会到Q2上, 其余的Message被丢弃</li>
</ul>
<p><strong>注意</strong></p>
<ul>
<li>当有多个队列绑定到同一个Exchange，且binding key相同时，这时消息会分发给所有满足条件的队列</li>
</ul>
<h4> b. Topic策略</h4>
<figure><img src="/imgs/200212/03.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>这个策略可以看成是Direct策略的升级版，通过<code>routing key</code>与 <code>bingding key</code>的模式匹配方式来分发消息</p>
<p>简单来讲，直接策略是完全精确匹配，而topic则支持正则匹配，满足某类指定规则的（如以xxx开头的路由键），可以将消息分发过去</p>
<ul>
<li><code>#</code> 匹配0个或多个单词</li>
<li><code>*</code> 匹配不多不少一个单词</li>
</ul>
<p><strong>一个更直观的实例如下</strong></p>
<figure><img src="/imgs/200212/04.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>Producer发送消息时需要设置routing_key,</p>
<ul>
<li>Q1 的binding key 是<code>*.orange.*</code></li>
<li>Q2 是 <code>*.*.rabbit</code> 和 <code>lazy.#</code>：</li>
<li>发布一个<code>routing key</code>为<code>test.orange.mm</code> 消息，则会路由到Q1；
<ul>
<li><strong>注意：</strong> 如果是<code>routng key</code>是 <code>test.orange</code>则无法路由到Q1，</li>
<li>因为Q1的规则是三个单词，中间一个为orange，不满足这个规则的都无效</li>
</ul>
</li>
<li>发布一个<code>routing key</code>为<code>test.qq.rabbit</code>或者<code>lazy.qq</code>的消息 都可以分发到Q2；即路由key为三个单词，最后一个为rabbit或者不限制单词个数，主要第一个是lazy的消息，都可以分发过来</li>
<li>如果发布的是一个<code>test.orange.rabbit</code>消息，则Q1和Q2都可以满足
<ul>
<li><strong>注意：</strong> 这时两个队列都会接受到这个消息</li>
</ul>
</li>
</ul>
<h4> c. Fanout策略</h4>
<figure><img src="/imgs/200212/05.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>广播策略，忽略<code>routing key</code> 和 <code>binding key</code>，将消息分发给所有绑定在这个exchange上的queue</p>
<h4> d. Headers策略</h4>
<p>这个实际上用得不多，它是根据Message的一些头部信息来分发过滤Message，忽略routing key的属性，如果Header信息和message消息的头信息相匹配</p>
<h2> II. 消息一致性问题</h2>
<p>在进入rabbitmq如何保证一致性之前，我们先得理解，什么是消息一致性？</p>
<h3> 1. 一致性问题</h3>
<blockquote>
<p><a href="https://www.php.cn/faq/415782.html" target="_blank" rel="noopener noreferrer">数据的一致性是什么</a></p>
</blockquote>
<p><strong>按照我个人的粗浅理解，我认为的消息一致性，应该包含下面几个</strong></p>
<ul>
<li>生产者，确保消息发布成功
<ul>
<li>消息不会丢</li>
<li>顺序不会乱</li>
<li>消息不会重复（如重传，导致发布一次，却出现多个消息）</li>
</ul>
</li>
<li>消费者，确保消息消费成功
<ul>
<li>有序消费</li>
<li>不重复消费</li>
</ul>
</li>
</ul>
<p><strong>发送端</strong></p>
<p>为了确保发布者推送的消息不会丢失，我们需要消息持久化</p>
<ul>
<li>broker持久化消息</li>
</ul>
<p>为了确定消息正确接收</p>
<ul>
<li>publisher 需要知道消息投递并成功持久化</li>
</ul>
<h3> 2. 持久化</h3>
<p>这里的持久化，主要是指将内存中的消息保存到磁盘，避免mq宕机导致的内存中消息丢失；然而单纯的持久化，只是保证一致性的其中一个要素，比如publisher将消息发送到exchange，在broker持久化的工程中，宕机了导致持久化失败，而publisher并不知道持久化失败，这个时候就会出现数据丢失，为了解决这个问题，rabbitmq提供了事务机制</p>
<h3> 3. 事务机制</h3>
<p>事务机制能够解决生产者与broker之间消息确认的问题，只有消息成功被broker接受，事务才能提交成功，否则就进行事务回滚操作并进行消息重发。但是使用事务机制会降低RabbitMQ的消息吞吐量，不适用于需要发布大量消息的业务场景。</p>
<p><strong>注意，事务是同步的</strong></p>
<h3> 4. 消息确认机制</h3>
<blockquote>
<p><a href="https://blog.csdn.net/anumbrella/article/details/81321701" target="_blank" rel="noopener noreferrer">RabbitMQ学习(六)——消息确认机制(Confirm模式)</a></p>
</blockquote>
<p>消息确认机制，可以区分为生产端和消费端</p>
<p><strong>生产端</strong></p>
<ul>
<li>生产者将信道设置成Confirm模式，一旦信道进入Confirm模式，所有在该信道上面发布的消息都会被指派一个唯一的ID(以confirm.select为基础从1开始计数)，</li>
<li>一旦消息被投递到所有匹配的队列之后，Broker就会发送一个确认给生产者（包含消息的唯一ID）,这就使得生产者知道消息已经正确到达目的队列了，</li>
<li>如果消息和队列是可持久化的，那么确认消息会将消息写入磁盘之后发出，</li>
<li>Broker回传给生产者的确认消息中deliver-tag域包含了确认消息的序列号（此外Broker也可以设置basic.ack的multiple域，表示到这个序列号之前的所有消息都已经得到了处理）</li>
</ul>
<p>Confirm模式属性异步，publisher发布一条消息之后，在等信道返回确认的同时，依然可以继续发送下一条消息，所以小概率会出现投递的消息顺序和broker中持久化消息顺序不一致的问题</p>
<p>一般从编程角度出发，Confirm模式有三种姿势</p>
<ul>
<li>普通Confirm模式：发送一条消息之后，等到服务器confirm，然后再发布下一条消息（串行发布）</li>
<li>批量Confirm模式：发送一批消息之后，等到服务器confirm，然后再发布下一批消息（如果失败，这一批消息全部重复，所以会有重复问题）</li>
<li>异步Confirm模式：提供一个回调方法，服务器confirm之后，触发回调方法，因此不会阻塞下一条消息的发送</li>
</ul>
<p><strong>消费端</strong></p>
<p>ACK机制是消费者从RabbitMQ收到消息并处理完成后，反馈给RabbitMQ，RabbitMQ收到反馈后才将此消息从队列中删除。</p>
<ul>
<li>如果一个消费者在处理消息出现了网络不稳定、服务器异常等现象，那么就不会有ACK反馈，RabbitMQ会认为这个消息没有正常消费，会将消息重新放入队列中</li>
<li>如果在集群的情况下，RabbitMQ会立即将这个消息推送给这个在线的其他消费者。这种机制保证了在消费者服务端故障的时候，不丢失任何消息和任务</li>
<li>消息永远不会从RabbitMQ中删除，只有当消费者正确发送ACK反馈，RabbitMQ确认收到后，消息才会从RabbitMQ服务器的数据中删除</li>
</ul>
<h2> III. 集群</h2>
<p>按照目前的发展趋势，一个不支持集群的中间件基本上是不会有市场的；rabbitmq也是支持集群的，下面简单的介绍一下常见的4种集群架构模式</p>
<blockquote>
<p>以下内容来自网上博文，详情请点击右边：<a href="https://www.jianshu.com/p/b7cc32b94d2a" target="_blank" rel="noopener noreferrer">RabbitMQ 的4种集群架构</a></p>
</blockquote>
<h3> 1. 主备模式</h3>
<p>这个属于常见的集群模式了，但又不太一样</p>
<p>主节点提供读写，备用节点不提供读写。如果主节点挂了，就切换到备用节点，原来的备用节点升级为主节点提供读写服务，当原来的主节点恢复运行后，原来的主节点就变成备用节点</p>
<h3> 2. 远程模式</h3>
<p>远程模式可以实现双活的一种模式，简称 shovel 模式，所谓的 shovel 就是把消息进行不同数据中心的复制工作，可以跨地域的让两个 MQ 集群互联，远距离通信和复制。</p>
<ul>
<li>Shovel 就是我们可以把消息进行数据中心的复制工作，我们可以跨地域的让两个 MQ 集群互联。</li>
</ul>
<figure><img src="/imgs/200212/06.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>如上图，有两个异地的 MQ 集群（可以是更多的集群），当用户在地区 1 这里下单了，系统发消息到 1 区的 MQ 服务器，发现 MQ 服务已超过设定的阈值，负载过高，这条消息就会被转到 地区 2 的 MQ 服务器上，由 2 区的去执行后面的业务逻辑，相当于分摊我们的服务压力。</p>
<h3> 3. 镜像模式</h3>
<p>非常经典的 mirror 镜像模式，保证 100% 数据不丢失。在实际工作中也是用得最多的，并且实现非常的简单，一般互联网大厂都会构建这种镜像集群模式。</p>
<figure><img src="/imgs/200212/07.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>如上图，用 KeepAlived 做了 HA-Proxy 的高可用，然后有 3 个节点的 MQ 服务，消息发送到主节点上，主节点通过 mirror 队列把数据同步到其他的 MQ 节点，这样来实现其高可靠</p>
<h3> 4. 多活模式</h3>
<p>也是实现异地数据复制的主流模式，因为 shovel 模式配置比较复杂，所以一般来说，实现异地集群的都是采用这种双活 或者 多活模型来实现的。这种模式需要依赖 rabbitMQ 的 federation 插件，可以实现持续的，可靠的 AMQP 数据通信，多活模式在实际配置与应用非常的简单</p>
<p>rabbitMQ 部署架构采用双中心模式(多中心)，那么在两套(或多套)数据中心各部署一套 rabbitMQ 集群，各中心的rabbitMQ 服务除了需要为业务提供正常的消息服务外，中心之间还需要实现部分队列消息共享。</p>
<figure><img src="/imgs/200212/08.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>federation 插件是一个不需要构建 cluster ，而在 brokers 之间传输消息的高性能插件，federation 插件可以在 brokers 或者 cluster 之间传输消息，连接的双方可以使用不同的 users 和 virtual hosts，双方也可以使用不同版本的 rabbitMQ 和 erlang。federation 插件使用 AMQP 协议通信，可以接受不连续的传输。federation 不是建立在集群上的，而是建立在单个节点上的，如图上黄色的 rabbit node 3 可以与绿色的 node1、node2、node3 中的任意一个利用 federation 插件进行数据同步。</p>
<h2> IV. 其他</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
</ul>
<h3> 1. 相关博文</h3>
<ul>
<li><a href="https://www.rabbitmq.com/getstarted.html" target="_blank" rel="noopener noreferrer">RabbitMQ Tutorials</a></li>
<li><a href="https://blog.csdn.net/weixin_40792878/article/details/82555791" target="_blank" rel="noopener noreferrer">MQ和RabbitMQ作用特点</a></li>
<li><a href="https://blog.hhui.top/hexblog/2018/05/27/RabbitMQ%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/" target="_blank" rel="noopener noreferrer">RabbitMq基础教程之基本概念</a></li>
<li><a href="https://blog.csdn.net/anumbrella/article/details/81321701" target="_blank" rel="noopener noreferrer">RabbitMQ学习(六)——消息确认机制(Confirm模式)</a></li>
<li><a href="https://www.jianshu.com/p/b7cc32b94d2a" target="_blank" rel="noopener noreferrer">RabbitMQ 的4种集群架构</a></li>
<li><a href="http://www.voidcn.com/article/p-fdbmgrcd-brm.html" target="_blank" rel="noopener noreferrer">Rabbitmq是如何来保证事务的</a></li>
<li><a href="http://www.liaoqiqi.com/post/215" target="_blank" rel="noopener noreferrer">rabbitmq消息一致性问题</a></li>
<li></li>
</ul>
<h3> 2. 一灰灰Blog</h3>
<p>尽信书则不如，以上内容，纯属一家之言，因个人能力有限，难免有疏漏和错误之处，如发现bug或者有更好的建议，欢迎批评指正，不吝感激</p>
<p>下面一灰灰的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛</p>
<ul>
<li>一灰灰Blog个人博客 <a href="https://blog.hhui.top" target="_blank" rel="noopener noreferrer">https://blog.hhui.top</a></li>
<li>一灰灰Blog-Spring专题博客 <a href="http://spring.hhui.top" target="_blank" rel="noopener noreferrer">http://spring.hhui.top</a></li>
</ul>
<figure><img src="https://spring.hhui.top/spring-blog/imgs/info/info.png" alt="一灰灰blog" tabindex="0" loading="lazy"><figcaption>一灰灰blog</figcaption></figure>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="SpringBoot"/>
    <category term="MQ系列"/>
    <category term="RabbitMq"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2020-02-12T16:58:31.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">3.发送消息基本使用姿势</title>
    <id>https://liuyueyi.github.io/tutorial/spring/mq/RabbitMq/200218-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B9%8BRabbitMq%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF.html</id>
    <link href="https://liuyueyi.github.io/tutorial/spring/mq/RabbitMq/200218-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B9%8BRabbitMq%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF.html"/>
    <updated>2023-02-10T04:50:05.000Z</updated>
    <summary type="html"><![CDATA[<p>前面两篇博文，分别介绍了RabbitMq的核心知识点，以及整合SpringBoot的demo应用；接下来也该进入正题，看一下SpringBoot的环境下，如何玩转rabbitmq</p>
<p>本篇内容主要为消息发送，包括以下几点</p>
<ul>
<li><code>RabbitTemplate</code> 发送消息的基本使用姿势</li>
<li>自定义消息基本属性</li>
<li>自定义消息转换器<code>AbstractMessageConverter</code></li>
<li>发送Object类型消息失败的case</li>
</ul>
]]></summary>
    <content type="html"><![CDATA[<p>前面两篇博文，分别介绍了RabbitMq的核心知识点，以及整合SpringBoot的demo应用；接下来也该进入正题，看一下SpringBoot的环境下，如何玩转rabbitmq</p>
<p>本篇内容主要为消息发送，包括以下几点</p>
<ul>
<li><code>RabbitTemplate</code> 发送消息的基本使用姿势</li>
<li>自定义消息基本属性</li>
<li>自定义消息转换器<code>AbstractMessageConverter</code></li>
<li>发送Object类型消息失败的case</li>
</ul>
<!-- more -->
<h2> I. 基本使用姿势</h2>
<h3> 1. 配置</h3>
<p>我们借助<code>SpringBoot 2.2.1.RELEASE</code> + <code>rabbitmq 3.7.5</code>来完整项目搭建与测试</p>
<p>项目pom.xml如下</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>配置文件<code>application.yml</code>内容如下</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 配置类</h3>
<p>通过前面rabbitmq的知识点学习，我们可以知道发送端的主要逻辑 “将消息发送给exchange，然后根据不同的策略分发给对应的queue”</p>
<p>本篇博文主要讨论的是消息发送，为了后续的实例演示，我们定义一个topic模式的exchange，并绑定一个的queue；（因为对发送端而言，不同的exchange类型，对发送端的使用姿势影响并不大，有影响的是消费者）</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. 消息发送</h3>
<p>消息发送，主要借助的是<code>RabbitTemplate#convertAndSend</code>方法来实现，通常情况下，我们直接使用即可</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的核心点就一行<code>rabbitTemplate.convertAndSend(MqConstants.exchange, MqConstants.routing, msg);</code></p>
<ul>
<li>表示将msg发送给指定的exchange，并设置消息的路由键</li>
</ul>
<p><strong>请注意</strong></p>
<p>通过上面的方式，发送的消息默认是持久化的，当持久化的消息，分发到持久化的队列时，会有消息的落盘操作；</p>
<p>在某些场景下，我们对消息的完整性要求并没有那么严格，反而更在意mq的性能，丢失一些数据也可以接受；这个时候我们可能需要定制一下发送的消息属性（比如将消息设置为非持久化的）</p>
<p>下面提供两种姿势，推荐第二种</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/200218/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p><strong>注意</strong></p>
<ul>
<li>在实际的项目开发中，推荐使用<code>MessagePostProcessor</code>来定制消息属性</li>
<li>其次不推荐在每次发送消息时都创建一个<code>MessagePostProcessor</code>对象，请定义一个通用的对象，能复用就复用</li>
</ul>
<h3> 4. 非序列化对象发送异常case</h3>
<p>通过查看<code>rabbitTemplate#convertAndSend</code>的接口定义，我们知道发送的消息可以是Object类型，那么是不是意味着任何对象，都可以推送给mq呢？</p>
<p>下面是一个测试case</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当我们调用上面的<code>publish2mq4</code>方法时，并不会是想象中的直接成功，相反抛出一个参数类型异常</p>
<figure><img src="/imgs/200218/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>为什么会出现这个问题呢？从堆栈分析，我们知道RabbitTemplate默认是利用<code>SimpleMessageConverter</code>来实现封装Message逻辑的，核心代码为</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面逻辑很明确的指出了，<strong>只接受byte数组，string字符串，可序列化对象（这里使用的是jdk的序列化方式来实现对象和byte数组之间的互转）</strong></p>
<ul>
<li>所以我们传递一个非序列化的对象会参数非法的异常</li>
</ul>
<p>自然而然的，我们会想有没有其他的<code>MessageConverter</code>来友好的支持任何类型的对象</p>
<h3> 5. 自定义MessageConverter</h3>
<p>接下来我们希望通过自定义一个json序列化方式的MessageConverter来解决上面的问题</p>
<p>一个比较简单的实现（利用FastJson来实现序列化/反序列化）</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>重新定义一个<code>rabbitTemplate</code>，并设置它的消息转换器为自定义的<code>SelfConverter</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后再次测试一下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>mq内接收到的推送消息如下</p>
<figure><img src="/imgs/200218/02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 6. Jackson2JsonMessageConverter</h3>
<p>上面虽然实现了Json格式的消息转换，但是比较简陋；而且这么基础通用的功能，按照Spring全家桶的一贯作风，肯定是有现成可用的，没错，这就是<code>Jackson2JsonMessageConverter</code></p>
<p>所以我们的使用姿势也可以如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>下面是通过Jackson序列化消息后的内容，与我们自定义的有一些不同，多了<code>headers</code>和<code>content_encoding</code></p>
<figure><img src="/imgs/200218/03.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 7. 小结</h3>
<p>本篇博文主要的知识点如下</p>
<ul>
<li>通过<code>RabbitTemplate#convertAndSend</code>来实现消息分发</li>
<li>通过<code>MessagePostProcessor</code>来自定义消息的属性（请注意默认投递的消息时持久化的）</li>
<li>默认的消息封装类为<code>SimpleMessageConverter</code>，只支持分发byte数组，字符串和可序列化的对象；不满足上面三个条件的方法调用会抛异常</li>
<li>我们可以通过实现<code>MessageConverter</code>接口，来定义自己的消息封装类，解决上面的问题</li>
</ul>
<p>在RabbitMq的知识点博文中，明确提到了，为了确保消息被brocker正确接收，提供了消息确认机制和事务机制两种case，那么如果需要使用这两种方式，消息生产者需要怎么做呢？</p>
<p>限于篇幅，下一篇博文将带来在消息确认机制/事务机制下的发送消息使用姿势</p>
<h2> II. 其他</h2>
<h3> 0. 系列博文&amp;项目源码</h3>
<p><strong>系列博文</strong></p>
<ul>
<li><a href="http://spring.hhui.top/spring-blog/2020/02/10/200210-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B9%8BRabbitMq%E5%88%9D%E4%BD%93%E9%AA%8C/" target="_blank" rel="noopener noreferrer">【MQ系列】springboot + rabbitmq初体验</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2020/02/12/200212-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B9%8BRabbitMq%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%E5%B0%8F%E7%BB%93/" target="_blank" rel="noopener noreferrer">【MQ系列】RabbitMq核心知识点小结</a></li>
</ul>
<p><strong>项目源码</strong></p>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/301-rabbitmq-publish" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/301-rabbitmq-publish</a></li>
</ul>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="SpringBoot"/>
    <category term="MQ系列"/>
    <category term="RabbitMq"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2020-02-18T11:11:57.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">4.消息确认机制/事务的使用姿势</title>
    <id>https://liuyueyi.github.io/tutorial/spring/mq/RabbitMq/200219-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B9%8BRabbitMq%E6%B6%88%E6%81%AF%E7%A1%AE%E8%AE%A4%E6%9C%BA%E5%88%B6-%E4%BA%8B%E5%8A%A1%E7%9A%84%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF.html</id>
    <link href="https://liuyueyi.github.io/tutorial/spring/mq/RabbitMq/200219-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B9%8BRabbitMq%E6%B6%88%E6%81%AF%E7%A1%AE%E8%AE%A4%E6%9C%BA%E5%88%B6-%E4%BA%8B%E5%8A%A1%E7%9A%84%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF.html"/>
    <updated>2023-02-10T04:50:05.000Z</updated>
    <summary type="html"><![CDATA[<p>上一篇介绍了RabbitMq借助RabbitTemplate来发送消息的基本使用姿势，我们知道RabbitMq提供了两种机制，来确保发送端的消息被brocke正确接收，本文将主要介绍，在消息确认和事物两种机制的场景下，发送消息的使用姿势</p>
]]></summary>
    <content type="html"><![CDATA[<p>上一篇介绍了RabbitMq借助RabbitTemplate来发送消息的基本使用姿势，我们知道RabbitMq提供了两种机制，来确保发送端的消息被brocke正确接收，本文将主要介绍，在消息确认和事物两种机制的场景下，发送消息的使用姿势</p>
<!-- more -->
<h2> I. 配置</h2>
<p>首先创建一个SpringBoot项目，用于后续的演示</p>
<ul>
<li>springboot版本为<code>2.2.1.RELEASE</code></li>
<li>rabbitmq 版本为 <code>3.7.5</code> （安装教程可参考: <a href="http://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484522&amp;idx=1&amp;sn=411fad078902200314d594b932fbdf35" target="_blank" rel="noopener noreferrer">【MQ系列】springboot + rabbitmq初体验</a>）</li>
</ul>
<p>依赖配置文件pom.xml</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在<code>application.yml</code>配置文件中，添加rabbitmq的相关属性</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> II. 消息确认机制</h2>
<p>本节来看一下消息确认机制的使用姿势，首先有必要了解一下什么是消息确认机制</p>
<h3> 1. 定义</h3>
<blockquote>
<p>简单来讲就是消息发送之后，需要接收到RabbitMq的正确反馈，然后才能判断消息是否正确发送成功；</p>
</blockquote>
<p>一般来说，RabbitMq的业务逻辑包括以下几点</p>
<ul>
<li>生产者将信道设置成Confirm模式，一旦信道进入Confirm模式，所有在该信道上面发布的消息都会被指派一个唯一的ID(以confirm.select为基础从1开始计数)</li>
<li>一旦消息被投递到所有匹配的队列之后，Broker就会发送一个确认给生产者（包含消息的唯一ID）,这就使得生产者知道消息已经正确到达目的队列了</li>
<li>如果消息和队列是可持久化的，那么确认消息会将消息写入磁盘之后发出</li>
<li>Broker回传给生产者的确认消息中deliver-tag域包含了确认消息的序列号（此外Broker也可以设置basic.ack的multiple域，表示到这个序列号之前的所有消息都已经得到了处理）</li>
</ul>
<h3> 2. 基本使用case</h3>
<p>从上面的解释，可以知道发送消息端，需要先将信道设置为Confirm模式，<code>RabbitProperties</code>配置类中，有个属性，正好是用来设置的这个参数的，所以我们可以直接在配置文件<code>application.yml</code>中，添加下面的配置</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面配置完毕之后，直接使用RabbitTemplate发送消息，表示已经支持Confirm模式了，但实际的使用，会有一点点区别，我们需要接收mq返回的消息，发送失败的回调（以实现重试逻辑等），所以一个典型的发送端代码可以如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>请注意上面的实现，首先需要给RabbitTemplate设置回调，这两个不可或缺</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. 手动配置方式</h3>
<p>上面利用的是标准的SpringBoot配置，一般来说是适用于绝大多数的场景的；当不能覆盖的时候，还可以通过手动的方式来定义一个特定的RabbitTemplate（比如一个项目中，只有某一个场景的消息发送需要确认机制，其他的默认即可，所以需要区分RabbitTemplate）</p>
<p>在自动配置类中，可以手动的注册一个RabbitTemplate的bean，来专职消息确认模式的发送</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>至于使用姿势，和前面完全一致，只是将<code>rabbitTemplate</code>换成<code>ackRabbitTemplate</code></p>
<h2> III. 事务机制</h2>
<p>消息确认机制属于异步模式，也就是说一个消息发送完毕之后，不待返回，就可以发送另外一条消息；这里就会有一个问题，publisher先后发送msg1, msg2，但是对RabbitMq而言，接收的顺序可能是msg2, msg1；所以消息的顺序可能会不一致</p>
<p>所以有了更加严格的事务机制，它属于同步模式，发送消息之后，等到接收到确认返回之后，才能发送下一条消息</p>
<h3> 1. 事务使用方式</h3>
<p>首先我们定义一个事务管理器</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>事务机制的使用姿势，看起来和上面的消息确认差不多，无非是需要添加一个<code>@Transactional</code>注解罢了</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>请注意，核心代码设置信道为事务模式必不可少</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2> IV. 测试</h2>
<p>我们这里主要测试一下事务和消息确认机制的性能对比吧，从定义上来看消息确认机制效率更高，我们简单的对比一下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>去掉无关的输出，仅保留耗时，对比如下（差距还是很明显的）</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> V. 其他</h2>
<p><strong>系列博文</strong></p>
<ul>
<li><a href="http://spring.hhui.top/spring-blog/2020/02/10/200210-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B9%8BRabbitMq%E5%88%9D%E4%BD%93%E9%AA%8C/" target="_blank" rel="noopener noreferrer">【MQ系列】springboot + rabbitmq初体验</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2020/02/12/200212-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B9%8BRabbitMq%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%E5%B0%8F%E7%BB%93/" target="_blank" rel="noopener noreferrer">【MQ系列】RabbitMq核心知识点小结</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2020/02/18/200218-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B9%8BRabbitMq%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF/" target="_blank" rel="noopener noreferrer">【MQ系列】SprigBoot + RabbitMq发送消息基本使用姿势</a></li>
</ul>
<p><strong>项目源码</strong></p>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/301-rabbitmq-publish" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/301-rabbitmq-publish</a></li>
</ul>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="SpringBoot"/>
    <category term="MQ系列"/>
    <category term="RabbitMq"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2020-02-19T11:30:53.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">5.RabbitListener消费基本使用姿势</title>
    <id>https://liuyueyi.github.io/tutorial/spring/mq/RabbitMq/200318-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B9%8BRabbitListener%E6%B6%88%E8%B4%B9%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF%E4%BB%8B%E7%BB%8D.html</id>
    <link href="https://liuyueyi.github.io/tutorial/spring/mq/RabbitMq/200318-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B9%8BRabbitListener%E6%B6%88%E8%B4%B9%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF%E4%BB%8B%E7%BB%8D.html"/>
    <updated>2023-02-10T04:50:05.000Z</updated>
    <summary type="html"><![CDATA[<p>之前介绍了rabbitmq的消息发送姿势，既然有发送，当然就得有消费者，在SpringBoot环境下，消费可以说比较简单了，借助<code>@RabbitListener</code>注解，基本上可以满足你90%以上的业务开发需求</p>
<p>下面我们来看一下<code>@RabbitListener</code>的最最常用使用姿势</p>
]]></summary>
    <content type="html"><![CDATA[<p>之前介绍了rabbitmq的消息发送姿势，既然有发送，当然就得有消费者，在SpringBoot环境下，消费可以说比较简单了，借助<code>@RabbitListener</code>注解，基本上可以满足你90%以上的业务开发需求</p>
<p>下面我们来看一下<code>@RabbitListener</code>的最最常用使用姿势</p>
<!-- more -->
<h2> I. 配置</h2>
<p>首先创建一个SpringBoot项目，用于后续的演示</p>
<ul>
<li>springboot版本为<code>2.2.1.RELEASE</code></li>
<li>rabbitmq 版本为 <code>3.7.5</code> （安装教程可参考: <a href="http://spring.hhui.top/spring-blog/2020/02/10/200210-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B9%8BRabbitMq%E5%88%9D%E4%BD%93%E9%AA%8C/" target="_blank" rel="noopener noreferrer">【MQ系列】springboot + rabbitmq初体验</a>)</li>
</ul>
<p>依赖配置文件pom.xml</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在<code>application.yml</code>配置文件中，添加rabbitmq的相关属性</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> II. 消费姿势</h2>
<p>本文将目标放在实用性上，将结合具体的场景来演示<code>@RabbitListener</code>的使用姿势，因此当你发现看完本文之后这个注解里面有些属性还是不懂，请不要着急，下一篇会一一道来</p>
<h3> 0. mock数据</h3>
<p>消费消费，没有数据，怎么消费呢？所以我们第一步，先创建一个消息生产者，可以往exchange写数据，供后续的消费者测试使用</p>
<p>本篇的消费主要以topic模式来进行说明（其他的几个模式使用差别不大，如果有需求的话，后续补齐）</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>提供一个简单rest接口，可以指定往哪个exchange推送数据，并制定路由键</p>
<h3> 1. case1: exchange, queue已存在</h3>
<p>对于消费者而言其实是不需要管理exchange的创建/销毁的，它是由发送者定义的；一般来讲，消费者更关注的是自己的queue，包括定义queue并与exchange绑定，而这一套过程是可以直接通过rabbitmq的控制台操作的哦</p>
<figure><img src="/imgs/200318/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>所以实际开发过程中，exchange和queue以及对应的绑定关系已经存在的可能性是很高的，并不需要再代码中额外处理；</p>
<p>在这种场景下，消费数据，可以说非常非常简单了，如下：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>直接指定注解中的<code>queues</code>参数即可，参数值为对列名(queueName)</p>
<h3> 2. case2: queue不存在</h3>
<p>当queue的autoDelete属性为false时，上面的使用场景还是比较合适了；但是，当这个属性为true时，没有消费者队列就会自动删除了，这个时候再用上面的姿势，可能会得到下面的异常</p>
<figure><img src="/imgs/200318/01.jpg" alt="队列不存在" tabindex="0" loading="lazy"><figcaption>队列不存在</figcaption></figure>
<p>通常这种场景下，是需要我们来主动创建Queue，并建立与Exchange的绑定关系，下面给出<code>@RabbitListener</code>的推荐使用姿势</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>一个注解，内部声明了队列，并建立绑定关系，就是这么神奇！！！</p>
<p>注意<code>@QueueBinding</code>注解的三个属性：</p>
<ul>
<li>value: @Queue注解，用于声明队列，value为queueName, durable表示队列是否持久化, autoDelete表示没有消费者之后队列是否自动删除</li>
<li>exchange: @Exchange注解，用于声明exchange， type指定消息投递策略，我们这里用的topic方式</li>
<li>key: 在topic方式下，这个就是我们熟知的 routingKey</li>
</ul>
<p>以上，就是在队列不存在时的使用姿势，看起来也不复杂</p>
<h3> 3. case3: ack</h3>
<p>在前面rabbitmq的核心知识点学习过程中，会知道为了保证数据的一致性，有一个消息确认机制；</p>
<p>我们这里的ack主要是针对消费端而言，当我们希望更改默认ack方式(noack, auto, manual)，可以如下处理</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的实现也比较简单，设置<code>ackMode=MANUAL</code>，手动ack</p>
<p>但是，请注意我们的实现中，没有任何一个地方体现了手动ack，这就相当于一致都没有ack，在后面的测试中，可以看出这种不ack时，会发现数据一直在<code>unacked</code>这一栏，当Unacked数量超过限制的时候，就不会再消费新的数据了</p>
<h3> 4. case4: manual ack</h3>
<p>上面虽然选择ack方式，但是还缺一步ack的逻辑，接下来我们看一下如何补齐</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>请注意，方法多了两个参数</p>
<ul>
<li><code>deliveryTag</code>: 相当于消息的唯一标识，用于mq辨别是哪个消息被ack/nak了</li>
<li><code>channel</code>: mq和consumer之间的管道，通过它来ack/nak</li>
</ul>
<p>当我们正确消费时，通过调用 <code>basicAck</code> 方法即可</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>当我们消费失败，需要将消息重新塞入队列，等待重新消费时，可以使用 <code>basicNack</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3> 5. case5: 并发消费</h3>
<p>当消息很多，一个消费者吭哧吭哧的消费太慢，但是我的机器性能又杠杠的，这个时候我就希望并行消费，相当于同时有多个消费者来处理数据</p>
<p>要支持并行消费，如下设置即可</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/200318/02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>请注意注解中的<code>concurrency = "4"</code>属性，表示固定4个消费者；</p>
<p>除了上面这种赋值方式之外，还有一种 <code>m-n</code> 的格式，表示m个并行消费者，最多可以有n个</p>
<p>（额外说明：这个参数的解释实在<code>SimpleMessageListenerContainer</code>的场景下的，下一篇文章会介绍它与<code>DirectMessageListenerContainer</code>的区别）</p>
<h3> 6. 测试</h3>
<p>通过前面预留的消息发送接口，我们在浏览器中请求: <code>http://localhost:8080/publish?exchange=topic.e&amp;routing=r&amp;data=wahaha</code></p>
<figure><img src="/imgs/200318/03.jpg" alt="消费" tabindex="0" loading="lazy"><figcaption>消费</figcaption></figure>
<p>然后看一下输出，五个消费者都接收到了，特别是主动nak的那个消费者，一直在接收到消息；</p>
<p>（因为一直打印日志，所以重启一下应用，开始下一个测试）</p>
<p>然后再发送一条成功的消息，验证下手动真确ack，是否还会出现上面的情况，请求命令: <code>http://localhost:8080/publish?exchange=topic.e&amp;routing=r&amp;data=successMsg</code></p>
<figure><img src="/imgs/200318/04.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>然后再关注一下，没有ack的那个队列，一直有一个unack的消息</p>
<figure><img src="/imgs/200318/05.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> II. 其他</h2>
<p><strong>系列博文</strong></p>
<ul>
<li><a href="http://spring.hhui.top/spring-blog/2020/02/10/200210-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B9%8BRabbitMq%E5%88%9D%E4%BD%93%E9%AA%8C/" target="_blank" rel="noopener noreferrer">【MQ系列】springboot + rabbitmq初体验</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2020/02/12/200212-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B9%8BRabbitMq%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%E5%B0%8F%E7%BB%93/" target="_blank" rel="noopener noreferrer">【MQ系列】RabbitMq核心知识点小结</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2020/02/18/200218-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B9%8BRabbitMq%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF/" target="_blank" rel="noopener noreferrer">【MQ系列】SprigBoot + RabbitMq发送消息基本使用姿势</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2020/02/19/200219-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B9%8BRabbitMq%E6%B6%88%E6%81%AF%E7%A1%AE%E8%AE%A4%E6%9C%BA%E5%88%B6-%E4%BA%8B%E5%8A%A1%E7%9A%84%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF/" target="_blank" rel="noopener noreferrer">【MQ系列】RabbitMq消息确认/事务机制的使用姿势</a></li>
</ul>
<p><strong>项目源码</strong></p>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/302-rabbitmq-consumer" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/302-rabbitmq-consumer</a></li>
</ul>
<h3> 1. <a href="https://liuyueyi.github.io/hexblog" target="_blank" rel="noopener noreferrer">一灰灰Blog</a>： <a href="https://liuyueyi.github.io/hexblog" target="_blank" rel="noopener noreferrer">https://liuyueyi.github.io/hexblog</a></h3>
<p>一灰灰的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛</p>
<h3> 2. 声明</h3>
<p>尽信书则不如，以上内容，纯属一家之言，因个人能力有限，难免有疏漏和错误之处，如发现bug或者有更好的建议，欢迎批评指正，不吝感激</p>
<ul>
<li>微博地址: <a href="https://weibo.com/p/1005052169825577/home" target="_blank" rel="noopener noreferrer">小灰灰Blog</a></li>
<li>QQ： 一灰灰/3302797840</li>
</ul>
<h3> 3. 扫描关注</h3>
<p><strong>一灰灰blog</strong></p>
<figure><img src="https://spring.hhui.top/spring-blog/imgs/info/info.png" alt="QrCode" tabindex="0" loading="lazy"><figcaption>QrCode</figcaption></figure>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="SpringBoot"/>
    <category term="MQ系列"/>
    <category term="RabbitMq"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2020-03-18T19:58:38.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">RabbitMQ</title>
    <id>https://liuyueyi.github.io/tutorial/spring/mq/RabbitMq/</id>
    <link href="https://liuyueyi.github.io/tutorial/spring/mq/RabbitMq/"/>
    <updated>2023-02-10T04:50:05.000Z</updated>
    <summary type="html"><![CDATA[<p>消息队列RabbitMQ的基础 &amp; 进阶教程，系列文章教你在生产中使用消息队列的各种姿势</p>
]]></summary>
    <content type="html"><![CDATA[<p>消息队列RabbitMQ的基础 &amp; 进阶教程，系列文章教你在生产中使用消息队列的各种姿势</p>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2023-02-10T04:50:05.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">1.ES基本项目搭建</title>
    <id>https://liuyueyi.github.io/tutorial/spring/search/ElasticSearch/01.220328-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8BES%E5%9F%BA%E6%9C%AC%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA.html</id>
    <link href="https://liuyueyi.github.io/tutorial/spring/search/ElasticSearch/01.220328-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8BES%E5%9F%BA%E6%9C%AC%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA.html"/>
    <updated>2023-02-10T04:50:05.000Z</updated>
    <summary type="html"><![CDATA[<p>之前一直没有写ES相关的博文，现在开始补课，预计5-6篇博文将es的使用姿势展示给各位小伙伴；本文将作为es结合springboot的第一篇博文，基本项目环境搭建</p>
]]></summary>
    <content type="html"><![CDATA[<p>之前一直没有写ES相关的博文，现在开始补课，预计5-6篇博文将es的使用姿势展示给各位小伙伴；本文将作为es结合springboot的第一篇博文，基本项目环境搭建</p>
<!-- more -->
<h2> I. 项目搭建</h2>
<h3> 1. 项目依赖</h3>
<p>本项目借助<code>SpringBoot 2.2.1.RELEASE</code> + <code>maven 3.5.3</code> + <code>IDEA</code>进行开发</p>
<p>开一个web服务用于测试</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 配置信息</h3>
<p>配置文件application.yml，注意下面的配置信息，下面采用的是由我们自己来解析配置的方式</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>说明</strong></p>
<p>上面配置介绍的是一种偏基础的es文档操作姿势，相比较于封装得更好的<code>spring-boot-starter-data-elasticsearch</code>，使用更加灵活</p>
<h2> II. SpringBoot结合ES使用</h2>
<h3> 1. RestHighLevelClient 初始化</h3>
<p>接下来我们基于<code>RestHighLevelClient</code>来操作es，首先第一步就是需要初始化这实例</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意上面的实现，用户名 + 密码并没有使用，当es设置了用户名、密码之后，是通过每次请求时，在请求头基于Basic Auth方式进行身份验证的；后面会介绍到</p>
<h3> 2. 基本使用</h3>
<p>我们在本机搭建了一个es用于模拟测试，在上面的配置完之后，就可以直接与es进行交互了</p>
<blockquote>
<p>es安装可以参考：</p>
<ul>
<li><a href="https://blog.hhui.top/hexblog/2020/06/05/200605-Centos-%E5%AE%89%E8%A3%85ElasticSearch/" target="_blank" rel="noopener noreferrer">200605-Centos 安装ElasticSearch - 一灰灰Blog</a></li>
<li><a href="https://blog.hhui.top/hexblog/2021/03/29/210329-Elastic-Kibana%E5%AE%89%E8%A3%85%E4%B8%8E%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/" target="_blank" rel="noopener noreferrer">210329-Elastic &amp; Kibana安装与基本使用 - 一灰灰Blog</a>
docker安装： <code>docker pull docker.elastic.co/elasticsearch/elasticsearch:xxx</code></li>
</ul>
</blockquote>
<p>下面是一个简单的使用姿势</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意上面的实现，有下面几个重要知识点</p>
<p><strong>身份验证</strong></p>
<p>采用Basic Auth方式进行身份校验，简单来说就是在请求头中添加一个</p>
<ul>
<li><code>key = Authorization</code></li>
<li><code>value = "Basic " + base64(user + ":" + pwd)</code></li>
</ul>
<p><strong>访问姿势</strong></p>
<p>上面是一个根据<code>id</code>查询文档的实例，简单可以理解为三步</p>
<ul>
<li>创建：<code>XxRequest</code></li>
<li>添加请求头：<code>RequestOptions.Builder.addHeader</code></li>
<li>执行: <code>client.get(xxRequest, RequestOptions)</code></li>
</ul>
<h2> III. 不能错过的源码和相关知识点</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/142-search-es" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/142-search-es</a></li>
</ul>
<h3> 1. 微信公众号: 一灰灰Blog</h3>
<p>尽信书则不如，以上内容，纯属一家之言，因个人能力有限，难免有疏漏和错误之处，如发现bug或者有更好的建议，欢迎批评指正，不吝感激</p>
<p>下面一灰灰的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛</p>
<ul>
<li>一灰灰Blog个人博客 <a href="https://blog.hhui.top" target="_blank" rel="noopener noreferrer">https://blog.hhui.top</a></li>
<li>一灰灰Blog-Spring专题博客 <a href="http://spring.hhui.top" target="_blank" rel="noopener noreferrer">http://spring.hhui.top</a></li>
</ul>
<figure><img src="https://spring.hhui.top/spring-blog/imgs/info/info.png" alt="一灰灰blog" tabindex="0" loading="lazy"><figcaption>一灰灰blog</figcaption></figure>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="SpringBoot"/>
    <category term="搜索系列"/>
    <category term="ElasticSearch"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2022-03-28T19:04:24.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">2.ES文档基本操作CURD实例演示</title>
    <id>https://liuyueyi.github.io/tutorial/spring/search/ElasticSearch/02.220331-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8BES%E6%96%87%E6%A1%A3%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9CCURD%E5%AE%9E%E4%BE%8B%E6%BC%94%E7%A4%BA.html</id>
    <link href="https://liuyueyi.github.io/tutorial/spring/search/ElasticSearch/02.220331-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8BES%E6%96%87%E6%A1%A3%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9CCURD%E5%AE%9E%E4%BE%8B%E6%BC%94%E7%A4%BA.html"/>
    <updated>2023-02-10T04:50:05.000Z</updated>
    <summary type="html"><![CDATA[<p>本文将作为es系列第二篇，在前文项目搭建的基础上，先来看一下es的基本操作姿势，如何实现CURD</p>
]]></summary>
    <content type="html"><![CDATA[<p>本文将作为es系列第二篇，在前文项目搭建的基础上，先来看一下es的基本操作姿势，如何实现CURD</p>
<!-- more -->
<h2> I. 项目搭建</h2>
<h3> 1. 项目依赖</h3>
<p>本项目借助<code>SpringBoot 2.2.1.RELEASE</code> + <code>maven 3.5.3</code> + <code>IDEA</code>进行开发</p>
<p>开一个web服务用于测试</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 配置信息</h3>
<p>配置文件application.yml，注意下面的配置信息，下面采用的是由我们自己来解析配置的方式</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> II. CURD实例</h2>
<h3> 1. 配置</h3>
<p>注意，本文介绍的es是添加了权限验证，因此我们在于es进行交互时，需要在请求头中携带验证信息，注意下面的实现姿势</p>
<p>读取配置，初始化RestHighLevelClient，和前文介绍的差不多</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 添加数据</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>添加数据，注意是利用 <code>IndexRequest</code> 来构建请求对象，添加文档时有几个注意事项</p>
<ul>
<li><code>request.source()</code> : 具体需要上传的文档，就是通过它挂上去的，我们这里采用的是json方式</li>
<li><code>request.id()</code>: 如果上传的文档需要指定id，则可以使用它；若未指定，则表明自动生成id</li>
</ul>
<p>发起请求: <code>client.index()</code></p>
<h3> 3. 查询数据</h3>
<p>这里先介绍一个基础的根据id进行查询的实例case，更多的查询姿势后面会详细介绍</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. 增量更新数据</h3>
<p>根据主键进行更新文档，如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>注意</strong></p>
<ul>
<li>上面的实现属于增量更新策略</li>
<li>即：新传的文档，若key之前已经存在，则覆盖更新；若之前不存在，则插入；之前文档中未被覆盖的数据依然保留</li>
</ul>
<h3> 4. 全量更新</h3>
<p>另外一个根据条件进行更新的使用case如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 5. 删除数据</h3>
<p>直接根据id进行删除</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 6. 条件删除数据</h3>
<p>根据条件进行匹配删除</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 7. 测试case</h3>
<p>写一个测试demo，将上面的case都跑一遍</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> III. 不能错过的源码和相关知识点</h2>
<h3> 0. 项目</h3>
<p><strong>系列博文</strong></p>
<ul>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247487412&amp;idx=1&amp;sn=9d8afecd4dc4dcc2a016a89709a4cf34&amp;chksm=fce71418cb909d0e59e4599a4460642614104c3d254b691165f0f3630f198458073e908714a3&amp;token=1796894300&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">SpringBoot系列之ES基本项目搭建</a></li>
</ul>
<p><strong>源码</strong></p>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/142-search-es" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/142-search-es</a></li>
</ul>
<h3> 1. 微信公众号: 一灰灰Blog</h3>
<p>尽信书则不如，以上内容，纯属一家之言，因个人能力有限，难免有疏漏和错误之处，如发现bug或者有更好的建议，欢迎批评指正，不吝感激</p>
<p>下面一灰灰的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛</p>
<ul>
<li>一灰灰Blog个人博客 <a href="https://blog.hhui.top" target="_blank" rel="noopener noreferrer">https://blog.hhui.top</a></li>
<li>一灰灰Blog-Spring专题博客 <a href="http://spring.hhui.top" target="_blank" rel="noopener noreferrer">http://spring.hhui.top</a></li>
</ul>
<figure><img src="https://spring.hhui.top/spring-blog/imgs/info/info.png" alt="一灰灰blog" tabindex="0" loading="lazy"><figcaption>一灰灰blog</figcaption></figure>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="SpringBoot"/>
    <category term="搜索系列"/>
    <category term="ElasticSearch"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2022-03-31T19:27:54.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">3.ES查询常用实例演示</title>
    <id>https://liuyueyi.github.io/tutorial/spring/search/ElasticSearch/03.220418-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8BES%E6%9F%A5%E8%AF%A2%E7%9A%84%E5%B8%B8%E7%94%A8%E5%AE%9E%E4%BE%8B%E6%BC%94%E7%A4%BA.html</id>
    <link href="https://liuyueyi.github.io/tutorial/spring/search/ElasticSearch/03.220418-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8BES%E6%9F%A5%E8%AF%A2%E7%9A%84%E5%B8%B8%E7%94%A8%E5%AE%9E%E4%BE%8B%E6%BC%94%E7%A4%BA.html"/>
    <updated>2023-02-10T04:50:05.000Z</updated>
    <summary type="html"><![CDATA[<p>本文将作为es系列第三篇，结合常见的实例，来演示下如何通过<code>RestHighLevelClient</code>来实现es的各种查询支持</p>
]]></summary>
    <content type="html"><![CDATA[<p>本文将作为es系列第三篇，结合常见的实例，来演示下如何通过<code>RestHighLevelClient</code>来实现es的各种查询支持</p>
<!-- more -->
<h2> I. 项目搭建</h2>
<h3> 1. 项目依赖</h3>
<p>本项目借助<code>SpringBoot 2.2.1.RELEASE</code> + <code>maven 3.5.3</code> + <code>IDEA</code>进行开发</p>
<p>开一个web服务用于测试</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 配置信息</h3>
<p>配置文件application.yml，注意下面的配置信息，下面采用的是由我们自己来解析配置的方式</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> II. 实例演示</h2>
<h3> 0. 准备</h3>
<p>在开始之前，先准备插入几条数据，这里会借助上一篇CURD博文中的插入接口</p>
<blockquote>
<ul>
<li><a href="https://spring.hhui.top/spring-blog/2022/03/31/220331-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8BES%E6%96%87%E6%A1%A3%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9CCURD%E5%AE%9E%E4%BE%8B%E6%BC%94%E7%A4%BA/" target="_blank" rel="noopener noreferrer">【搜索系列】ES文档基本操作CURD实例演示 | 一灰灰Blog</a></li>
</ul>
</blockquote>
<p>在开始之前就准备两条数据</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1. 全量查询</h3>
<p>即查询所有的文档，如借助kibanan的控制台，发起的请求形如</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>于此对应的java实现如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意上面的实现：</p>
<ul>
<li>初始化<code>SearchRequest</code>实例，用于构建请求相关数据</li>
<li><code>SearchSourceBuilder</code> 来填充查询条件</li>
<li><code>client.search(searchRequest, requestOptions)</code> 执行查询请求，第二个参数为请求参数，这里主要是设置请求时的权限验证信息</li>
</ul>
<p>通常来说，实际的业务场景中，不太可能出现上面这种没有任何限制的查全量数据，即便真的有查全量数据的case，更常见的是分页查询，如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 根据Field值精确查询</h3>
<p>即es中常说的term查询，具体实现如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从上面的实现也可以看出，查询的套路没啥区别，无非就是<code>SearchSourceBuilder</code>中的参数构造不一样；上面主要通过</p>
<ul>
<li><code>QueryBuilders.termQuery("site", "blog.hhui.top")</code> 来构建 term的查询条件，表明查询 <code>site=blog.hhui.top</code> 的文档</li>
</ul>
<p><strong>中文查询不到问题</strong></p>
<p>在我们实际使用过程中，如果value为中文，在查询时，可能会遇到命名有对应的数据，但是就查不到，主要原因就在于分词，如对于中文的查询，可以考虑下面这种方式</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. Field值in查询</h3>
<p>另外一个常见的就是多值查询，也就是我们常说的 <code>field in (val1, val2...)</code>，这个对应的就是es中的<code>terms</code>查询</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4. 范围查询</h3>
<p>对于数值类型的Field，同样是支持比较、范围查询的，对应的是es中 <code>range</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意上面的查询有条件</p>
<ul>
<li><code>QueryBuilders.rangeQuery("age").gt(8).lt(12)</code></li>
<li>表示查询 <code>age &gt; 8 &amp;&amp; age &lt; 12</code></li>
<li>gte: 表示 &gt;=</li>
<li>lte: 表示 &lt;=</li>
</ul>
<h3> 5. Field是否存在查询</h3>
<p>es不同于mysql的在于它的field可以动态新增，当我们希望查询包含某个字段的文档时，可以考虑 <code>exists</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 6. 模糊查询</h3>
<p>es作为搜索引擎，更常见的是模糊匹配，比如match查询</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>多Field中进行查询</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在es的语法支持中，除了match，还有一个<code>wildcard</code>，可以使用<code>?</code>来代指单字符，<code>*</code>来代指0..n字符</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 7. 正则匹配</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 8. 前缀查询</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 9.小结</h3>
<p>本文虽然介绍了一些常见的查询case，但注意并不仅仅只有这些，比如</p>
<ul>
<li>查询指定Feild的内容</li>
<li>排序</li>
<li>分组聚合</li>
<li>多查询条件组合：and/or</li>
<li>高亮</li>
<li>...</li>
</ul>
<p>更多的使用实例，敬请期待...，欢迎感兴趣的小伙伴，点赞收藏评论一波😝</p>
<h2> III. 不能错过的源码和相关知识点</h2>
<h3> 0. 项目</h3>
<p><strong>系列博文</strong></p>
<ul>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247487412&amp;idx=1&amp;sn=9d8afecd4dc4dcc2a016a89709a4cf34&amp;chksm=fce71418cb909d0e59e4599a4460642614104c3d254b691165f0f3630f198458073e908714a3&amp;token=1796894300&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">SpringBoot系列之ES基本项目搭建</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247487420&amp;idx=1&amp;sn=3d64361be03a95631e1c50f6d84ab5f3&amp;chksm=fce71410cb909d069d43a59541933284b231a694620d31b8ba46065bd43c15c049e2b2c1bdb1&amp;token=623887797&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">SpringBoot之ES文档基本操作CURD实例演示</a></li>
</ul>
<p><strong>源码</strong></p>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/142-search-es" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/142-search-es</a></li>
</ul>
<h3> 1. 微信公众号: 一灰灰Blog</h3>
<p>尽信书则不如，以上内容，纯属一家之言，因个人能力有限，难免有疏漏和错误之处，如发现bug或者有更好的建议，欢迎批评指正，不吝感激</p>
<p>下面一灰灰的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛</p>
<ul>
<li>一灰灰Blog个人博客 <a href="https://blog.hhui.top" target="_blank" rel="noopener noreferrer">https://blog.hhui.top</a></li>
<li>一灰灰Blog-Spring专题博客 <a href="http://spring.hhui.top" target="_blank" rel="noopener noreferrer">http://spring.hhui.top</a></li>
</ul>
<figure><img src="https://spring.hhui.top/spring-blog/imgs/info/info.png" alt="一灰灰blog" tabindex="0" loading="lazy"><figcaption>一灰灰blog</figcaption></figure>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="SpringBoot"/>
    <category term="搜索系列"/>
    <category term="ElasticSearch"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2022-04-18T19:43:19.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">ElasticSearch</title>
    <id>https://liuyueyi.github.io/tutorial/spring/search/ElasticSearch/</id>
    <link href="https://liuyueyi.github.io/tutorial/spring/search/ElasticSearch/"/>
    <updated>2023-02-10T04:50:05.000Z</updated>
    <summary type="html"><![CDATA[<p>SpringBoot整合ElasticSearch，支撑搜索全业务场景</p>
]]></summary>
    <content type="html"><![CDATA[<p>SpringBoot整合ElasticSearch，支撑搜索全业务场景</p>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2023-02-10T04:50:05.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">1.环境搭建与简单测试</title>
    <id>https://liuyueyi.github.io/tutorial/spring/search/Solr/01.190510-SpringBoot%E9%AB%98%E7%BA%A7%E7%AF%87%E6%90%9C%E7%B4%A2%E4%B9%8BSolr%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E7%AE%80%E5%8D%95%E6%B5%8B%E8%AF%95.html</id>
    <link href="https://liuyueyi.github.io/tutorial/spring/search/Solr/01.190510-SpringBoot%E9%AB%98%E7%BA%A7%E7%AF%87%E6%90%9C%E7%B4%A2%E4%B9%8BSolr%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E7%AE%80%E5%8D%95%E6%B5%8B%E8%AF%95.html"/>
    <updated>2023-02-10T04:50:05.000Z</updated>
    <summary type="html"><![CDATA[<p>搜索可以说是非常常见的场景了，一般选择比较多的有solr和es，底层都是基于Lucene搜索引擎实现。之前简单的使用过solr，一直没有成体系的学习过，正好需要给一个内部项目封装统一的查询组件，借这个机会好好的撸一把solr的知识要点</p>
]]></summary>
    <content type="html"><![CDATA[<p>搜索可以说是非常常见的场景了，一般选择比较多的有solr和es，底层都是基于Lucene搜索引擎实现。之前简单的使用过solr，一直没有成体系的学习过，正好需要给一个内部项目封装统一的查询组件，借这个机会好好的撸一把solr的知识要点</p>
<!-- more -->
<h2> I. Solr环境搭建</h2>
<h3> 1. docker方式安装solr</h3>
<p>使用docker实现solr环境的搭建，快速简洁</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>启动solr容器</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>浏览器打开: <a href="http://localhost:8983/solr/#/" target="_blank" rel="noopener noreferrer">http://localhost:8983/solr/#/</a></p>
<p><strong>新建core</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>建立成功之后，终端会有相应的提示，然后刷新浏览器，可以看到新的yhh</p>
<figure><img src="/imgs/190510/00.jpg" alt="控制台" tabindex="0" loading="lazy"><figcaption>控制台</figcaption></figure>
<h3> 2. schema</h3>
<p>通过docker安装的最新solr版本为8.0，可以直接在http界面通过控制台来创建schema，而不需要像以前那样，进入配置文件进行添加处理；当然也可以通过修改对应的配置</p>
<p>假定我们现在需要在yhh这个core中存文章，结构为</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> a. 控制台添加方式</h4>
<p>首先进入schema的页面，可以如下操作，也可以点击连接: <a href="http://localhost:8983/solr/#/yhh/schema" target="_blank" rel="noopener noreferrer">http://localhost:8983/solr/#/yhh/schema</a></p>
<figure><img src="/imgs/190510/01.jpg" alt="1" tabindex="0" loading="lazy"><figcaption>1</figcaption></figure>
<p>然后通过点击Add Field按钮添加字段，确认按钮之后完成添加</p>
<figure><img src="/imgs/190510/02.jpg" alt="2" tabindex="0" loading="lazy"><figcaption>2</figcaption></figure>
<p>添加完成之后点击<code>please select...</code>，弹出下拉框，看到刚才添加的东西</p>
<figure><img src="/imgs/190510/03.jpg" alt="3" tabindex="0" loading="lazy"><figcaption>3</figcaption></figure>
<h4> b. 编辑xml文件方式</h4>
<p>通过控制台的overiew可以定位到core存储路径，然后我们找到对应的定义文件，添加两个字段</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>修改配置文件</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>修改完成之后如下图</p>
<figure><img src="/imgs/190510/04.jpg" alt="xml" tabindex="0" loading="lazy"><figcaption>xml</figcaption></figure>
<p>配置文件修改之后，再去刷控制台，发现并没有显示出来，通过重启solr之后，新的才显示出来</p>
<figure><img src="/imgs/190510/05.jpg" alt="show" tabindex="0" loading="lazy"><figcaption>show</figcaption></figure>
<h4> c. 功能测试</h4>
<p>schema定义完毕之后，就可以进行简单的测试了，先加几个文档；然后再进行查询</p>
<p><strong>添加文档</strong></p>
<p>直接在控制台进行添加: <a href="http://localhost:8983/solr/#/yhh/documents" target="_blank" rel="noopener noreferrer">http://localhost:8983/solr/#/yhh/documents</a></p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/190510/06.jpg" alt="添加文档" tabindex="0" loading="lazy"><figcaption>添加文档</figcaption></figure>
<p><strong>文档查询</strong></p>
<p>直接在控制台进行操作：<a href="http://localhost:8983/solr/#/yhh/query" target="_blank" rel="noopener noreferrer">http://localhost:8983/solr/#/yhh/query</a></p>
<figure><img src="/imgs/190510/07.jpg" alt="文档查询" tabindex="0" loading="lazy"><figcaption>文档查询</figcaption></figure>
<p>然后来个高级一点的查询，我希望查询所有内容包含一灰灰的数据，可以如下查询</p>
<figure><img src="/imgs/190510/08.jpg" alt="文档查询" tabindex="0" loading="lazy"><figcaption>文档查询</figcaption></figure>
<h2> II. SpringBoot搭建solr环境</h2>
<h3> 1. 配置</h3>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的配置中，需要注意是引入包 <code>spring-boot-starter-data-solr</code></p>
<p>引入这个包之后，我们就可以愉快的使用<code>SolrTemplate</code>来完成solr的各种骚操作了</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 简单测试</h3>
<p>下面搞一个简单的查询，看下能不能获取到solr文档</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. 测试</h3>
<p>启动下任务开始测试</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>执行截图如下</p>
<figure><img src="/imgs/190510/09.jpg" alt="测试输出" tabindex="0" loading="lazy"><figcaption>测试输出</figcaption></figure>
<h2> III. 小结</h2>
<p>上面介绍了最基础的solr环境搭建，springboot的solr测试环境准备，并实现了一个简单的查询实例，但距离真正上手撸solr还缺不少东西</p>
<ul>
<li>solr的基础知识，前面的字段定义是否合法，索引什么的改怎么考虑</li>
<li>配置修改，安全保证</li>
<li>中文分词如何设置，如何使用在solr中进行使用</li>
<li>solr的增删改查的基本操作姿势</li>
<li>solr的全文搜索优势如何体现</li>
<li>SpringBoot中进行solr操作</li>
<li>...</li>
</ul>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>项目： <a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/140-search-solr" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/140-search-solr</a></li>
</ul>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="SpringBoot"/>
    <category term="搜索系列"/>
    <category term="Solr"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2019-05-10T20:10:41.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">2.文档新增与修改使用姿势</title>
    <id>https://liuyueyi.github.io/tutorial/spring/search/Solr/02.190526-SpringBoot%E9%AB%98%E7%BA%A7%E7%AF%87%E6%90%9C%E7%B4%A2Solr%E4%B9%8B%E6%96%87%E6%A1%A3%E6%96%B0%E5%A2%9E%E4%B8%8E%E4%BF%AE%E6%94%B9%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF.html</id>
    <link href="https://liuyueyi.github.io/tutorial/spring/search/Solr/02.190526-SpringBoot%E9%AB%98%E7%BA%A7%E7%AF%87%E6%90%9C%E7%B4%A2Solr%E4%B9%8B%E6%96%87%E6%A1%A3%E6%96%B0%E5%A2%9E%E4%B8%8E%E4%BF%AE%E6%94%B9%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF.html"/>
    <updated>2023-02-10T04:50:05.000Z</updated>
    <summary type="html"><![CDATA[<p>大多涉及到数据的处理，无非CURD四种操作，对于搜索SOLR而言，基本操作也可以说就这么几种，在实际应用中，搜索条件的多样性才是重点，我们在进入复杂的搜索之前，先来看一下如何新增和修改文档</p>
]]></summary>
    <content type="html"><![CDATA[<p>大多涉及到数据的处理，无非CURD四种操作，对于搜索SOLR而言，基本操作也可以说就这么几种，在实际应用中，搜索条件的多样性才是重点，我们在进入复杂的搜索之前，先来看一下如何新增和修改文档</p>
<!-- more -->
<h2> I. 环境准备</h2>
<p>solr的基础环境需要准备好，如果对这一块有疑问的童鞋，可以参考下上一篇博文: 《<a href="http://spring.hhui.top/spring-blog/2019/05/10/190510-SpringBoot%E9%AB%98%E7%BA%A7%E7%AF%87%E6%90%9C%E7%B4%A2%E4%B9%8BSolr%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E7%AE%80%E5%8D%95%E6%B5%8B%E8%AF%95/" target="_blank" rel="noopener noreferrer">190510-SpringBoot高级篇搜索之Solr环境搭建与简单测试</a>》</p>
<h3> 1. 环境配置</h3>
<p>在pom文件中，设置好对应的依赖</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>因为我们采用默认的solr访问姿势，所以配置文件中可以不加对应的参数，当然也可以加上</p>
<p>打开 <code>application.yml</code> 配置文件</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果我们的solr加上了用户名密码访问条件，参数中并没有地方设置username和password，那应该怎么办?</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如上写法，将用户名和密码写入http的连接中</p>
<h3> 2. 自动装配</h3>
<p>我们主要使用SolrTemplate来和Solr打交到，因此我们需要先注册这个bean，可以怎么办？</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的配置是条件注入，只有当SolrTemplate对应的bean没有被自动加载时，才会加载，为什么要怎么干？</p>
<p>（可以想一想原因...）</p>
<h2> II. 使用姿势示例</h2>
<p>我们的操作主要依赖的是SolrTemplate，因此有必要在开始之前，看一下它的签名</p>
<p>Spring的源码中，可以发现大多<code>xxxTemplate</code>都会实现一个<code>xxxOperations</code> 接口，而这个接口就是用来定义CURD的api，比如我们看下 <code>SolrOperations</code>中与修改相关的api</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的api签名中，比较明确的说明了这个 <code>saveXXX</code> 既可以用来新增文档，也可以用来修改文档，主要有提供了两类</p>
<ul>
<li>单个与批量</li>
<li>saveDocument 与 saveBean</li>
</ul>
<h3> 1. 添加文档</h3>
<p>从上面的api签名上看，<code>saveDocument</code> 应该是相对原始的操作方式了，因此我们先看下它的使用姿势</p>
<h4> a. saveDocument</h4>
<p>首先就是创建文档 <code>SolrInputDocument</code> 对象，通过调用<code>addField</code>来设置成员值</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> b. saveBean</h4>
<p>前面需要创建<code>SolrInputDocument</code>对象，我们更希望的使用case是直接传入一个POJO，然后自动与solr的filed进行关联</p>
<p>因此一种使用方式可以如下</p>
<ul>
<li>定义pojo，成员上通过 @Field 注解来关联solr的field</li>
<li>pojo对象直接当做参数传入，保存之后，执行 commit 提交</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> c. 批量</h4>
<p>批量的方式就比较简单了，传入集合即可</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> d. 测试</h4>
<p>上面的几个方法，我们执行之后，我们看下是否能查询到新增加的数据</p>
<figure><img src="/imgs/190526/00.jpg" alt="output" tabindex="0" loading="lazy"><figcaption>output</figcaption></figure>
<h3> 2. 文档修改</h3>
<p>在看前面的接口签名时，就知道修改和新增用的是相同的api，所以修改文档和上面的使用实际上也没有什么特别的，下面简单的演示一下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的实例中，修改了id为5的文档标题，并删除了content内容，执行完毕之后，结果如何呢？</p>
<figure><img src="/imgs/190526/01.jpg" alt="output" tabindex="0" loading="lazy"><figcaption>output</figcaption></figure>
<ul>
<li>title被替换</li>
<li>content没有了</li>
</ul>
<p><strong>到这里就有个疑问了，对于调用而言，怎么保证是修改还是新增呢？</strong></p>
<ul>
<li>这里主要是根据id来判断，这个id类似db中的唯一主键，当我们没有指定id时，会随机生成一个id</li>
<li>如果存在相同的id，则修改文档；如果不存在，则新增文档</li>
</ul>
<h2> III. 其他</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">spring-boot-demo</a></li>
</ul>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="SpringBoot"/>
    <category term="搜索系列"/>
    <category term="Solr"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2019-05-26T20:36:00.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">3.Solr文档删除</title>
    <id>https://liuyueyi.github.io/tutorial/spring/search/Solr/03.200114-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8BSolr%E4%B9%8B%E6%96%87%E6%A1%A3%E5%88%A0%E9%99%A4.html</id>
    <link href="https://liuyueyi.github.io/tutorial/spring/search/Solr/03.200114-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8BSolr%E4%B9%8B%E6%96%87%E6%A1%A3%E5%88%A0%E9%99%A4.html"/>
    <updated>2023-02-10T04:50:05.000Z</updated>
    <summary type="html"><![CDATA[<p>之前的搜索教程开了个头就没有继续了，现在重新捡回来，至少也把CURD的基本操作姿势补全了；本篇主要介绍如何删除数据</p>
]]></summary>
    <content type="html"><![CDATA[<p>之前的搜索教程开了个头就没有继续了，现在重新捡回来，至少也把CURD的基本操作姿势补全了；本篇主要介绍如何删除数据</p>
<!-- more -->
<h2> I. 配置</h2>
<p>在介绍demo之前，需要先安装solr环境，搭建SpringBoot项目工程，具体的环境搭建过程不细说，推荐参考文档</p>
<ul>
<li><a href="http://spring.hhui.top/spring-blog/2019/05/10/190510-SpringBoot%E9%AB%98%E7%BA%A7%E7%AF%87%E6%90%9C%E7%B4%A2%E4%B9%8BSolr%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E7%AE%80%E5%8D%95%E6%B5%8B%E8%AF%95/" target="_blank" rel="noopener noreferrer">190510-SpringBoot高级篇搜索之Solr环境搭建与简单测试</a></li>
</ul>
<p>在<code>application.yml</code> 配置文件中红，指定solr的域名</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后在solr中，写入一些数据，供我们删除使用，可以通过控制台的方式写入，也可以通过<a href="http://spring.hhui.top/spring-blog/2019/05/26/190526-SpringBoot%E9%AB%98%E7%BA%A7%E7%AF%87%E6%90%9C%E7%B4%A2Solr%E4%B9%8B%E6%96%87%E6%A1%A3%E6%96%B0%E5%A2%9E%E4%B8%8E%E4%BF%AE%E6%94%B9%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF/" target="_blank" rel="noopener noreferrer">190526-SpringBoot高级篇搜索Solr之文档新增与修改使用姿势</a> 这篇文档的case添加</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> II. 删除</h2>
<p>我们依然是使用<code>SolrTemplate</code>来操作solr的正删改查，它整合了solr的各种基本操作</p>
<h3> 1. 根据主键删除</h3>
<p>请注意，这种case是根据主键id进行删除的，支持批量删除，需要<code>solrTemplate.commit("yhh");</code>这一行来提交修改</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 查询删除</h3>
<p>上面根据主键删除适合精准的删除操作，但是适用性有限；下面介绍查询删除的方式，将满足查询条件的数据都删除掉</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面提供了一个简单的查询条件，删除content内容以<code>新增</code>开头的文档，至于查询语句的使用姿势在下一篇介绍Solr的查询姿势时详细说明</p>
<h3> 3. 测试</h3>
<p>接下来测试一下上面的两种case</p>
<p>首先我们提供一个输出所有文档的方法，用于对比删除前后的数据变化</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来是方法调用</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果如下，id为4,5,6的都被删除了</p>
<div class="language-log line-numbers-mode" data-ext="log"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> II. 其他</h2>
<h3> 0. 系列博文&amp;项目源码</h3>
<p><strong>系列博文</strong></p>
<ul>
<li><a href="http://spring.hhui.top/spring-blog/2019/05/26/190526-SpringBoot%E9%AB%98%E7%BA%A7%E7%AF%87%E6%90%9C%E7%B4%A2Solr%E4%B9%8B%E6%96%87%E6%A1%A3%E6%96%B0%E5%A2%9E%E4%B8%8E%E4%BF%AE%E6%94%B9%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF/" target="_blank" rel="noopener noreferrer">190526-SpringBoot高级篇搜索Solr之文档新增与修改使用姿势</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2019/05/10/190510-SpringBoot%E9%AB%98%E7%BA%A7%E7%AF%87%E6%90%9C%E7%B4%A2%E4%B9%8BSolr%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E7%AE%80%E5%8D%95%E6%B5%8B%E8%AF%95/" target="_blank" rel="noopener noreferrer">190510-SpringBoot高级篇搜索之Solr环境搭建与简单测试</a></li>
</ul>
<p><strong>项目源码</strong></p>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码: <a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/140-search-solr" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/140-search-solr</a></li>
</ul>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="SpringBoot"/>
    <category term="搜索系列"/>
    <category term="Solr"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2020-01-14T16:16:57.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">4.Solr查询使用姿势小结</title>
    <id>https://liuyueyi.github.io/tutorial/spring/search/Solr/04.200115-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8BSolr%E4%B9%8B%E6%9F%A5%E8%AF%A2%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF%E5%B0%8F%E7%BB%93.html</id>
    <link href="https://liuyueyi.github.io/tutorial/spring/search/Solr/04.200115-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8BSolr%E4%B9%8B%E6%9F%A5%E8%AF%A2%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF%E5%B0%8F%E7%BB%93.html"/>
    <updated>2023-02-10T04:50:05.000Z</updated>
    <summary type="html"><![CDATA[<p>接下来进入solr CURD的第四篇，查询的使用姿势介绍，本文将主要包括以下知识点</p>
<ul>
<li>基本的查询操作</li>
<li>fq查询</li>
<li>fl指定字段查询</li>
<li>比较/范围</li>
<li>排序</li>
<li>分页</li>
<li>分组</li>
</ul>
]]></summary>
    <content type="html"><![CDATA[<p>接下来进入solr CURD的第四篇，查询的使用姿势介绍，本文将主要包括以下知识点</p>
<ul>
<li>基本的查询操作</li>
<li>fq查询</li>
<li>fl指定字段查询</li>
<li>比较/范围</li>
<li>排序</li>
<li>分页</li>
<li>分组</li>
</ul>
<!-- more -->
<h2> I. 配置</h2>
<p>在介绍demo之前，需要先安装solr环境，搭建SpringBoot项目工程，具体的环境搭建过程不细说，推荐参考文档</p>
<ul>
<li><a href="http://spring.hhui.top/spring-blog/2019/05/10/190510-SpringBoot%E9%AB%98%E7%BA%A7%E7%AF%87%E6%90%9C%E7%B4%A2%E4%B9%8BSolr%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E7%AE%80%E5%8D%95%E6%B5%8B%E8%AF%95/" target="_blank" rel="noopener noreferrer">190510-SpringBoot高级篇搜索之Solr环境搭建与简单测试</a></li>
</ul>
<p>在<code>application.yml</code> 配置文件中红，指定solr的域名</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后在solr中，写入一些数据，供我们查询使用，可以通过控制台的方式写入，也可以通过<a href="http://spring.hhui.top/spring-blog/2019/05/26/190526-SpringBoot%E9%AB%98%E7%BA%A7%E7%AF%87%E6%90%9C%E7%B4%A2Solr%E4%B9%8B%E6%96%87%E6%A1%A3%E6%96%B0%E5%A2%9E%E4%B8%8E%E4%BF%AE%E6%94%B9%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF/" target="_blank" rel="noopener noreferrer">190526-SpringBoot高级篇搜索Solr之文档新增与修改使用姿势</a> 这篇文档的case添加</p>
<p>初始化solr文档内容如下</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> II. 查询</h2>
<p>solr文档对应的POJO如下，（注意solr中的主键id为string类型，下面定义中用的是Integer，推荐与solr的数据类型保持一致）</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1. 主键查询</h3>
<p>支持单个查询和批量查询，三个参数，第一个为需要查询的Collection, 第二个为id/id集合，第三个为返回的数据类型</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 简单查询</h3>
<p>比如最简单的根据某个字段进行查询</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>直接在SimpleQuery中指定查询条件，上面的case表示查询title为<code>一灰灰</code>的文档</p>
<p>输出结果如下：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>简单的查询使用上面的姿势ok，当然就是阅读起来不太优雅；推荐另外一种基于<code>Criteria</code>的查询条件构建方式</p>
<ul>
<li>如果看过之前的mongodb系列教程，可以看到monodb的查询条件也用到了Criteria来拼装，但是请注意这两个并不是一个东西</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><code>Criteria</code>可以构建复杂的且阅读友好的查询条件，后面会有具体的演示，这里给出一个多条件查询的case</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果如下，在上面的基础上，捞出了contentId小于2的记录</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 3. fq查询</h3>
<p>fq 主要用来快速过滤，配合query进行操作，主要是借助<code>org.springframework.data.solr.core.query.Query#addFilterQuery</code>来添加fq条件</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果如:</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 4. fl指定查询字段</h3>
<p>当我们只关注solr文档中的部分字段时，可以考虑指定fl，只获取所需的字段；通过<code>org.springframework.data.solr.core.query.SimpleQuery#addProjectionOnFields(java.lang.String...)</code>来指定需要返回的字段名</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>请注意，我们指定了只需要返回<code>id</code>, <code>title</code>, <code>content</code>，所以返回的DO中其他的成员为null</p>
<h3> 5. 范围查询</h3>
<p>针对数字类型，支持范围查询，比如上面给出<code>Criteria.where("content_id").lessThanEqual(2)</code>，表示查询<code>content_id</code>小于2的记录，下面给出一个between的查询</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果如下，请注意between查询，左右都是闭区间</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>如果不想要闭区间，可以用<code>between</code>的重载方法</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果如</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 6. 排序</h3>
<p>上面的case中，已经用到了排序，主要是<code>Sort</code>来指定排序字段以及排序的方式；因为id在solr中实际上是字符串格式，所以如果用id进行排序时，实际上是根据字符串的排序规则来的（虽然我们的POJO中id为int类型）</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 7. 分页查询</h3>
<p>分页查询比较常见，特别是当数据量比较大时，请一定记得，添加分页条件</p>
<p>一个查询case如下，查询所有的数据，并制定了分页条件，查询第二条和第三条数据（计数从0开始）</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在返回结果中，查了返回查询的文档之外，还会给出满足条件的文档数量，可以通过<code>Page#getTotalElements</code>获取，</p>
<p>上面case输出结果如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 8. 分组查询</h3>
<p>分组和前面的查询有一点区别，主要在于结果的处理，以及分组参数必须指定分页信息</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的case虽然比较简单，但是有几点需要注意, 特别是返回结果的获取，包装层级有点深</p>
<ul>
<li>GroupOptions：
<ul>
<li>必须指定offset/limit，当两个条件都没有时会抛异常</li>
<li>只指定offset时，limit默认为1</li>
<li>只指定limit时，offset默认为0</li>
</ul>
</li>
<li>结果处理
<ul>
<li><code>GroupPage#getGroupResult(field)</code> 获取分组内容，其中field为指定分组的成员</li>
<li>遍历<code>GroupResult#getGroupEntries</code>，获取每个分组对应的文档列表</li>
</ul>
</li>
</ul>
<p>输出结果如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> III. 其他</h2>
<h3> 0. 系列博文&amp;工程源码</h3>
<p><strong>系列博文</strong></p>
<ul>
<li><a href="http://spring.hhui.top/spring-blog/2020/01/14/200114-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8BSolr%E4%B9%8B%E6%96%87%E6%A1%A3%E5%88%A0%E9%99%A4/" target="_blank" rel="noopener noreferrer">200114-SpringBoot系列教程Solr之文档删除</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2019/05/26/190526-SpringBoot%E9%AB%98%E7%BA%A7%E7%AF%87%E6%90%9C%E7%B4%A2Solr%E4%B9%8B%E6%96%87%E6%A1%A3%E6%96%B0%E5%A2%9E%E4%B8%8E%E4%BF%AE%E6%94%B9%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF/" target="_blank" rel="noopener noreferrer">190526-SpringBoot高级篇搜索Solr之文档新增与修改使用姿势</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2019/05/10/190510-SpringBoot%E9%AB%98%E7%BA%A7%E7%AF%87%E6%90%9C%E7%B4%A2%E4%B9%8BSolr%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E7%AE%80%E5%8D%95%E6%B5%8B%E8%AF%95/" target="_blank" rel="noopener noreferrer">190510-SpringBoot高级篇搜索之Solr环境搭建与简单测试</a></li>
</ul>
<p><strong>工程源码</strong></p>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码: <a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/140-search-solr" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/140-search-solr</a></li>
</ul>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="SpringBoot"/>
    <category term="搜索系列"/>
    <category term="Solr"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2020-01-15T15:55:37.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">5.Solr身份认证与授权更新异常解决方案</title>
    <id>https://liuyueyi.github.io/tutorial/spring/search/Solr/05.200330-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B9%8BSolr%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83%E6%9B%B4%E6%96%B0%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90.html</id>
    <link href="https://liuyueyi.github.io/tutorial/spring/search/Solr/05.200330-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B9%8BSolr%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83%E6%9B%B4%E6%96%B0%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90.html"/>
    <updated>2023-02-10T04:50:05.000Z</updated>
    <summary type="html"><![CDATA[<p>之前介绍solr的教程中，solr没有开启权限校验，所有的操作都是无需鉴权；当时提到，如果solr开启了权限校验，改一下solr的host，带上用户名/密码即可，然而真实情况却并不太一样，查询ok，涉及到修改的操作，则会抛异常</p>
<p>本文将带你了解一下，这到底是个什么鬼畜现象</p>
]]></summary>
    <content type="html"><![CDATA[<p>之前介绍solr的教程中，solr没有开启权限校验，所有的操作都是无需鉴权；当时提到，如果solr开启了权限校验，改一下solr的host，带上用户名/密码即可，然而真实情况却并不太一样，查询ok，涉及到修改的操作，则会抛异常</p>
<p>本文将带你了解一下，这到底是个什么鬼畜现象</p>
<!-- more -->
<h2> I. Solr配置用户登录</h2>
<h3> 1. 安装</h3>
<p>之前的solr系列教程中，通过docker安装的solr，下面的步骤也是直接针对docker中的solr进行配置，基本步骤一样</p>
<p>具体可以参考： <a href="http://spring.hhui.top/spring-blog/2019/05/10/190510-SpringBoot%E9%AB%98%E7%BA%A7%E7%AF%87%E6%90%9C%E7%B4%A2%E4%B9%8BSolr%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E7%AE%80%E5%8D%95%E6%B5%8B%E8%AF%95/" target="_blank" rel="noopener noreferrer">【搜索系列】Solr环境搭建与简单测试</a></p>
<p>不想看的同学，直接用下面的命令即可:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 配置</h3>
<p>下面一步一步教你如何设置用户密码，也可以参考博文: <a href="https://blog.csdn.net/u011561335/article/details/90695860" target="_blank" rel="noopener noreferrer">手把手教你 对 solr8 配置用户登录验证</a></p>
<p>进入实例，注意使用<code>root</code>用户，否则某些操作可能没有权限</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>创建鉴权文件</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>内容如下，格式为 <code>用户名:密码,权限</code>， 一行一个账号</p>
<div class="language-properties line-numbers-mode" data-ext="properties"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>配置鉴权文件</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>添加下面的内容放在<code>Configure</code>标签内</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>修改web.xml</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>在<code>security-constraint</code>标签下面，新增</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>重启solr，配置生效</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2> II. 场景复现</h2>
<p>接下来介绍一下我们的环境</p>
<ul>
<li>springboot: 2.2.1.RELEASE</li>
<li>solr: 8.0</li>
</ul>
<h3> 1. 项目环境</h3>
<p>搭建一个简单的springboot项目，xml依赖如下</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对应的配置文件<code>application.yml</code></p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 复现</h3>
<p>关于solr的基本操作，如果有疑问的小伙伴可以翻一下我之前的搜索系列博文，满足你的扫盲需求；</p>
<p>核心的solr操作实例如下:</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>SolrTemplat</code>定义如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>开始测试</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/200330/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>请注意，复现上面的场景时，会发现查询没问题，修改则会抛异常</p>
<h3> 3. 解决方案</h3>
<h4> a. 降版本</h4>
<p>我之前用solr的时候，也是上面的操作方式，然而并没有出现过这种问题，这就有点蛋疼了；</p>
<p>找之前的项目查看版本，发现之前用的<code>solr-solrj</code>用的是<code>6.6.5</code>，换个版本试一下（默认的版本是<code>8.2.0</code>）</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>见证奇迹的时刻到了，执行正常了，虽然<code>saveDocument</code>方法的调用标红，但是不影响具体的执行哦</p>
<figure><img src="/imgs/200330/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h4> b. SystemDefaultHttpClient</h4>
<p>通过一顿debug，单步执行，终于找到为啥<code>6.6.5</code>版本的<code>solr-solrj</code>可以正常操作，而<code>8.2.0</code>却不行（如果想知道这一枯燥的过程，请评论告诉我，否则我也不知道啥时候可以看到😂）</p>
<p>关键的问题就是旧版本的用的是<code>SystemDefaultHttpClient</code>来实现solr的沟通；新版本使用的是<code>InternalHttpClient</code></p>
<p>那么一个可用的解决方法就是不降版本，改为指定Solr的<code>HttpClient</code></p>
<p>在配置类中，如下操作：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后测试，也是正常执行，输出结果就不截图了，各位小伙伴可以亲自测试一下</p>
<h4> c. HttpClient拦截器</h4>
<blockquote>
<p>关于下面的这段写法，来自: <a href="https://stackoverflow.com/questions/2014700/preemptive-basic-authentication-with-apache-httpclient-4/11868040#11868040" target="_blank" rel="noopener noreferrer">Preemptive Basic authentication with Apache HttpClient 4</a></p>
</blockquote>
<p>上面的方式虽然可以让我们正确操作solr了，但是<code>SystemDefaultHttpClient</code>有一个删除注解，也就是说不建议再直接用它了，那就借鉴它的使用方式，来满足我们的需求，所以可以如下操作</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的实现有点长，简单的拆解一下</p>
<ul>
<li><code>UrlDo</code>: 解析solr的url，得到我们需要的<code>host + port + user + password</code></li>
<li><code>solrClient</code>: 在创建<code>SolrClient</code> bean实例时，指定相应的授权信息</li>
<li><code>SolrAuthInterceptor</code>: 自定义拦截器，更新<code>authState</code>信息</li>
</ul>
<h4> d. SolrRequest</h4>
<p>上面的三种方式，适用于利用<code>SolrClient</code>或者<code>SolrTemplate</code>来操作的solr；当然我可以完全抛弃掉它们，直接使用<code>SolrRequest</code>来操作，如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4. 小结</h3>
<p>本篇博文主要是针对需要登录验证的solr更新操作异常时，给出了四种解决方案</p>
<ul>
<li>降<code>solr-solrj</code>版本到<code>6.6.0</code></li>
<li>指定<code>SolrClient</code>的<code>HttpClient</code>为<code>SystemDefaultHttpClient</code></li>
<li>HttpClient拦截器</li>
<li>SolrRequest指定用户名密码</li>
</ul>
<p>上面虽然给出了解决方法，但是为啥有这个问题呢？</p>
<p>直接通过curl来测试一下更新solr操作，正常返回，并没有问题，那么这个问题到底啥原因，究竟是谁的锅，请敬请期待后续问题定位盖锅定论</p>
<figure><img src="/imgs/200330/02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> II. 其他</h2>
<h3> 0. 系列博文&amp;工程源码</h3>
<p><strong>参考博文</strong></p>
<ul>
<li><a href="https://blog.csdn.net/u011561335/article/details/90695860" target="_blank" rel="noopener noreferrer">手把手教你 对 solr8 配置用户登录验证</a></li>
<li><a href="https://stackoverflow.com/questions/2014700/preemptive-basic-authentication-with-apache-httpclient-4/11868040#11868040" target="_blank" rel="noopener noreferrer">Preemptive Basic authentication with Apache HttpClient 4</a></li>
</ul>
<p><strong>系列博文</strong></p>
<ul>
<li><a href="http://spring.hhui.top/spring-blog/2020/01/15/200115-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8BSolr%E4%B9%8B%E6%9F%A5%E8%AF%A2%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF%E5%B0%8F%E7%BB%93/" target="_blank" rel="noopener noreferrer">200115-SpringBoot系列教程Solr之查询使用姿势小结</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2020/01/14/200114-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8BSolr%E4%B9%8B%E6%96%87%E6%A1%A3%E5%88%A0%E9%99%A4/" target="_blank" rel="noopener noreferrer">200114-SpringBoot系列教程Solr之文档删除</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2019/05/26/190526-SpringBoot%E9%AB%98%E7%BA%A7%E7%AF%87%E6%90%9C%E7%B4%A2Solr%E4%B9%8B%E6%96%87%E6%A1%A3%E6%96%B0%E5%A2%9E%E4%B8%8E%E4%BF%AE%E6%94%B9%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF/" target="_blank" rel="noopener noreferrer">190526-SpringBoot高级篇搜索Solr之文档新增与修改使用姿势</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2019/05/10/190510-SpringBoot%E9%AB%98%E7%BA%A7%E7%AF%87%E6%90%9C%E7%B4%A2%E4%B9%8BSolr%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E7%AE%80%E5%8D%95%E6%B5%8B%E8%AF%95/" target="_blank" rel="noopener noreferrer">190510-SpringBoot高级篇搜索之Solr环境搭建与简单测试</a></li>
</ul>
<p><strong>工程源码</strong></p>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/141-search-solr-auth" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/141-search-solr-auth</a></li>
</ul>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="SpringBoot"/>
    <category term="搜索系列"/>
    <category term="Solr"/>
    <category term="采坑记录"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2020-03-30T19:13:16.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">Solr</title>
    <id>https://liuyueyi.github.io/tutorial/spring/search/Solr/</id>
    <link href="https://liuyueyi.github.io/tutorial/spring/search/Solr/"/>
    <updated>2023-02-10T04:50:05.000Z</updated>
    <summary type="html"><![CDATA[<p>SpringBoot整合Solr，支撑搜索业务场景</p>
]]></summary>
    <content type="html"><![CDATA[<p>SpringBoot整合Solr，支撑搜索业务场景</p>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2023-02-10T04:50:05.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">0.起源篇（零）</title>
    <id>https://liuyueyi.github.io/tutorial/spring/security/basic/191223-SpringBoot-%E6%95%B4%E5%90%88-SpringSecurity-%E4%B9%8B%E8%B5%B7%E6%BA%90%E7%AF%87%EF%BC%88%E9%9B%B6%EF%BC%89.html</id>
    <link href="https://liuyueyi.github.io/tutorial/spring/security/basic/191223-SpringBoot-%E6%95%B4%E5%90%88-SpringSecurity-%E4%B9%8B%E8%B5%B7%E6%BA%90%E7%AF%87%EF%BC%88%E9%9B%B6%EF%BC%89.html"/>
    <updated>2023-02-10T04:50:05.000Z</updated>
    <summary type="html"><![CDATA[<p>本篇为SpringSecurity的第一篇，主要来介绍下什么是SpringSecurity，以及在springboot中如何使用它</p>
]]></summary>
    <content type="html"><![CDATA[<p>本篇为SpringSecurity的第一篇，主要来介绍下什么是SpringSecurity，以及在springboot中如何使用它</p>
<!-- more -->
<h2> I. 基本知识点</h2>
<blockquote>
<p>官方文档: <a href="https://docs.spring.io/spring-security/site/docs/5.2.2.BUILD-SNAPSHOT/reference/htmlsingle/#community-help" target="_blank" rel="noopener noreferrer">https://docs.spring.io/spring-security/site/docs/5.2.2.BUILD-SNAPSHOT/reference/htmlsingle/#community-help</a></p>
</blockquote>
<p>下面是官方介绍</p>
<blockquote>
<p>Spring Security is a powerful and highly customizable authentication and access-control framework. It is the de-facto standard for securing Spring-based applications.</p>
</blockquote>
<blockquote>
<p>Spring Security is a framework that focuses on providing both authentication and authorization to Java applications. Like all Spring projects, the real power of Spring Security is found in how easily it can be extended to meet custom requirements</p>
</blockquote>
<p>用国语，简单抽象的说一下它的定义</p>
<ul>
<li>很🐂的认证和访问权限校验框架</li>
</ul>
<p>那么具体能干嘛？</p>
<ul>
<li>用户登录认证：用户名+密码登录，确定用户身份</li>
<li>用户访问鉴权（常见的ACL访问控制列表，RBAC角色访问控制）：判定是否有权限访问某个资源</li>
<li>安全保护（CSRF跨站点攻击,Session Fixation会话固定攻击...）</li>
</ul>
<h2> II. 初体验</h2>
<p>接下来我们看一下再springboot中如何使用springsecurity</p>
<h3> 1. 配置</h3>
<p>首先得是spring boot项目，然后添加上security的依赖即可，相对完整的pom配置如下（注意我们使用的springboot版本为2.2.1.RELEASE）</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 实例demo</h3>
<p>上面配置完之后，啥都不需要干，项目已经接入了spring security；项目中的服务都需要登录之后才能访问</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当我们需要访问首页时，会发现直接302重定向到登录页面了，如下图</p>
<figure><img src="/imgs/191223/00.gif" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>spring security默认给我们生成了一个用户名为user，密码为控制台中输出的一行日志如<code>Using generated security password: aa410186-5c04-4282-b217-507ffb1f61eb</code></p>
<p>登录之后会重定向回我们之前访问的url，通过抓包可以看到，登录成功之后，会设置请求方的cookie，后续的请求携带cookie来表明用户身份</p>
<figure><img src="/imgs/191223/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 3. 基本配置</h3>
<p>上面虽然演示了一个hello world的初体验项目，但是这个默认的用户名/密码有点鬼畜，默认的配置主要来自于<code>org.springframework.boot.autoconfigure.security.SecurityProperties.User</code>，下面是截图（所以前面的用户名为user）</p>
<figure><img src="/imgs/191223/02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>接下来我们需要配置为对人类友好的方式，在项目的配置文件<code>application.yml</code>中，指定登录的用户名/密码</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>重启测试项目，使用新的用户名/密码（yihuihui/123456)就可以登录成功了;</p>
<h3> 4. 用户身份获取</h3>
<p>上面虽然是一个简单的case，但还有一点不得不提一下，在我的接口中，虽然知道你登录了，但怎么知道你是谁呢？</p>
<p>我们可以直接通过<code>HttpServletRequest#getRemoteUser()</code>的方法来获取登录用户； 或者通过<code>SecurityContextHolder.getContext().getAuthentication().getPrincipal()</code>来获取授权信息</p>
<p>我们来写一个通用方法</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后稍微改一下我们的服务接口</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>再次访问之后，结果如下</p>
<figure><img src="/imgs/191223/03.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 5. 小结</h3>
<p>本文主要是spring security系列的起源篇，第一节介绍了下什么是SpringSecurity，有什么特点</p>
<ul>
<li>spring security是一个很🐂🍺的认证（可以简单理解为登录验证）和鉴权（可简单理解为访问控制）框架</li>
<li>三大特点：登录 + 鉴权 + 安全防护</li>
</ul>
<p>第二节介绍了一个简单入门的HelloWorld实例</p>
<ul>
<li>springboot项目，添加依赖 <code>spring-boot-starter-security</code>； 所有的http接口访问都需要登录，默认提供一个用户名为user，密码为控制台输出的UUID字符串</li>
<li>通过<code>spring.security.user.name</code>和<code>spring.security.user.password</code>来指定用户名密码</li>
<li>通过<code>HttpServletRequest#getRemoteUser()</code>获取登录用户</li>
</ul>
<p>那么问题来了，什么系统可能只有一个用户呢？要多用户怎么办？不同的用户不同的权限怎么办？某些接口所有人都可以访问又怎么办？</p>
<h2> II. 其他</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>代码: <a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-security/000-basic-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-security/000-basic-demo</a></li>
</ul>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="SpringSecurity"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2019-12-23T18:55:02.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">1.基于内存认证（一）</title>
    <id>https://liuyueyi.github.io/tutorial/spring/security/basic/200111-SpringBoot-%E6%95%B4%E5%90%88-SpringSecurity-%E4%B9%8B%E5%9F%BA%E4%BA%8E%E5%86%85%E5%AD%98%E8%AE%A4%E8%AF%81%EF%BC%88%E4%B8%80%EF%BC%89.html</id>
    <link href="https://liuyueyi.github.io/tutorial/spring/security/basic/200111-SpringBoot-%E6%95%B4%E5%90%88-SpringSecurity-%E4%B9%8B%E5%9F%BA%E4%BA%8E%E5%86%85%E5%AD%98%E8%AE%A4%E8%AF%81%EF%BC%88%E4%B8%80%EF%BC%89.html"/>
    <updated>2023-02-10T04:50:05.000Z</updated>
    <summary type="html"><![CDATA[<p>在第一篇的教程中，我们简单的了解了一下SpringSecurity的使用姿势，添加依赖，在<code>application.yml</code>文件中加几行配置，就可以实现一个基本的登录认证；</p>
<p>默认的配置只能设置一个账号，那么如果需要多个账号可以怎么支持呢？</p>
<p>本文将介绍一下基于内存的认证方式</p>
]]></summary>
    <content type="html"><![CDATA[<p>在第一篇的教程中，我们简单的了解了一下SpringSecurity的使用姿势，添加依赖，在<code>application.yml</code>文件中加几行配置，就可以实现一个基本的登录认证；</p>
<p>默认的配置只能设置一个账号，那么如果需要多个账号可以怎么支持呢？</p>
<p>本文将介绍一下基于内存的认证方式</p>
<!-- more -->
<h2> I. 内存认证</h2>
<p>基于内存保存认证信息的方式，本篇博文中，会介绍两种常见的使用姿势</p>
<h3> 0. 项目配置</h3>
<p>环境配置和前面一致，相关内容可以参考博文: <a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484424&amp;idx=1&amp;sn=614b861a69c5c04b193b5192d2c8b0e6" target="_blank" rel="noopener noreferrer">191223-SpringBoot 整合 SpringSecurity 之起源篇（零）</a></p>
<h3> 1. WebSecurityConfigurerAdapter</h3>
<p>这里主要是借助<code>SpringSecurity</code>的配置适配器来处理，下面是一个简单的case</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>主要逻辑在 <code>configure</code>这个方法中，但是需要注意，我们额外的设置了密码的加密方式, 当我们不设置这个的时候，实际登录的时候会发现，即便你输入了正确的用户名密码，也会提示失败(欢迎各位大佬实测一下)</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其次，在创建用户的时候，需要注意的是，除了设置了用户名和密码之外，还给用户加上了一个角色，这个会在后续文章的RBAC（基于角色的授权）中介绍它的作用</p>
<h3> 2. UserDetailsService</h3>
<p>这里介绍另外一种方式，在后面的db中保存认证信息时，也会用到；在SpringSecurity的实现中，通过 UserDetailService 这个bean来根据用户名查询对应的用户信息；所以我们只需要实现一个我们自定义的Bean来替换默认的，就可以来实现我们的目标</p>
<p>我们的配置类如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. 测试</h3>
<p>上面两种方式，都可以实现在内存中保存认证信息，接下来我们进入实测环节，首先写一个http接口</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在实际测试时，上面两种case都是ok的，下面的演示过程主要是基于第二种方式给出的示例</p>
<figure><img src="/imgs/200111/00.gif" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> II. 其他</h2>
<h3> 0. 系列博文&amp;项目源码</h3>
<p><strong>博文</strong></p>
<ul>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484424&amp;idx=1&amp;sn=614b861a69c5c04b193b5192d2c8b0e6" target="_blank" rel="noopener noreferrer">191223-SpringBoot 整合 SpringSecurity 之起源篇（零）</a></li>
</ul>
<p><strong>源码</strong></p>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：
<ul>
<li><a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-security/001-authentication-mem-config" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-security/001-authentication-mem-config</a></li>
<li><a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-security/001-authentication-mem-userdetail" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-security/001-authentication-mem-userdetail</a></li>
</ul>
</li>
</ul>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="SpringSecurity"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2020-01-11T11:53:44.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">SpringSecurity</title>
    <id>https://liuyueyi.github.io/tutorial/spring/security/basic/</id>
    <link href="https://liuyueyi.github.io/tutorial/spring/security/basic/"/>
    <updated>2023-02-10T04:50:05.000Z</updated>
    <summary type="html"><![CDATA[<p>SpringBoot Security基础系列教程，目标是实现权限管理的无障碍接入使用</p>
]]></summary>
    <content type="html"><![CDATA[<p>SpringBoot Security基础系列教程，目标是实现权限管理的无障碍接入使用</p>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2023-02-10T04:50:05.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">1.Get请求参数解析姿势汇总</title>
    <id>https://liuyueyi.github.io/tutorial/spring/web/Request/190824-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8Bweb%E7%AF%87%E4%B9%8BGet%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%E5%A7%BF%E5%8A%BF%E6%B1%87%E6%80%BB.html</id>
    <link href="https://liuyueyi.github.io/tutorial/spring/web/Request/190824-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8Bweb%E7%AF%87%E4%B9%8BGet%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%E5%A7%BF%E5%8A%BF%E6%B1%87%E6%80%BB.html"/>
    <updated>2023-02-10T04:50:05.000Z</updated>
    <summary type="html"><![CDATA[<p>一般在开发web应用的时候，如果提供http接口，最常见的http请求方式为GET/POST，我们知道这两种请求方式的一个显著区别是GET请求的参数在url中，而post请求可以不在url中；那么一个SpringBoot搭建的web应用可以如何解析发起的http请求参数呢？</p>
<p>下面我们将结合实例汇总一下GET请求参数的几种常见的解析姿势</p>
]]></summary>
    <content type="html"><![CDATA[<p>一般在开发web应用的时候，如果提供http接口，最常见的http请求方式为GET/POST，我们知道这两种请求方式的一个显著区别是GET请求的参数在url中，而post请求可以不在url中；那么一个SpringBoot搭建的web应用可以如何解析发起的http请求参数呢？</p>
<p>下面我们将结合实例汇总一下GET请求参数的几种常见的解析姿势</p>
<!-- more -->
<h2> I. 环境搭建</h2>
<p>首先得搭建一个web应用才有可能继续后续的测试，借助SpringBoot搭建一个web应用属于比较简单的活;</p>
<p>创建一个maven项目，pom文件如下</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>添加项目启动类<code>Application.cass</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在演示请求参数的解析实例中，我们使用终端的curl命令来发起http请求（主要原因是截图上传太麻烦，还是终端的文本输出比较方便；缺点是不太直观）</p>
<h2> II. GET请求参数解析</h2>
<p>接下来我们正式进入参数解析的妖娆姿势篇，会介绍一下常见的一些case（并不能说包含了所有的使用case）</p>
<p>下面所有的方法都放在 <code>ParamGetRest</code> 这个Controller中</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1. HttpServletRequest</h3>
<p>直接使用<code>HttpServletRequest</code>来获取请求参数，属于比较原始，但是灵活性最高的使用方法了。</p>
<p>常规使用姿势是方法的请求参数中有一个<code>HttpServletRequest</code>，我们通过<code>ServletRequest#getParameter(参数名)</code>来获取具体的请求参数，下面演示返回所有请求参数的case</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>测试case，注意下使用curl请求参数中有中文时，进行了url编码（后续会针对这个问题进行说明）</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用HttpServletRequest获取请求参数，还有另外一种使用case，不通过参数传递的方式获取Request实例，而是借助<code>RequestContextHolder</code>；这样的一个好处就是，假设我们想写一个AOP，拦截GET请求并输出请求参数时，可以通过下面这种方式来处理</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>测试case</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h3> 2. 方法参数</h3>
<p>这种解析方式比较厉害了，将GET参数与方法的参数根据参数名进行映射，从感官上来看，就像是直接调用这个一样</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>针对上面提供的方式，我们的测试自然会区分为下面几种，看下会怎样</p>
<ul>
<li>正好两个参数，与定义一直</li>
<li>缺少一个请求参数</li>
<li>多一个请求参数</li>
<li>参数类型不一致</li>
</ul>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从上面实际的case可以看出，利用方法参数解析GET传参时，实际效果是：</p>
<ul>
<li>方法参数与GET传参，通过参数签名进行绑定</li>
<li>方法参数类型，需要与接收的GET传参类型一致</li>
<li>方法参数非基本类型时，若传参没有，则为null；（也就是说如果为基本类型，无法转null，抛异常）</li>
<li>实际的GET传参可以多于方法定义的参数</li>
</ul>
<p>接下来给一个数组传参解析的实例</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>测试case如下，传数组时参数值用逗号分隔；基本类型，必须传参，否则解析异常</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h3> 3. RequestParam 注解</h3>
<p>这种方式看起来和前面有些相似，但更加灵活，我们先看一下注解</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>有两个参数需要注意，一个是name表示这个参数与GET传参的哪个关联；required表示这个参数是否可选</p>
<p>下面是一个简单的使用方式</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>测试如下:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用<code>RequestParam</code>注解时，如果指定了<code>name/value</code>，这个参数就与指定的GETGET传参关联；如果不指定时，则根据参数签名来关联</p>
<p>下面给出两个更有意思的使用方式，一个是枚举参数解析，一个是Map容纳参数，一个是数组参数解析</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>测试case如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从测试结果可以知道：</p>
<ul>
<li>GET传参映射到枚举时，根据<code>enum.valueOf()</code>来实例的</li>
<li>如果希望使用Map来容纳所有的传参，需要加上注解<code>@RequestParam</code></li>
<li>如果参数为List类型，必须添加注解<code>@RequestParam</code>；否则用数组来接收</li>
</ul>
<hr>
<h3> 4. PathVariable</h3>
<p>从请求的url路径中解析参数，使用方法和前面的差别不大</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面是一个常见的使用方式，对此我们带着几个疑问设计case</p>
<ul>
<li>只有name没有index，会怎样？</li>
<li>有name，有index，后面还有路径，会怎样？</li>
</ul>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从path中获取参数时，对url有相对严格的要求，注意使用</p>
<hr>
<h3> 5. POJO</h3>
<p>这种case，我个人用得比较多，特别是基于SpringCloud的生态下，借助Feign来调用第三方微服务，可以说是很舒爽了；下面看一下这种方式的使用姿势</p>
<p>首先定义一个POJO</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>提供一个服务</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>POJO中定义了三个参数，我们再测试的时候，看一下这些参数是否必选</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> II. 其他</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>项目: <a href="https://github.com/liuyueyi/spring-boot-demo/blob/master/spring-boot/202-web-params" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/blob/master/spring-boot/202-web-params</a></li>
</ul>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="SpringBoot"/>
    <category term="WEB系列"/>
    <category term="Request"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2019-08-24T22:07:56.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">2.Post请求参数解析姿势汇总</title>
    <id>https://liuyueyi.github.io/tutorial/spring/web/Request/190828-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8Bweb%E7%AF%87%E4%B9%8BPost%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%E5%A7%BF%E5%8A%BF%E6%B1%87%E6%80%BB.html</id>
    <link href="https://liuyueyi.github.io/tutorial/spring/web/Request/190828-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8Bweb%E7%AF%87%E4%B9%8BPost%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%E5%A7%BF%E5%8A%BF%E6%B1%87%E6%80%BB.html"/>
    <updated>2023-02-10T04:50:05.000Z</updated>
    <summary type="html"><![CDATA[<p>作为一个常年提供各种Http接口的后端而言，如何获取请求参数可以说是一项基本技能了，本篇为《<a href="http://spring.hhui.top/spring-blog/2019/08/24/190824-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8Bweb%E7%AF%87%E4%B9%8BGet%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%E5%A7%BF%E5%8A%BF%E6%B1%87%E6%80%BB/" target="_blank" rel="noopener noreferrer">190824-SpringBoot系列教程web篇之Get请求参数解析姿势汇总</a>》之后的第二篇，对于POST请求方式下，又可以怎样获取请求参数呢</p>
<p>本篇主要内容包括以下几种姿势</p>
<ul>
<li>@RequestBody  json格式</li>
<li>RequestEntity</li>
<li>MultipartFile 文件上传</li>
</ul>
]]></summary>
    <content type="html"><![CDATA[<p>作为一个常年提供各种Http接口的后端而言，如何获取请求参数可以说是一项基本技能了，本篇为《<a href="http://spring.hhui.top/spring-blog/2019/08/24/190824-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8Bweb%E7%AF%87%E4%B9%8BGet%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%E5%A7%BF%E5%8A%BF%E6%B1%87%E6%80%BB/" target="_blank" rel="noopener noreferrer">190824-SpringBoot系列教程web篇之Get请求参数解析姿势汇总</a>》之后的第二篇，对于POST请求方式下，又可以怎样获取请求参数呢</p>
<p>本篇主要内容包括以下几种姿势</p>
<ul>
<li>@RequestBody  json格式</li>
<li>RequestEntity</li>
<li>MultipartFile 文件上传</li>
</ul>
<!-- more -->
<h2> I. 环境搭建</h2>
<p>首先得搭建一个web应用才有可能继续后续的测试，借助SpringBoot搭建一个web应用属于比较简单的活;</p>
<p>创建一个maven项目，pom文件如下</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>添加项目启动类<code>Application.cass</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在演示请求参数的解析实例中，我们使用终端的curl命令来发起http请求（主要原因是截图上传太麻烦，还是终端的文本输出比较方便；缺点是不太直观）</p>
<h2> II. POST请求参数解析</h2>
<p>接下来我们正式进入参数解析的妖娆姿势篇，会介绍一下常见的一些case（并不能说包含了所有的使用case）</p>
<p>下面所有的方法都放在 <code>ParamPostRest</code> 这个Controller中</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在正式介绍之前，强烈推荐看一下《<a href="http://spring.hhui.top/spring-blog/2019/08/24/190824-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8Bweb%E7%AF%87%E4%B9%8BGet%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%E5%A7%BF%E5%8A%BF%E6%B1%87%E6%80%BB/" target="_blank" rel="noopener noreferrer">190824-SpringBoot系列教程web篇之Get请求参数解析姿势汇总</a>》, 因为get传参的姿势，在post参数解析中同样适用，下面的内容并不会再次详细介绍</p>
<h3> 1. HttpServletRequest</h3>
<p>首先看一下最基本的使用case，和get请求里的case一样，我们先开一个接口</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们测试下两种post请求下，会出现怎样的结果</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从上面的case中可以知道，通过传统的表达方式提交的数据时，获取参数和get获取参数使用姿势一样；然而当然传入的是json串格式的数据时，直接通过<code>javax.servlet.ServletRequest#getParameter</code>获取不到对应的参数</p>
<p>我们通过debug，来看一下在传json串数据的时候，如果我们要获取数据，可以怎么做</p>
<figure><img src="/imgs/190828/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>上面截图演示了我们从请求的InputStream中获取post参数；所以再实际使用的时候需要注意，流中的数据只能读一次，读完了就没了; 这个和我们使用GET传参是有很大的差别的</p>
<p><strong>注意：如果您有一个打印请求参数日志的切面，在获取post传的参数时需要注意，是不是把流的数据读了，导致业务中无法获取到正确的数据！！！</strong></p>
<h3> 2. RequestBody</h3>
<p>上面说到传json串数据时，后端直接通过<code>HttpServletRequest</code>获取数据不太方便，那么有更优雅的使用姿势么？下面我们看一下<code>@RequestBody</code>注解的使用</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>只需要在参数中添加<code>@RequestBody</code>注解即可，然后这个接口就支持json串的POST提交了</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>说明：使用<code>@RequestBody</code>注解之后，可解析提交的json串；但不再支持表单提交参数方式(<code>application/x-www-form-urlencoded</code>)</strong></p>
<h3> 3. RequestEntity</h3>
<p>使用RequestEntity来解析参数，可能并不太常见，它用来解析json串提交的参数也比较合适，使用姿势也比较简单</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用case如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4. MultipartFile 文件上传</h3>
<p>文件上传也是一个比较常见的，支持起来也比较简单，有两种方式，一个是使用MultipartHttpServletRequest参数来获取上传的文件；一个是借助 <code>@RequestParam</code>注解</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>测试case如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 5. 其他</h3>
<p>上面介绍的几种有别于GET篇中的请求姿势，请注意GET请求参数的解析方式，在POST请求中，可能也是适用的，为什么说可能？因为在post请求中，不同的<code>content-type</code>，对参数的解析影响还是有的；</p>
<p>需要注意的是，对于传统的表单提交(application/x-www-form-urlencoded)方式，post的参数解析依然可以使用</p>
<ul>
<li>@RequsetParam</li>
<li>POJO（BEAN的解析方式）</li>
<li>@PathVariable参数解析</li>
<li>方法参数解析</li>
</ul>
<h2> II. 其他</h2>
<h3> 0. 项目&amp;相关博文</h3>
<ul>
<li><a href="http://spring.hhui.top/spring-blog/2019/08/24/190824-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8Bweb%E7%AF%87%E4%B9%8BGet%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%E5%A7%BF%E5%8A%BF%E6%B1%87%E6%80%BB/" target="_blank" rel="noopener noreferrer">190824-SpringBoot系列教程web篇之Get请求参数解析姿势汇总</a></li>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>项目: <a href="https://github.com/liuyueyi/spring-boot-demo/blob/master/spring-boot/202-web-params" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/blob/master/spring-boot/202-web-params</a></li>
</ul>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="SpringBoot"/>
    <category term="WEB系列"/>
    <category term="Request"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2019-08-28T18:41:16.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">3.如何自定义参数解析器</title>
    <id>https://liuyueyi.github.io/tutorial/spring/web/Request/190831-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8Bweb%E7%AF%87%E4%B9%8B%E5%A6%82%E4%BD%95%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%E5%99%A8.html</id>
    <link href="https://liuyueyi.github.io/tutorial/spring/web/Request/190831-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8Bweb%E7%AF%87%E4%B9%8B%E5%A6%82%E4%BD%95%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%E5%99%A8.html"/>
    <updated>2023-02-10T04:50:05.000Z</updated>
    <summary type="html"><![CDATA[<p>SpringMVC提供了各种姿势的http参数解析支持，从前面的GET/POST参数解析篇也可以看到，加一个<code>@RequsetParam</code>注解就可以将方法参数与http参数绑定，看到这时自然就会好奇这是怎么做到的,我们能不能自己定义一种参数解析规则呢？</p>
<p>本文将介绍如何实现自定义的参数解析，并让其生效</p>
]]></summary>
    <content type="html"><![CDATA[<p>SpringMVC提供了各种姿势的http参数解析支持，从前面的GET/POST参数解析篇也可以看到，加一个<code>@RequsetParam</code>注解就可以将方法参数与http参数绑定，看到这时自然就会好奇这是怎么做到的,我们能不能自己定义一种参数解析规则呢？</p>
<p>本文将介绍如何实现自定义的参数解析，并让其生效</p>
<!-- more -->
<h2> I. 环境搭建</h2>
<p>首先得搭建一个web应用才有可能继续后续的测试，借助SpringBoot搭建一个web应用属于比较简单的活;</p>
<p>创建一个maven项目，pom文件如下</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> II. 自定义参数解析器</h2>
<p>对于如何自定义参数解析器，一个较推荐的方法是，先搞清楚springmvc接收到一个请求之后完整的处理链路，然后再来看在什么地方，什么时机，来插入自定义参数解析器，无论是从理解还是实现都会简单很多。遗憾的是，本篇主要目标放在的是使用角度，所以这里只会简单的提一下参数解析的链路，具体的深入留待后续的源码解析</p>
<h3> 1. 参数解析链路</h3>
<p>http请求流程图，来自 <a href="https://www.jianshu.com/p/bf3537334e76" target="_blank" rel="noopener noreferrer">SpringBoot是如何解析HTTP参数的</a></p>
<figure><img src="/imgs/190831/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>既然是参数解析，所以肯定是在方法调用之前就会被触发，在Spring中，负责将http参数与目标方法参数进行关联的，主要是借助<code>org.springframework.web.method.support.HandlerMethodArgumentResolver</code>类来实现</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这段核心代码来自<code>org.springframework.web.method.support.HandlerMethodArgumentResolverComposite#resolveArgument</code>，主要作用就是获取一个合适的<code>HandlerMethodArgumentResolver</code>，实现将http参数(<code>webRequest</code>)映射到目标方法的参数上(<code>parameter</code>)</p>
<p>所以说，实现自定义参数解析器的核心就是实现一个自己的<code>HandlerMethodArgumentResolver</code></p>
<h3> 2. HandlerMethodArgumentResolver</h3>
<p>实现一个自定义的参数解析器，首先得有个目标，我们在get参数解析篇里面，当时遇到了一个问题，当传参为数组时，定义的方法参数需要为数组，而不能是List，否则无法正常解析；现在我们则希望能实现这样一个参数解析，以支持上面的场景</p>
<p>为了实现上面这个小目标，我们可以如下操作</p>
<h4> a. 自定义注解ListParam</h4>
<p>定义这个注解，主要就是用于表明，带有这个注解的参数，希望可以使用我们自定义的参数解析器来解析；</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> b. 参数解析器ListHandlerMethodArgumentResolver</h4>
<p>接下来就是自定义的参数解析器了，需要实现接口<code>HandlerMethodArgumentResolver</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面有两个方法：</p>
<ul>
<li><code>supportsParameter</code>就是用来表明这个参数解析器适不适用
<ul>
<li>实现也比较简单，就是看参数上有没有前面定义的<code>ListParam</code>注解</li>
</ul>
</li>
<li><code>resolveArgument</code> 这个方法就是实现将http参数粗转换为目标方法参数的具体逻辑
<ul>
<li>上面主要是为了演示自定义参数解析器的过程，实现比较简单，默认只支持<code>List&lt;String&gt;</code></li>
</ul>
</li>
</ul>
<h3> 3. 注册</h3>
<p>上面虽然实现了自定义的参数解析器，但是我们需要把它注册到<code>HandlerMethodArgumentResolver</code>才能生效，一个简单的方法如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4. 测试</h3>
<p>为了验证我们的自定义参数解析器ok，我们开两个对比的rest服务</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>演示demo如下，添加了<code>ListParam</code>注解的可以正常解析，没有添加注解的会抛异常</p>
<figure><img src="/imgs/190831/01.gif" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> II. 其他</h2>
<h3> 0. 项目&amp;相关博文</h3>
<ul>
<li><a href="http://spring.hhui.top/spring-blog/2019/08/24/190824-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8Bweb%E7%AF%87%E4%B9%8BGet%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%E5%A7%BF%E5%8A%BF%E6%B1%87%E6%80%BB/" target="_blank" rel="noopener noreferrer">190824-SpringBoot系列教程web篇之Get请求参数解析姿势汇总</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2019/08/28/190828-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8Bweb%E7%AF%87%E4%B9%8BPost%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%E5%A7%BF%E5%8A%BF%E6%B1%87%E6%80%BB/" target="_blank" rel="noopener noreferrer">190828-SpringBoot系列教程web篇之Post请求参数解析姿势汇总</a></li>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>项目: <a href="https://github.com/liuyueyi/spring-boot-demo/blob/master/spring-boot/202-web-params" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/blob/master/spring-boot/202-web-params</a></li>
</ul>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="SpringBoot"/>
    <category term="WEB系列"/>
    <category term="Request"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2019-08-31T16:45:48.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">4.自定义请求匹配条件RequestCondition</title>
    <id>https://liuyueyi.github.io/tutorial/spring/web/Request/191222-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8Bweb%E7%AF%87%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E8%AF%B7%E6%B1%82%E5%8C%B9%E9%85%8D%E6%9D%A1%E4%BB%B6RequestCondition.html</id>
    <link href="https://liuyueyi.github.io/tutorial/spring/web/Request/191222-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8Bweb%E7%AF%87%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E8%AF%B7%E6%B1%82%E5%8C%B9%E9%85%8D%E6%9D%A1%E4%BB%B6RequestCondition.html"/>
    <updated>2023-02-10T04:50:05.000Z</updated>
    <summary type="html"><![CDATA[<p>在spring mvc中，我们知道用户发起的请求可以通过url匹配到我们通过<code>@RequestMapping</code>定义的服务端点上；不知道有几个问题大家是否有过思考</p>
<p>一个项目中，能否存在完全相同的url？</p>
<p>有了解http协议的同学可能很快就能给出答案，当然可以，url相同，请求方法不同即可；那么能否出现url相同且请求方法l也相同的呢？</p>
<p>本文将介绍一下如何使用<code>RequestCondition</code>结合<code>RequestMappingHandlerMapping</code>，来实现url匹配规则的扩展，从而支持上面提出的case</p>
]]></summary>
    <content type="html"><![CDATA[<p>在spring mvc中，我们知道用户发起的请求可以通过url匹配到我们通过<code>@RequestMapping</code>定义的服务端点上；不知道有几个问题大家是否有过思考</p>
<p>一个项目中，能否存在完全相同的url？</p>
<p>有了解http协议的同学可能很快就能给出答案，当然可以，url相同，请求方法不同即可；那么能否出现url相同且请求方法l也相同的呢？</p>
<p>本文将介绍一下如何使用<code>RequestCondition</code>结合<code>RequestMappingHandlerMapping</code>，来实现url匹配规则的扩展，从而支持上面提出的case</p>
<!-- more -->
<h2> I. 环境相关</h2>
<p>本文介绍的内容和实际case将基于<code>spring-boot-2.2.1.RELEASE</code>版本，如果在测试时，发现某些地方没法兼容时，请确定一下版本</p>
<h3> 1. 项目搭建</h3>
<p>首先我们需要搭建一个web工程，以方便后续的servelt注册的实例演示，可以通过spring boot官网创建工程，也可以建立一个maven工程，在pom.xml中如下配置</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. RequestCondition介绍</h3>
<p>在spring mvc中，通过<code>DispatchServlet</code>接收客户端发起的一个请求之后，会通过HanderMapping来获取对应的请求处理器；而HanderMapping如何找到可以处理这个请求的处理器呢，这就需要RequestCondition来决定了</p>
<p>接口定义如下，主要有三个方法，</p>
<div class="language-ja line-numbers-mode" data-ext="ja"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>简单说下三个接口的作用</p>
<ul>
<li>
<p><code>combine</code>: 某个接口有多个规则时，进行合并</p>
<ul>
<li>比如类上指定了<code>@RequestMapping</code>的url为 <code>root</code></li>
<li>而方法上指定的<code>@RequestMapping</code>的url为 <code>method</code></li>
<li>那么在获取这个接口的url匹配规则时，类上扫描一次，方法上扫描一次，这个时候就需要把这两个合并成一个，表示这个接口匹配<code>root/method</code></li>
</ul>
</li>
<li>
<p><code>getMatchingCondition</code>:</p>
<ul>
<li>判断是否成功，失败返回null；否则，则返回匹配成功的条件</li>
</ul>
</li>
<li>
<p><code>compareTo</code>:</p>
<ul>
<li>多个都满足条件时，用来指定具体选择哪一个</li>
</ul>
</li>
</ul>
<p>在Spring MVC中，默认提供了下面几种</p>
<table>
<thead>
<tr>
<th>类</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>PatternsRequestCondition</td>
<td>路径匹配，即url</td>
</tr>
<tr>
<td>RequestMethodsRequestCondition</td>
<td>请求方法，注意是指http请求方法</td>
</tr>
<tr>
<td>ParamsRequestCondition</td>
<td>请求参数条件匹配</td>
</tr>
<tr>
<td>HeadersRequestCondition</td>
<td>请求头匹配</td>
</tr>
<tr>
<td>ConsumesRequestCondition</td>
<td>可消费MIME匹配条件</td>
</tr>
<tr>
<td>ProducesRequestCondition</td>
<td>可生成MIME匹配条件</td>
</tr>
</tbody>
</table>
<h2> II. 实例说明</h2>
<p>单纯的看说明，可能不太好理解它的使用方式，接下来我们通过一个实际的case，来演示使用姿势</p>
<h3> 1. 场景说明</h3>
<p>我们有个服务同时针对app/wap/pc三个平台，我们希望可以指定某些接口只为特定的平台提供服务</p>
<h3> 2. 实现</h3>
<p>首先我们定义通过请求头中的<code>x-platform</code>来区分平台；即用户发起的请求中，需要携带这个请求头</p>
<p>定义平台枚举类</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后定义一个注解<code>@Platform</code>，如果某个接口需要指定平台，则加上这个注解即可</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>定义匹配规则<code>PlatformRequestCondition</code>继承自<code>RequestCondition</code>，实现三个接口，从请求头中获取平台，根据平台是否相同过来判定是否可以支持请求</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>匹配规则指定完毕之后，需要注册到HandlerMapping上才能生效，这里我们自定义一个<code>PlatformHandlerMapping</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>最后则是需要将我们的HandlerMapping注册到Spring MVC容器，在这里我们借助<code>WebMvcConfigurationSupport</code>来手动注册(注意一下，不同的版本，下面的方法可能会不太一样哦)</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. 测试</h3>
<p>接下来进入实测环节，定义几个接口，分别指定不同的平台</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果我们的规则可以正常生效，那么在请求头中设置不同的<code>x-platform</code>，返回的结果应该会不一样，实测结果如下</p>
<figure><img src="/imgs/191222/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>注意最后两个，一个是指定了一个不匹配我们的平台的请求头，一个是没有对应的请求头，都是走了默认的匹配规则；这是因为我们在<code>PlatformRequestCondition</code>中做了兼容，无法匹配平台时，分配到默认的<code>Platform.ALL</code></p>
<p>然后还有一个小疑问，如果有一个服务不区分平台，那么不加上<code>@Platform</code>注解是否可以呢?</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当然是可以的实测结果如下:</p>
<figure><img src="/imgs/191222/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>在不加上<code>@Platform</code>注解时，有一点需要注意，这个时候就不能出现多个url和请求方法相同的，在启动的时候会直接抛出异常哦</p>
<figure><img src="/imgs/191222/02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> III. 其他</h2>
<h4> web系列博文</h4>
<ul>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484393&amp;idx=1&amp;sn=84babe4c83fa49fe54605e156f81a18f&amp;chksm=fce71845cb9091533190e99f2928585aea56562312d087f2b2b0e5ae4f082e3393023349e903&amp;token=713643402&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">191206-SpringBoot系列教程web篇Listener四种注册姿势</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484377&amp;idx=1&amp;sn=a20ce7e5e04ede4dff5fa84a7c5c8448&amp;chksm=fce71875cb9091639124afa69d0ec7bbf8f50438fd7acaf582fb029b7a4adf2f36fa50d4f0fa&amp;token=1748723444&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">191122-SpringBoot系列教程web篇Servlet 注册的四种姿势</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484377&amp;idx=2&amp;sn=b341d12c8179ba803d5c82882d9799ee&amp;chksm=fce71875cb90916376c76a901187b396595082c8ab3bd9df699227132430b9a40d2b07b30638&amp;token=713643402&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">191120-SpringBoot系列教程Web篇之开启GZIP数据压缩</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484356&amp;idx=1&amp;sn=7c80f55f875f8d9ed37ef618cd7852ff&amp;chksm=fce71868cb90917ec76ed23990a287b25dfecd6e60300a215ff9b85d9d9db32b3ba1c7b549c7&amp;token=713643402&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">191018-SpringBoot系列教程web篇之过滤器Filter使用指南扩展篇</a></li>
<li><a href="https://mp.weixin.qq.com/s/f01KWO3d2zhoN0Qa9-Qb6w" target="_blank" rel="noopener noreferrer">191016-SpringBoot系列教程web篇之过滤器Filter使用指南</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484348&amp;idx=1&amp;sn=e9b36572c721418b097396b50319d140&amp;chksm=fce71810cb9091063e810327e44f7ed07256188aecd352fa43f37e63e63dc64292b1a48b00cf&amp;token=823367253&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">191012-SpringBoot系列教程web篇之自定义异常处理HandlerExceptionResolver</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484344&amp;idx=1&amp;sn=d4b1422a709d9540583e33443aab6fff&amp;chksm=fce71814cb9091025a960312c878ff9fc4f44fd0035aa597f55f37c90dcbac25a3e96ee2c528&amp;token=118864495&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">191010-SpringBoot系列教程web篇之全局异常处理</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484336&amp;idx=1&amp;sn=d70f15e77bbd219af8015f9037a167fb&amp;chksm=fce7181ccb90910aee427a3f3ed7660e8303c7460859c82622a651ce1cc3d7a97f62f80ed4e0&amp;token=2447275&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">190930-SpringBoot系列教程web篇之404、500异常页面配置</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484322&amp;idx=1&amp;sn=b18090f35b59097f78858b6609506b74&amp;chksm=fce7180ecb909118d939f3ddf741a11c0977b1213d7afa12c970590590d40441c3a085c43c52&amp;token=2447275&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">190929-SpringBoot系列教程web篇之重定向</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484310&amp;idx=1&amp;sn=f6259cf1b79db095ff2e9534993d27cf&amp;chksm=fce7183acb90912cd150f086e90ecab3eceb3464e9352853e2e722288d412dbb3eb20c6e6ae7&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190913-SpringBoot系列教程web篇之返回文本、网页、图片的操作姿势</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484309&amp;idx=1&amp;sn=33d782f7529268eef6607a1ab8d41018&amp;chksm=fce71839cb90912f6020aa9463bc0136cb57969ebe27eba865d97e212c28211435791aa874ea&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190905-SpringBoot系列教程web篇之中文乱码问题解决</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484291&amp;idx=1&amp;sn=3f7e8c92ca4d7270cc5c40cafea39683&amp;chksm=fce7182fcb90913922654a4f2f04e7029b8944d71c31741334a3235aecbe1e60babcb0c0be74&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190831-SpringBoot系列教程web篇之如何自定义参数解析器</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484287&amp;idx=1&amp;sn=44461f564d6b04cbf1a5902dcb4f23c6&amp;chksm=fce718d3cb9091c5d730e63ae954c0831d53f3dd5af5d19d9c78b6009102838efaf56f7838ff&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190828-SpringBoot系列教程web篇之Post请求参数解析姿势汇总</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484282&amp;idx=1&amp;sn=a8d236d935ae24cfbe6977e24a479caa&amp;chksm=fce718d6cb9091c0dd8a6b113236f9ae9388fb026c9403c97bdf7505f773bd7330a43e3b269c&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190824-SpringBoot系列教程web篇之Get请求参数解析姿势汇总</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484268&amp;idx=3&amp;sn=9e8a6121dce291c65bd2b3d4fab24178&amp;chksm=fce718c0cb9091d6674fb809d68ca3dc3b1695162368481abf8dc094000412116d2f9971c54b&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190822-SpringBoot系列教程web篇之Beetl环境搭建</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484268&amp;idx=2&amp;sn=f800c001061eabe74e2cad915af1921a&amp;chksm=fce718c0cb9091d682b600673a0584955783f0d339248e34323efbea9b698560c432018717ef&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190820-SpringBoot系列教程web篇之Thymeleaf环境搭建</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484268&amp;idx=1&amp;sn=acd691729488d81a94c938151d5737ce&amp;chksm=fce718c0cb9091d63ef5f12893bb835c256a18318e791a0d193d00ef767ecfd019491d02e83d&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190816-SpringBoot系列教程web篇之Freemaker环境搭建</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484217&amp;idx=1&amp;sn=9fdf45d2261cdcf2ccaccaebfb5ef598&amp;chksm=fce71895cb90918361f1afd55a2b5fc9d65508913c1d793710afa79cae38bd9d57e32ad2c187&amp;token=2447275&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">190421-SpringBoot高级篇WEB之websocket的使用说明</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484197&amp;idx=1&amp;sn=0184953527f58058ee8c2bbcfc2689ec&amp;chksm=fce71889cb90919f9be003bf2487343f7952d6b33ab5ee5fb7251ae37a631d4c32e6d8a57528&amp;token=2447275&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">190327-Spring-RestTemplate之urlencode参数解析异常全程分析</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484193&amp;idx=1&amp;sn=d8a284fe0a2b8e1fefe07d892558f563&amp;chksm=fce7188dcb90919b1f8a2408bf955e37e88b043e2dbd59b5290ac1501e3d2d303512bac6af2c&amp;token=2447275&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">190317-Spring MVC之基于java config无xml配置的web应用构建</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484186&amp;idx=1&amp;sn=18db571b670815965ae9185830c4e88f&amp;chksm=fce718b6cb9091a054e0ac4be051341d8ce38ff8e40c5911302e3d6981206c14b80770590044&amp;token=2447275&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">190316-Spring MVC之基于xml配置的web应用构建</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484139&amp;idx=1&amp;sn=b4a5f3ca6215641c6bcf5123f2bfb501&amp;chksm=fce71947cb9090511042ae97a12cc975d2b199521e17980e685cccb5e0be91a8e932cef4eb76&amp;token=2447275&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">190213-SpringBoot文件上传异常之提示The temporary upload location xxx is not valid</a></li>
</ul>
<h4> 项目源码</h4>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>项目: <a href="https://github.com/liuyueyi/spring-boot-demo/blob/master/spring-boot/208-web-mapping" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/blob/master/spring-boot/208-web-mapping</a></li>
</ul>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="SpringBoot"/>
    <category term="WEB系列"/>
    <category term="Request"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2019-12-22T16:49:58.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">5.参数校验Validation</title>
    <id>https://liuyueyi.github.io/tutorial/spring/web/Request/200526-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B9%8B%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C.html</id>
    <link href="https://liuyueyi.github.io/tutorial/spring/web/Request/200526-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B9%8B%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C.html"/>
    <updated>2023-02-10T04:50:05.000Z</updated>
    <summary type="html"><![CDATA[<p>业务开发的小伙伴总有那么几个无法逃避的点，如大段if/else，接口的参数校验等。接下来将介绍几种使用<code>Validation-Api</code>的方式，来实现参数校验，让我们的业务代码更简洁</p>
]]></summary>
    <content type="html"><![CDATA[<p>业务开发的小伙伴总有那么几个无法逃避的点，如大段if/else，接口的参数校验等。接下来将介绍几种使用<code>Validation-Api</code>的方式，来实现参数校验，让我们的业务代码更简洁</p>
<!-- more -->
<h2> I. 基本知识点</h2>
<h3> 1. validation-api</h3>
<p>参数校验有自己的一个规范JSR303, 它是一套 JavaBean 参数校验的标准，它定义了很多常用的校验注解。</p>
<p>java开发环境中，可以通过引入<code>validation-api</code>包的相关注解，来实现参数的条件限定</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>请注意上面这个包只是定义，如果项目中单独的引入上面的这个包，并没有什么效果，我们通常选用<code>hibernate-validator</code>来作为具体的实现</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>下面给出一些常用的参数限定注解</p>
<table>
<thead>
<tr>
<th>注解</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>@AssertFalse</code></td>
<td>被修饰的元素必须为 false</td>
</tr>
<tr>
<td><code>@AssertTrue</code></td>
<td>被修饰的元素必须是true</td>
</tr>
<tr>
<td><code>@DecimalMax</code></td>
<td>被修饰的元素必须是一个数字，其值必须小于等于指定的最大值</td>
</tr>
<tr>
<td><code>@DecimalMin</code></td>
<td>同DecimalMax</td>
</tr>
<tr>
<td><code>@Digits</code></td>
<td>被修饰的元素是数字</td>
</tr>
<tr>
<td><code>@Email</code></td>
<td>被修饰的元素必须是邮箱格式</td>
</tr>
<tr>
<td><code>@Future</code></td>
<td>将来的日期</td>
</tr>
<tr>
<td><code>@Max</code></td>
<td>被修饰的元素必须是一个数字，其值必须小于等于指定的最大值</td>
</tr>
<tr>
<td><code>@Min</code></td>
<td>被修饰的元素必须是一个数字，其值必须大于等于指定的最小值</td>
</tr>
<tr>
<td><code>@NotNull</code></td>
<td>不能是Null</td>
</tr>
<tr>
<td><code>@Null</code></td>
<td>元素是Null</td>
</tr>
<tr>
<td><code>@Past</code></td>
<td>被修饰的元素必须是一个过去的日期</td>
</tr>
<tr>
<td><code>@Pattern</code></td>
<td>被修饰的元素必须符合指定的正则表达式</td>
</tr>
<tr>
<td><code>@Size</code></td>
<td>被修饰的元素长度</td>
</tr>
<tr>
<td><code>@Positive</code></td>
<td>正数</td>
</tr>
<tr>
<td><code>@PositiveOrZero</code></td>
<td>0 or 正数</td>
</tr>
<tr>
<td><code>@Negative</code></td>
<td>负数</td>
</tr>
<tr>
<td><code>@NegativeOrZero</code></td>
<td>0 or 负数</td>
</tr>
</tbody>
</table>
<h3> 2. 项目搭建</h3>
<p>接下来我们创建一个SpringBoot项目，用于后续的实例演示</p>
<p>我们采用IDEA + JDK1.8 进行项目开发</p>
<ul>
<li>SpringBoot: <code>2.2.1.RELEASE</code></li>
</ul>
<p>pom核心依赖如下</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>请注意</strong> 并没有显示的添加上一小节的两个依赖，因为已经集成在start包中了</p>
<h2> II. 实例演示</h2>
<p>接下来我们进入实例演示环节，会给出几种常见的使用case，以及如何扩展参数校验，使其支持自己定制化的参数校验规则</p>
<h3> 1. 校验失败抛异常</h3>
<p>如果我们的参数校验失败，直接抛异常，可以说是最简单的使用方式了；首先我们创建一个简单ReqDo，并对参数进行一些必要的限定</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后提供一个rest接口</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>参数左边有一个<code>@Valid</code>注解，用于表示这个对象需要执行参数校验，如果校验失败，会抛400错误</p>
<p>演示如下</p>
<figure><img src="/imgs/200526/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 2. BindingResult</h3>
<p>将校验失败的结果塞入<code>BindingResult</code>，避免直接返回400，这种方式只需要在方法参数中，加一个对象即可，通过它来获取所有的参数异常错误</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/200526/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 3. 手动校验</h3>
<p>除了上面两个借助 <code>@Valid</code> 注解修饰，自动实现参数校验之外，我们还可以手动校验一个DO是否准确，下面给出一个简单的实例</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/200526/02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 4. 自定义参数校验</h3>
<p>虽然JSR303规范中给出了一些常见的校验限定，但显示的业务场景千千万万，总会有覆盖不到的地方，比如最简单的手机号校验就没有，所以可扩展就很有必要了，接下来我们演示一下，自定义一个身份证校验的注解</p>
<p>首先定义注解 <code>@IdCard</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的实现中，有几个需要注意的点</p>
<ul>
<li><code>@Constraint</code> 注解，指定校验器为 <code>IdCardValidator</code>, 即表示待有<code>@IdCard</code>直接的属性，由<code>IdCardValidator</code>来校验是否合乎规范</li>
<li><code>groups</code>: 分组，主要用于不同场景下，校验方式不一样的case
<ul>
<li>如新增数据时，主键id可以为空；更新数据时，主键id不能为空</li>
</ul>
</li>
<li><code>payload</code>: 知道这个具体干嘛用的老哥请留言指点一下</li>
</ul>
<p>接下来完成身份证号的校验器<code>IdCardValidator</code></p>
<blockquote>
<p>这里直接借助<code>hutool</code>工具集中的<code>cn.hutool.core.util.IdcardUtil#isValidCard</code>来实现身份证有效性判断</p>
</blockquote>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后将我们前面的ReqDo修改一下，新增一个身份证的字段</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>再次访问测试(说明，图1中身份证号是随便填的，图2中的身份证号是<code>http://sfz.uzuzuz.com/</code>这个网站生成的，并不指代真实的某个小伙伴)</p>
<p><img src="/imgs/200526/03.jpg" alt="IdCard校验" loading="lazy">
<img src="/imgs/200526/04.jpg" alt="IdCard校验" loading="lazy"></p>
<h2> II. 其他</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码: <a href="https://github.com/liuyueyi/spring-boot-demo/spring-boot/202-web-params-validate" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/spring-boot/202-web-params-validate</a></li>
</ul>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="SpringBoot"/>
    <category term="WEB系列"/>
    <category term="Request"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2020-05-26T09:14:34.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">6.静态资源配置与读取</title>
    <id>https://liuyueyi.github.io/tutorial/spring/web/Request/200611-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8BWeb%E7%AF%87%E4%B9%8B%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E9%85%8D%E7%BD%AE.html</id>
    <link href="https://liuyueyi.github.io/tutorial/spring/web/Request/200611-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8BWeb%E7%AF%87%E4%B9%8B%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E9%85%8D%E7%BD%AE.html"/>
    <updated>2023-02-10T04:50:05.000Z</updated>
    <summary type="html"><![CDATA[<p>SpringWeb项目除了我们常见的返回json串之外，还可以直接返回静态资源（当然在现如今前后端分离比较普遍的情况下，不太常见了），一些简单的web项目中，前后端可能就一个人包圆了，前端页面，js/css文件也都直接放在Spring项目中，那么你知道这些静态资源文件放哪里么</p>
]]></summary>
    <content type="html"><![CDATA[<p>SpringWeb项目除了我们常见的返回json串之外，还可以直接返回静态资源（当然在现如今前后端分离比较普遍的情况下，不太常见了），一些简单的web项目中，前后端可能就一个人包圆了，前端页面，js/css文件也都直接放在Spring项目中，那么你知道这些静态资源文件放哪里么</p>
<!-- more -->
<h2> I. 默认配置</h2>
<h3> 1. 配置</h3>
<p>静态资源路径，SpringBoot默认从属性<code>spring.resources.static-locations</code>中获取</p>
<p>默认值可以从<code>org.springframework.boot.autoconfigure.web.ResourceProperties#CLASSPATH_RESOURCE_LOCATIONS</code>获取</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意上面的默认值，默认有四个，优先级从高到低</p>
<ul>
<li><code>/META-INF/resources/</code></li>
<li><code>/resources/</code></li>
<li><code>/static/</code></li>
<li><code>/public/</code></li>
</ul>
<h3> 2. 实例演示</h3>
<blockquote>
<p>默认静态资源路径有四个，所以我们设计case需要依次访问这四个路径中的静态资源，看是否正常访问到；其次就是需要判定优先级的问题，是否和上面说的一致</p>
</blockquote>
<p>首先创建一个SpringBoot web项目，工程创建流程不额外多说，pom中主要确保有下面依赖即可（本文使用版本为: <code>2.2.1.RELEASE</code>)</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在资源文件夹<code>resources</code>下，新建四个目录，并添加html文件，用于测试是否可以访问到对应的资源文件（主要关注下图中标红的几个文件）</p>
<figure><img src="/imgs/200611/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h4> a. META-INF/resources</h4>
<p>静态文件 m.html</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>完成对应的Rest接口</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/200611/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h4> b. resources</h4>
<p>静态文件 r.html</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对应的Rest接口</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/200611/02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h4> c. static</h4>
<p>静态文件 s.html</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对应的Rest接口</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/200611/03.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h4> d. public</h4>
<p>静态文件 p.html</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对应的Rest接口</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/200611/04.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h4> e. 优先级测试</h4>
<p>关于优先级的测试用例，主要思路就是在上面四个不同的文件夹下面放相同文件名的静态资源，然后根据访问时具体的返回来确定相应的优先级。相关代码可以在文末的源码中获取，这里就不赘述了</p>
<h2> II. 自定义资源路径</h2>
<p>一般来讲，我们的静态资源放在上面的四个默认文件夹下面已经足够，但总会有特殊情况，如果资源文件放在其他的目录下，应该怎么办？</p>
<h3> 1. 修改配置文件</h3>
<p>第一种方式比较简单和实用，修改上面的<code>spring.resources.static-locations</code>配置，添加上自定义的资源目录，如在 <code>application.yml</code> 中，指定配置</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面指定了可以扫描<code>/out</code>目录下的静态资源文件，且它的优先级是最高的（上面的配置顺序中，优先级的高低从左到右）</p>
<p><strong>实例演示</strong></p>
<p>在资源目录下，新建文件<code>/out/index.html</code></p>
<figure><img src="/imgs/200611/05.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>请注意在其他的四个资源目录下，也都存在 <code>index.html</code>这个文件（根据上面优先级的描述，返回的应该是<code>/out/index.html</code>）</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/200611/06.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 2. WebMvcConfigurer 添加资源映射</h3>
<p>除了上述的配置指定之外，还有一种常见的使用姿势就是利用配置类<code>WebMvcConfigurer</code>来手动添加资源映射关系，为了简单起见，我们直接让启动类实现<code>WebMvcConfigure</code>接口</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>根据上面的配置表示将/ts目录下的资源ts.html，映射到/ts/ts，而直接访问/ts会报404（这个逻辑可能有点绕，需要仔细想一想）</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/200611/07.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> III. Jar包资源访问</h2>
<p>前面描述的静态资源访问主要都是当前包内的资源访问，如果我们的静态资源是由第三方的jar包提供（比如大名鼎鼎的Swagger UI)，这种时候使用姿势是否有不一样的呢？</p>
<h3> 1. classpath 与 classpath*</h3>
<p>在之前使用<code>SpringMVC3+/4</code>的时候，<code>classpath:/META-INF/resources/</code>表示只扫描当前包内的<code>/META-INF/resources/</code>路径，而<code>classpath*:/META-INF/resources/</code>则会扫描当前+第三方jar包中的<code>/META-INF/resources/</code>路径</p>
<p>那么在<code>SpringBoot2.2.1-RELEASE</code>版本中是否也需要这样做呢？（答案是不需要，且看后面的实例）</p>
<h3> 2. 实例</h3>
<p>新建一个工程，只提供基本的html静态资源，项目基本结构如下（具体的html内容就不粘贴了，墙裂建议有兴趣的小伙伴直接看源码，阅读效果更优雅）</p>
<figure><img src="/imgs/200611/08.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>接着在我们上面常见的工程中，添加依赖</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>添加对应资源的访问端点</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>请注意，这个时候我们是没有修改前面的<code>spring.resources.static-locations</code>配置的</p>
<figure><img src="/imgs/200611/09.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>上面的访问结果，除了说明访问第三方jar包中的静态资源与当前包的静态资源配置没有什么区别之外，还可以得出一点</p>
<ul>
<li>相同资源路径下，当前包的资源优先级高于jar包中的静态资源</li>
<li>默认配置下，第三方jar包中<code>META-INF/resources</code>下的静态资源，优先级高于当前包的<code>/resources</code>, <code>/static</code>, <code>/public</code></li>
</ul>
<h2> IV. 其他</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：<a href="https://github.com/liuyueyi/spring-boot-demo/spring-boot/204-web-static-resources" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/spring-boot/204-web-static-resources</a></li>
<li><a href="https://github.com/liuyueyi/spring-boot-demo/spring-boot/204-web-static-resources-ui" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/spring-boot/204-web-static-resources-ui</a></li>
</ul>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="SpringBoot"/>
    <category term="WEB系列"/>
    <category term="Request"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2020-06-11T08:47:54.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">7.xml传参与返回使用姿势</title>
    <id>https://liuyueyi.github.io/tutorial/spring/web/Request/200706-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B9%8Bxml%E4%BC%A0%E5%8F%82%E4%B8%8E%E8%BF%94%E5%9B%9E%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF.html</id>
    <link href="https://liuyueyi.github.io/tutorial/spring/web/Request/200706-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B9%8Bxml%E4%BC%A0%E5%8F%82%E4%B8%8E%E8%BF%94%E5%9B%9E%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF.html"/>
    <updated>2023-02-10T04:50:05.000Z</updated>
    <summary type="html"><![CDATA[<p>使用XML作为传参和返回结果，在实际的编码中可能不太常见，特别是当前json大行其道的时候；那么为什么突然来这么一出呢？源于对接微信公众号的消息接收，自动回复的开发时，惊奇的发现微信使用xml格式进行交互，所以也就不得不支持了</p>
<p>下面介绍一下SpringBoot中如何支持xml传参解析与返回xml文档</p>
]]></summary>
    <content type="html"><![CDATA[<p>使用XML作为传参和返回结果，在实际的编码中可能不太常见，特别是当前json大行其道的时候；那么为什么突然来这么一出呢？源于对接微信公众号的消息接收，自动回复的开发时，惊奇的发现微信使用xml格式进行交互，所以也就不得不支持了</p>
<p>下面介绍一下SpringBoot中如何支持xml传参解析与返回xml文档</p>
<!-- more -->
<h2> I. 项目环境</h2>
<p>本文创建的实例工程采用<code>SpringBoot 2.2.1.RELEASE</code> + <code>maven 3.5.3</code> + <code>idea</code>进行开发</p>
<h3> 1. pom依赖</h3>
<p>具体的SpringBoot项目工程创建就不赘述了，对于pom文件中，需要重点关注下面两个依赖类</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>请注意jackson-dataformat-xml版本，不要选择太老的</strong></p>
<h2> II. 实例演示</h2>
<h3> 1. 传参Bean</h3>
<p>定义一个接受参数的bean对象，如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>请注意，我们使用<code>@JacksonXmlRootElement</code>注解来修饰这个bean，localName中的value，相当于xml的根标签；如果类中的属性成员名，和xml标签名不一样，可以使用注解<code>@JacksonXmlProperty(localName = "xxx")</code>来修饰</p>
<p>其次，请保留bean的默认无参构造函数，get/set方法 （我上面为了简洁，使用了lombok（最近看到了不少抨击lombok的文章...），不希望使用lombok的小伙伴，可以利用IDEA的自动生成，来实现相关的代码）</p>
<h3> 2. Response Bean</h3>
<p>定义返回的也是一个xml bean</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. rest服务</h3>
<p>然后像平常一样，实现一个"普通"的rest服务即可</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意三点</p>
<ul>
<li><code>@RestController</code>：返回的不是视图</li>
<li><code>@PostMapping</code>注解中的 <code>consumes</code> 和 <code>produces</code>参数，指定了"application/xml"，表示我们接收和返回的都是xml文档</li>
<li><code>@RequestBody</code>：不加这个注解时，无法获取传参哦（可以想一想why?)</li>
</ul>
<p><strong>接口测试</strong></p>
<p>我个人倾向于万能的curl进行测试，打开终端即可使用，如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/200706/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>考虑到有些小伙伴更青睐于Postman进行url测试，下面是具体的请求姿势</p>
<figure><img src="/imgs/200706/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 4. 解析异常问题</h3>
<blockquote>
<p>如果需要重新这个问题，可以参考项目: <a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/202-web-params" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/202-web-params</a></p>
</blockquote>
<p>某些场景下，直接使用上面的姿势貌似不能正常工作，会抛出一个<code>Resolved [org.springframework.web.HttpMediaTypeNotSupportedException: Content type 'application/xml;charset=UTF-8' not supported]</code>的异常信息</p>
<p>针对出现<code>HttpMediaTypeNotSupportedException</code>的场景，解决办法也很明确，增加一个xml的<code>HttpMesssageConverter</code>即可，依然是借助<code>MappingJackson2XmlHttpMessageConverter</code>，如</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> II. 其他</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/202-web-params" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/202-web-params</a></li>
</ul>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="SpringBoot"/>
    <category term="WEB系列"/>
    <category term="Request"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2020-07-06T07:43:45.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">8.xml传参与返回实战演练</title>
    <id>https://liuyueyi.github.io/tutorial/spring/web/Request/220704-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B9%8BXML%E4%BC%A0%E5%8F%82%E8%BF%94%E5%9B%9E%E5%AE%9E%E6%88%98.html</id>
    <link href="https://liuyueyi.github.io/tutorial/spring/web/Request/220704-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B9%8BXML%E4%BC%A0%E5%8F%82%E8%BF%94%E5%9B%9E%E5%AE%9E%E6%88%98.html"/>
    <updated>2023-02-10T04:50:05.000Z</updated>
    <summary type="html"><![CDATA[<p>最近在准备使用微信公众号来做个人站点的登录，发现微信的回调协议居然是xml格式的，之前使用json传输的较多，结果发现换成xml之后，好像并没有想象中的那么顺利，比如回传的数据始终拿不到，返回的数据对方不认等</p>
<p>接下来我们来实际看一下，一个传参和返回都是xml的SpringBoot应用，究竟是怎样的</p>
]]></summary>
    <content type="html"><![CDATA[<p>最近在准备使用微信公众号来做个人站点的登录，发现微信的回调协议居然是xml格式的，之前使用json传输的较多，结果发现换成xml之后，好像并没有想象中的那么顺利，比如回传的数据始终拿不到，返回的数据对方不认等</p>
<p>接下来我们来实际看一下，一个传参和返回都是xml的SpringBoot应用，究竟是怎样的</p>
<!-- more -->
<h2> I. 项目搭建</h2>
<p>本文创建的实例工程采用<code>SpringBoot 2.2.1.RELEASE</code> + <code>maven 3.5.3</code> + <code>idea</code>进行开发</p>
<h3> 1. pom依赖</h3>
<p>具体的SpringBoot项目工程创建就不赘述了，对于pom文件中，需要重点关注下面两个依赖类</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 接口调研</h3>
<p>我们直接使用微信公众号的回调传参、返回来搭建项目服务，微信开发平台文档如: <a href="https://developers.weixin.qq.com/doc/offiaccount/Message_Management/Receiving_standard_messages.html" target="_blank" rel="noopener noreferrer">基础消息能力</a></p>
<p>其定义的推送参数如下</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>要求返回的结果如下</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的结构看起来还好，但是需要注意的是外层标签为<code>xml</code>，内层标签都是大写开头的；而微信识别返回是大小写敏感的</p>
<h2> II. 实战</h2>
<p>项目工程搭建完毕之后，首先定义一个接口，用于接收xml传参，并返回xml对象；</p>
<p>那么核心的问题就是如何定义传参为xml，返回也是xml呢？</p>
<blockquote>
<p>没错：就是请求头 + 返回头</p>
</blockquote>
<h3> 1.REST接口</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意上面的接口定义，POST传参，请求头和返回头都是 <code>application/xml</code></p>
<h3> 2.请求参数与返回结果对象定义</h3>
<p>上面的接口中定义了<code>WxTxtMsgReqVo</code>来接收传参，定义<code>WxTxtMsgResVo</code>来返回结果，由于我们采用的是xml协议传输数据，这里需要借助<code>JacksonXmlRootElement</code>和<code>JacksonXmlProperty</code>注解；它们的实际作用与json传输时，使用<code>JsonProperty</code>来指定json key的作用相仿</p>
<p>下面是具体的实体定义</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>重点说明：</p>
<ul>
<li>JacksonXmlRootElement 注解，定义返回的xml文档中最外层的标签名</li>
<li>JacksonXmlProperty 注解，定义每个属性值对应的标签名</li>
<li>无需额外添加<code>&lt;![CDATA[...]]&gt;</code>，这个会自动添加，防转义</li>
</ul>
<h3> 3.测试</h3>
<p>然后访问测试一下，直接通过curl来发送xml请求</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>实际响应如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4.问题记录</h3>
<h4> 4.1 HttpMediaTypeNotSupportedException异常</h4>
<p>通过前面的方式搭建项目之后，在实际测试时，可能会遇到下面的异常情况<code>Resolved [org.springframework.web.HttpMediaTypeNotSupportedException: Content type 'application/xml;charset=UTF-8' not supported]</code></p>
<p>当出现这个问题时，表明是没有对应的Convert来处理<code>application/xml</code>格式的请求头</p>
<p>对应的解决方案则是主动注册上</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 4.2 其他json接口也返回xml数据</h4>
<p>另外一个场景则是配置了前面的xml之后，导致项目中其他正常的json传参、返回的接口也开始返回xml格式的数据了，此时解决方案如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 4.3 微信实际回调参数一直拿不到</h4>
<p>这个问题是在实际测试回调的时候遇到的，接口定义之后始终拿不到结果，主要原因就在于最开始没有在定义的实体类上添加 <code>@JacksonXmlProperty</code></p>
<p>当我们没有指定这个注解时，接收的xml标签名与实体对象的fieldName完全相同，既区分大小写</p>
<p>所以为了解决这个问题，就是老老实实如上面的写法，在每个成员上添加注解，如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 5.小结</h3>
<p>本文主要介绍的是SpringBoot如何支持xml格式的传参与返回，大体上使用姿势与json格式并没有什么区别，但是在实际使用的时候需要注意上面提出的几个问题，避免采坑</p>
<p>关键知识点提炼如下：</p>
<ul>
<li>Post接口上，指定请求头和返回头：
<ul>
<li><code>consumes = {"application/xml", "text/xml"},</code></li>
<li><code>produces = "application/xml;charset=utf-8"</code></li>
</ul>
</li>
<li>实体对象，通过<code>JacksonXmlRootElement</code>和<code>JacksonXmlProperty</code>来重命名返回的标签名</li>
<li>注册<code>MappingJackson2XmlHttpMessageConverter</code>解决HttpMediaTypeNotSupportedException异常</li>
<li>指定<code>ContentNegotiationConfigurer.defaultContentType</code> 避免出现所有接口返回xml文档</li>
</ul>
<h2> III. 其他</h2>
<h3> 0. 项目与源码</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/204-web-xml" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/204-web-xml</a></li>
</ul>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="SpringBoot"/>
    <category term="WEB系列"/>
    <category term="Request"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2022-07-04T21:43:45.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">Web请求知识点</title>
    <id>https://liuyueyi.github.io/tutorial/spring/web/Request/</id>
    <link href="https://liuyueyi.github.io/tutorial/spring/web/Request/"/>
    <updated>2023-02-10T04:50:05.000Z</updated>
    <summary type="html"><![CDATA[<p>请求参数如何解析？如何自定义参数转换器？参数校验怎么做？路由匹配又是什么？交互协议JSON还是XML？如有这些疑问，请打开这个教程</p>
]]></summary>
    <content type="html"><![CDATA[<p>请求参数如何解析？如何自定义参数转换器？参数校验怎么做？路由匹配又是什么？交互协议JSON还是XML？如有这些疑问，请打开这个教程</p>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2023-02-10T04:50:05.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">1.Freemaker环境搭建</title>
    <id>https://liuyueyi.github.io/tutorial/spring/web/Response/190816-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8Bweb%E7%AF%87%E4%B9%8BFreemaker%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.html</id>
    <link href="https://liuyueyi.github.io/tutorial/spring/web/Response/190816-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8Bweb%E7%AF%87%E4%B9%8BFreemaker%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.html"/>
    <updated>2023-02-10T04:50:05.000Z</updated>
    <summary type="html"><![CDATA[<p>现在的开发现状比较流行前后端分离，使用springboot搭建一个提供rest接口的后端服务特别简单，引入<code>spring-boot-starter-web</code>依赖即可。那么在不分离的场景下，比如要开发一个后端使用的控制台，这时候可能并没有前端资源，由javaer自己来客串一把，我希望简单一点，前后端项目都集成在一起，一个jar包运行起来就完事，可以怎么搞呢？</p>
<p>本篇将介绍一下如何使用springboot集合freemaker引擎来搭建web应用</p>
]]></summary>
    <content type="html"><![CDATA[<p>现在的开发现状比较流行前后端分离，使用springboot搭建一个提供rest接口的后端服务特别简单，引入<code>spring-boot-starter-web</code>依赖即可。那么在不分离的场景下，比如要开发一个后端使用的控制台，这时候可能并没有前端资源，由javaer自己来客串一把，我希望简单一点，前后端项目都集成在一起，一个jar包运行起来就完事，可以怎么搞呢？</p>
<p>本篇将介绍一下如何使用springboot集合freemaker引擎来搭建web应用</p>
<!-- more -->
<h2> I. 准备</h2>
<blockquote>
<p>Freemaker是模板引擎，和jsp的作用差不多，对于它的不太清楚的同学可以参考一下官方文档
<a href="https://freemarker.apache.org/docs/index.html" target="_blank" rel="noopener noreferrer">https://freemarker.apache.org/docs/index.html</a></p>
</blockquote>
<h3> 1. 依赖</h3>
<p>首先我们是需要一个springboot项目，基本的pom结构大都相似</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个项目中，我们主要需要引入两个依赖包，一个web，一个freemaker</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 配置参数</h3>
<p>通常我们直接使用默认的freemaker参数配置即可，下面给出几个常用的</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>freemaker的参数，主要对应的是<code>org.springframework.boot.autoconfigure.freemarker.FreeMarkerProperties</code></p>
<h2> II. 项目搭建演示</h2>
<h3> 1. 项目结构</h3>
<p>搭建一个web项目和我们之前的纯后端项目有点不一样，前端资源放在什么地方，依赖文件怎么处理都是有讲究的，下面是一个常规的项目结构</p>
<figure><img src="/imgs/190816/00.jpg" alt="项目结构" tabindex="0" loading="lazy"><figcaption>项目结构</figcaption></figure>
<p>如上图，前端资源文件默认放在resources目录下，下面有两个目录</p>
<ul>
<li><code>templates</code>：存放模板文件，可以理解为我们编写的html，注意这个文件名不能有问题</li>
<li><code>static</code>: 存放静态资源文件，如js,css,image等</li>
</ul>
<h3> 2. Rest服务</h3>
<p>我们这里提供了三个接口，主要是为了演示三种不同的数据绑定方式</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的三种case中</p>
<ul>
<li>第一个是最好理解的，在创建<code>ModelAndView</code>时，传入viewName和数据</li>
<li>第二个是通过接口参数Model，设置传递给view的数据</li>
<li>第三种则直接使用Map来传递数据</li>
</ul>
<p>三个接口，对应的三个html文件，如下</p>
<p><strong>index.ftl</strong></p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>show1.ftl</strong></p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>show2.ft</strong></p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面的模板文件中，需要注意引用css样式文件，路径前面并没有static，我们对应的css文件</p>
<p><strong>index.css</strong></p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. 演示</h3>
<p>启动项目后，可以看到三个页面的切换，模板中的数据根据后端的返回替换，特别是主页的时间，每次刷新都会随之改变</p>
<figure><img src="/imgs/190816/01.gif" alt="demo" tabindex="0" loading="lazy"><figcaption>demo</figcaption></figure>
<h2> II. 其他</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>项目地址: <a href="https://github.com/liuyueyi/spring-boot-demo/blob/master/spring-boot/204-web-freemaker" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/blob/master/spring-boot/204-web-freemaker</a></li>
</ul>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="SpringBoot"/>
    <category term="WEB系列"/>
    <category term="Response"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2019-08-16T16:26:25.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">2.Thymeleaf环境搭建</title>
    <id>https://liuyueyi.github.io/tutorial/spring/web/Response/190820-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8Bweb%E7%AF%87%E4%B9%8BThymeleaf%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.html</id>
    <link href="https://liuyueyi.github.io/tutorial/spring/web/Response/190820-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8Bweb%E7%AF%87%E4%B9%8BThymeleaf%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.html"/>
    <updated>2023-02-10T04:50:05.000Z</updated>
    <summary type="html"><![CDATA[<p>上一篇博文介绍了如何使用Freemaker引擎搭建web项目，这一篇我们则看一下另外一个常见的页面渲染引擎Thymeleaf如何搭建一个web项目</p>
<blockquote>
<p>推荐结合Freemaker博文一起查看，效果更佳 <a href="http://spring.hhui.top/spring-blog/2019/08/16/190816-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8Bweb%E7%AF%87%E4%B9%8BFreemaker%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" target="_blank" rel="noopener noreferrer">190816-SpringBoot系列教程web篇之Freemaker环境搭建</a></p>
</blockquote>
]]></summary>
    <content type="html"><![CDATA[<p>上一篇博文介绍了如何使用Freemaker引擎搭建web项目，这一篇我们则看一下另外一个常见的页面渲染引擎Thymeleaf如何搭建一个web项目</p>
<blockquote>
<p>推荐结合Freemaker博文一起查看，效果更佳 <a href="http://spring.hhui.top/spring-blog/2019/08/16/190816-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8Bweb%E7%AF%87%E4%B9%8BFreemaker%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" target="_blank" rel="noopener noreferrer">190816-SpringBoot系列教程web篇之Freemaker环境搭建</a></p>
</blockquote>
<!-- more -->
<h2> I. 准备</h2>
<blockquote>
<p>Thymeleaf 是现代化服务器端的Java模板引擎，不同与JSP和FreeMarker，Thymeleaf的语法更加接近HTML，关于它的使用说明，可以参考官方文档
<a href="https://www.thymeleaf.org/documentation.html" target="_blank" rel="noopener noreferrer">https://www.thymeleaf.org/documentation.html</a></p>
</blockquote>
<h3> 1. 依赖</h3>
<p>首先我们是需要一个springboot项目，基本的pom结构大都相似</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个项目中，我们主要需要引入两个依赖包，一个web，一个thymeleaf</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 配置参数</h3>
<p>通常我们直接使用默认的thymeleaf参数配置即可，下面给出几个常用的配置</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>thymeleaf的参数，主要对应的是<code>org.springframework.boot.autoconfigure.thymeleaf.ThymeleafProperties</code></p>
<h2> II. 项目搭建演示</h2>
<h3> 1. 项目结构</h3>
<p>搭建一个web项目和我们之前的纯后端项目有点不一样，前端资源放在什么地方，依赖文件怎么处理都是有讲究的，下面是一个常规的项目结构</p>
<figure><img src="/imgs/190820/00.jpg" alt="项目结构" tabindex="0" loading="lazy"><figcaption>项目结构</figcaption></figure>
<p>如上图，前端资源文件默认放在resources目录下，下面有两个目录</p>
<ul>
<li><code>templates</code>：存放模板文件，可以理解为我们编写的html，注意这个文件名不能有问题</li>
<li><code>static</code>: 存放静态资源文件，如js,css,image等</li>
</ul>
<h3> 2. Rest服务</h3>
<p>我们这里提供了三个接口，主要是为了演示三种不同的数据绑定方式（和Freemaker这篇博文基本一样）</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的三种case中</p>
<ul>
<li>第一个是最好理解的，在创建<code>ModelAndView</code>时，传入viewName和数据</li>
<li>第二个是通过接口参数Model，设置传递给view的数据</li>
<li>第三种则直接使用Map来传递数据</li>
</ul>
<p>三个接口，对应的三个html文件，如下</p>
<p><strong>index.html</strong></p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>show1.html</strong></p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>show2.html</strong></p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面的模板文件中，需要注意引用css样式文件，路径前面并没有static，我们对应的css文件</p>
<p><strong>index.css</strong></p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. 演示</h3>
<p>启动项目后，可以看到三个页面的切换，模板中的数据根据后端的返回替换，特别是主页的时间，每次刷新都会随之改变</p>
<figure><img src="/imgs/190820/01.gif" alt="演示" tabindex="0" loading="lazy"><figcaption>演示</figcaption></figure>
<h2> II. 其他</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>项目地址: <a href="https://github.com/liuyueyi/spring-boot-demo/blob/master/spring-boot/205-web-thymeleaf" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/blob/master/spring-boot/205-web-thymeleaf</a></li>
</ul>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="SpringBoot"/>
    <category term="WEB系列"/>
    <category term="Response"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2019-08-20T21:33:19.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">3.Beetl环境搭建</title>
    <id>https://liuyueyi.github.io/tutorial/spring/web/Response/190822-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8Bweb%E7%AF%87%E4%B9%8BBeetl%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.html</id>
    <link href="https://liuyueyi.github.io/tutorial/spring/web/Response/190822-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8Bweb%E7%AF%87%E4%B9%8BBeetl%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.html"/>
    <updated>2023-02-10T04:50:05.000Z</updated>
    <summary type="html"><![CDATA[<p>前面两篇分别介绍了目前流行的模板引擎Freemaker和Thymeleaf构建web应用的方式，接下来我们看一下号称性能最好的国产模板引擎Beetl，如何搭建web环境</p>
<blockquote>
<p>本文主要来自官方文档，如有疑问，推荐查看: <a href="http://ibeetl.com/guide/#beetl" target="_blank" rel="noopener noreferrer">http://ibeetl.com/guide/#beetl</a></p>
</blockquote>
]]></summary>
    <content type="html"><![CDATA[<p>前面两篇分别介绍了目前流行的模板引擎Freemaker和Thymeleaf构建web应用的方式，接下来我们看一下号称性能最好的国产模板引擎Beetl，如何搭建web环境</p>
<blockquote>
<p>本文主要来自官方文档，如有疑问，推荐查看: <a href="http://ibeetl.com/guide/#beetl" target="_blank" rel="noopener noreferrer">http://ibeetl.com/guide/#beetl</a></p>
</blockquote>
<!-- more -->
<h2> I. 准备</h2>
<h3> 1. 依赖</h3>
<p>首先我们是需要一个springboot项目，基本的pom结构大都相似</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个项目中，我们主要需要引入两个依赖包，一个web，一个官方提供的<code>beetl-framework-starter</code>，当前最新的版本为 <code>1.2.12.RELEASE</code></p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 配置参数</h3>
<p>通常我们直接使用默认的thymeleaf参数配置即可，下面给出几个常用的配置</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> II. 项目搭建演示</h2>
<h3> 1. 项目结构</h3>
<p>搭建一个web项目和我们之前的纯后端项目有点不一样，前端资源放在什么地方，依赖文件怎么处理都是有讲究的，下面是一个常规的项目结构</p>
<figure><img src="/imgs/190822/00.jpg" alt="项目结构" tabindex="0" loading="lazy"><figcaption>项目结构</figcaption></figure>
<p>如上图，前端资源文件默认放在resources目录下，下面有两个目录</p>
<ul>
<li><code>templates</code>：存放模板文件，可以理解为我们编写的html，注意这个文件名不能有问题</li>
<li><code>static</code>: 存放静态资源文件，如js,css,image等</li>
</ul>
<h3> 2. Rest服务</h3>
<p>我们这里提供了三个接口，主要是为了演示三种不同的数据绑定方式（和前面两篇博文基本一样）</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的三种case中</p>
<ul>
<li>第一个是最好理解的，在创建<code>ModelAndView</code>时，传入viewName和数据</li>
<li>第二个是通过接口参数Model，设置传递给view的数据</li>
<li>第三种则直接使用Map来传递数据</li>
</ul>
<p><strong>注意</strong></p>
<p>如果和前面两篇博文进行对比，会发现一个显著的区别，之前的<code>Freemaker</code>, <code>Thymeleaf</code>指定视图名的时候，都不需要后缀，但是这里，必须带上后缀，否则会500错误</p>
<hr>
<p>三个接口，对应的三个btl文件，如下</p>
<p><strong>index.btl</strong></p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>show1.btl</strong></p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>show2.btl</strong></p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面的模板文件中，需要注意引用css样式文件，路径前面并没有static，我们对应的css文件</p>
<p><strong>index.css</strong></p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. 演示</h3>
<p>启动项目后，可以看到三个页面的切换，模板中的数据根据后端的返回替换，特别是主页的时间，每次刷新都会随之改变</p>
<figure><img src="/imgs/190822/01.gif" alt="demo" tabindex="0" loading="lazy"><figcaption>demo</figcaption></figure>
<h2> II. 其他</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>项目地址: <a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/206-web-beetl" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/206-web-beetl</a></li>
</ul>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="SpringBoot"/>
    <category term="WEB系列"/>
    <category term="Response"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2019-08-22T19:25:47.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">4.返回文本、网页、图片的操作姿势</title>
    <id>https://liuyueyi.github.io/tutorial/spring/web/Response/190913-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8Bweb%E7%AF%87%E4%B9%8B%E8%BF%94%E5%9B%9E%E6%96%87%E6%9C%AC%E3%80%81%E7%BD%91%E9%A1%B5%E3%80%81%E5%9B%BE%E7%89%87%E7%9A%84%E6%93%8D%E4%BD%9C%E5%A7%BF%E5%8A%BF.html</id>
    <link href="https://liuyueyi.github.io/tutorial/spring/web/Response/190913-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8Bweb%E7%AF%87%E4%B9%8B%E8%BF%94%E5%9B%9E%E6%96%87%E6%9C%AC%E3%80%81%E7%BD%91%E9%A1%B5%E3%80%81%E5%9B%BE%E7%89%87%E7%9A%84%E6%93%8D%E4%BD%9C%E5%A7%BF%E5%8A%BF.html"/>
    <updated>2023-02-10T04:50:05.000Z</updated>
    <summary type="html"><![CDATA[<p>前面几篇博文介绍了如何获取get/post传参，既然是http请求，一般也都是有来有往，有请求参数传递，就会有数据返回。那么我们通过springboot搭建的web应用，可以怎样返回数据呢？</p>
<p>本篇将主要介绍以下几种数据格式的返回实例</p>
<ul>
<li>返回文本</li>
<li>返回数组</li>
<li>返回json串</li>
<li>返回静态网页</li>
<li>返回图片</li>
</ul>
]]></summary>
    <content type="html"><![CDATA[<p>前面几篇博文介绍了如何获取get/post传参，既然是http请求，一般也都是有来有往，有请求参数传递，就会有数据返回。那么我们通过springboot搭建的web应用，可以怎样返回数据呢？</p>
<p>本篇将主要介绍以下几种数据格式的返回实例</p>
<ul>
<li>返回文本</li>
<li>返回数组</li>
<li>返回json串</li>
<li>返回静态网页</li>
<li>返回图片</li>
</ul>
<!-- more -->
<h2> I. 环境搭建</h2>
<p>首先得搭建一个web应用才有可能继续后续的测试，借助SpringBoot搭建一个web应用属于比较简单的活;</p>
<p>创建一个maven项目，pom文件如下</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>依然是一般的流程，pom依赖搞定之后，写一个程序入口</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> II. 数据返回姿势实例</h2>
<p>以下返回实例都放在同一个Controller中，具体定义如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1. 文本返回</h3>
<p>这个属于基础功能了，发起请求，返回一串文本，在SpringMVC的体系中，要实现这种通常的写法通常是直接定义方法的返回为String；当然还有另外一种非常基础的写法，直接将返回的数据通过<code>HttpServletResponse</code>写入到输出流中</p>
<p>下面给出这两种写法的实例</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意上面的实现中，方法上面多了一个注解<code>@ResponseBody</code>，这个表示返回数据，而不是视图（后面会详细说明）</p>
<p><code>strRsp2</code>的输出借助了FastJson来实现将map序列化为json串，然后写入输出流</p>
<p>实例访问如下</p>
<figure><img src="/imgs/190913/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>从上面的输出也可以看出，第一种返回方式，<code>ResponseHeaders</code>的<code>Content-Type: text/html;charset=UTF-8</code>；而第二种方式则没有这个响应头，需要我们自己主动设置（这里注意一下即可，在后面的返回图片中有实例）</p>
<h3> 2，返回数组</h3>
<p>前面请求参数的博文中，我们看到请求参数允许传入数组，那么我们返回可以直接返回数组么？讲道理的话，应该没啥问题</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后请求输出为</p>
<figure><img src="/imgs/190913/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>注意下响应头，为<code>application/json</code>, 也就是说SpringMVC将数组当成json串进行返回了</p>
<h3> 3. Bean返回</h3>
<p>在我们实际的业务开发中，这种应该属于非常常见的使用姿势了，直接返回一个POJO，调用者接收的是一个json串，可以很容易的反序列化为需要的对象</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/190913/02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 4. 网页返回</h3>
<p>前面都是直接返回数据，但是我们平常在使用浏览器，更多的是发起一个请求，然后返回一个网页啊，难道说springmvc不能直接返回网页么？</p>
<p>当然返回网页怎么可能会不支持，（题外话：个人感觉在前后端分离逐渐流行之后，直接由后端返回网页的case不太多了，前端和后端作为独立的项目部署，两者之间通过json串进行交流；这里扯远了），我们下面看一下SpringMVC中如何返回网页</p>
<p>我们可以从上面直接返回字符串的case中，得到一个思路，如果我直接返回一个html文本，会怎样？既然返回<code>content-type</code>是<code>text/html</code>，那浏览器应该可以解析为网页的，下面实测一下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>测试如下</p>
<figure><img src="/imgs/190913/03.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>浏览器发起请求之后，将我们返回的html文本当做网页正常渲染了，所以我们如果想返回网页，就这么干，没毛病！</p>
<p>上面这种方式虽然说可以返回网页，然而在实际业务中，如果真要我们这么干，想想也是可怕，还干什么后端，分分钟全栈得了！！！</p>
<p>下面看一下更常规的写法，首先我们需要配置下返回视图的前缀、后缀, 在<code>application.yml</code>配置文件中添加如下配置</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后我们的静态网页，放在资源文件的static目录下，下面是我们实际的项目截图，index.html为我们需要返回的静态网页</p>
<figure><img src="/imgs/190913/04.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>接下来就是我们的服务接口</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意下上面的接口，没有<code>@ResponseBody</code>注解，表示这个接口返回的是一个视图，会从static目录下寻找名为<code>index.html</code>（前缀路径和后缀是上面的application.yml中定义）的网页返回</p>
<p>实测case如下</p>
<figure><img src="/imgs/190913/05.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 5. 图片返回</h3>
<p>图片返回与前面的又不太一样了，上面介绍的几种case中，要么是返回文本，要么返回视图，而返回图片呢，更多的是返回图片的字符数组，然后告诉浏览器这是个图片，老哥你按照图片渲染</p>
<p>直接返回二进制流，上面在介绍文本返回的两种方式中，有个直接通过<code>HttpServletResponse</code>向输出流中写数据的方式，我们这里是不是可以直接这么用呢？</p>
<p>下面给出一个从网络下载图片并返回二进制流的实际case</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意下上面的实例case，首先设置了返回的<code>ContentType</code>，然后借助<code>ImateIO</code>来下载图片（个人不太建议这种写法，很容易出现403；这里演示主要是为了简单...），并将图片写入到输出流</p>
<p>实例演示如下</p>
<figure><img src="/imgs/190913/06.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> III 小结</h2>
<h3> 1. 返回数据小结</h3>
<p>本篇博文主要介绍了几种常见数据格式的返回使用姿势，本文更多的是一种使用方式的实例case演示，并没有涉及到底层的支持原理，也没有过多的提及如何设置响应头，web交互中常见的cookies/session也没有说到，这些将作为下篇的内容引入，恳请关注</p>
<p>下面做一个简单的小结</p>
<p><strong>返回纯数据</strong></p>
<ul>
<li>添加<code>@ResponseBody</code>注解，则表示我们返回的是数据，而不需要进行视图解析渲染；
<ul>
<li>如果一个controller中全部都是返回数据，不会返回视图时，我们可以在添加<code>@RestController</code>注解，然后这个类中的接口都不需要添加<code>@ResponseBody</code>注解了</li>
</ul>
</li>
<li>返回视图时，我们会根据接口返回的字符串，结合定义的前缀，后缀，到资源路径的static目录下寻找对应的静态文件返回</li>
<li>可以直接通过向<code>HttpServletResponse</code>的输出流中写数据的方式来返回数据，如返回图片常用这种case</li>
</ul>
<h3> 2. 更多web系列博文</h3>
<ul>
<li><a href="http://spring.hhui.top/spring-blog/2019/09/05/190905-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8Bweb%E7%AF%87%E4%B9%8B%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/" target="_blank" rel="noopener noreferrer">190905-SpringBoot系列教程web篇之中文乱码问题解决</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2019/08/31/190831-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8Bweb%E7%AF%87%E4%B9%8B%E5%A6%82%E4%BD%95%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%E5%99%A8/" target="_blank" rel="noopener noreferrer">190831-SpringBoot系列教程web篇之如何自定义参数解析器</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2019/08/28/190828-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8Bweb%E7%AF%87%E4%B9%8BPost%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%E5%A7%BF%E5%8A%BF%E6%B1%87%E6%80%BB/" target="_blank" rel="noopener noreferrer">190828-SpringBoot系列教程web篇之Post请求参数解析姿势汇总</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2019/08/24/190824-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8Bweb%E7%AF%87%E4%B9%8BGet%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%E5%A7%BF%E5%8A%BF%E6%B1%87%E6%80%BB/" target="_blank" rel="noopener noreferrer">190824-SpringBoot系列教程web篇之Get请求参数解析姿势汇总</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2019/08/22/190822-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8Bweb%E7%AF%87%E4%B9%8BBeetl%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" target="_blank" rel="noopener noreferrer">190822-SpringBoot系列教程web篇之Beetl环境搭建</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2019/08/20/190820-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8Bweb%E7%AF%87%E4%B9%8BThymeleaf%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" target="_blank" rel="noopener noreferrer">190820-SpringBoot系列教程web篇之Thymeleaf环境搭建</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2019/08/16/190816-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8Bweb%E7%AF%87%E4%B9%8BFreemaker%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" target="_blank" rel="noopener noreferrer">190816-SpringBoot系列教程web篇之Freemaker环境搭建</a></li>
</ul>
<h2> IV. 其他</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>项目: <a href="https://github.com/liuyueyi/spring-boot-demo/blob/master/spring-boot/207-web-response" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/blob/master/spring-boot/207-web-response</a></li>
</ul>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="SpringBoot"/>
    <category term="WEB系列"/>
    <category term="Response"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2019-09-13T17:44:42.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">5.请求重定向</title>
    <id>https://liuyueyi.github.io/tutorial/spring/web/Response/190929-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8Bweb%E7%AF%87%E4%B9%8B%E9%87%8D%E5%AE%9A%E5%90%91.html</id>
    <link href="https://liuyueyi.github.io/tutorial/spring/web/Response/190929-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8Bweb%E7%AF%87%E4%B9%8B%E9%87%8D%E5%AE%9A%E5%90%91.html"/>
    <updated>2023-02-10T04:50:05.000Z</updated>
    <summary type="html"><![CDATA[<p>前面介绍了spring web篇数据返回的几种常用姿势，当我们在相应一个http请求时，除了直接返回数据之外，还有另一种常见的case -&gt; 重定向；</p>
<p>比如我们在逛淘宝，没有登录就点击购买时，会跳转到登录界面，这其实就是一个重定向。本文主要介绍对于后端而言，可以怎样支持302重定向</p>
]]></summary>
    <content type="html"><![CDATA[<p>前面介绍了spring web篇数据返回的几种常用姿势，当我们在相应一个http请求时，除了直接返回数据之外，还有另一种常见的case -&gt; 重定向；</p>
<p>比如我们在逛淘宝，没有登录就点击购买时，会跳转到登录界面，这其实就是一个重定向。本文主要介绍对于后端而言，可以怎样支持302重定向</p>
<!-- more -->
<h2> I. 环境搭建</h2>
<p>首先得搭建一个web应用才有可能继续后续的测试，借助SpringBoot搭建一个web应用属于比较简单的活;</p>
<p>创建一个maven项目，pom文件如下</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>依然是一般的流程，pom依赖搞定之后，写一个程序入口</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> II. 302重定向</h2>
<h3> 1. 返回redirect</h3>
<p>这种case通常适用于返回视图的接口，在返回的字符串前面添加<code>redirect:</code>方式来告诉Spring框架，需要做302重定向处理</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面给出了一个简单的demo，当我们访问<code>/redirect/r1</code>时，会重定向到请求<code>/redirect/index?base=r1</code>，实际测试结果如下</p>
<figure><img src="/imgs/190929/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>注意上面的截图，我们实际访问的连接是 <code>http://127.0.0.1:8080/redirect/index?base=r1</code>，在浏览器中的表现则是请求url变成了<code>http://127.0.0.1:8080/redirect/index?base=r1</code>；通过控制台查看到的返回头状态码是302</p>
<p><strong>说明</strong></p>
<ul>
<li>使用这种方式的前提是不能在接口上添加<code>@ResponseBody</code>注解，否则返回的字符串被当成普通字符串处理直接返回，并不会实现重定向</li>
</ul>
<h3> 2. HttpServletResponse重定向</h3>
<p>前面一篇说到SpringMVC返回数据的时候，介绍到可以直接通过<code>HttpServletResponse</code>往输出流中写数据的方式，来返回结果；我们这里也是利用它，来实现重定向</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从上面的demo中，也可以看出这个的使用方式很简单了，直接调用<code>javax.servlet.http.HttpServletResponse#sendRedirect</code>，并传入需要重定向的url即可</p>
<figure><img src="/imgs/190929/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 3. 小结</h3>
<p>这里主要介绍了两种常见的后端重定向方式，都比较简单，这两种方式也有自己的适用场景（当然并不绝对）</p>
<ul>
<li>在返回视图的前面加上<code>redirect</code>的方式，更加适用于视图的跳转，从一个网页跳转到另一个网页</li>
<li><code>HttpServletResponse#sendRedirec</code>的方式更加灵活，可以在后端接收一次http请求生命周期中的任何一个阶段来使用，比如有以下几种常见的场景
<ul>
<li>某个接口要求登录时，在拦截器层针对所有未登录的请求，重定向到登录页面</li>
<li>全局异常处理中，如果出现服务器异常，重定向到定制的500页面</li>
<li>不支持的请求，重定向到404页面</li>
</ul>
</li>
</ul>
<h2> II. 其他</h2>
<h3> 0. 项目</h3>
<h4> a. 系列博文</h4>
<ul>
<li><a href="http://spring.hhui.top/spring-blog/2019/09/13/190913-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8Bweb%E7%AF%87%E4%B9%8B%E8%BF%94%E5%9B%9E%E6%96%87%E6%9C%AC%E3%80%81%E7%BD%91%E9%A1%B5%E3%80%81%E5%9B%BE%E7%89%87%E7%9A%84%E6%93%8D%E4%BD%9C%E5%A7%BF%E5%8A%BF/" target="_blank" rel="noopener noreferrer">190913-SpringBoot系列教程web篇之返回文本、网页、图片的操作姿势</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2019/09/05/190905-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8Bweb%E7%AF%87%E4%B9%8B%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/" target="_blank" rel="noopener noreferrer">190905-SpringBoot系列教程web篇之中文乱码问题解决</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2019/08/31/190831-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8Bweb%E7%AF%87%E4%B9%8B%E5%A6%82%E4%BD%95%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%E5%99%A8/" target="_blank" rel="noopener noreferrer">190831-SpringBoot系列教程web篇之如何自定义参数解析器</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2019/08/28/190828-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8Bweb%E7%AF%87%E4%B9%8BPost%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%E5%A7%BF%E5%8A%BF%E6%B1%87%E6%80%BB/" target="_blank" rel="noopener noreferrer">190828-SpringBoot系列教程web篇之Post请求参数解析姿势汇总</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2019/08/24/190824-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8Bweb%E7%AF%87%E4%B9%8BGet%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%E5%A7%BF%E5%8A%BF%E6%B1%87%E6%80%BB/" target="_blank" rel="noopener noreferrer">190824-SpringBoot系列教程web篇之Get请求参数解析姿势汇总</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2019/08/22/190822-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8Bweb%E7%AF%87%E4%B9%8BBeetl%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" target="_blank" rel="noopener noreferrer">190822-SpringBoot系列教程web篇之Beetl环境搭建</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2019/08/20/190820-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8Bweb%E7%AF%87%E4%B9%8BThymeleaf%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" target="_blank" rel="noopener noreferrer">190820-SpringBoot系列教程web篇之Thymeleaf环境搭建</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2019/08/16/190816-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8Bweb%E7%AF%87%E4%B9%8BFreemaker%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" target="_blank" rel="noopener noreferrer">190816-SpringBoot系列教程web篇之Freemaker环境搭建</a></li>
</ul>
<h4> b. 项目源码</h4>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>项目: <a href="https://github.com/liuyueyi/spring-boot-demo/blob/master/spring-boot/207-web-response" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/blob/master/spring-boot/207-web-response</a></li>
</ul>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="SpringBoot"/>
    <category term="WEB系列"/>
    <category term="Response"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2019-09-29T19:35:48.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">6.404、500异常页面配置</title>
    <id>https://liuyueyi.github.io/tutorial/spring/web/Response/190930-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8Bweb%E7%AF%87%E4%B9%8B404%E3%80%81500%E5%BC%82%E5%B8%B8%E9%A1%B5%E9%9D%A2%E9%85%8D%E7%BD%AE.html</id>
    <link href="https://liuyueyi.github.io/tutorial/spring/web/Response/190930-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8Bweb%E7%AF%87%E4%B9%8B404%E3%80%81500%E5%BC%82%E5%B8%B8%E9%A1%B5%E9%9D%A2%E9%85%8D%E7%BD%AE.html"/>
    <updated>2023-02-10T04:50:05.000Z</updated>
    <summary type="html"><![CDATA[<p>接着前面几篇web处理请求的博文，本文将说明，当出现异常的场景下，如404请求url不存在，，403无权，500服务器异常时，我们可以如何处理</p>
]]></summary>
    <content type="html"><![CDATA[<p>接着前面几篇web处理请求的博文，本文将说明，当出现异常的场景下，如404请求url不存在，，403无权，500服务器异常时，我们可以如何处理</p>
<!-- more -->
<h2> I. 环境搭建</h2>
<p>首先得搭建一个web应用才有可能继续后续的测试，借助SpringBoot搭建一个web应用属于比较简单的活;</p>
<p>创建一个maven项目，pom文件如下</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>依然是一般的流程，pom依赖搞定之后，写一个程序入口</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> II. 异常页面配置</h2>
<p>在SpringBoot项目中，本身提供了一个默认的异常处理页面，当我们希望使用自定义的404,500等页面时，可以如何处理呢？</p>
<h3> 1. 默认异常页面配置</h3>
<p>在默认的情况下，要配置异常页面非常简单，在资源路径下面，新建 <code>error</code> 目录，在下面添加<code>400.html</code>, <code>500html</code>页面即可</p>
<figure><img src="/imgs/190930/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>项目结构如上，注意这里的实例demo是没有使用模板引擎的，所以我们的异常页面放在static目录下；如果使用了如FreeMaker模板引擎时，可以将错误模板页面放在template目录下</p>
<p>接下来实际测试下是否生效, 我们先定义一个可能出现服务器500的服务</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>请求一个不存在的url，返回我们定义的<code>400.html</code>页面</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/190930/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>请求一个服务器500异常，返回我们定义的<code>500.html</code>页面</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/190930/02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 2. BasicErrorController</h3>
<p>看上面的使用比较简单，自然会有个疑问，这个异常页面是怎么返回的呢？</p>
<p>从项目启动的日志中，注意一下<code>RequestMappingHandlerMapping</code></p>
<figure><img src="/imgs/190930/03.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>可以发现里面有个<code>/error</code>的路径不是我们自己定义的，从命名上来看，这个多半就是专门用来处理异常的Controller -&gt; <code>BasicErrorController</code>， 部分代码如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个Controller中，一个返回网页的接口，一个返回Json串的接口；我们前面使用的应该是第一个，那我们什么场景下会使用到第二个呢？</p>
<ul>
<li>通过制定请求头的<code>Accept</code>，来限定我们只希望获取json的返回即可</li>
</ul>
<figure><img src="/imgs/190930/04.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 3. 小结</h3>
<p>本篇内容比较简单，归纳为两句话如下</p>
<ul>
<li>将自定义的异常页面根据http状态码命名，放在<code>/error</code>目录下</li>
<li>在异常状况下，根据返回的http状态码找到对应的异常页面返回</li>
</ul>
<h2> II. 其他</h2>
<h3> 0. 项目</h3>
<h4> a. 系列博文</h4>
<ul>
<li><a href="http://spring.hhui.top/spring-blog/2019/09/29/190929-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8Bweb%E7%AF%87%E4%B9%8B%E9%87%8D%E5%AE%9A%E5%90%91/" target="_blank" rel="noopener noreferrer">190929-SpringBoot系列教程web篇之重定向</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2019/09/13/190913-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8Bweb%E7%AF%87%E4%B9%8B%E8%BF%94%E5%9B%9E%E6%96%87%E6%9C%AC%E3%80%81%E7%BD%91%E9%A1%B5%E3%80%81%E5%9B%BE%E7%89%87%E7%9A%84%E6%93%8D%E4%BD%9C%E5%A7%BF%E5%8A%BF/" target="_blank" rel="noopener noreferrer">190913-SpringBoot系列教程web篇之返回文本、网页、图片的操作姿势</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2019/09/05/190905-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8Bweb%E7%AF%87%E4%B9%8B%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/" target="_blank" rel="noopener noreferrer">190905-SpringBoot系列教程web篇之中文乱码问题解决</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2019/08/31/190831-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8Bweb%E7%AF%87%E4%B9%8B%E5%A6%82%E4%BD%95%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%E5%99%A8/" target="_blank" rel="noopener noreferrer">190831-SpringBoot系列教程web篇之如何自定义参数解析器</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2019/08/28/190828-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8Bweb%E7%AF%87%E4%B9%8BPost%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%E5%A7%BF%E5%8A%BF%E6%B1%87%E6%80%BB/" target="_blank" rel="noopener noreferrer">190828-SpringBoot系列教程web篇之Post请求参数解析姿势汇总</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2019/08/24/190824-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8Bweb%E7%AF%87%E4%B9%8BGet%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%E5%A7%BF%E5%8A%BF%E6%B1%87%E6%80%BB/" target="_blank" rel="noopener noreferrer">190824-SpringBoot系列教程web篇之Get请求参数解析姿势汇总</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2019/08/22/190822-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8Bweb%E7%AF%87%E4%B9%8BBeetl%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" target="_blank" rel="noopener noreferrer">190822-SpringBoot系列教程web篇之Beetl环境搭建</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2019/08/20/190820-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8Bweb%E7%AF%87%E4%B9%8BThymeleaf%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" target="_blank" rel="noopener noreferrer">190820-SpringBoot系列教程web篇之Thymeleaf环境搭建</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2019/08/16/190816-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8Bweb%E7%AF%87%E4%B9%8BFreemaker%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" target="_blank" rel="noopener noreferrer">190816-SpringBoot系列教程web篇之Freemaker环境搭建</a></li>
</ul>
<h4> b. 项目源码</h4>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>项目: <a href="https://github.com/liuyueyi/spring-boot-demo/blob/master/spring-boot/207-web-response" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/blob/master/spring-boot/207-web-response</a></li>
</ul>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="SpringBoot"/>
    <category term="WEB系列"/>
    <category term="Response"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2019-09-30T18:17:11.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">7.全局异常处理</title>
    <id>https://liuyueyi.github.io/tutorial/spring/web/Response/191010-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8Bweb%E7%AF%87%E4%B9%8B%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86.html</id>
    <link href="https://liuyueyi.github.io/tutorial/spring/web/Response/191010-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8Bweb%E7%AF%87%E4%B9%8B%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86.html"/>
    <updated>2023-02-10T04:50:05.000Z</updated>
    <summary type="html"><![CDATA[<p>当我们的后端应用出现异常时，通常会将异常状况包装之后再返回给调用方或者前端，在实际的项目中，不可能对每一个地方都做好异常处理，再优雅的代码也可能抛出异常，那么在Spring项目中，可以怎样优雅的处理这些异常呢?</p>
<p>本文将介绍一种全局异常处理方式，主要包括以下知识点</p>
<ul>
<li>@ControllerAdvice Controller增强</li>
<li>@ExceptionHandler 异常捕获</li>
<li>@ResponseStatus 返回状态码</li>
<li>NoHandlerFoundException处理（404异常捕获）</li>
</ul>
]]></summary>
    <content type="html"><![CDATA[<p>当我们的后端应用出现异常时，通常会将异常状况包装之后再返回给调用方或者前端，在实际的项目中，不可能对每一个地方都做好异常处理，再优雅的代码也可能抛出异常，那么在Spring项目中，可以怎样优雅的处理这些异常呢?</p>
<p>本文将介绍一种全局异常处理方式，主要包括以下知识点</p>
<ul>
<li>@ControllerAdvice Controller增强</li>
<li>@ExceptionHandler 异常捕获</li>
<li>@ResponseStatus 返回状态码</li>
<li>NoHandlerFoundException处理（404异常捕获）</li>
</ul>
<!-- more -->
<h2> I. 环境搭建</h2>
<p>首先得搭建一个web应用才有可能继续后续的测试，借助SpringBoot搭建一个web应用属于比较简单的活;</p>
<p>创建一个maven项目，pom文件如下</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>依然是一般的流程，pom依赖搞定之后，写一个程序入口</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> II. 异常处理</h2>
<h3> 1. @ControllerAdvice</h3>
<p>我们通常利用<code>@ControllerAdvice</code>配合注解<code>@ExceptionHandler</code>来实现全局异常捕获处理</p>
<ul>
<li><code>@ControllerAdvice</code>为所有的Controller织入增强方法</li>
<li><code>@ExceptionHandler</code>标记在方法上，表示当出现对应的异常抛出到上层时（即没有被业务捕获），这个方法会被触发</li>
</ul>
<p>下面我们通过实例进行功能演示</p>
<h4> a. 异常捕获</h4>
<p>我们定义两个异常捕获的case，一个是除0，一个是数组越界异常</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面的测试中，我们将异常堆栈返回调用方</p>
<h4> b. 示例服务</h4>
<p>增加几个测试方法</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> c. 测试说明</h4>
<p>实例测试如下，上面我们声明捕获的两种异常被拦截并输出对应的堆栈信息；</p>
<p>但是需要注意</p>
<ul>
<li><strong>404和未捕获的500异常</strong>则显示的SpringBoot默认的错误页面；</li>
<li>此外我们捕获返回的http状态码是200</li>
</ul>
<figure><img src="/imgs/191010/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 2. @ResponseStatus</h3>
<p>上面的case中捕获的异常返回的状态码是200，但是在某些case中，可能更希望返回更合适的http状态码，此时可以使用<code>ResponseStatus</code>来指定</p>
<p>使用方式比较简单，加一个注解即可</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/191010/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 3. 404处理</h3>
<p>通过<code>@ControllerAdvice</code>配合<code>@ExceptionHandler</code>可以拦截500异常，如果我希望404异常也可以拦截，可以如何处理？</p>
<p>首先修改配置文件<code>application.properties</code>，将<code>NoHandlerFoundException</code>抛出来</p>
<div class="language-properties line-numbers-mode" data-ext="properties"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其次是定义异常捕获</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>再次测试如下，404被我们捕获并返回堆栈信息</p>
<figure><img src="/imgs/191010/02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> II. 其他</h2>
<h3> 0. 项目</h3>
<h4> web系列博文</h4>
<ul>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484336&amp;idx=1&amp;sn=d70f15e77bbd219af8015f9037a167fb&amp;chksm=fce7181ccb90910aee427a3f3ed7660e8303c7460859c82622a651ce1cc3d7a97f62f80ed4e0&amp;token=2447275&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">190930-SpringBoot系列教程web篇之404、500异常页面配置</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484322&amp;idx=1&amp;sn=b18090f35b59097f78858b6609506b74&amp;chksm=fce7180ecb909118d939f3ddf741a11c0977b1213d7afa12c970590590d40441c3a085c43c52&amp;token=2447275&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">190929-SpringBoot系列教程web篇之重定向</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484310&amp;idx=1&amp;sn=f6259cf1b79db095ff2e9534993d27cf&amp;chksm=fce7183acb90912cd150f086e90ecab3eceb3464e9352853e2e722288d412dbb3eb20c6e6ae7&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190913-SpringBoot系列教程web篇之返回文本、网页、图片的操作姿势</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484309&amp;idx=1&amp;sn=33d782f7529268eef6607a1ab8d41018&amp;chksm=fce71839cb90912f6020aa9463bc0136cb57969ebe27eba865d97e212c28211435791aa874ea&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190905-SpringBoot系列教程web篇之中文乱码问题解决</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484291&amp;idx=1&amp;sn=3f7e8c92ca4d7270cc5c40cafea39683&amp;chksm=fce7182fcb90913922654a4f2f04e7029b8944d71c31741334a3235aecbe1e60babcb0c0be74&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190831-SpringBoot系列教程web篇之如何自定义参数解析器</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484287&amp;idx=1&amp;sn=44461f564d6b04cbf1a5902dcb4f23c6&amp;chksm=fce718d3cb9091c5d730e63ae954c0831d53f3dd5af5d19d9c78b6009102838efaf56f7838ff&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190828-SpringBoot系列教程web篇之Post请求参数解析姿势汇总</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484282&amp;idx=1&amp;sn=a8d236d935ae24cfbe6977e24a479caa&amp;chksm=fce718d6cb9091c0dd8a6b113236f9ae9388fb026c9403c97bdf7505f773bd7330a43e3b269c&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190824-SpringBoot系列教程web篇之Get请求参数解析姿势汇总</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484268&amp;idx=3&amp;sn=9e8a6121dce291c65bd2b3d4fab24178&amp;chksm=fce718c0cb9091d6674fb809d68ca3dc3b1695162368481abf8dc094000412116d2f9971c54b&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190822-SpringBoot系列教程web篇之Beetl环境搭建</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484268&amp;idx=2&amp;sn=f800c001061eabe74e2cad915af1921a&amp;chksm=fce718c0cb9091d682b600673a0584955783f0d339248e34323efbea9b698560c432018717ef&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190820-SpringBoot系列教程web篇之Thymeleaf环境搭建</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484268&amp;idx=1&amp;sn=acd691729488d81a94c938151d5737ce&amp;chksm=fce718c0cb9091d63ef5f12893bb835c256a18318e791a0d193d00ef767ecfd019491d02e83d&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190816-SpringBoot系列教程web篇之Freemaker环境搭建</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484217&amp;idx=1&amp;sn=9fdf45d2261cdcf2ccaccaebfb5ef598&amp;chksm=fce71895cb90918361f1afd55a2b5fc9d65508913c1d793710afa79cae38bd9d57e32ad2c187&amp;token=2447275&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">190421-SpringBoot高级篇WEB之websocket的使用说明</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484197&amp;idx=1&amp;sn=0184953527f58058ee8c2bbcfc2689ec&amp;chksm=fce71889cb90919f9be003bf2487343f7952d6b33ab5ee5fb7251ae37a631d4c32e6d8a57528&amp;token=2447275&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">190327-Spring-RestTemplate之urlencode参数解析异常全程分析</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484193&amp;idx=1&amp;sn=d8a284fe0a2b8e1fefe07d892558f563&amp;chksm=fce7188dcb90919b1f8a2408bf955e37e88b043e2dbd59b5290ac1501e3d2d303512bac6af2c&amp;token=2447275&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">190317-Spring MVC之基于java config无xml配置的web应用构建</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484186&amp;idx=1&amp;sn=18db571b670815965ae9185830c4e88f&amp;chksm=fce718b6cb9091a054e0ac4be051341d8ce38ff8e40c5911302e3d6981206c14b80770590044&amp;token=2447275&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">190316-Spring MVC之基于xml配置的web应用构建</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484139&amp;idx=1&amp;sn=b4a5f3ca6215641c6bcf5123f2bfb501&amp;chksm=fce71947cb9090511042ae97a12cc975d2b199521e17980e685cccb5e0be91a8e932cef4eb76&amp;token=2447275&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">190213-SpringBoot文件上传异常之提示The temporary upload location xxx is not valid</a></li>
</ul>
<h4> 项目源码</h4>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>项目：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/209-web-error" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/209-web-error</a></li>
</ul>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="SpringBoot"/>
    <category term="WEB系列"/>
    <category term="Response"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2019-10-10T18:15:16.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">8.自定义异常处理HandlerExceptionResolver</title>
    <id>https://liuyueyi.github.io/tutorial/spring/web/Response/191012-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8Bweb%E7%AF%87%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86HandlerExceptionResolver.html</id>
    <link href="https://liuyueyi.github.io/tutorial/spring/web/Response/191012-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8Bweb%E7%AF%87%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86HandlerExceptionResolver.html"/>
    <updated>2023-02-10T04:50:05.000Z</updated>
    <summary type="html"><![CDATA[<p>关于Web应用的全局异常处理，上一篇介绍了<code>ControllerAdvice</code>结合<code>@ExceptionHandler</code>的方式来实现web应用的全局异常管理；</p>
<p>本篇博文则带来另外一种并不常见的使用方式，通过实现自定义的<code>HandlerExceptionResolver</code>，来处理异常状态</p>
<blockquote>
<p>上篇博文链接: <a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484344&amp;idx=1&amp;sn=d4b1422a709d9540583e33443aab6fff&amp;chksm=fce71814cb9091025a960312c878ff9fc4f44fd0035aa597f55f37c90dcbac25a3e96ee2c528&amp;token=118864495&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">SpringBoot系列教程web篇之全局异常处理</a></p>
</blockquote>
]]></summary>
    <content type="html"><![CDATA[<p>关于Web应用的全局异常处理，上一篇介绍了<code>ControllerAdvice</code>结合<code>@ExceptionHandler</code>的方式来实现web应用的全局异常管理；</p>
<p>本篇博文则带来另外一种并不常见的使用方式，通过实现自定义的<code>HandlerExceptionResolver</code>，来处理异常状态</p>
<blockquote>
<p>上篇博文链接: <a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484344&amp;idx=1&amp;sn=d4b1422a709d9540583e33443aab6fff&amp;chksm=fce71814cb9091025a960312c878ff9fc4f44fd0035aa597f55f37c90dcbac25a3e96ee2c528&amp;token=118864495&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">SpringBoot系列教程web篇之全局异常处理</a></p>
</blockquote>
<!-- more -->
<h2> I. 环境搭建</h2>
<p>首先得搭建一个web应用才有可能继续后续的测试，借助SpringBoot搭建一个web应用属于比较简单的活;</p>
<p>创建一个maven项目，pom文件如下</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> II. HandlerExceptionResolver</h2>
<h3> 1. 自定义异常处理</h3>
<p><code>HandlerExceptionResolver</code>顾名思义，就是处理异常的类，接口就一个方法，出现异常之后的回调，四个参数中还携带了异常堆栈信息</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们自定义异常处理类就比较简单了，实现上面的接口，然后将完整的堆栈返回给调用方</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>仔细观察上面的代码实现，有下面几个点需要注意</p>
<ul>
<li>为了确保中文不会乱码，我们设置了返回头 <code>response.addHeader("Content-Type", "text/html; charset=UTF-8");</code> 如果没有这一行，会出现中文乱码的情况</li>
<li>我们纯后端应用，不想返回视图，直接想Response的输出流中写入数据返回 <code>response.getWriter().append("自定义异常处理!!! \n").append(msg).flush();</code>； 如果项目中有自定义的错误页面，可以通过返回<code>ModelAndView</code>来确定最终返回的错误页面</li>
<li>上面一个代码并不会直接生效，需要注册，可以在<code>WebMvcConfigurer</code>的子类中实现注册，实例如下</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 测试case</h3>
<p>我们依然使用上篇博文的用例来测试</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>下面分别是404异常和500异常的实测情况</p>
<figure><img src="/imgs/191012/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>500异常会进入我们的自定义异常处理类, 而404依然走的是默认的错误页面，所以如果我们需要捕获404异常，依然需要在配置文件中添加</p>
<div class="language-properties line-numbers-mode" data-ext="properties"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>为什么404需要额外处理？</strong></p>
<p>下面尽量以通俗易懂的方式说明下这个问题</p>
<ul>
<li>java web应用，除了返回json类数据之外还可能返回网页，js，css</li>
<li>我们通过 <code>@ResponseBody</code>来表明一个url返回的是json数据（通常情况下是这样的，不考虑自定义实现）</li>
<li>我们的<code>@Controller</code>中通过<code>@RequestMapping</code>定义的REST服务，返回的是静态资源</li>
<li>那么js,css,图片这些文件呢，在我们的web应用中并不会定义一个REST服务</li>
<li>所以当接收一个http请求，找不到url关联映射时，默认场景下不认为这是一个<code>NoHandlerFoundException</code>，不抛异常，而是到静态资源中去找了(静态资源中也没有，为啥不抛NoHandlerFoundException呢？这个异常表示这个url请求没有对应的处理器，但是我们这里呢，给它分配到了静态资源处理器了<code>ResourceHttpRequestHandler</code>)</li>
</ul>
<p>针对上面这点，如果有兴趣深挖的同学，这里给出关键代码位置</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. 小结</h3>
<p>本篇博文虽然也介绍了一种新的全局异常处理方式，实现效果和<code>ControllerAdvice</code>也差不多，但是并不推荐用这种方法, 原因如下</p>
<ul>
<li><code>HandlerExceptionResolver</code>的方式没有<code>ControllerAdvice</code>方式简介优雅</li>
<li>官方提供的<code>DefaultHandlerExceptionResolver</code>已经非常强大了，基本上覆盖了http的各种状态码，我们自己再去定制的必要性不大</li>
</ul>
<h2> II. 其他</h2>
<h4> web系列博文</h4>
<ul>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484344&amp;idx=1&amp;sn=d4b1422a709d9540583e33443aab6fff&amp;chksm=fce71814cb9091025a960312c878ff9fc4f44fd0035aa597f55f37c90dcbac25a3e96ee2c528&amp;token=118864495&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">191010-SpringBoot系列教程web篇之全局异常处理</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484336&amp;idx=1&amp;sn=d70f15e77bbd219af8015f9037a167fb&amp;chksm=fce7181ccb90910aee427a3f3ed7660e8303c7460859c82622a651ce1cc3d7a97f62f80ed4e0&amp;token=2447275&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">190930-SpringBoot系列教程web篇之404、500异常页面配置</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484322&amp;idx=1&amp;sn=b18090f35b59097f78858b6609506b74&amp;chksm=fce7180ecb909118d939f3ddf741a11c0977b1213d7afa12c970590590d40441c3a085c43c52&amp;token=2447275&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">190929-SpringBoot系列教程web篇之重定向</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484310&amp;idx=1&amp;sn=f6259cf1b79db095ff2e9534993d27cf&amp;chksm=fce7183acb90912cd150f086e90ecab3eceb3464e9352853e2e722288d412dbb3eb20c6e6ae7&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190913-SpringBoot系列教程web篇之返回文本、网页、图片的操作姿势</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484309&amp;idx=1&amp;sn=33d782f7529268eef6607a1ab8d41018&amp;chksm=fce71839cb90912f6020aa9463bc0136cb57969ebe27eba865d97e212c28211435791aa874ea&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190905-SpringBoot系列教程web篇之中文乱码问题解决</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484291&amp;idx=1&amp;sn=3f7e8c92ca4d7270cc5c40cafea39683&amp;chksm=fce7182fcb90913922654a4f2f04e7029b8944d71c31741334a3235aecbe1e60babcb0c0be74&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190831-SpringBoot系列教程web篇之如何自定义参数解析器</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484287&amp;idx=1&amp;sn=44461f564d6b04cbf1a5902dcb4f23c6&amp;chksm=fce718d3cb9091c5d730e63ae954c0831d53f3dd5af5d19d9c78b6009102838efaf56f7838ff&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190828-SpringBoot系列教程web篇之Post请求参数解析姿势汇总</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484282&amp;idx=1&amp;sn=a8d236d935ae24cfbe6977e24a479caa&amp;chksm=fce718d6cb9091c0dd8a6b113236f9ae9388fb026c9403c97bdf7505f773bd7330a43e3b269c&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190824-SpringBoot系列教程web篇之Get请求参数解析姿势汇总</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484268&amp;idx=3&amp;sn=9e8a6121dce291c65bd2b3d4fab24178&amp;chksm=fce718c0cb9091d6674fb809d68ca3dc3b1695162368481abf8dc094000412116d2f9971c54b&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190822-SpringBoot系列教程web篇之Beetl环境搭建</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484268&amp;idx=2&amp;sn=f800c001061eabe74e2cad915af1921a&amp;chksm=fce718c0cb9091d682b600673a0584955783f0d339248e34323efbea9b698560c432018717ef&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190820-SpringBoot系列教程web篇之Thymeleaf环境搭建</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484268&amp;idx=1&amp;sn=acd691729488d81a94c938151d5737ce&amp;chksm=fce718c0cb9091d63ef5f12893bb835c256a18318e791a0d193d00ef767ecfd019491d02e83d&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190816-SpringBoot系列教程web篇之Freemaker环境搭建</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484217&amp;idx=1&amp;sn=9fdf45d2261cdcf2ccaccaebfb5ef598&amp;chksm=fce71895cb90918361f1afd55a2b5fc9d65508913c1d793710afa79cae38bd9d57e32ad2c187&amp;token=2447275&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">190421-SpringBoot高级篇WEB之websocket的使用说明</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484197&amp;idx=1&amp;sn=0184953527f58058ee8c2bbcfc2689ec&amp;chksm=fce71889cb90919f9be003bf2487343f7952d6b33ab5ee5fb7251ae37a631d4c32e6d8a57528&amp;token=2447275&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">190327-Spring-RestTemplate之urlencode参数解析异常全程分析</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484193&amp;idx=1&amp;sn=d8a284fe0a2b8e1fefe07d892558f563&amp;chksm=fce7188dcb90919b1f8a2408bf955e37e88b043e2dbd59b5290ac1501e3d2d303512bac6af2c&amp;token=2447275&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">190317-Spring MVC之基于java config无xml配置的web应用构建</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484186&amp;idx=1&amp;sn=18db571b670815965ae9185830c4e88f&amp;chksm=fce718b6cb9091a054e0ac4be051341d8ce38ff8e40c5911302e3d6981206c14b80770590044&amp;token=2447275&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">190316-Spring MVC之基于xml配置的web应用构建</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484139&amp;idx=1&amp;sn=b4a5f3ca6215641c6bcf5123f2bfb501&amp;chksm=fce71947cb9090511042ae97a12cc975d2b199521e17980e685cccb5e0be91a8e932cef4eb76&amp;token=2447275&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">190213-SpringBoot文件上传异常之提示The temporary upload location xxx is not valid</a></li>
</ul>
<h4> 项目源码</h4>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>项目：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/209-web-error" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/209-web-error</a></li>
</ul>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="SpringBoot"/>
    <category term="WEB系列"/>
    <category term="Response"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2019-10-12T19:53:50.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">9.开启GZIP数据压缩</title>
    <id>https://liuyueyi.github.io/tutorial/spring/web/Response/191120-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8BWeb%E7%AF%87%E4%B9%8B%E5%BC%80%E5%90%AFGZIP%E6%95%B0%E6%8D%AE%E5%8E%8B%E7%BC%A9.html</id>
    <link href="https://liuyueyi.github.io/tutorial/spring/web/Response/191120-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8BWeb%E7%AF%87%E4%B9%8B%E5%BC%80%E5%90%AFGZIP%E6%95%B0%E6%8D%AE%E5%8E%8B%E7%BC%A9.html"/>
    <updated>2023-02-10T04:50:05.000Z</updated>
    <summary type="html"><![CDATA[<p>本篇可以归纳在性能调优篇，虽然内容非常简单，但效果可能出乎预料的好；</p>
<p>分享一个真实案例，我们的服务部署在海外，国内访问时访问服务时，响应有点夸张；某些返回数据比较大的接口，耗时在600ms+上，然而我们的服务rt却是在20ms以下，绝大部分的开销都花在了网络传输上</p>
<p>针对这样的场景，除了买云服务商的网络通道之外，另外一个直观的想法就是减少数据包的大小，直接在nginx层配置gzip压缩是一个方案，本文主要介绍下，SpringBoot如何开启gzip压缩</p>
]]></summary>
    <content type="html"><![CDATA[<p>本篇可以归纳在性能调优篇，虽然内容非常简单，但效果可能出乎预料的好；</p>
<p>分享一个真实案例，我们的服务部署在海外，国内访问时访问服务时，响应有点夸张；某些返回数据比较大的接口，耗时在600ms+上，然而我们的服务rt却是在20ms以下，绝大部分的开销都花在了网络传输上</p>
<p>针对这样的场景，除了买云服务商的网络通道之外，另外一个直观的想法就是减少数据包的大小，直接在nginx层配置gzip压缩是一个方案，本文主要介绍下，SpringBoot如何开启gzip压缩</p>
<!-- more -->
<h2> I. gizp压缩配置</h2>
<h3> 1. 配置</h3>
<p>SpringBoot默认是不开启gzip压缩的，需要我们手动开启，在配置文件中添加两行</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意下上面配置中的<code>mime-types</code>，在spring2.0+的版本中，默认值如下，所以一般我们不需要特意添加这个配置</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 测试</h3>
<p>写一个测试的demo</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/191120/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>下面是开启压缩前后的数据报对比</p>
<figure><img src="/imgs/191120/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 3. 说明</h3>
<p>虽然加上了上面的配置，开启了gzip压缩，但是需要注意并不是说所有的接口都会使用gzip压缩，默认情况下，仅会压缩2048字节以上的内容</p>
<p>如果我们需要修改这个值，通过修改配置即可</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> II. 其他</h2>
<h3> 0. 项目</h3>
<h4> web系列博文</h4>
<ul>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484356&amp;idx=1&amp;sn=7c80f55f875f8d9ed37ef618cd7852ff&amp;chksm=fce71868cb90917ec76ed23990a287b25dfecd6e60300a215ff9b85d9d9db32b3ba1c7b549c7&amp;token=1964747263&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">191018-SpringBoot系列教程web篇之过滤器Filter使用指南扩展篇</a></li>
<li><a href="https://mp.weixin.qq.com/s/f01KWO3d2zhoN0Qa9-Qb6w" target="_blank" rel="noopener noreferrer">191016-SpringBoot系列教程web篇之过滤器Filter使用指南</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484348&amp;idx=1&amp;sn=e9b36572c721418b097396b50319d140&amp;chksm=fce71810cb9091063e810327e44f7ed07256188aecd352fa43f37e63e63dc64292b1a48b00cf&amp;token=823367253&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">191012-SpringBoot系列教程web篇之自定义异常处理HandlerExceptionResolver</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484344&amp;idx=1&amp;sn=d4b1422a709d9540583e33443aab6fff&amp;chksm=fce71814cb9091025a960312c878ff9fc4f44fd0035aa597f55f37c90dcbac25a3e96ee2c528&amp;token=118864495&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">191010-SpringBoot系列教程web篇之全局异常处理</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484336&amp;idx=1&amp;sn=d70f15e77bbd219af8015f9037a167fb&amp;chksm=fce7181ccb90910aee427a3f3ed7660e8303c7460859c82622a651ce1cc3d7a97f62f80ed4e0&amp;token=2447275&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">190930-SpringBoot系列教程web篇之404、500异常页面配置</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484322&amp;idx=1&amp;sn=b18090f35b59097f78858b6609506b74&amp;chksm=fce7180ecb909118d939f3ddf741a11c0977b1213d7afa12c970590590d40441c3a085c43c52&amp;token=2447275&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">190929-SpringBoot系列教程web篇之重定向</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484310&amp;idx=1&amp;sn=f6259cf1b79db095ff2e9534993d27cf&amp;chksm=fce7183acb90912cd150f086e90ecab3eceb3464e9352853e2e722288d412dbb3eb20c6e6ae7&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190913-SpringBoot系列教程web篇之返回文本、网页、图片的操作姿势</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484309&amp;idx=1&amp;sn=33d782f7529268eef6607a1ab8d41018&amp;chksm=fce71839cb90912f6020aa9463bc0136cb57969ebe27eba865d97e212c28211435791aa874ea&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190905-SpringBoot系列教程web篇之中文乱码问题解决</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484291&amp;idx=1&amp;sn=3f7e8c92ca4d7270cc5c40cafea39683&amp;chksm=fce7182fcb90913922654a4f2f04e7029b8944d71c31741334a3235aecbe1e60babcb0c0be74&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190831-SpringBoot系列教程web篇之如何自定义参数解析器</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484287&amp;idx=1&amp;sn=44461f564d6b04cbf1a5902dcb4f23c6&amp;chksm=fce718d3cb9091c5d730e63ae954c0831d53f3dd5af5d19d9c78b6009102838efaf56f7838ff&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190828-SpringBoot系列教程web篇之Post请求参数解析姿势汇总</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484282&amp;idx=1&amp;sn=a8d236d935ae24cfbe6977e24a479caa&amp;chksm=fce718d6cb9091c0dd8a6b113236f9ae9388fb026c9403c97bdf7505f773bd7330a43e3b269c&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190824-SpringBoot系列教程web篇之Get请求参数解析姿势汇总</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484268&amp;idx=3&amp;sn=9e8a6121dce291c65bd2b3d4fab24178&amp;chksm=fce718c0cb9091d6674fb809d68ca3dc3b1695162368481abf8dc094000412116d2f9971c54b&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190822-SpringBoot系列教程web篇之Beetl环境搭建</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484268&amp;idx=2&amp;sn=f800c001061eabe74e2cad915af1921a&amp;chksm=fce718c0cb9091d682b600673a0584955783f0d339248e34323efbea9b698560c432018717ef&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190820-SpringBoot系列教程web篇之Thymeleaf环境搭建</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484268&amp;idx=1&amp;sn=acd691729488d81a94c938151d5737ce&amp;chksm=fce718c0cb9091d63ef5f12893bb835c256a18318e791a0d193d00ef767ecfd019491d02e83d&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190816-SpringBoot系列教程web篇之Freemaker环境搭建</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484217&amp;idx=1&amp;sn=9fdf45d2261cdcf2ccaccaebfb5ef598&amp;chksm=fce71895cb90918361f1afd55a2b5fc9d65508913c1d793710afa79cae38bd9d57e32ad2c187&amp;token=2447275&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">190421-SpringBoot高级篇WEB之websocket的使用说明</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484197&amp;idx=1&amp;sn=0184953527f58058ee8c2bbcfc2689ec&amp;chksm=fce71889cb90919f9be003bf2487343f7952d6b33ab5ee5fb7251ae37a631d4c32e6d8a57528&amp;token=2447275&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">190327-Spring-RestTemplate之urlencode参数解析异常全程分析</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484193&amp;idx=1&amp;sn=d8a284fe0a2b8e1fefe07d892558f563&amp;chksm=fce7188dcb90919b1f8a2408bf955e37e88b043e2dbd59b5290ac1501e3d2d303512bac6af2c&amp;token=2447275&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">190317-Spring MVC之基于java config无xml配置的web应用构建</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484186&amp;idx=1&amp;sn=18db571b670815965ae9185830c4e88f&amp;chksm=fce718b6cb9091a054e0ac4be051341d8ce38ff8e40c5911302e3d6981206c14b80770590044&amp;token=2447275&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">190316-Spring MVC之基于xml配置的web应用构建</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484139&amp;idx=1&amp;sn=b4a5f3ca6215641c6bcf5123f2bfb501&amp;chksm=fce71947cb9090511042ae97a12cc975d2b199521e17980e685cccb5e0be91a8e932cef4eb76&amp;token=2447275&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">190213-SpringBoot文件上传异常之提示The temporary upload location xxx is not valid</a></li>
</ul>
<h4> 项目源码</h4>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>项目：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/210-web-filter" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/210-web-filter</a></li>
</ul>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="SpringBoot"/>
    <category term="WEB系列"/>
    <category term="Response"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2019-11-20T22:11:39.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">10.RestTemplate 4xx/5xx 异常信息捕获</title>
    <id>https://liuyueyi.github.io/tutorial/spring/web/Response/200104-SpringWeb%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8BRestTemplate-4xx-5xx-%E5%BC%82%E5%B8%B8%E4%BF%A1%E6%81%AF%E6%8D%95%E8%8E%B7.html</id>
    <link href="https://liuyueyi.github.io/tutorial/spring/web/Response/200104-SpringWeb%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8BRestTemplate-4xx-5xx-%E5%BC%82%E5%B8%B8%E4%BF%A1%E6%81%AF%E6%8D%95%E8%8E%B7.html"/>
    <updated>2023-02-10T04:50:05.000Z</updated>
    <summary type="html"><![CDATA[<p>近期使用RestTemplate访问外部资源时，发现一个有意思的问题。因为权限校验失败，对方返回的401的http code，此外返回数据中也会包含一些异常提示信息；然而在使用RestTemplate访问时，却是直接抛了如下提示401的异常，并不能拿到提示信息</p>
<figure><img src="/imgs/200104/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>那么RestTemplate如果希望可以获取到非200状态码返回数据时，可以怎么操作呢？</p>
]]></summary>
    <content type="html"><![CDATA[<p>近期使用RestTemplate访问外部资源时，发现一个有意思的问题。因为权限校验失败，对方返回的401的http code，此外返回数据中也会包含一些异常提示信息；然而在使用RestTemplate访问时，却是直接抛了如下提示401的异常，并不能拿到提示信息</p>
<figure><img src="/imgs/200104/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>那么RestTemplate如果希望可以获取到非200状态码返回数据时，可以怎么操作呢？</p>
<!-- more -->
<h2> I. 异常捕获</h2>
<h3> 1. 问题分析</h3>
<p>RestTemplate的异常处理，是借助<code>org.springframework.web.client.ResponseErrorHandler</code>来做的，先看一下两个核心方法</p>
<ul>
<li>下面代码来自 spring-web.5.0.7.RELEASE版本</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>简单来讲，当RestTemplate发出请求，获取到对方相应之后，会交给<code>ResponseErrorHandler</code>来判断一下，返回结果是否ok</p>
<p>因此接下来将目标瞄准到RestTemplate默认的异常处理器: <code>org.springframework.web.client.DefaultResponseErrorHandler</code></p>
<h4> a. 判定返回结果是否ok</h4>
<p>从源码上看，主要是根据返回的http code来判断是否ok</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>请注意上面的实现，自定义的某些http code是不会被认为是异常的，因为无法转换为对应的<code>HttpStatus</code> （后面实例进行说明）</p>
<h4> b. 异常处理</h4>
<p>当上面的 <code>hasError</code> 返回ture的时候，就会进入异常处理逻辑</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从上面也可以看到，异常处理逻辑很简单，直接抛异常</p>
<h3> 2. 异常捕获</h3>
<p>定位到上面的问题之后，再想解决问题就相对简单了，自定义一个异常处理类，不管状态码返回是啥，全都认为正常即可</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. 实测</h3>
<p>首先写两个结果，返回的http状态码非200；针对返回非200状态码的case，有多种写法，下面演示两种常见的</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>首先来看一下自定义的525和标准的401 http code，直接通过<code>RestTemplate</code>访问的case</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/200104/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>从上面的输出结果也可以看出来，非标准http code不会抛异常（原因上面有分析），接下来看一下即便是标准的http code也不希望抛异常的case</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/200104/02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> II. 其他</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
</ul>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="SpringBoot"/>
    <category term="WEB系列"/>
    <category term="Response"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2020-01-04T16:25:14.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">11.自定义返回Http Code的n种姿势</title>
    <id>https://liuyueyi.github.io/tutorial/spring/web/Response/200105-SpringBoot%E7%B3%BB%E5%88%97web%E7%AF%87%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BF%94%E5%9B%9EHttp-Code%E7%9A%84n%E7%A7%8D%E5%A7%BF%E5%8A%BF.html</id>
    <link href="https://liuyueyi.github.io/tutorial/spring/web/Response/200105-SpringBoot%E7%B3%BB%E5%88%97web%E7%AF%87%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BF%94%E5%9B%9EHttp-Code%E7%9A%84n%E7%A7%8D%E5%A7%BF%E5%8A%BF.html"/>
    <updated>2023-02-10T04:50:05.000Z</updated>
    <summary type="html"><![CDATA[<p>虽然http的提供了一整套完整、定义明确的状态码，但实际的业务支持中，后端并不总会遵守这套规则，更多的是在返回结果中，加一个code字段来自定义业务状态，即便是后端5xx了，返回给前端的http code依然是200</p>
<p>那么如果我想遵守http的规范，不同的case返回不同的http code在Spring中可以做呢?</p>
<p>本文将介绍四种设置返回的HTTP CODE的方式</p>
<ul>
<li><code>@ResponseStatus</code> 注解方式</li>
<li><code>HttpServletResponse#sendError</code></li>
<li><code>HttpServletResponse#setStatus</code></li>
<li><code>ResponseEntity</code></li>
</ul>
]]></summary>
    <content type="html"><![CDATA[<p>虽然http的提供了一整套完整、定义明确的状态码，但实际的业务支持中，后端并不总会遵守这套规则，更多的是在返回结果中，加一个code字段来自定义业务状态，即便是后端5xx了，返回给前端的http code依然是200</p>
<p>那么如果我想遵守http的规范，不同的case返回不同的http code在Spring中可以做呢?</p>
<p>本文将介绍四种设置返回的HTTP CODE的方式</p>
<ul>
<li><code>@ResponseStatus</code> 注解方式</li>
<li><code>HttpServletResponse#sendError</code></li>
<li><code>HttpServletResponse#setStatus</code></li>
<li><code>ResponseEntity</code></li>
</ul>
<!-- more -->
<h2> I. 返回Http Code的n中姿势</h2>
<h3> 0. 环境</h3>
<p>进入正文之前，先创建一个SpringBoot项目，本文示例所有版本为 <code>spring-boot.2.1.2.RELEASE</code></p>
<p>(需要测试的小伙伴，本机创建一个maven项目，在<code>pom.xml</code>文件中，拷贝下面的配置即可)</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>下面所有的方法都放在ErrorCodeRest这个类中</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1. ResponseStatus使用姿势</h3>
<p>通过注解<code>@ResponseStatus</code>，来指定返回的http code, 一般来说，使用它有两种姿势，一个是直接加在方法上，一个是加在异常类上</p>
<h4> a. 装饰方法</h4>
<p>直接在方法上添加注解，并制定对应的code</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>实测一下，返回结果如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当我们发起请求时，返回的状态码为400，返回的数据为springboot默认的错误信息格式</p>
<p>虽然上面这种使用姿势可以设置http code，但是这种使用姿势有什么意义呢？</p>
<p>如果看过web系列教程中的：<a href="http://spring.hhui.top/spring-blog/2019/10/10/191010-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8Bweb%E7%AF%87%E4%B9%8B%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/" target="_blank" rel="noopener noreferrer">SpringBoot系列教程web篇之全局异常处理</a> 可能就会有一些映象，配合<code>@ExceptionHandler</code>来根据异常返回对应的状态码</p>
<p>一个推荐的使用姿势，下面表示当你的业务逻辑中出现数组越界时，返回500的状态码以及完整的堆栈信息</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> b. 装饰异常类</h4>
<p>另外一种使用姿势就是直接装饰在异常类上，然后当你的业务代码中，抛出特定的异常类，返回的httpcode就会设置为注解中的值</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>测试结果如下，在异常类上添加注解的方式，优点在于不需要配合<code>@ExceptionHandler</code>写额外的逻辑了；缺点则在于需要定义很多的自定义异常类型</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>注意</strong></p>
<ul>
<li>ResponseStatus注解的使用姿势，只支持标准的Http Code（必须是枚举类<code>org.springframework.http.HttpStatus</code>）</li>
</ul>
<h3> 2. ResponseEntity</h3>
<p>这种使用姿势就比较简单了，方法的返回结果必须是<code>ResponseEntity</code>，下面给出两个实际的case</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>实测结果</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从上面的使用实例上看，可以知道这种使用方式，不仅仅支持标准的http code，也支持自定义的code（如返回code 451)</p>
<h3> 3. HttpServletResponse</h3>
<p>这种使用姿势则是直接操作<code>HttpServletResponse</code>对象，手动录入返回的结果</p>
<h4> a. setStatus</h4>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用方式比较简单，直接设置status即可，支持自定义的Http Code返回</p>
<h4> b. sendError</h4>
<p>使用这种姿势的时候需要注意一下，只支持标准的http code，而且response body中不会有你的业务返回数据，如</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从上面的case也可以看出，当我们使用send error时，如果是标准的http code，会设置对响应头；如果是自定义的不被识别的code，那么返回的http code是500</p>
<h3> 4, 小结</h3>
<p>上面介绍了几种常见的设置响应http code的姿势，下面小结一下使用时的注意事项</p>
<p><strong>ResponseStatus</strong></p>
<ul>
<li>只支持标准的http code</li>
<li>装饰自定义异常类，使用时抛出对应的异常类，从而达到设置响应code的效果
<ul>
<li>缺点对非可控的异常类不可用</li>
</ul>
</li>
<li>结合<code>@ExceptionHandler</code>，用来装饰方法</li>
</ul>
<p><strong>ResponseEntity</strong></p>
<p>形如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul>
<li>我个人感觉是最强大的使用姿势，就是写起来没有那么简洁</li>
<li>支持自定义code，支持设置 response body</li>
</ul>
<p><strong>HttpServletResponse</strong></p>
<ul>
<li>setStatus: 设置响应code，支持自定义code，支持返回response body</li>
<li>sendError: 只支持标准的http code，如果传入自定义的code，返回的http code会是500</li>
</ul>
<h2> II. 其他</h2>
<h4> web系列博文</h4>
<ul>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484419&amp;idx=1&amp;sn=d04d591f6f3af7b594b2940febf3b5a1" target="_blank" rel="noopener noreferrer">191222-SpringBoot系列教程web篇之自定义请求匹配条件RequestCondition</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484393&amp;idx=1&amp;sn=84babe4c83fa49fe54605e156f81a18f&amp;chksm=fce71845cb9091533190e99f2928585aea56562312d087f2b2b0e5ae4f082e3393023349e903&amp;token=713643402&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">191206-SpringBoot系列教程web篇Listener四种注册姿势</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484377&amp;idx=1&amp;sn=a20ce7e5e04ede4dff5fa84a7c5c8448&amp;chksm=fce71875cb9091639124afa69d0ec7bbf8f50438fd7acaf582fb029b7a4adf2f36fa50d4f0fa&amp;token=1748723444&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">191122-SpringBoot系列教程web篇Servlet 注册的四种姿势</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484377&amp;idx=2&amp;sn=b341d12c8179ba803d5c82882d9799ee&amp;chksm=fce71875cb90916376c76a901187b396595082c8ab3bd9df699227132430b9a40d2b07b30638&amp;token=713643402&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">191120-SpringBoot系列教程Web篇之开启GZIP数据压缩</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484356&amp;idx=1&amp;sn=7c80f55f875f8d9ed37ef618cd7852ff&amp;chksm=fce71868cb90917ec76ed23990a287b25dfecd6e60300a215ff9b85d9d9db32b3ba1c7b549c7&amp;token=713643402&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">191018-SpringBoot系列教程web篇之过滤器Filter使用指南扩展篇</a></li>
<li><a href="https://mp.weixin.qq.com/s/f01KWO3d2zhoN0Qa9-Qb6w" target="_blank" rel="noopener noreferrer">191016-SpringBoot系列教程web篇之过滤器Filter使用指南</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484348&amp;idx=1&amp;sn=e9b36572c721418b097396b50319d140&amp;chksm=fce71810cb9091063e810327e44f7ed07256188aecd352fa43f37e63e63dc64292b1a48b00cf&amp;token=823367253&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">191012-SpringBoot系列教程web篇之自定义异常处理HandlerExceptionResolver</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484344&amp;idx=1&amp;sn=d4b1422a709d9540583e33443aab6fff&amp;chksm=fce71814cb9091025a960312c878ff9fc4f44fd0035aa597f55f37c90dcbac25a3e96ee2c528&amp;token=118864495&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">191010-SpringBoot系列教程web篇之全局异常处理</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484336&amp;idx=1&amp;sn=d70f15e77bbd219af8015f9037a167fb&amp;chksm=fce7181ccb90910aee427a3f3ed7660e8303c7460859c82622a651ce1cc3d7a97f62f80ed4e0&amp;token=2447275&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">190930-SpringBoot系列教程web篇之404、500异常页面配置</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484322&amp;idx=1&amp;sn=b18090f35b59097f78858b6609506b74&amp;chksm=fce7180ecb909118d939f3ddf741a11c0977b1213d7afa12c970590590d40441c3a085c43c52&amp;token=2447275&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">190929-SpringBoot系列教程web篇之重定向</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484310&amp;idx=1&amp;sn=f6259cf1b79db095ff2e9534993d27cf&amp;chksm=fce7183acb90912cd150f086e90ecab3eceb3464e9352853e2e722288d412dbb3eb20c6e6ae7&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190913-SpringBoot系列教程web篇之返回文本、网页、图片的操作姿势</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484309&amp;idx=1&amp;sn=33d782f7529268eef6607a1ab8d41018&amp;chksm=fce71839cb90912f6020aa9463bc0136cb57969ebe27eba865d97e212c28211435791aa874ea&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190905-SpringBoot系列教程web篇之中文乱码问题解决</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484291&amp;idx=1&amp;sn=3f7e8c92ca4d7270cc5c40cafea39683&amp;chksm=fce7182fcb90913922654a4f2f04e7029b8944d71c31741334a3235aecbe1e60babcb0c0be74&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190831-SpringBoot系列教程web篇之如何自定义参数解析器</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484287&amp;idx=1&amp;sn=44461f564d6b04cbf1a5902dcb4f23c6&amp;chksm=fce718d3cb9091c5d730e63ae954c0831d53f3dd5af5d19d9c78b6009102838efaf56f7838ff&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190828-SpringBoot系列教程web篇之Post请求参数解析姿势汇总</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484282&amp;idx=1&amp;sn=a8d236d935ae24cfbe6977e24a479caa&amp;chksm=fce718d6cb9091c0dd8a6b113236f9ae9388fb026c9403c97bdf7505f773bd7330a43e3b269c&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190824-SpringBoot系列教程web篇之Get请求参数解析姿势汇总</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484268&amp;idx=3&amp;sn=9e8a6121dce291c65bd2b3d4fab24178&amp;chksm=fce718c0cb9091d6674fb809d68ca3dc3b1695162368481abf8dc094000412116d2f9971c54b&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190822-SpringBoot系列教程web篇之Beetl环境搭建</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484268&amp;idx=2&amp;sn=f800c001061eabe74e2cad915af1921a&amp;chksm=fce718c0cb9091d682b600673a0584955783f0d339248e34323efbea9b698560c432018717ef&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190820-SpringBoot系列教程web篇之Thymeleaf环境搭建</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484268&amp;idx=1&amp;sn=acd691729488d81a94c938151d5737ce&amp;chksm=fce718c0cb9091d63ef5f12893bb835c256a18318e791a0d193d00ef767ecfd019491d02e83d&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190816-SpringBoot系列教程web篇之Freemaker环境搭建</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484217&amp;idx=1&amp;sn=9fdf45d2261cdcf2ccaccaebfb5ef598&amp;chksm=fce71895cb90918361f1afd55a2b5fc9d65508913c1d793710afa79cae38bd9d57e32ad2c187&amp;token=2447275&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">190421-SpringBoot高级篇WEB之websocket的使用说明</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484197&amp;idx=1&amp;sn=0184953527f58058ee8c2bbcfc2689ec&amp;chksm=fce71889cb90919f9be003bf2487343f7952d6b33ab5ee5fb7251ae37a631d4c32e6d8a57528&amp;token=2447275&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">190327-Spring-RestTemplate之urlencode参数解析异常全程分析</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484193&amp;idx=1&amp;sn=d8a284fe0a2b8e1fefe07d892558f563&amp;chksm=fce7188dcb90919b1f8a2408bf955e37e88b043e2dbd59b5290ac1501e3d2d303512bac6af2c&amp;token=2447275&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">190317-Spring MVC之基于java config无xml配置的web应用构建</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484186&amp;idx=1&amp;sn=18db571b670815965ae9185830c4e88f&amp;chksm=fce718b6cb9091a054e0ac4be051341d8ce38ff8e40c5911302e3d6981206c14b80770590044&amp;token=2447275&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">190316-Spring MVC之基于xml配置的web应用构建</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484139&amp;idx=1&amp;sn=b4a5f3ca6215641c6bcf5123f2bfb501&amp;chksm=fce71947cb9090511042ae97a12cc975d2b199521e17980e685cccb5e0be91a8e932cef4eb76&amp;token=2447275&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">190213-SpringBoot文件上传异常之提示The temporary upload location xxx is not valid</a></li>
</ul>
<p><strong>项目源码</strong></p>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>项目：<a href="https://github.com/liuyueyi/spring-boot-demo/blob/master/spring-boot/207-web-response" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/blob/master/spring-boot/207-web-response</a></li>
</ul>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="SpringBoot"/>
    <category term="WEB系列"/>
    <category term="Response"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2020-01-05T10:02:49.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">12.异步请求知识点与使用姿势小结</title>
    <id>https://liuyueyi.github.io/tutorial/spring/web/Response/200329-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B9%8B%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82%E6%9C%80%E5%85%A8%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%8E%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF.html</id>
    <link href="https://liuyueyi.github.io/tutorial/spring/web/Response/200329-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B9%8B%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82%E6%9C%80%E5%85%A8%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%8E%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF.html"/>
    <updated>2023-02-10T04:50:05.000Z</updated>
    <summary type="html"><![CDATA[<p>在Servlet3.0就引入了异步请求的支持，但是在实际的业务开发中，可能用过这个特性的童鞋并不多？</p>
<p>本篇博文作为异步请求的扫盲和使用教程，将包含以下知识点</p>
<ul>
<li>什么是异步请求，有什么特点，适用场景</li>
<li>四种使用姿势：
<ul>
<li>AsyncContext方式</li>
<li>Callable</li>
<li>WebAsyncTask</li>
<li>DeferredResult</li>
</ul>
</li>
</ul>
]]></summary>
    <content type="html"><![CDATA[<p>在Servlet3.0就引入了异步请求的支持，但是在实际的业务开发中，可能用过这个特性的童鞋并不多？</p>
<p>本篇博文作为异步请求的扫盲和使用教程，将包含以下知识点</p>
<ul>
<li>什么是异步请求，有什么特点，适用场景</li>
<li>四种使用姿势：
<ul>
<li>AsyncContext方式</li>
<li>Callable</li>
<li>WebAsyncTask</li>
<li>DeferredResult</li>
</ul>
</li>
</ul>
<!-- more -->
<h2> I. 异步请求</h2>
<p>异步对于我们而言，应该属于经常可以听到的词汇了，在实际的开发中多多少少都会用到，那么什么是异步请求呢</p>
<h3> 1. 异步请求描述</h3>
<p><strong>先介绍一下同步与异步：</strong></p>
<p>一个正常调用，吭哧吭哧执行完毕之后直接返回，这个叫同步；</p>
<p>接收到调用，自己不干，新开一个线程来做，主线程自己则去干其他的事情，等后台线程吭哧吭哧的跑完之后，主线程再返回结果，这个就叫异步</p>
<p><strong>异步请求：</strong></p>
<p>我们这里讲到的异步请求，主要是针对web请求而言，后端响应请求的一种手段，同步/异步对于前端而言是无感知、无区别的</p>
<p>同步请求，后端接收到请求之后，直接在处理请求线程中，执行业务逻辑，并返回</p>
<figure><img src="/imgs/200329/00.jpg" alt="来源于网络" tabindex="0" loading="lazy"><figcaption>来源于网络</figcaption></figure>
<p>异步请求，后端接收到请求之后，新开一个线程，来执行业务逻辑，释放请求线程，避免请求线程被大量耗时的请求沾满，导致服务不可用</p>
<figure><img src="/imgs/200329/01.jpg" alt="来源于网络" tabindex="0" loading="lazy"><figcaption>来源于网络</figcaption></figure>
<h3> 2. 特点</h3>
<p>通过上面两张图，可以知道异步请求的最主要特点</p>
<ul>
<li>业务线程，处理请求逻辑</li>
<li>请求处理线程立即释放，通过回调处理线程返回结果</li>
</ul>
<h3> 3. 场景分析</h3>
<p>从特点出发，也可以很容易看出异步请求，更适用于耗时的请求，快速的释放请求处理线程，避免web容器的请求线程被打满，导致服务不可用</p>
<p>举一个稍微极端一点的例子，比如我以前做过的一个多媒体服务，提供图片、音视频的编辑，这些服务接口有同步返回结果的也有异步返回结果的；同步返回结果的接口有快有慢，大部分耗时可能<code>&lt;10ms</code>，而有部分接口耗时则在几十甚至上百</p>
<p>这种场景下，耗时的接口就可以考虑用异步请求的方式来支持了，避免占用过多的请求处理线程，影响其他的服务</p>
<h2> II. 使用姿势</h2>
<p>接下来介绍四种异步请求的使用姿势，原理一致，只是使用的场景稍有不同</p>
<h3> 1. AsyncContext</h3>
<p>在Servlet3.0+之后就支持了异步请求，第一种方式比较原始，相当于直接借助Servlet的规范来实现，当然下面的case并不是直接创建一个servlet，而是借助<code>AsyncContext</code>来实现</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>完整的实现如上，简单的来看一下一般步骤</p>
<ul>
<li><code>javax.servlet.ServletRequest#startAsync()</code>获取<code>AsyncContext</code></li>
<li>添加监听器 <code>asyncContext.addListener(AsyncListener)</code>（这个是可选的）
<ul>
<li>用户请求开始、超时、异常、完成时回调</li>
</ul>
</li>
<li>设置超时时间 <code>asyncContext.setTimeout(3000L)</code> （可选）</li>
<li>异步任务<code>asyncContext.start(Runnable)</code></li>
</ul>
<h3> 2. Callable</h3>
<p>相比较于上面的复杂的示例，SpringMVC可以非常easy的实现，直接返回一个<code>Callable</code>即可</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>请注意上面的两种case，一个正常返回，一个业务执行过程中，抛出来异常</p>
<p>分别请求，输出如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>异常请求: <code>http://localhost:8080/call/exception</code></p>
<figure><img src="/imgs/200329/02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. WebAsyncTask</h3>
<p>callable的方式，非常直观简单，但是我们经常关注的超时+异常的处理却不太好，这个时候我们可以用<code>WebAsyncTask</code>，实现姿势也很简单，包装一下<code>callable</code>，然后设置各种回调事件即可</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4. DeferredResult</h3>
<p><code>DeferredResult</code>与<code>WebAsyncTask</code>最大的区别就是前者不确定什么时候会返回结果，</p>
<blockquote>
<p><code>DeferredResult</code>的这个特点，可以用来做实现很多有意思的东西，如后面将介绍的<code>SseEmitter</code>就用到了它</p>
</blockquote>
<p>下面给出一个实例</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面的实例中，用户如果先访问<code>http://localhost:8080/defer/get?id=yihuihui</code>，不会立马有结果，直到用户再次访问<code>http://localhost:8080/defer/pub?id=yihuihui&amp;content=哈哈</code>时，前面的请求才会有结果返回</p>
<figure><img src="/imgs/200329/03.gif" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>那么这个可以设置超时么，如果一直把前端挂住，貌似也不太合适吧</p>
<ul>
<li>在构造方法中指定超时时间: <code>new DeferredResult&lt;&gt;(3000L)</code></li>
<li>设置全局的默认超时时间</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> II. 其他</h2>
<h3> 0. 项目</h3>
<p><strong>相关博文</strong></p>
<ul>
<li><a href="https://www.cnblogs.com/bjlhx/p/10444814.html" target="_blank" rel="noopener noreferrer">007-优化web请求三-异步调用【WebAsyncTask】</a></li>
<li><a href="https://blog.csdn.net/f641385712/article/details/88692534" target="_blank" rel="noopener noreferrer">高性能关键技术之---体验Spring MVC的异步模式（Callable、WebAsyncTask、DeferredResult） 基础使用篇</a></li>
</ul>
<p><strong>系列博文</strong></p>
<ul>
<li><a href="http://spring.hhui.top/spring-blog/2020/01/05/200105-SpringBoot%E7%B3%BB%E5%88%97web%E7%AF%87%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BF%94%E5%9B%9EHttp-Code%E7%9A%84n%E7%A7%8D%E5%A7%BF%E5%8A%BF/" target="_blank" rel="noopener noreferrer">200105-SpringBoot系列web篇之自定义返回Http-Code的n种姿势</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484419&amp;idx=1&amp;sn=d04d591f6f3af7b594b2940febf3b5a1" target="_blank" rel="noopener noreferrer">191222-SpringBoot系列教程web篇之自定义请求匹配条件RequestCondition</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484393&amp;idx=1&amp;sn=84babe4c83fa49fe54605e156f81a18f&amp;chksm=fce71845cb9091533190e99f2928585aea56562312d087f2b2b0e5ae4f082e3393023349e903&amp;token=713643402&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">191206-SpringBoot系列教程web篇Listener四种注册姿势</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484377&amp;idx=1&amp;sn=a20ce7e5e04ede4dff5fa84a7c5c8448&amp;chksm=fce71875cb9091639124afa69d0ec7bbf8f50438fd7acaf582fb029b7a4adf2f36fa50d4f0fa&amp;token=1748723444&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">191122-SpringBoot系列教程web篇Servlet 注册的四种姿势</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484377&amp;idx=2&amp;sn=b341d12c8179ba803d5c82882d9799ee&amp;chksm=fce71875cb90916376c76a901187b396595082c8ab3bd9df699227132430b9a40d2b07b30638&amp;token=713643402&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">191120-SpringBoot系列教程Web篇之开启GZIP数据压缩</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484356&amp;idx=1&amp;sn=7c80f55f875f8d9ed37ef618cd7852ff&amp;chksm=fce71868cb90917ec76ed23990a287b25dfecd6e60300a215ff9b85d9d9db32b3ba1c7b549c7&amp;token=713643402&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">191018-SpringBoot系列教程web篇之过滤器Filter使用指南扩展篇</a></li>
<li><a href="https://mp.weixin.qq.com/s/f01KWO3d2zhoN0Qa9-Qb6w" target="_blank" rel="noopener noreferrer">191016-SpringBoot系列教程web篇之过滤器Filter使用指南</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484348&amp;idx=1&amp;sn=e9b36572c721418b097396b50319d140&amp;chksm=fce71810cb9091063e810327e44f7ed07256188aecd352fa43f37e63e63dc64292b1a48b00cf&amp;token=823367253&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">191012-SpringBoot系列教程web篇之自定义异常处理HandlerExceptionResolver</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484344&amp;idx=1&amp;sn=d4b1422a709d9540583e33443aab6fff&amp;chksm=fce71814cb9091025a960312c878ff9fc4f44fd0035aa597f55f37c90dcbac25a3e96ee2c528&amp;token=118864495&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">191010-SpringBoot系列教程web篇之全局异常处理</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484336&amp;idx=1&amp;sn=d70f15e77bbd219af8015f9037a167fb&amp;chksm=fce7181ccb90910aee427a3f3ed7660e8303c7460859c82622a651ce1cc3d7a97f62f80ed4e0&amp;token=2447275&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">190930-SpringBoot系列教程web篇之404、500异常页面配置</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484322&amp;idx=1&amp;sn=b18090f35b59097f78858b6609506b74&amp;chksm=fce7180ecb909118d939f3ddf741a11c0977b1213d7afa12c970590590d40441c3a085c43c52&amp;token=2447275&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">190929-SpringBoot系列教程web篇之重定向</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484310&amp;idx=1&amp;sn=f6259cf1b79db095ff2e9534993d27cf&amp;chksm=fce7183acb90912cd150f086e90ecab3eceb3464e9352853e2e722288d412dbb3eb20c6e6ae7&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190913-SpringBoot系列教程web篇之返回文本、网页、图片的操作姿势</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484309&amp;idx=1&amp;sn=33d782f7529268eef6607a1ab8d41018&amp;chksm=fce71839cb90912f6020aa9463bc0136cb57969ebe27eba865d97e212c28211435791aa874ea&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190905-SpringBoot系列教程web篇之中文乱码问题解决</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484291&amp;idx=1&amp;sn=3f7e8c92ca4d7270cc5c40cafea39683&amp;chksm=fce7182fcb90913922654a4f2f04e7029b8944d71c31741334a3235aecbe1e60babcb0c0be74&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190831-SpringBoot系列教程web篇之如何自定义参数解析器</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484287&amp;idx=1&amp;sn=44461f564d6b04cbf1a5902dcb4f23c6&amp;chksm=fce718d3cb9091c5d730e63ae954c0831d53f3dd5af5d19d9c78b6009102838efaf56f7838ff&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190828-SpringBoot系列教程web篇之Post请求参数解析姿势汇总</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484282&amp;idx=1&amp;sn=a8d236d935ae24cfbe6977e24a479caa&amp;chksm=fce718d6cb9091c0dd8a6b113236f9ae9388fb026c9403c97bdf7505f773bd7330a43e3b269c&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190824-SpringBoot系列教程web篇之Get请求参数解析姿势汇总</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484268&amp;idx=3&amp;sn=9e8a6121dce291c65bd2b3d4fab24178&amp;chksm=fce718c0cb9091d6674fb809d68ca3dc3b1695162368481abf8dc094000412116d2f9971c54b&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190822-SpringBoot系列教程web篇之Beetl环境搭建</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484268&amp;idx=2&amp;sn=f800c001061eabe74e2cad915af1921a&amp;chksm=fce718c0cb9091d682b600673a0584955783f0d339248e34323efbea9b698560c432018717ef&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190820-SpringBoot系列教程web篇之Thymeleaf环境搭建</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484268&amp;idx=1&amp;sn=acd691729488d81a94c938151d5737ce&amp;chksm=fce718c0cb9091d63ef5f12893bb835c256a18318e791a0d193d00ef767ecfd019491d02e83d&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190816-SpringBoot系列教程web篇之Freemaker环境搭建</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484217&amp;idx=1&amp;sn=9fdf45d2261cdcf2ccaccaebfb5ef598&amp;chksm=fce71895cb90918361f1afd55a2b5fc9d65508913c1d793710afa79cae38bd9d57e32ad2c187&amp;token=2447275&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">190421-SpringBoot高级篇WEB之websocket的使用说明</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484197&amp;idx=1&amp;sn=0184953527f58058ee8c2bbcfc2689ec&amp;chksm=fce71889cb90919f9be003bf2487343f7952d6b33ab5ee5fb7251ae37a631d4c32e6d8a57528&amp;token=2447275&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">190327-Spring-RestTemplate之urlencode参数解析异常全程分析</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484193&amp;idx=1&amp;sn=d8a284fe0a2b8e1fefe07d892558f563&amp;chksm=fce7188dcb90919b1f8a2408bf955e37e88b043e2dbd59b5290ac1501e3d2d303512bac6af2c&amp;token=2447275&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">190317-Spring MVC之基于java config无xml配置的web应用构建</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484186&amp;idx=1&amp;sn=18db571b670815965ae9185830c4e88f&amp;chksm=fce718b6cb9091a054e0ac4be051341d8ce38ff8e40c5911302e3d6981206c14b80770590044&amp;token=2447275&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">190316-Spring MVC之基于xml配置的web应用构建</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484139&amp;idx=1&amp;sn=b4a5f3ca6215641c6bcf5123f2bfb501&amp;chksm=fce71947cb9090511042ae97a12cc975d2b199521e17980e685cccb5e0be91a8e932cef4eb76&amp;token=2447275&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">190213-SpringBoot文件上传异常之提示The temporary upload location xxx is not valid</a></li>
</ul>
<p><strong>源码</strong></p>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>项目源码: <a href="https://github.com/liuyueyi/spring-boot-demo/blob/master/spring-boot/219-web-asyn" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/blob/master/spring-boot/219-web-asyn</a></li>
</ul>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="SpringBoot"/>
    <category term="WEB系列"/>
    <category term="Response"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2020-03-29T16:47:54.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">13.SSE服务器发送事件详解</title>
    <id>https://liuyueyi.github.io/tutorial/spring/web/Response/200401-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B9%8BSSE%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%91%E9%80%81%E4%BA%8B%E4%BB%B6%E8%AF%A6%E8%A7%A3.html</id>
    <link href="https://liuyueyi.github.io/tutorial/spring/web/Response/200401-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B9%8BSSE%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%91%E9%80%81%E4%BA%8B%E4%BB%B6%E8%AF%A6%E8%A7%A3.html"/>
    <updated>2023-02-10T04:50:05.000Z</updated>
    <summary type="html"><![CDATA[<p>SSE全称<code>Server Sent Event</code>，直译一下就是服务器发送事件，一般的项目开发中，用到的机会不多，可能很多小伙伴不太清楚这个东西，到底是干啥的，有啥用</p>
<p>本文主要知识点如下：</p>
<ul>
<li>SSE扫盲，应用场景分析</li>
<li>借助异步请求实现sse功能，加深概念理解</li>
<li>使用<code>SseEmitter</code>实现一个简单的推送示例</li>
</ul>
]]></summary>
    <content type="html"><![CDATA[<p>SSE全称<code>Server Sent Event</code>，直译一下就是服务器发送事件，一般的项目开发中，用到的机会不多，可能很多小伙伴不太清楚这个东西，到底是干啥的，有啥用</p>
<p>本文主要知识点如下：</p>
<ul>
<li>SSE扫盲，应用场景分析</li>
<li>借助异步请求实现sse功能，加深概念理解</li>
<li>使用<code>SseEmitter</code>实现一个简单的推送示例</li>
</ul>
<!-- more -->
<h2> I. SSE扫盲</h2>
<blockquote>
<p>对于sse基础概念比较清楚的可以跳过本节</p>
</blockquote>
<h3> 1. 概念介绍</h3>
<p>sse(<code>Server Sent Event</code>)，直译为服务器发送事件，顾名思义，也就是客户端可以获取到服务器发送的事件</p>
<p>我们常见的http交互方式是客户端发起请求，服务端响应，然后一次请求完毕；但是在sse的场景下，客户端发起请求，连接一直保持，服务端有数据就可以返回数据给客户端，这个返回可以是多次间隔的方式</p>
<h3> 2. 特点分析</h3>
<p>SSE最大的特点，可以简单规划为两个</p>
<ul>
<li>长连接</li>
<li>服务端可以向客户端推送信息</li>
</ul>
<p>了解websocket的小伙伴，可能也知道它也是长连接，可以推送信息，但是它们有一个明显的区别</p>
<p><strong>sse是单通道，只能服务端向客户端发消息；而webscoket是双通道</strong></p>
<p>那么为什么有了webscoket还要搞出一个sse呢？既然存在，必然有着它的优越之处</p>
<table>
<thead>
<tr>
<th>sse</th>
<th>websocket</th>
</tr>
</thead>
<tbody>
<tr>
<td>http协议</td>
<td>独立的websocket协议</td>
</tr>
<tr>
<td>轻量，使用简单</td>
<td>相对复杂</td>
</tr>
<tr>
<td>默认支持断线重连</td>
<td>需要自己实现断线重连</td>
</tr>
<tr>
<td>文本传输</td>
<td>二进制传输</td>
</tr>
<tr>
<td>支持自定义发送的消息类型</td>
<td>-</td>
</tr>
</tbody>
</table>
<h3> 3. 应用场景</h3>
<p>从sse的特点出发，我们可以大致的判断出它的应用场景，需要轮询获取服务端最新数据的case下，多半是可以用它的</p>
<p>比如显示当前网站在线的实时人数，法币汇率显示当前实时汇率，电商大促的实时成交额等等...</p>
<h2> II. 手动实现sse功能</h2>
<p>sse本身是有自己的一套玩法的，后面会进行说明，这一小节，则主要针对sse的两个特点<code>长连接 + 后端推送数据</code>，如果让我们自己来实现这样的一个接口，可以怎么做？</p>
<h3> 1. 项目创建</h3>
<p>借助SpringBoot <code>2.2.1.RELEASE</code>来创建一个用于演示的工程项目，核心的xml依赖如下</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 功能实现</h3>
<p>在Http1.1支持了长连接，请求头添加一个<code>Connection: keep-alive</code>即可</p>
<p>在这里我们借助异步请求来实现sse功能，至于什么是异步请求，推荐查看博文: <a href="http://spring.hhui.top/spring-blog/2020/03/29/200329-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B9%8B%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82%E6%9C%80%E5%85%A8%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%8E%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF/" target="_blank" rel="noopener noreferrer">【WEB系列】异步请求知识点与使用姿势小结</a></p>
<p>因为后端可以不定时返回数据，所以我们需要注意的就是需要保持连接，不要返回一次数据之后就断开了；其次就是需要设置请求头<code>Content-Type: text/event-stream;charset=UTF-8</code> （如果不是流的话会怎样？）</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>看一下上面的实现，基本上还是异步请求的那一套逻辑，请仔细看一下<code>callable</code>中的逻辑，有一个while循环，来保证长连接不中断</p>
<p>接下来我们新增两个接口，用来模拟后端给客户端发送消息，关闭连接的场景</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们简单的来演示下操作过程</p>
<figure><img src="/imgs/200401/00.gif" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> III. SseEmitter</h2>
<p>上面只是简单实现了sse的长连接 + 后端推送消息，但是与标准的SSE还是有区别的，sse有自己的规范，而我们上面的实现，实际上并没有管这个，导致的问题是前端按照sse的玩法来请求数据，可能并不能正常工作</p>
<h3> 1. sse规范</h3>
<p>在html5的定义中，服务端sse，一般需要遵循以下要求</p>
<p><strong>请求头</strong></p>
<p>开启长连接 + 流方式传递</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>数据格式</strong></p>
<p>服务端发送的消息，由message组成，其格式如下:</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>其中field有五种可能</p>
<ul>
<li>空: 即以<code>:</code>开头，表示注释，可以理解为服务端向客户端发送的心跳，确保连接不中断</li>
<li>data：数据</li>
<li>event: 事件，默认值</li>
<li>id: 数据标识符用id字段表示，相当于每一条数据的编号</li>
<li>retry: 重连时间</li>
</ul>
<h3> 2. 实现</h3>
<p>SpringBoot利用SseEmitter来支持sse，可以说非常简单了，直接返回<code>SseEmitter</code>对象即可；重写一下上面的逻辑</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的实现，用到了SseEmitter的几个方法，解释如下</p>
<ul>
<li><code>send()</code>: 发送数据，如果传入的是一个非<code>SseEventBuilder</code>对象，那么传递参数会被封装到data中</li>
<li><code>complete()</code>: 表示执行完毕，会断开连接</li>
<li><code>onTimeout()</code>: 超时回调触发</li>
<li><code>onCompletion()</code>: 结束之后的回调触发</li>
</ul>
<p>同样演示一下访问请求</p>
<figure><img src="/imgs/200401/01.gif" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>上图总的效果和前面的效果差不多，而且输出还待上了前缀，接下来我们写一个简单的html消费端，用来演示一下完整的sse的更多特性</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>将上面的html文件放在项目的<code>resources/static</code>目录下；然后修改一下前面的<code>SseRest</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们上面超时时间设置的比较短，用来测试下客户端的自动重连，如下，开启的日志不断增加</p>
<figure><img src="/imgs/200401/02.gif" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>其次将SseEmitter的超时时间设长一点，再试一下数据推送功能</p>
<figure><img src="/imgs/200401/03.gif" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>请注意上面的演示，当后端结束了长连接之后，客户端会自动重新再次连接，不用写外的重试逻辑了，就这么神奇</p>
<h3> 3. 小结</h3>
<p>本篇文章介绍了SSE的相关知识点，并对比websocket给出了sse的优点（至于啥优点请往上翻）</p>
<p>请注意，本文虽然介绍了两种sse的方式，第一种借助异步请求来实现，如果需要完成sse的规范要求，需要自己做一些适配，如果需要了解sse底层实现原理的话，可以参考一下；在实际的业务开发中，推荐使用<code>SseEmitter</code></p>
<h2> IV. 其他</h2>
<h3> 0. 项目</h3>
<p><strong>系列博文</strong></p>
<ul>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484567&amp;idx=1&amp;sn=de01a82e80c748aa6bb9fde8a51cae5b" target="_blank" rel="noopener noreferrer">200329-SpringBoot系列教程web篇之异步请求知识点与使用姿势小结</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484453&amp;idx=1&amp;sn=6d273ec9e6756d17e1b18dd88d322759" target="_blank" rel="noopener noreferrer">200105-SpringBoot系列教程web篇之自定义返回Http-Code的n种姿势</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484419&amp;idx=1&amp;sn=d04d591f6f3af7b594b2940febf3b5a1" target="_blank" rel="noopener noreferrer">191222-SpringBoot系列教程web篇之自定义请求匹配条件RequestCondition</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484393&amp;idx=1&amp;sn=84babe4c83fa49fe54605e156f81a18f&amp;chksm=fce71845cb9091533190e99f2928585aea56562312d087f2b2b0e5ae4f082e3393023349e903&amp;token=713643402&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">191206-SpringBoot系列教程web篇Listener四种注册姿势</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484377&amp;idx=1&amp;sn=a20ce7e5e04ede4dff5fa84a7c5c8448&amp;chksm=fce71875cb9091639124afa69d0ec7bbf8f50438fd7acaf582fb029b7a4adf2f36fa50d4f0fa&amp;token=1748723444&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">191122-SpringBoot系列教程web篇Servlet 注册的四种姿势</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484377&amp;idx=2&amp;sn=b341d12c8179ba803d5c82882d9799ee&amp;chksm=fce71875cb90916376c76a901187b396595082c8ab3bd9df699227132430b9a40d2b07b30638&amp;token=713643402&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">191120-SpringBoot系列教程Web篇之开启GZIP数据压缩</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484356&amp;idx=1&amp;sn=7c80f55f875f8d9ed37ef618cd7852ff&amp;chksm=fce71868cb90917ec76ed23990a287b25dfecd6e60300a215ff9b85d9d9db32b3ba1c7b549c7&amp;token=713643402&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">191018-SpringBoot系列教程web篇之过滤器Filter使用指南扩展篇</a></li>
<li><a href="https://mp.weixin.qq.com/s/f01KWO3d2zhoN0Qa9-Qb6w" target="_blank" rel="noopener noreferrer">191016-SpringBoot系列教程web篇之过滤器Filter使用指南</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484348&amp;idx=1&amp;sn=e9b36572c721418b097396b50319d140&amp;chksm=fce71810cb9091063e810327e44f7ed07256188aecd352fa43f37e63e63dc64292b1a48b00cf&amp;token=823367253&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">191012-SpringBoot系列教程web篇之自定义异常处理HandlerExceptionResolver</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484344&amp;idx=1&amp;sn=d4b1422a709d9540583e33443aab6fff&amp;chksm=fce71814cb9091025a960312c878ff9fc4f44fd0035aa597f55f37c90dcbac25a3e96ee2c528&amp;token=118864495&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">191010-SpringBoot系列教程web篇之全局异常处理</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484336&amp;idx=1&amp;sn=d70f15e77bbd219af8015f9037a167fb&amp;chksm=fce7181ccb90910aee427a3f3ed7660e8303c7460859c82622a651ce1cc3d7a97f62f80ed4e0&amp;token=2447275&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">190930-SpringBoot系列教程web篇之404、500异常页面配置</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484322&amp;idx=1&amp;sn=b18090f35b59097f78858b6609506b74&amp;chksm=fce7180ecb909118d939f3ddf741a11c0977b1213d7afa12c970590590d40441c3a085c43c52&amp;token=2447275&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">190929-SpringBoot系列教程web篇之重定向</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484310&amp;idx=1&amp;sn=f6259cf1b79db095ff2e9534993d27cf&amp;chksm=fce7183acb90912cd150f086e90ecab3eceb3464e9352853e2e722288d412dbb3eb20c6e6ae7&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190913-SpringBoot系列教程web篇之返回文本、网页、图片的操作姿势</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484309&amp;idx=1&amp;sn=33d782f7529268eef6607a1ab8d41018&amp;chksm=fce71839cb90912f6020aa9463bc0136cb57969ebe27eba865d97e212c28211435791aa874ea&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190905-SpringBoot系列教程web篇之中文乱码问题解决</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484291&amp;idx=1&amp;sn=3f7e8c92ca4d7270cc5c40cafea39683&amp;chksm=fce7182fcb90913922654a4f2f04e7029b8944d71c31741334a3235aecbe1e60babcb0c0be74&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190831-SpringBoot系列教程web篇之如何自定义参数解析器</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484287&amp;idx=1&amp;sn=44461f564d6b04cbf1a5902dcb4f23c6&amp;chksm=fce718d3cb9091c5d730e63ae954c0831d53f3dd5af5d19d9c78b6009102838efaf56f7838ff&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190828-SpringBoot系列教程web篇之Post请求参数解析姿势汇总</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484282&amp;idx=1&amp;sn=a8d236d935ae24cfbe6977e24a479caa&amp;chksm=fce718d6cb9091c0dd8a6b113236f9ae9388fb026c9403c97bdf7505f773bd7330a43e3b269c&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190824-SpringBoot系列教程web篇之Get请求参数解析姿势汇总</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484268&amp;idx=3&amp;sn=9e8a6121dce291c65bd2b3d4fab24178&amp;chksm=fce718c0cb9091d6674fb809d68ca3dc3b1695162368481abf8dc094000412116d2f9971c54b&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190822-SpringBoot系列教程web篇之Beetl环境搭建</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484268&amp;idx=2&amp;sn=f800c001061eabe74e2cad915af1921a&amp;chksm=fce718c0cb9091d682b600673a0584955783f0d339248e34323efbea9b698560c432018717ef&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190820-SpringBoot系列教程web篇之Thymeleaf环境搭建</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484268&amp;idx=1&amp;sn=acd691729488d81a94c938151d5737ce&amp;chksm=fce718c0cb9091d63ef5f12893bb835c256a18318e791a0d193d00ef767ecfd019491d02e83d&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190816-SpringBoot系列教程web篇之Freemaker环境搭建</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484217&amp;idx=1&amp;sn=9fdf45d2261cdcf2ccaccaebfb5ef598&amp;chksm=fce71895cb90918361f1afd55a2b5fc9d65508913c1d793710afa79cae38bd9d57e32ad2c187&amp;token=2447275&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">190421-SpringBoot高级篇WEB之websocket的使用说明</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484197&amp;idx=1&amp;sn=0184953527f58058ee8c2bbcfc2689ec&amp;chksm=fce71889cb90919f9be003bf2487343f7952d6b33ab5ee5fb7251ae37a631d4c32e6d8a57528&amp;token=2447275&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">190327-Spring-RestTemplate之urlencode参数解析异常全程分析</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484193&amp;idx=1&amp;sn=d8a284fe0a2b8e1fefe07d892558f563&amp;chksm=fce7188dcb90919b1f8a2408bf955e37e88b043e2dbd59b5290ac1501e3d2d303512bac6af2c&amp;token=2447275&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">190317-Spring MVC之基于java config无xml配置的web应用构建</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484186&amp;idx=1&amp;sn=18db571b670815965ae9185830c4e88f&amp;chksm=fce718b6cb9091a054e0ac4be051341d8ce38ff8e40c5911302e3d6981206c14b80770590044&amp;token=2447275&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">190316-Spring MVC之基于xml配置的web应用构建</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484139&amp;idx=1&amp;sn=b4a5f3ca6215641c6bcf5123f2bfb501&amp;chksm=fce71947cb9090511042ae97a12cc975d2b199521e17980e685cccb5e0be91a8e932cef4eb76&amp;token=2447275&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">190213-SpringBoot文件上传异常之提示The temporary upload location xxx is not valid</a></li>
</ul>
<p><strong>源码</strong></p>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>项目源码: <a href="https://github.com/liuyueyi/spring-boot-demo/blob/master/spring-boot/220-web-sse" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/blob/master/spring-boot/220-web-sse</a></li>
</ul>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="SpringBoot"/>
    <category term="WEB系列"/>
    <category term="Response"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2020-04-01T19:01:42.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">14.thymeleaf foreach踩坑记录</title>
    <id>https://liuyueyi.github.io/tutorial/spring/web/Response/211113-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8Bthymeleaf-foreach%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95.html</id>
    <link href="https://liuyueyi.github.io/tutorial/spring/web/Response/211113-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8Bthymeleaf-foreach%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95.html"/>
    <updated>2023-02-10T04:50:05.000Z</updated>
    <summary type="html"><![CDATA[<p>话说自从前后端分离之后，前后端放在一起的场景就很少了，最近写个简单的后台，突然踩坑了，使用themeleaf模板渲染时，发现<code>th:each</code>来遍历生成表单数据，一直抛异常，提示<code>Property or field 'xxx' cannot be found on null</code></p>
<p>接下来看一下这个问题到底是个什么情况</p>
]]></summary>
    <content type="html"><![CDATA[<p>话说自从前后端分离之后，前后端放在一起的场景就很少了，最近写个简单的后台，突然踩坑了，使用themeleaf模板渲染时，发现<code>th:each</code>来遍历生成表单数据，一直抛异常，提示<code>Property or field 'xxx' cannot be found on null</code></p>
<p>接下来看一下这个问题到底是个什么情况</p>
<!-- more -->
<h2> I. 项目搭建</h2>
<h3> 1. 项目依赖</h3>
<p>本项目借助<code>SpringBoot 2.2.1.RELEASE</code> + <code>maven 3.5.3</code> + <code>IDEA</code>进行开发</p>
<p>开一个web服务用于测试</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>配置文件application.yml</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> II. 问题复现与处理</h2>
<h3> 1. 场景复现</h3>
<p>一个最基础的demo，来演示一下问题</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对应的html文件如下(注意，放在资源目录 <code>templates</code> 下)</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意上面的模板，有两个each遍历，出现问题的是第二个</p>
<figure><img src="/imgs/211113/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 2. 原因说明</h3>
<p>上面提示user没有，那么是否是语法问题呢？将html改成下面这个时</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/211113/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>相同的写法，上面这个就可以，经过多方尝试，发现出现问题的原因居然是<code>&lt;p&gt;</code>这个标签</p>
<p>简单来讲，就是<code>&lt;p&gt;</code>标签不能使用<code>th:each</code>，测试一下其他的标签之后发现<code>&lt;img&gt;</code>，<code>&lt;input&gt;</code>标签也不能用</p>
<p>那么问题来了，为啥这几个标签不能使用each呢？</p>
<p>这个原因可能就需要去瞅一下实现逻辑了，有知道的小伙伴可以科普一下</p>
<h2> III. 不能错过的源码和相关知识点</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/</a></li>
</ul>
<h3> 1. 微信公众号: 一灰灰Blog</h3>
<p>尽信书则不如，以上内容，纯属一家之言，因个人能力有限，难免有疏漏和错误之处，如发现bug或者有更好的建议，欢迎批评指正，不吝感激</p>
<p>下面一灰灰的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛</p>
<ul>
<li>一灰灰Blog个人博客 <a href="https://blog.hhui.top" target="_blank" rel="noopener noreferrer">https://blog.hhui.top</a></li>
<li>一灰灰Blog-Spring专题博客 <a href="http://spring.hhui.top" target="_blank" rel="noopener noreferrer">http://spring.hhui.top</a></li>
</ul>
<figure><img src="https://spring.hhui.top/spring-blog/imgs/info/info.png" alt="一灰灰blog" tabindex="0" loading="lazy"><figcaption>一灰灰blog</figcaption></figure>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="SpringBoot"/>
    <category term="WEB系列"/>
    <category term="采坑记录"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2021-11-13T18:56:17.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">15.如何支持下划线驼峰互转的传参与返回</title>
    <id>https://liuyueyi.github.io/tutorial/spring/web/Response/220117-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8BWeb%E5%A6%82%E4%BD%95%E6%94%AF%E6%8C%81%E4%B8%8B%E5%88%92%E7%BA%BF%E9%A9%BC%E5%B3%B0%E4%BA%92%E8%BD%AC%E7%9A%84%E4%BC%A0%E5%8F%82%E4%B8%8E%E8%BF%94%E5%9B%9E.html</id>
    <link href="https://liuyueyi.github.io/tutorial/spring/web/Response/220117-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8BWeb%E5%A6%82%E4%BD%95%E6%94%AF%E6%8C%81%E4%B8%8B%E5%88%92%E7%BA%BF%E9%A9%BC%E5%B3%B0%E4%BA%92%E8%BD%AC%E7%9A%84%E4%BC%A0%E5%8F%82%E4%B8%8E%E8%BF%94%E5%9B%9E.html"/>
    <updated>2023-02-10T04:50:05.000Z</updated>
    <summary type="html"><![CDATA[<blockquote>
<p>SpringBoot系列之Web如何支持下划线驼峰互转的传参与返回</p>
</blockquote>
<p>接下来介绍一个非常现实的应用场景，有些时候后端接口对外定义的传参/返回都是下划线命名风格，但是Java本身是推荐驼峰命名方式的，那么必然就存在一个传参下换线，转换成驼峰的场景；以及在返回时，将驼峰命名的转换成下划线</p>
<p>那么如何支持上面这种应用场景呢?</p>
<p>本文介绍几种常见的手段</p>
]]></summary>
    <content type="html"><![CDATA[<blockquote>
<p>SpringBoot系列之Web如何支持下划线驼峰互转的传参与返回</p>
</blockquote>
<p>接下来介绍一个非常现实的应用场景，有些时候后端接口对外定义的传参/返回都是下划线命名风格，但是Java本身是推荐驼峰命名方式的，那么必然就存在一个传参下换线，转换成驼峰的场景；以及在返回时，将驼峰命名的转换成下划线</p>
<p>那么如何支持上面这种应用场景呢?</p>
<p>本文介绍几种常见的手段</p>
<!-- more -->
<h2> I. 项目搭建</h2>
<h3> 1. 项目依赖</h3>
<p>本项目借助<code>SpringBoot 2.2.1.RELEASE</code> + <code>maven 3.5.3</code> + <code>IDEA</code>进行开发</p>
<p>开一个web服务用于测试</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>配置文件application.yml</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 需求拆分</h3>
<p>接下来为了更方便的理解我们要做的事情，对上面的应用场景进行一些拆分，方便理解</p>
<h4> 2.1 请求参数解析</h4>
<p>对于请求参数，外部传递是下划线命名格式的方式，需要与项目中驼峰命名的对象进行映射，所以这里的问题点就是无法走默认的绑定规则，需要我们进行兼容处理</p>
<p>比如传参是 <code>user_name = 一灰灰</code>，但是我们接收的参数是 <code>userName</code></p>
<h4> 2.2 返回结果处理</h4>
<p>返回结果的处理，这里单指返回json对象的场景，一个普通的POJO对象，正常序列化为json字符串时，key实际上与对象的成员名是一致的，而现在则希望将key统一成下划线风格的方式</p>
<p>如，返回一个简单的实体对象</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对应期待返回的json串为</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> II. 支持方式</h2>
<p>为了简化后续的流程，我们这里的传参都确定两个userName + userId，对应项目中的实体类如</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1. 请求参数解析</h3>
<h4> 1.1 @RequestParam注解方式</h4>
<p>最简单也是最容易想到的方式自然是直接使用<code>RequestParam</code>注解，将所有的请求参数都通过它来重命名</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用上面直接来写参数映射关系的方式属于比较常见的方法了，但是存在一个问题</p>
<ul>
<li>通用性差（每个接口的每个参数都要这么整，如果工资是按照代码来付费的话，那还是可以接收的；否则这个写法，就真的有点难受了）</li>
<li>若接口参数定义的是Map、Java bean实体（POJO），这个映射关联就不太好处理了</li>
</ul>
<p>除了上面这个问题之外，有个不是问题的问题（为什么这么说，且看下面的说法）</p>
<ul>
<li>如果我的接口传参，希望同时接收驼峰和下划线命名的传参（现实中还真有这种神经病似的场景，别问我怎么知道的），上面这个是不行的</li>
</ul>
<h4> 1.2 Json传参指定命名策略</h4>
<p>上面的case，适用于常见的get请求，post表单传参，然后在接口处一一定义参数；对于post json传参时，我们可以考虑通过定义json序列化的命名策略，来支持下划线与驼峰的互转</p>
<p>比如SpringMVC默认使用的jackson来实现json序列化，那么我们可以直接通过指定jackson的PropertyNamingStrategy来完成</p>
<p>配置文件中 application.yml，添加下面这行</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对应的接口定义如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>实际请求之后，看一下效果</p>
<figure><img src="/imgs/220117/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p><strong>注意</strong></p>
<ul>
<li>使用上面这种配置的方式，需要特比注意的，如果在项目中自己定义了<code>WebMvcConfigurationSupport</code>，那么上面的配置将不会生效（至于具体的原因，后面有机会单独说明）</li>
</ul>
<p>当我们实际的项目中，无法直接使用上面这种配置时，可以考虑使用下面的方式</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用jackson的命名策略来支持驼峰下划线的转换虽好，但是存在一个非常明显的缺陷</p>
<ul>
<li>它只适用于json传参</li>
</ul>
<h4> 1.3 自定义DataBinder</h4>
<p>对于非json的传承，比如普通的get请求，post表单传参，然后在接口处通过定义一个POJO参数类来接收，此时又应该怎么处理呢?</p>
<p>比如接口定义如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对于上面这种场景，一个想法就是是否可以在ViewDo的成员上，添加一个注解，指定参数名，一如<code>RequestParam</code>，不过Spring貌似并没有提供这种支持能力</p>
<p>因此我们可以考虑自己来实现数据绑定，下面提供一个基础的实现, 来演示这种方式改怎么玩（相对完整的基于注解的映射方式，下篇博文介绍）</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后在参数解析中，使用这个DataBinder</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接着就是注册这个参数解析</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>再次请求时，可以发现下划线的传参也可以映射到ViewDo对象上(无论是get请求还是post请求，都可以正确映射)</p>
<figure><img src="/imgs/220117/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 2.返回结果</h3>
<p>对于返回结果，希望返回下划线格式的json串，除了上面介绍到的设置json序列化的命名策略之外，还有下面几种配置方式</p>
<h4> 2.1 属性注解 @JsonProperty</h4>
<p>直接在POJO对象的成员上，指定希望输出的name</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 2.2 实体类注解 @JsonNaming</h4>
<p>直接在类上添加注解，指定驼峰策略</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 2.3 全局配置</h4>
<p>上面两种缺点比较明显，不太通用；更通用的选择和前面传参的json序列化配置方式一样，两种姿势</p>
<p>配置文件指定</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>前面也说到，上面这种配置可能会失效（比如你设置了自己的WebMvcConfig)，推荐使用下面的方式</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. 小结</h3>
<p>本文主要介绍了几种实例case，用于实现传参/返回的驼峰与下划线的互转，核心策略，有下面几种</p>
<ul>
<li>传参：<code>@RequestParam</code> 指定真正的传参name</li>
<li>Json传参、返回：通过定义json序列化框架的PropertyNamingStrategy，来实现</li>
<li>普通表单传参/get传参，映射POJO时：通过自定义的DataBinder，来实现映射</li>
</ul>
<p>虽然上面几种姿势，可以满足我们的基本诉求，但是如果我希望实现一个通用的下划线/驼峰互转策略，即不管传参是下划线还是驼峰，都可以正确无误的绑定到接口的参数变量上，可以怎么实现呢？</p>
<p>最后再抛出一个问题，如果接收参数是Map，上面的几种实现姿势会生效么？又可以如何怎么处理map这种场景呢？</p>
<h2> III. 不能错过的源码和相关知识点</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/202-web-params-camel" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/202-web-params-camel</a></li>
</ul>
<h3> 1. 微信公众号: 一灰灰Blog</h3>
<p>尽信书则不如，以上内容，纯属一家之言，因个人能力有限，难免有疏漏和错误之处，如发现bug或者有更好的建议，欢迎批评指正，不吝感激</p>
<p>下面一灰灰的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛</p>
<ul>
<li>一灰灰Blog个人博客 <a href="https://blog.hhui.top" target="_blank" rel="noopener noreferrer">https://blog.hhui.top</a></li>
<li>一灰灰Blog-Spring专题博客 <a href="http://spring.hhui.top" target="_blank" rel="noopener noreferrer">http://spring.hhui.top</a></li>
</ul>
<figure><img src="https://spring.hhui.top/spring-blog/imgs/info/info.png" alt="一灰灰blog" tabindex="0" loading="lazy"><figcaption>一灰灰blog</figcaption></figure>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="SpringBoot"/>
    <category term="WEB系列"/>
    <category term="Request"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2022-01-17T19:09:53.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">16.定义接口返回类型的几种方式</title>
    <id>https://liuyueyi.github.io/tutorial/spring/web/Response/220817-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8B%E5%AE%9A%E4%B9%89%E6%8E%A5%E5%8F%A3%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F.html</id>
    <link href="https://liuyueyi.github.io/tutorial/spring/web/Response/220817-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8B%E5%AE%9A%E4%B9%89%E6%8E%A5%E5%8F%A3%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F.html"/>
    <updated>2023-02-10T04:50:05.000Z</updated>
    <summary type="html"><![CDATA[<p>实现一个web接口返回json数据，基本上是每一个javaer非常熟悉的事情了；那么问题来了，如果我有一个接口，除了希望返回json格式的数据之外，若也希望可以返回xml格式数据可行么？</p>
<p>答案当然是可行的，接下来我们将介绍一下，一个接口的返回数据类型，可以怎么处理</p>
]]></summary>
    <content type="html"><![CDATA[<p>实现一个web接口返回json数据，基本上是每一个javaer非常熟悉的事情了；那么问题来了，如果我有一个接口，除了希望返回json格式的数据之外，若也希望可以返回xml格式数据可行么？</p>
<p>答案当然是可行的，接下来我们将介绍一下，一个接口的返回数据类型，可以怎么处理</p>
<!-- more --> 
<h2> I. 项目搭建</h2>
<p>本文创建的实例工程采用<code>SpringBoot 2.2.1.RELEASE</code> + <code>maven 3.5.3</code> + <code>idea</code>进行开发</p>
<h3> 1. pom依赖</h3>
<p>具体的SpringBoot项目工程创建就不赘述了，对于pom文件中，需要重点关注下面两个依赖类</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意 <code>jackson-datafromat-xml</code>这个依赖，加上这个主要时为了支持返回xml格式的数据</p>
<h2> II. 返回类型设置的多种方式</h2>
<p>正常来讲，一个RestController的接口，默认返回的是Json格式数据，当我们引入了上面的xml包之后，会怎样呢？返回的还是json么？</p>
<h3> 1.通过produce设置返回类型</h3>
<p>如果一个接口希望返回json或者xml格式的数据，最容易想到的方式就是直接设置<code>RequestMapping</code>注解中的produce属性</p>
<p>这个值主要就是用来设置这个接口响应头中的<code>content-type</code>； 如我们现在有两个接口，一个指定返回json格式数据，一个指定返回xml格式数据，可以如下写</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的实现中</p>
<ul>
<li>xml接口，指定<code>produces = application/xml</code></li>
<li>json接口，指定<code>produces = applicatin/json</code></li>
</ul>
<p>接下来我们访问一下看看返回的是否和预期一致</p>
<figure><img src="/imgs/220817/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>从上面截图也可以看出，xml接口返回的是xml格式数据；json接口返回的是json格式数据</p>
<h3> 2. 通过请求头accept设置返回类型</h3>
<p>上面的方式，非常直观，自然我们就会有一个疑问，当接口上不指定produces属性时，直接访问会怎么表现呢？</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/220817/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>请注意上面的截图，两种访问方式返回的数据类型不一致</p>
<ul>
<li>curl请求：返回json格式数据</li>
<li>浏览器请求：返回 <code>application/xhtml+xml</code>响应头的数据（实际上还是xml格式）</li>
</ul>
<p>那么问题来了，为什么两者的表现形式不一致呢？</p>
<p>对着上面的图再看三秒，会发现主要的差别点就在于请求头<code>Accept</code>不同；我们可以通过这个请求头参数，来要求服务端返回我希望的数据类型</p>
<p>如指定返回json格式数据</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/220817/02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>从上面的执行结果也可以看出，返回的类型与预期的一致；</p>
<p><strong>说明</strong></p>
<p>请求头可以设置多种MediaType，用英文逗号分割，后端接口会根据自己定义的produce与请求头希望的mediaType取交集，至于最终选择的顺序则以accept中出现的顺序为准</p>
<p>看一下实际的表现来验证下上面的说法</p>
<figure><img src="/imgs/220817/03.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>通过请求头来控制返回数据类型的方式可以说是非常经典的策略了，（遵循html协议还有什么好说的呢！）</p>
<h3> 3. 请求参数来控制返回类型</h3>
<p>除了上面介绍的两种方式之外，还可以考虑为所有的接口，增加一个根据特定的请求参数来控制返回的类型的方式</p>
<p>比如我们现在定义，所有的接口可以选传一个参数 <code>mediaType</code>，如果值为xml，则返回xml格式数据；如果值为json，则返回json格式数据</p>
<p>当不传时，默认返回json格式数据</p>
<p>基于此，我们主要借助mvc配置中的内容协商<code>ContentNegotiationConfigurer</code>来实现</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的实现中，添加了很多注释，先别急；我来逐一进行说明</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这三行代码，主要就是说，现在可以根据传参 mediaType 来控制返回的类型，我们新增一个接口来验证一下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们来看下几个不同的传参表现</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/220817/04.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p><strong>疑问：若请求头中传递了Accept或者接口上定义了produce，会怎样?</strong></p>
<p>当指定了accept时，并且传参中指定了mediaType，则以传参为准</p>
<ul>
<li>如<code>accept: application/json,application.xml</code>， 此时<code>mediaType=json</code>, 返回json格式</li>
<li>如<code>accept: application/json</code>, 此时 <code>mediaTyep=xml</code>， 返回xml格式</li>
<li>如<code>accept: text/html</code>，此时<code>mediaType=xml</code> ，此时返回的也是xml格式</li>
<li>如<code>accept: text/html</code>，此时<code>mediaType</code>不传时 ，因为无法处理<code>text/html</code>类型，所以会出现406</li>
<li>如<code>accept: application/xml</code>， 但是<code>mediaType</code>不传，虽然默认优先是json，此时返回的也是xml格式，与请求头希望的保持一致</li>
</ul>
<p>但是若传参与produce冲突了，那么就直接406异常，不会选择mediaType设置的类型</p>
<ul>
<li>如<code>produce = applicatin/json</code>， 但是 <code>mediaType=xml</code>，此时就会喜提406</li>
</ul>
<p>细心的小伙伴可能发现了上面的配置中，注释了一行 <code>.ignoreAcceptHeader(true)</code>，当我们把它打开之后，前面说的Accept请求头可以随意传，我们完全不care，当做没有传这个参数进行处理即可开</p>
<h3> 4.小结</h3>
<p>本文介绍了三种方式，控制接口返回数据类型</p>
<p><strong>方式一</strong></p>
<p>接口上定义produce, 如 <code>@GetMapping(path = "p2", produces = {"application/xml", "application/json"})</code></p>
<p>注意produces属性值是有序的，即先定义的优先级更高；当一个请求可以同时接受xml/json格式数据时，上面这个定义会确保这个接口现有返回xml格式数据</p>
<p><strong>方式二</strong></p>
<p>借助标准的请求头accept，控制希望返回的数据类型；但是需要注意的时，使用这种方式时，要求后端不能设置<code>ContentNegotiationConfigurer.ignoreAcceptHeader(true)</code></p>
<p>在实际使用这种方式的时候，客户端需要额外注意，Accept请求头中定义的MediaType的顺序，是优于后端定义的produces顺序的，因此用户需要将自己实际希望接受的数据类型放在前面，或者干脆就只设置一个</p>
<p><strong>方式三</strong></p>
<p>借助<code>ContentNegotiationConfigurer</code>实现通过请求参数来决定返回类型，常见的配置方式形如</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>即添加这个设置之后，最终的表现为：</p>
<ol>
<li>请求参数指定的返回类型，优先级最高，返回指定参数对应的类型</li>
<li>没有指定参数时，选择defaultContentType定义的默认返回类型与接口 <code>produce</code>中支持的求交集，优先级则按照defaultContentType中定义的顺序来选择</li>
<li>没有指定参数时，若此时还有accept请求头，则请求头中定义顺序的优先级高于 defaultContentType， 高于 produce</li>
</ol>
<p>注意注意：当配置中忽略了AcceptHeader时，<code>.ignoreAcceptHeader(true)</code>，上面第三条作废</p>
<p>最后的最后，本文所有的源码可以再下面的git中获取；本文的知识点已经汇总在<a href="https://hhui.top/spring-web/02.response/" target="_blank" rel="noopener noreferrer">《一灰灰的Spring专栏》</a> 两百多篇的原创系列博文，你值得拥有；我是一灰灰，咱们下次再见</p>
<h2> III. 不能错过的源码和相关知识点</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/204-web-xml-json" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/204-web-xml-json</a></li>
</ul>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="SpringBoot"/>
    <category term="WEB系列"/>
    <category term="Response"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2022-08-16T18:42:37.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">Web花样返回</title>
    <id>https://liuyueyi.github.io/tutorial/spring/web/Response/</id>
    <link href="https://liuyueyi.github.io/tutorial/spring/web/Response/"/>
    <updated>2023-02-10T04:50:05.000Z</updated>
    <summary type="html"><![CDATA[<p>后端接口返回什么，json串？xml文档？html网页？文件？还是重定向？</p>
]]></summary>
    <content type="html"><![CDATA[<p>后端接口返回什么，json串？xml文档？html网页？文件？还是重定向？</p>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2023-02-10T04:50:05.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">1.基础用法小结</title>
    <id>https://liuyueyi.github.io/tutorial/spring/web/RestTemplate/200617-SpringBoot%E7%B3%BB%E5%88%97RestTemplate%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95%E5%B0%8F%E7%BB%93.html</id>
    <link href="https://liuyueyi.github.io/tutorial/spring/web/RestTemplate/200617-SpringBoot%E7%B3%BB%E5%88%97RestTemplate%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95%E5%B0%8F%E7%BB%93.html"/>
    <updated>2023-02-10T04:50:05.000Z</updated>
    <summary type="html"><![CDATA[<p>在Spring项目中，通常会借助<code>RestTemplate</code>来实现网络请求，RestTemplate封装得很完善了，基本上可以非常简单的完成各种HTTP请求，本文主要介绍一下基本操作，最常见的GET/POST请求的使用姿势</p>
]]></summary>
    <content type="html"><![CDATA[<p>在Spring项目中，通常会借助<code>RestTemplate</code>来实现网络请求，RestTemplate封装得很完善了，基本上可以非常简单的完成各种HTTP请求，本文主要介绍一下基本操作，最常见的GET/POST请求的使用姿势</p>
<!-- more -->
<h2> I. 项目搭建</h2>
<h3> 1. 配置</h3>
<p>借助SpringBoot搭建一个SpringWEB项目，提供一些用于测试的REST服务</p>
<ul>
<li>SpringBoot版本: <code>2.2.1.RELEASE</code></li>
<li>核心依赖: <code>spring-boot-stater-web</code></li>
</ul>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>为了后续输出的日志更直观，这里设置了一下日志输出格式，在配置文件<code>application.yml</code>中，添加</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. Rest服务</h3>
<p>添加三个接口，分别提供GET请求，POST表单，POST json对象，然后返回请求头、请求参数、cookie，具体实现逻辑相对简单，也不属于本篇重点，因此不赘述说明</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> II. RestTemplate示例</h2>
<h3> 1. Get请求</h3>
<p>使用RestTemplate发起GET请求，通常有两种常见的方式</p>
<ul>
<li>getForEntity: 返回的正文对象包装在<code>HttpEntity</code>实体中，适用于获取除了返回的正文之外，对返回头、状态码有需求的场景</li>
<li>getForObject: 返回正文，适用于只对正文感兴趣的场景</li>
</ul>
<p>上面这两种方法除了返回结果不同之外，其他的使用姿势基本一样，有三种</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面三个重载方法，区别仅在于GET参数如何处理，下面给出一个实例进行说明</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果如下:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. POST表单</h3>
<p>POST表单属于非常基础的请求方式了，根据返回结果，RestTemplate同样提供了两种姿势</p>
<ul>
<li>postForEntity: 返回的正文封装在HttpEntity</li>
<li>postForObject: 直接返回正文对象</li>
</ul>
<p>它的使用姿势一样有三种</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>请注意上面三个方法的前两个，后面的<code>uriVariables</code>是url参数，不是POST表单参数哦，它们之间是有区别的（虽然我们一般post提交表单时，不怎么会在url中添加参数）</p>
<p>下面还是根据实际的用例来查看</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>测试输出如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. post body</h3>
<p>post一个json串，也属于比较常见的一种case了，对于RestTemplate而言，要支持这种方式，需要额外处理一下请求头，设置<code>Content-Type</code>为<code>application/json</code></p>
<p>使用姿势和上面相差不大，只是需要注意一下请求参数的构建</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>请注意，提交的json串中文乱码了</strong></p>
<h3> 4. 小结</h3>
<p>上面主要介绍的是RestTemplate的常规用法，基础的GET/POST请求姿势，如果业务简单，不需要考虑各种复杂的异常情况，也是没有太多的问题了；那么如果需要考虑，又有哪些需要注意的呢？</p>
<ul>
<li>上面的中文乱码问题如何解决？</li>
<li>自定义的请求头如何塞入（如果是爬虫，上面的User-Agent太容易被屏蔽了）</li>
<li>cookie设置</li>
<li>REST支持Basic Auth的验证方式如何发起请求</li>
<li>超时设置</li>
<li>自定义连接池替换</li>
<li>REST返回非200状态码的情况，能否不抛异常，自定义处理？</li>
<li>ssl校验</li>
<li>...</li>
</ul>
<p>如果你对上面的这些点感兴趣，不妨关注一波，相关的文章快正热火朝天的进行中...</p>
<h2> II. 其他</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>项目: <a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/221-web-resttemplate" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/221-web-resttemplate</a></li>
</ul>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="SpringBoot"/>
    <category term="WEB系列"/>
    <category term="RestTemplate"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2020-06-17T09:26:20.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">2.之自定义请求头</title>
    <id>https://liuyueyi.github.io/tutorial/spring/web/RestTemplate/200630-SpringBoot%E7%B3%BB%E5%88%97RestTemplate%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E8%AF%B7%E6%B1%82%E5%A4%B4.html</id>
    <link href="https://liuyueyi.github.io/tutorial/spring/web/RestTemplate/200630-SpringBoot%E7%B3%BB%E5%88%97RestTemplate%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E8%AF%B7%E6%B1%82%E5%A4%B4.html"/>
    <updated>2023-02-10T04:50:05.000Z</updated>
    <summary type="html"><![CDATA[<p>上一篇介绍了RestTemplate的基本使用姿势，在文末提出了一些扩展的高级使用姿势，本篇将主要集中在如何携带自定义的请求头，如设置User-Agent，携带Cookie</p>
<ul>
<li>Get携带请求头</li>
<li>Post携带请求头</li>
<li>拦截器方式设置统一请求头</li>
</ul>
]]></summary>
    <content type="html"><![CDATA[<p>上一篇介绍了RestTemplate的基本使用姿势，在文末提出了一些扩展的高级使用姿势，本篇将主要集中在如何携带自定义的请求头，如设置User-Agent，携带Cookie</p>
<ul>
<li>Get携带请求头</li>
<li>Post携带请求头</li>
<li>拦截器方式设置统一请求头</li>
</ul>
<!-- more -->
<h2> I. 项目搭建</h2>
<h3> 1. 配置</h3>
<p>借助SpringBoot搭建一个SpringWEB项目，提供一些用于测试的REST服务</p>
<ul>
<li>SpringBoot版本: <code>2.2.1.RELEASE</code></li>
<li>核心依赖: <code>spring-boot-stater-web</code></li>
</ul>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>为了后续输出的日志更直观，这里设置了一下日志输出格式，在配置文件<code>application.yml</code>中，添加</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. Rest服务</h3>
<p>添加三个接口，分别提供GET请求，POST表单，POST json对象，然后返回请求头、请求参数、cookie，具体实现逻辑相对简单，也不属于本篇重点，因此不赘述说明</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> II. 使用姿势</h2>
<p>最常见的携带请求头的需求，无非是referer校验，user-agent的防爬以及携带cookie，使用RestTemplate可以借助<code>HttpHeaders</code>来处理请求头</p>
<h3> 1. Get携带请求头</h3>
<p>前一篇博文介绍了GET请求的三种方式，但是<code>getForObject</code>/<code>getForEntity</code>都不满足我们的场景，这里需要引入<code>exchange</code>方法</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>exchange的使用姿势和我们前面介绍的<code>postForEntity</code>差不多，只是多了一个指定HttpMethod的参数而已</p>
<p><strong>重点在于将请求头塞入HttpEntity</strong></p>
<p>输出结果</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. Post携带请求头</h3>
<p>post携带请求头，也可以利用上面的方式实现；当然我们一般直接借助<code>postForObject/postForEntity</code>就可以满足需求了</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. 拦截器方式</h3>
<p>如果我们可以确定每次发起请求时，都要设置一个自定义的 <code>User-Agent</code>，每次都使用上面的两种姿势就有点繁琐了，因此我们是可以通过拦截器的方式来添加通用的请求头，这样使用这个RestTemplate时，都会携带上请求头</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这个使用姿势比较适用于通用的场景，测试输出</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4. 请求头错误使用姿势</h3>
<p>在我们使用自定义请求头时，有一个需要特殊重视的地方，HttpHeaders使用不当，可能导致请求头爆炸</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面演示的关键点为</p>
<ul>
<li>希望复用 HttpHeaders</li>
<li><code>headers.add</code> 方式添加请求头；而不是前面的 <code>set</code>方式</li>
</ul>
<p>输出如下，请注意每一次请求过后，请求头膨胀了一次</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> II. 其他</h2>
<h3> 0. 项目&amp;系列博文</h3>
<p><strong>系列博文</strong></p>
<ul>
<li><a href="http://spring.hhui.top/spring-blog/2020/06/17/200617-SpringBoot%E7%B3%BB%E5%88%97RestTemplate%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95%E5%B0%8F%E7%BB%93/" target="_blank" rel="noopener noreferrer">【WEB系列】RestTemplate基础用法小结</a></li>
</ul>
<p><strong>源码</strong></p>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>项目: <a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/221-web-resttemplate" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/221-web-resttemplate</a></li>
</ul>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="SpringBoot"/>
    <category term="WEB系列"/>
    <category term="RestTemplate"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2020-06-30T08:20:39.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">3.中文乱码问题fix</title>
    <id>https://liuyueyi.github.io/tutorial/spring/web/RestTemplate/200701-SpringBoot%E7%B3%BB%E5%88%97RestTemplate%E4%B9%8B%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98fix.html</id>
    <link href="https://liuyueyi.github.io/tutorial/spring/web/RestTemplate/200701-SpringBoot%E7%B3%BB%E5%88%97RestTemplate%E4%B9%8B%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98fix.html"/>
    <updated>2023-02-10T04:50:05.000Z</updated>
    <summary type="html"><![CDATA[<p>在RestTemplate基础用法博文中，post json表单时，会发现存在中文乱码问题，本文主要介绍对应的解决方案</p>
]]></summary>
    <content type="html"><![CDATA[<p>在RestTemplate基础用法博文中，post json表单时，会发现存在中文乱码问题，本文主要介绍对应的解决方案</p>
<!-- more -->
<h2> I. 中文乱码Fix</h2>
<h3> 1. "罪魁祸首"</h3>
<p><strong>场景复现</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果如下:</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>原因定位</strong></p>
<p>RestTemplate中存在一个<code>HttpMessageConverter</code>列表的属性成员，而<code>HttpMessageConverter</code>主要的职责就是消息转码</p>
<p>导致我们中文乱码的一个关键点在于<code>StringHttpMessageConverter</code>采用的默认编码格式为<code>StandardCharsets.ISO_8859_1</code></p>
<h3> 2. 指定StringHttpMessageConverter编码</h3>
<p>既然是因为<code>StringHttpMessageConverter</code>的默认编码不是UTF-8，那么将它手动改成utf-8不就over了么</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>测试输出如:</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. 传参POJO</h3>
<p>在看<code>RestTemplate</code>的<code>HttpMessageConvert</code>时，会看到默认提供了一个<code>MappingJackson2HttpMessageConverter</code>，那么我们直接传参POJO，走Jackson序列化，是不是也可以解决中文乱码呢?</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>说明：上面的InnerParam对象改成HashMap，也是ok的</strong></p>
<h2> II. 其他</h2>
<h3> 0. 项目&amp;系列博文</h3>
<p><strong>博文</strong></p>
<ul>
<li><a href="http://spring.hhui.top/spring-blog/2020/06/30/200630-SpringBoot%E7%B3%BB%E5%88%97RestTemplate%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E8%AF%B7%E6%B1%82%E5%A4%B4/" target="_blank" rel="noopener noreferrer">【WEB系列】RestTemplate之自定义请求头</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2020/06/30/200630-SpringBoot%E7%B3%BB%E5%88%97RestTemplate%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E8%AF%B7%E6%B1%82%E5%A4%B4/" target="_blank" rel="noopener noreferrer">【WEB系列】RestTemplate基础用法小结</a></li>
</ul>
<p><strong>源码</strong></p>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码: <a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/221-web-resttemplate" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/221-web-resttemplate</a></li>
</ul>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="SpringBoot"/>
    <category term="WEB系列"/>
    <category term="RestTemplate"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2020-07-01T09:14:59.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">4.超时设置</title>
    <id>https://liuyueyi.github.io/tutorial/spring/web/RestTemplate/200702-SpringBoot%E7%B3%BB%E5%88%97RestTemplate%E4%B9%8B%E8%B6%85%E6%97%B6%E8%AE%BE%E7%BD%AE.html</id>
    <link href="https://liuyueyi.github.io/tutorial/spring/web/RestTemplate/200702-SpringBoot%E7%B3%BB%E5%88%97RestTemplate%E4%B9%8B%E8%B6%85%E6%97%B6%E8%AE%BE%E7%BD%AE.html"/>
    <updated>2023-02-10T04:50:05.000Z</updated>
    <summary type="html"><![CDATA[<p>一般来讲我们访问外部资源时，需要做一个保护，比如最常见的添加一个超时设置，避免一直被阻塞，RestTemplate可以通过<code>SimpleClientHttpRequestFactory</code>来处理超时设置</p>
]]></summary>
    <content type="html"><![CDATA[<p>一般来讲我们访问外部资源时，需要做一个保护，比如最常见的添加一个超时设置，避免一直被阻塞，RestTemplate可以通过<code>SimpleClientHttpRequestFactory</code>来处理超时设置</p>
<!-- more -->
<h2> I. RestTemplate超时设置</h2>
<blockquote>
<p>博文测试项目完全基于<a href="http://spring.hhui.top/spring-blog/2020/06/17/200617-SpringBoot%E7%B3%BB%E5%88%97RestTemplate%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95%E5%B0%8F%E7%BB%93/" target="_blank" rel="noopener noreferrer">【WEB系列】RestTemplate基础用法小结</a>的项目环境，建议配合查看</p>
</blockquote>
<p>基本环境：<code>IDEA</code> + <code>maven</code> + <code>SpringBoot 2.2.1.RELEASE</code></p>
<h3> 1. 超时端点</h3>
<p>添加一个超时模拟的端点如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 超时设置</h3>
<p>主要是通过设置<code>SimpleClientHttpRequestFactory</code>来设置超时</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出如下:</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> II. 其他</h2>
<h3> 1. 源码&amp;系列博文</h3>
<p><strong>博文</strong></p>
<ul>
<li><a href="http://spring.hhui.top/spring-blog/2020/07/01/200701-SpringBoot%E7%B3%BB%E5%88%97RestTemplate%E4%B9%8B%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98fix/" target="_blank" rel="noopener noreferrer">【WEB系列】RestTemplate之中文乱码问题fix</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2020/06/30/200630-SpringBoot%E7%B3%BB%E5%88%97RestTemplate%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E8%AF%B7%E6%B1%82%E5%A4%B4/" target="_blank" rel="noopener noreferrer">【WEB系列】RestTemplate之自定义请求头</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2020/06/30/200630-SpringBoot%E7%B3%BB%E5%88%97RestTemplate%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E8%AF%B7%E6%B1%82%E5%A4%B4/" target="_blank" rel="noopener noreferrer">【WEB系列】RestTemplate基础用法小结</a></li>
</ul>
<p><strong>源码</strong></p>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码: <a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/221-web-resttemplate" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/221-web-resttemplate</a></li>
</ul>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="SpringBoot"/>
    <category term="WEB系列"/>
    <category term="RestTemplate"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2020-07-02T08:03:21.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">5.代理访问</title>
    <id>https://liuyueyi.github.io/tutorial/spring/web/RestTemplate/200703-SpringBoot%E7%B3%BB%E5%88%97RestTemplate%E4%B9%8B%E4%BB%A3%E7%90%86%E8%AE%BF%E9%97%AE.html</id>
    <link href="https://liuyueyi.github.io/tutorial/spring/web/RestTemplate/200703-SpringBoot%E7%B3%BB%E5%88%97RestTemplate%E4%B9%8B%E4%BB%A3%E7%90%86%E8%AE%BF%E9%97%AE.html"/>
    <updated>2023-02-10T04:50:05.000Z</updated>
    <summary type="html"><![CDATA[<p>通过代理访问，对于java后端可能用得不多的，但有过爬虫开发经验的小伙伴可能一点也不会陌生，有时候不太方便直接去访问目标资源，借助代理是要给选择，对于RestTemplate而言，使用代理的姿势同样如设置超时一般，借助<code>SimpleClientHttpRequestFactory</code>来实现，本文演示一下具体的使用case</p>
]]></summary>
    <content type="html"><![CDATA[<p>通过代理访问，对于java后端可能用得不多的，但有过爬虫开发经验的小伙伴可能一点也不会陌生，有时候不太方便直接去访问目标资源，借助代理是要给选择，对于RestTemplate而言，使用代理的姿势同样如设置超时一般，借助<code>SimpleClientHttpRequestFactory</code>来实现，本文演示一下具体的使用case</p>
<!-- more -->
<h2> I. 环境准备</h2>
<h3> 1. 项目环境</h3>
<p>借助SpringBoot搭建一个SpringWEB项目，提供一些用于测试的REST服务</p>
<ul>
<li>SpringBoot版本: <code>2.2.1.RELEASE</code></li>
<li>核心依赖: <code>spring-boot-stater-web</code></li>
</ul>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>为了后续输出的日志更直观，这里设置了一下日志输出格式，在配置文件<code>application.yml</code>中，添加</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 测试端点</h3>
<p>我们的测试端点，主要需要返回客户端主机信息，我们这里直接借助<code>HttpServletRequest#getRemoteHost</code> + <code>HttpServlet#getRemotePort</code>来实现（当然实际的业务开发中不建议直接使用它）</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. 代理服务器搭建</h3>
<p>我们这里借助tinyproxy来搭建代理服务器，详细步骤可以参考博文: <a href="https://blog.hhui.top/hexblog/2020/06/19/200619-http%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8tinyproxy%E6%90%AD%E5%BB%BA%E6%89%8B%E5%86%8C/" target="_blank" rel="noopener noreferrer">http代理服务器tinyproxy搭建手册</a></p>
<p>本文的演示中，是在<code>192.168.0.241</code>状态centos机器上安装的，步骤如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> II. 代理访问</h2>
<p>接下来进入正文演示，核心代码也比较简单</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>请注意，上面的使用姿势中</p>
<ul>
<li>Proxy的方式除了HTTP之外还有SOCKS，这个是与代理服务器的支持方式相关的</li>
<li><code>postForEntity</code>中url的ip是我本机的ip，而不是<code>127.0.0.1</code></li>
</ul>
<p>测试输出如下:</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> II. 其他</h2>
<h3> 0. 项目&amp;系列博文</h3>
<p><strong>博文</strong></p>
<ul>
<li><a href="http://spring.hhui.top/spring-blog/2020/07/02/200702-SpringBoot%E7%B3%BB%E5%88%97RestTemplate%E4%B9%8B%E8%B6%85%E6%97%B6%E8%AE%BE%E7%BD%AE/" target="_blank" rel="noopener noreferrer">【WEB系列】RestTemplate之超时设置</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2020/07/01/200701-SpringBoot%E7%B3%BB%E5%88%97RestTemplate%E4%B9%8B%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98fix/" target="_blank" rel="noopener noreferrer">【WEB系列】RestTemplate之中文乱码问题fix</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2020/06/30/200630-SpringBoot%E7%B3%BB%E5%88%97RestTemplate%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E8%AF%B7%E6%B1%82%E5%A4%B4/" target="_blank" rel="noopener noreferrer">【WEB系列】RestTemplate之自定义请求头</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2020/06/30/200630-SpringBoot%E7%B3%BB%E5%88%97RestTemplate%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E8%AF%B7%E6%B1%82%E5%A4%B4/" target="_blank" rel="noopener noreferrer">【WEB系列】RestTemplate基础用法小结</a></li>
</ul>
<p><strong>源码</strong></p>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码: <a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/221-web-resttemplate" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/221-web-resttemplate</a></li>
</ul>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="SpringBoot"/>
    <category term="WEB系列"/>
    <category term="RestTemplate"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2020-07-03T08:09:12.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">6.Basic Auth授权</title>
    <id>https://liuyueyi.github.io/tutorial/spring/web/RestTemplate/200704-SpringBoot%E7%B3%BB%E5%88%97RestTemplate%E4%B9%8BBasic-Auth%E6%8E%88%E6%9D%83.html</id>
    <link href="https://liuyueyi.github.io/tutorial/spring/web/RestTemplate/200704-SpringBoot%E7%B3%BB%E5%88%97RestTemplate%E4%B9%8BBasic-Auth%E6%8E%88%E6%9D%83.html"/>
    <updated>2023-02-10T04:50:05.000Z</updated>
    <summary type="html"><![CDATA[<p>前面介绍的RestTemplate的所有使用姿势都是不需要鉴权的，然而实际情况可不一定都这么友好；Http Basic Auth属于非常基础的一种鉴权方式了，将用户名和密码以Base64编码之后，携带在请求头，从而实现身份校验；</p>
<p>本文将主要介绍RestTemplate实现Basic Auth鉴权的几种姿势</p>
]]></summary>
    <content type="html"><![CDATA[<p>前面介绍的RestTemplate的所有使用姿势都是不需要鉴权的，然而实际情况可不一定都这么友好；Http Basic Auth属于非常基础的一种鉴权方式了，将用户名和密码以Base64编码之后，携带在请求头，从而实现身份校验；</p>
<p>本文将主要介绍RestTemplate实现Basic Auth鉴权的几种姿势</p>
<!-- more -->
<h2> I. 项目环境</h2>
<blockquote>
<p>博文测试项目完全基于<a href="http://spring.hhui.top/spring-blog/2020/06/17/200617-SpringBoot%E7%B3%BB%E5%88%97RestTemplate%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95%E5%B0%8F%E7%BB%93/" target="_blank" rel="noopener noreferrer">【WEB系列】RestTemplate基础用法小结</a>的项目环境，建议配合查看</p>
</blockquote>
<p>基本环境：<code>IDEA</code> + <code>maven</code> + <code>SpringBoot 2.2.1.RELEASE</code></p>
<h3> 1. 鉴权端点</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>一个简单的鉴权逻辑如上，从请求头中拿到<code>Authorization</code>对应的value，并解析用户名密码，如果满足则正确返回；如果不存在or不满足，则返回http状态码为401，并携带对应的提示信息</p>
<h2> II. Basic Auth鉴权姿势</h2>
<h3> 1. 请求头方式</h3>
<p>最基础的一种是实现方式，完全根据Basic Auth的规则来，既然是校验请求头，那么我直接在请求头中加上即可</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 拦截器方式</h3>
<p>上面的方式不太通用，借助前面的请求头设置姿势，如果有通用的需求，借助拦截器是一个好的选择</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. 标准验证拦截器</h3>
<p>上面的拦截器主要还是我们自己来设置请求头，实际上Spring已经提供了标准的<code>BasicAuthenticationInterceptor</code>来实现我们的需求</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4. RestTemplateBuilder方式创建RestTemplate</h3>
<p>RestTemplate除了使用new来构造之外，还可以借助<code>RestTemplateBuilder</code>来创建，有时候可能更加方便简洁</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 5. 反面case</h3>
<p>上面介绍的几种都是正常可以工作的，接下来给出一个不能工作的case</p>
<p>对于Basic Auth，有一种常见的方式是将用户名和密码，放在url里面，如</p>
<figure><img src="/imgs/200704/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>那么我们直接用RestTemplate这么操作呢？</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>注意直接在url里面添加用户名密码的方式是不行的，需要额外处理</strong></p>
<h2> II. 其他</h2>
<h3> 0. 项目&amp;系列博文</h3>
<p><strong>博文</strong></p>
<ul>
<li><a href="http://spring.hhui.top/spring-blog/2020/07/03/200703-SpringBoot%E7%B3%BB%E5%88%97RestTemplate%E4%B9%8B%E4%BB%A3%E7%90%86%E8%AE%BF%E9%97%AE/" target="_blank" rel="noopener noreferrer">【WEB系列】RestTemplate之代理访问</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2020/07/02/200702-SpringBoot%E7%B3%BB%E5%88%97RestTemplate%E4%B9%8B%E8%B6%85%E6%97%B6%E8%AE%BE%E7%BD%AE/" target="_blank" rel="noopener noreferrer">【WEB系列】RestTemplate之超时设置</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2020/07/01/200701-SpringBoot%E7%B3%BB%E5%88%97RestTemplate%E4%B9%8B%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98fix/" target="_blank" rel="noopener noreferrer">【WEB系列】RestTemplate之中文乱码问题fix</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2020/06/30/200630-SpringBoot%E7%B3%BB%E5%88%97RestTemplate%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E8%AF%B7%E6%B1%82%E5%A4%B4/" target="_blank" rel="noopener noreferrer">【WEB系列】RestTemplate之自定义请求头</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2020/06/30/200630-SpringBoot%E7%B3%BB%E5%88%97RestTemplate%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E8%AF%B7%E6%B1%82%E5%A4%B4/" target="_blank" rel="noopener noreferrer">【WEB系列】RestTemplate基础用法小结</a></li>
</ul>
<p><strong>源码</strong></p>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码: <a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/221-web-resttemplate" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/221-web-resttemplate</a></li>
</ul>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="SpringBoot"/>
    <category term="WEB系列"/>
    <category term="RestTemplate"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2020-07-04T09:53:31.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">7.非200状态码信息捕获</title>
    <id>https://liuyueyi.github.io/tutorial/spring/web/RestTemplate/200705-SpringBoot%E7%B3%BB%E5%88%97RestTemplate%E4%B9%8B%E9%9D%9E200%E7%8A%B6%E6%80%81%E7%A0%81%E4%BF%A1%E6%81%AF%E6%8D%95%E8%8E%B7.html</id>
    <link href="https://liuyueyi.github.io/tutorial/spring/web/RestTemplate/200705-SpringBoot%E7%B3%BB%E5%88%97RestTemplate%E4%B9%8B%E9%9D%9E200%E7%8A%B6%E6%80%81%E7%A0%81%E4%BF%A1%E6%81%AF%E6%8D%95%E8%8E%B7.html"/>
    <updated>2023-02-10T04:50:05.000Z</updated>
    <summary type="html"><![CDATA[<p>前面介绍的RestTemplate的使用，都是接口正常返回200的状态码case，当返回非200状态码时，会直接抛异常，如果我希望能捕获异常，并针对正常获取返回的message，可以如何处理呢？</p>
]]></summary>
    <content type="html"><![CDATA[<p>前面介绍的RestTemplate的使用，都是接口正常返回200的状态码case，当返回非200状态码时，会直接抛异常，如果我希望能捕获异常，并针对正常获取返回的message，可以如何处理呢？</p>
<!-- more -->
<h2> I. 项目环境</h2>
<blockquote>
<p>博文测试项目完全基于<a href="http://spring.hhui.top/spring-blog/2020/06/17/200617-SpringBoot%E7%B3%BB%E5%88%97RestTemplate%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95%E5%B0%8F%E7%BB%93/" target="_blank" rel="noopener noreferrer">【WEB系列】RestTemplate基础用法小结</a>的项目环境，建议配合查看</p>
</blockquote>
<p>基本环境：<code>IDEA</code> + <code>maven</code> + <code>SpringBoot 2.2.1.RELEASE</code></p>
<p>测试的REST服务借助前一篇的鉴权，如果鉴权失败，则返回401状态码，具体实现如下</p>
<h3> 1. 鉴权端点</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>一个简单的鉴权逻辑如上，从请求头中拿到<code>Authorization</code>对应的value，并解析用户名密码，如果满足则正确返回；如果不存在or不满足，则返回http状态码为401，并携带对应的提示信息</p>
<h2> II. 异常捕获</h2>
<h3> 1. 未捕获场景</h3>
<p>当我们直接像之前一样使用RestTemplate时，看一下效果如何</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出如下，走入了catch逻辑，从异常堆栈中，也只能看到<code>401 Unauthorized</code>，拿不到返回的Response body</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 异常捕获</h3>
<blockquote>
<p>更详细原理定位请参考：<a href="http://spring.hhui.top/spring-blog/2020/01/04/200104-SpringWeb%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8BRestTemplate-4xx-5xx-%E5%BC%82%E5%B8%B8%E4%BF%A1%E6%81%AF%E6%8D%95%E8%8E%B7/" target="_blank" rel="noopener noreferrer">【WEB系列】RestTemplate 4xx/5xx 异常信息捕获</a></p>
</blockquote>
<p>为了处理上面的问题，我们可以设置自定义的<code>ResponseErrorHandler</code>来处理</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出如下, 401为返回的状态码，其中也包含了ResponseBody，然后再业务中根据状态码和返回结果进行处理即可</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> II. 其他</h2>
<h3> 0. 项目&amp;系列博文</h3>
<p><strong>博文</strong></p>
<ul>
<li><a href="http://spring.hhui.top/spring-blog/2020/07/04/200704-SpringBoot%E7%B3%BB%E5%88%97RestTemplate%E4%B9%8BBasic-Auth%E6%8E%88%E6%9D%83/" target="_blank" rel="noopener noreferrer">【WEB系列】RestTemplate之Basic Auth授权</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2020/07/03/200703-SpringBoot%E7%B3%BB%E5%88%97RestTemplate%E4%B9%8B%E4%BB%A3%E7%90%86%E8%AE%BF%E9%97%AE/" target="_blank" rel="noopener noreferrer">【WEB系列】RestTemplate之代理访问</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2020/07/02/200702-SpringBoot%E7%B3%BB%E5%88%97RestTemplate%E4%B9%8B%E8%B6%85%E6%97%B6%E8%AE%BE%E7%BD%AE/" target="_blank" rel="noopener noreferrer">【WEB系列】RestTemplate之超时设置</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2020/07/01/200701-SpringBoot%E7%B3%BB%E5%88%97RestTemplate%E4%B9%8B%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98fix/" target="_blank" rel="noopener noreferrer">【WEB系列】RestTemplate之中文乱码问题fix</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2020/06/30/200630-SpringBoot%E7%B3%BB%E5%88%97RestTemplate%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E8%AF%B7%E6%B1%82%E5%A4%B4/" target="_blank" rel="noopener noreferrer">【WEB系列】RestTemplate之自定义请求头</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2020/06/30/200630-SpringBoot%E7%B3%BB%E5%88%97RestTemplate%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E8%AF%B7%E6%B1%82%E5%A4%B4/" target="_blank" rel="noopener noreferrer">【WEB系列】RestTemplate基础用法小结</a></li>
</ul>
<p><strong>源码</strong></p>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码: <a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/221-web-resttemplate" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/221-web-resttemplate</a></li>
</ul>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="SpringBoot"/>
    <category term="WEB系列"/>
    <category term="RestTemplate"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2020-07-05T07:21:01.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">8.异步非阻塞网络请求介绍篇</title>
    <id>https://liuyueyi.github.io/tutorial/spring/web/RestTemplate/200707-SpringBoot%E7%B3%BB%E5%88%97AsyncRestTemplate%E4%B9%8B%E5%BC%82%E6%AD%A5%E9%9D%9E%E9%98%BB%E5%A1%9E%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E4%BB%8B%E7%BB%8D%E7%AF%87.html</id>
    <link href="https://liuyueyi.github.io/tutorial/spring/web/RestTemplate/200707-SpringBoot%E7%B3%BB%E5%88%97AsyncRestTemplate%E4%B9%8B%E5%BC%82%E6%AD%A5%E9%9D%9E%E9%98%BB%E5%A1%9E%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E4%BB%8B%E7%BB%8D%E7%AF%87.html"/>
    <updated>2023-02-10T04:50:05.000Z</updated>
    <summary type="html"><![CDATA[<p>AsyncRestTemplate发起异步网络请求，由Spring4.0引入，但是在5.0就被表上了删除注解，官方推荐使用基于React的WebClient来代替。</p>
<p>虽然官方已经不推荐使用<code>AsyncRestTemplate</code>，但是如果你的web项目，并不想引入react相关的包，使用<code>AsyncRestTemplate</code>来实现异步网络请求也不失为一个选择，本文将主要介绍它的基本使用姿势</p>
]]></summary>
    <content type="html"><![CDATA[<p>AsyncRestTemplate发起异步网络请求，由Spring4.0引入，但是在5.0就被表上了删除注解，官方推荐使用基于React的WebClient来代替。</p>
<p>虽然官方已经不推荐使用<code>AsyncRestTemplate</code>，但是如果你的web项目，并不想引入react相关的包，使用<code>AsyncRestTemplate</code>来实现异步网络请求也不失为一个选择，本文将主要介绍它的基本使用姿势</p>
<!-- more -->
<h2> I. 项目环境</h2>
<p>本文创建的实例工程采用<code>SpringBoot 2.2.1.RELEASE</code> + <code>maven 3.5.3</code> + <code>idea</code>进行开发</p>
<h3> 1. pom依赖</h3>
<p>具体的SpringBoot项目工程创建就不赘述了，对于pom文件中，需要重点关注下面两个依赖类</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>请注意我们并没有引入react相关的包，所以是没法直接使用webclient的</strong></p>
<p>简单的配置一下logback的日志输出（非必要条件）, <code>application.yml</code>文件内容如下</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 测试接口</h3>
<p>编写几个简单的用于测试的REST接口</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> II. 使用说明</h2>
<p>从接口声明上来看，AsyncRestTemplate与RestTemplate的使用姿势没有什么区别，如典型的GET/POST接口声明如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1. 使用姿势</h3>
<p>GET/POST的访问姿势就不再赘述，有兴趣的小伙伴可以查看RestTemplate的使用博文：<a href="http://spring.hhui.top/spring-blog/2020/06/17/200617-SpringBoot%E7%B3%BB%E5%88%97RestTemplate%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95%E5%B0%8F%E7%BB%93/" target="_blank" rel="noopener noreferrer">【WEB系列】RestTemplate基础用法小结</a></p>
<p>注意到不同的点在于返回的对象，<code>RestTemplate</code>是直接返回实体；而<code>AsyncRestTemplate</code>返回的则是<code>ListenerableFuture</code>包装的结果，这个类属于Spring自定义对象，继承自Future体系，而Future是我们并发编程中用于获取异步结果的一个接口</p>
<p><code>ListenerableFuture</code>的最大特点在于它可以绑定执行完成的监听器，就不需要通过get来阻塞获取结果了，一个简单的使用姿势如下, 分别演示正常返回，异常返回的回调case（两者都不会阻塞主线程的执行哦）</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>请注意下面的动图，主线程的<code>do something else!!!</code>文案会优先输出，并不会被阻塞；然后就是返回结果之后的回调，因为第一个case访问的rest服务有个sleep，所以输出也会有一个明显的滞后</p>
<figure><img src="/imgs/200707/00.gif" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 2. Guava方式的异步请求</h3>
<p>除了上面说到的AsyncRestTemplate来实现异步访问，我们也可以借助Gauva配合<code>RestTemplate</code>来实现类似的效果，下面作为扩展知识点，给出一个等效的使用说明</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>看到这里自然而然会有一个疑问，异步任务完成的回调，是怎么实现呢？</p>
<p>欢迎各位小伙伴评论给出看法</p>
<h2> II. 其他</h2>
<h3> 0. 项目&amp;系列博文</h3>
<p><strong>博文</strong></p>
<ul>
<li><a href="http://spring.hhui.top/spring-blog/2020/07/05/200705-SpringBoot%E7%B3%BB%E5%88%97RestTemplate%E4%B9%8B%E9%9D%9E200%E7%8A%B6%E6%80%81%E7%A0%81%E4%BF%A1%E6%81%AF%E6%8D%95%E8%8E%B7/" target="_blank" rel="noopener noreferrer">【WEB系列】RestTemplate之非200状态码信息捕获</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2020/07/04/200704-SpringBoot%E7%B3%BB%E5%88%97RestTemplate%E4%B9%8BBasic-Auth%E6%8E%88%E6%9D%83/" target="_blank" rel="noopener noreferrer">【WEB系列】RestTemplate之Basic Auth授权</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2020/07/03/200703-SpringBoot%E7%B3%BB%E5%88%97RestTemplate%E4%B9%8B%E4%BB%A3%E7%90%86%E8%AE%BF%E9%97%AE/" target="_blank" rel="noopener noreferrer">【WEB系列】RestTemplate之代理访问</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2020/07/02/200702-SpringBoot%E7%B3%BB%E5%88%97RestTemplate%E4%B9%8B%E8%B6%85%E6%97%B6%E8%AE%BE%E7%BD%AE/" target="_blank" rel="noopener noreferrer">【WEB系列】RestTemplate之超时设置</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2020/07/01/200701-SpringBoot%E7%B3%BB%E5%88%97RestTemplate%E4%B9%8B%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98fix/" target="_blank" rel="noopener noreferrer">【WEB系列】RestTemplate之中文乱码问题fix</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2020/06/30/200630-SpringBoot%E7%B3%BB%E5%88%97RestTemplate%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E8%AF%B7%E6%B1%82%E5%A4%B4/" target="_blank" rel="noopener noreferrer">【WEB系列】RestTemplate之自定义请求头</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2020/06/30/200630-SpringBoot%E7%B3%BB%E5%88%97RestTemplate%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E8%AF%B7%E6%B1%82%E5%A4%B4/" target="_blank" rel="noopener noreferrer">【WEB系列】RestTemplate基础用法小结</a></li>
</ul>
<p><strong>源码</strong></p>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码: <a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/221-web-resttemplate" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/221-web-resttemplate</a></li>
</ul>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="SpringBoot"/>
    <category term="WEB系列"/>
    <category term="RestTemplate"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2020-07-07T08:02:35.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">9.文件上传</title>
    <id>https://liuyueyi.github.io/tutorial/spring/web/RestTemplate/200710-SpringBoot%E7%B3%BB%E5%88%97RestTemplate%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0.html</id>
    <link href="https://liuyueyi.github.io/tutorial/spring/web/RestTemplate/200710-SpringBoot%E7%B3%BB%E5%88%97RestTemplate%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0.html"/>
    <updated>2023-02-10T04:50:05.000Z</updated>
    <summary type="html"><![CDATA[<p>虽然在实际的项目中，借助RestTemplate来实现文件上传的机会不多（比如我已经开webclient的新坑了，才发现忘了这货...），但是这个知识点也还是有必要了解一下的，本文将简单介绍一下单个文件上传，多个文件上传的使用姿势</p>
]]></summary>
    <content type="html"><![CDATA[<p>虽然在实际的项目中，借助RestTemplate来实现文件上传的机会不多（比如我已经开webclient的新坑了，才发现忘了这货...），但是这个知识点也还是有必要了解一下的，本文将简单介绍一下单个文件上传，多个文件上传的使用姿势</p>
<!-- more -->
<h2> I. 项目搭建</h2>
<p>本项目基于SpringBoot <code>2.2.1.RELEASE</code> + <code>maven 3.5.3</code> + <code>idea</code>进行开发</p>
<h3> 1. pom依赖</h3>
<p>核心pom依赖如下</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. Rest服务</h3>
<p>提供两个简单的上传文件的接口，下面给出两种不一样的写法，效果差不多</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. 上传文件</h3>
<p>在Resource资源目录下，新建两个用于测试上传的文本文件，内容分别如下</p>
<p>文件1 <code>test.txt</code>:</p>
<div class="language-txt line-numbers-mode" data-ext="txt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>文件2 <code>test2.txt</code>:</p>
<div class="language-txt line-numbers-mode" data-ext="txt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>简单设置一下日志格式，在<code>application.yml</code>文件中</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> II. 项目实现</h2>
<p>文件上传，依然是走的POST请求，所以基本操作知识和前面的POST差不多，唯一的区别在于传参</p>
<h3> 1. 文件上传</h3>
<p>文件上传两个核心步骤</p>
<ul>
<li>设置请求头</li>
<li>传参为Resource</li>
</ul>
<p>最基础的单文件上传姿势实例如下，主要是借助<code>FileSystemResource</code>来获取文件并上传</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当需要后端发起上传文件时，一般来讲是更多的情况下是上传二进制（or流），不太会是文件上传，所以更常见的是<code>InputStreamResource</code>的使用姿势</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>重点注意</strong></p>
<ul>
<li><code>InputStreamResource</code> 重写了<code>contentLength()</code>, <code>getFilename()</code>方法，去掉这个就没法正常的上传文件了</li>
</ul>
<p>当然除了<code>InputStreamResource</code>之外，<code>ByteArrayResource</code>也是一个比较好的选择</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>重点注意</strong></p>
<ul>
<li><code>ByteArrayResource</code>重写了<code>getFilename()</code>方法，感兴趣的小伙伴可以测试一下没有它的情况</li>
</ul>
<h3> 2. 多文件上传</h3>
<p>上面介绍的是单文件上传，当然我们也会出现一次上传多个文件的情况，使用姿势和前面基本上一样，无非是传参的时候多传两个而已</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. 输出结果</h3>
<figure><img src="/imgs/200710/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> II. 其他</h2>
<h3> 0. 项目&amp;系列博文</h3>
<p><strong>博文</strong></p>
<ul>
<li><a href="http://spring.hhui.top/spring-blog/2020/07/07/200707-SpringBoot%E7%B3%BB%E5%88%97AsyncRestTemplate%E4%B9%8B%E5%BC%82%E6%AD%A5%E9%9D%9E%E9%98%BB%E5%A1%9E%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E4%BB%8B%E7%BB%8D%E7%AF%87/" target="_blank" rel="noopener noreferrer">【WEB系列】AsyncRestTemplate之异步非阻塞网络请求介绍篇</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2020/07/05/200705-SpringBoot%E7%B3%BB%E5%88%97RestTemplate%E4%B9%8B%E9%9D%9E200%E7%8A%B6%E6%80%81%E7%A0%81%E4%BF%A1%E6%81%AF%E6%8D%95%E8%8E%B7/" target="_blank" rel="noopener noreferrer">【WEB系列】RestTemplate之非200状态码信息捕获</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2020/07/04/200704-SpringBoot%E7%B3%BB%E5%88%97RestTemplate%E4%B9%8BBasic-Auth%E6%8E%88%E6%9D%83/" target="_blank" rel="noopener noreferrer">【WEB系列】RestTemplate之Basic Auth授权</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2020/07/03/200703-SpringBoot%E7%B3%BB%E5%88%97RestTemplate%E4%B9%8B%E4%BB%A3%E7%90%86%E8%AE%BF%E9%97%AE/" target="_blank" rel="noopener noreferrer">【WEB系列】RestTemplate之代理访问</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2020/07/02/200702-SpringBoot%E7%B3%BB%E5%88%97RestTemplate%E4%B9%8B%E8%B6%85%E6%97%B6%E8%AE%BE%E7%BD%AE/" target="_blank" rel="noopener noreferrer">【WEB系列】RestTemplate之超时设置</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2020/07/01/200701-SpringBoot%E7%B3%BB%E5%88%97RestTemplate%E4%B9%8B%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98fix/" target="_blank" rel="noopener noreferrer">【WEB系列】RestTemplate之中文乱码问题fix</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2020/06/30/200630-SpringBoot%E7%B3%BB%E5%88%97RestTemplate%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E8%AF%B7%E6%B1%82%E5%A4%B4/" target="_blank" rel="noopener noreferrer">【WEB系列】RestTemplate之自定义请求头</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2020/06/30/200630-SpringBoot%E7%B3%BB%E5%88%97RestTemplate%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E8%AF%B7%E6%B1%82%E5%A4%B4/" target="_blank" rel="noopener noreferrer">【WEB系列】RestTemplate基础用法小结</a></li>
</ul>
<p><strong>源码</strong></p>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码: <a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/221-web-resttemplate" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/221-web-resttemplate</a></li>
</ul>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="SpringBoot"/>
    <category term="WEB系列"/>
    <category term="RestTemplate"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2020-07-10T11:53:21.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">10.连接池配置</title>
    <id>https://liuyueyi.github.io/tutorial/spring/web/RestTemplate/200723-SpringBoot%E7%B3%BB%E5%88%97RestTemplate%E4%B9%8B%E8%BF%9E%E6%8E%A5%E6%B1%A0%E9%85%8D%E7%BD%AE.html</id>
    <link href="https://liuyueyi.github.io/tutorial/spring/web/RestTemplate/200723-SpringBoot%E7%B3%BB%E5%88%97RestTemplate%E4%B9%8B%E8%BF%9E%E6%8E%A5%E6%B1%A0%E9%85%8D%E7%BD%AE.html"/>
    <updated>2023-02-10T04:50:05.000Z</updated>
    <summary type="html"><![CDATA[<p>我又回来更新RestTemplate了，前面更完之后忽然发现还漏了两个常用的场景，连接池的配置以及错误重试，这就迅速的把这个补上；本篇主要介绍RestTemplate如何设置连接池</p>
]]></summary>
    <content type="html"><![CDATA[<p>我又回来更新RestTemplate了，前面更完之后忽然发现还漏了两个常用的场景，连接池的配置以及错误重试，这就迅速的把这个补上；本篇主要介绍RestTemplate如何设置连接池</p>
<!-- more -->
<h2> I. 项目搭建</h2>
<p>本项目基于SpringBoot <code>2.2.1.RELEASE</code> + <code>maven 3.5.3</code> + <code>idea</code>进行开发</p>
<h3> 1. pom依赖</h3>
<p>核心pom依赖如下</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>请注意，我们这里引入的依赖，多了一个<code>httpclient</code>，在下面的连接池配置中，主要借助它的连接池管理来创建HttpClient对象</p>
<h2> II. 使用姿势</h2>
<h3> 1. 连接池配置</h3>
<p>一般来讲，借助<code>httpcomponents</code>这个包进行连接池配置时，可以分为三步</p>
<p><strong>初始化连接池管理类</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>HttpClient构造器</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>RestTemplate RequestFactory创建</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>到这里基本上就是前面的初始化RestTemplate的环节了</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. OkHttp方式</h3>
<p>对于RestTemplate的HttpClient执行库，除了上面的<code>httpcomponents</code>之外，还有一个OkHttp目前也是大受欢迎，如果我们使用OkHttp，那么可以怎么设置呢?</p>
<p>首先依然是引入依赖</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其次和上面三步骤差不多的设置</p>
<p><strong>初始化连接池</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>创建OkHttpClient</strong></p>
<p>注意这里和上面是有区别的，前面是构建HttpClient构造器，而这里直接生成了一个OkHttpClient，内置连接池</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>RestTemplate RequestFactory创建</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>最后就是创建<code>RestTemplate</code>了</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2> II. 其他</h2>
<h3> 0. 项目&amp;系列博文</h3>
<p><strong>博文</strong></p>
<ul>
<li><a href="http://spring.hhui.top/spring-blog/2020/07/10/200710-SpringBoot%E7%B3%BB%E5%88%97RestTemplate%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/" target="_blank" rel="noopener noreferrer">【WEB系列】RestTemplate之文件上传</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2020/07/07/200707-SpringBoot%E7%B3%BB%E5%88%97AsyncRestTemplate%E4%B9%8B%E5%BC%82%E6%AD%A5%E9%9D%9E%E9%98%BB%E5%A1%9E%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E4%BB%8B%E7%BB%8D%E7%AF%87/" target="_blank" rel="noopener noreferrer">【WEB系列】AsyncRestTemplate之异步非阻塞网络请求介绍篇</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2020/07/05/200705-SpringBoot%E7%B3%BB%E5%88%97RestTemplate%E4%B9%8B%E9%9D%9E200%E7%8A%B6%E6%80%81%E7%A0%81%E4%BF%A1%E6%81%AF%E6%8D%95%E8%8E%B7/" target="_blank" rel="noopener noreferrer">【WEB系列】RestTemplate之非200状态码信息捕获</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2020/07/04/200704-SpringBoot%E7%B3%BB%E5%88%97RestTemplate%E4%B9%8BBasic-Auth%E6%8E%88%E6%9D%83/" target="_blank" rel="noopener noreferrer">【WEB系列】RestTemplate之Basic Auth授权</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2020/07/03/200703-SpringBoot%E7%B3%BB%E5%88%97RestTemplate%E4%B9%8B%E4%BB%A3%E7%90%86%E8%AE%BF%E9%97%AE/" target="_blank" rel="noopener noreferrer">【WEB系列】RestTemplate之代理访问</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2020/07/02/200702-SpringBoot%E7%B3%BB%E5%88%97RestTemplate%E4%B9%8B%E8%B6%85%E6%97%B6%E8%AE%BE%E7%BD%AE/" target="_blank" rel="noopener noreferrer">【WEB系列】RestTemplate之超时设置</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2020/07/01/200701-SpringBoot%E7%B3%BB%E5%88%97RestTemplate%E4%B9%8B%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98fix/" target="_blank" rel="noopener noreferrer">【WEB系列】RestTemplate之中文乱码问题fix</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2020/06/30/200630-SpringBoot%E7%B3%BB%E5%88%97RestTemplate%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E8%AF%B7%E6%B1%82%E5%A4%B4/" target="_blank" rel="noopener noreferrer">【WEB系列】RestTemplate之自定义请求头</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2020/06/30/200630-SpringBoot%E7%B3%BB%E5%88%97RestTemplate%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E8%AF%B7%E6%B1%82%E5%A4%B4/" target="_blank" rel="noopener noreferrer">【WEB系列】RestTemplate基础用法小结</a></li>
</ul>
<p><strong>源码</strong></p>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码: <a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/221-web-resttemplate" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/221-web-resttemplate</a></li>
</ul>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="SpringBoot"/>
    <category term="WEB系列"/>
    <category term="RestTemplate"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2020-07-23T08:39:19.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">RestTemplate</title>
    <id>https://liuyueyi.github.io/tutorial/spring/web/RestTemplate/</id>
    <link href="https://liuyueyi.github.io/tutorial/spring/web/RestTemplate/"/>
    <updated>2023-02-10T04:50:05.000Z</updated>
    <summary type="html"><![CDATA[<p>天天与网络打交道，那么你知道Spring中哪个工具类是最好用的么？没错就是RestTemplate，系列文章教你用好这个利器，解决网络资源访问的难点</p>
]]></summary>
    <content type="html"><![CDATA[<p>天天与网络打交道，那么你知道Spring中哪个工具类是最好用的么？没错就是RestTemplate，系列文章教你用好这个利器，解决网络资源访问的难点</p>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2023-02-10T04:50:05.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">1.基础使用姿势</title>
    <id>https://liuyueyi.github.io/tutorial/spring/web/WebClient/200709-SpringBoot%E7%B3%BB%E5%88%97WebClient%E4%B9%8B%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF.html</id>
    <link href="https://liuyueyi.github.io/tutorial/spring/web/WebClient/200709-SpringBoot%E7%B3%BB%E5%88%97WebClient%E4%B9%8B%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF.html"/>
    <updated>2023-02-10T04:50:05.000Z</updated>
    <summary type="html"><![CDATA[<p>前面在介绍使用<code>AsyncRestTemplate</code>来实现网络异步请求时，当时提到在Spring5+之后，建议通过WebClient来取代AsyncRestTemplate来实现异步网络请求；</p>
<p>那么WebClient又是一个什么东西呢，它是怎样替代<code>AsyncRestTemplate</code>来实现异步请求的呢，接下来我们将进入Spring Web工具篇中，比较重要的WebClient系列知识点，本文为第一篇，基本使用姿势一览</p>
]]></summary>
    <content type="html"><![CDATA[<p>前面在介绍使用<code>AsyncRestTemplate</code>来实现网络异步请求时，当时提到在Spring5+之后，建议通过WebClient来取代AsyncRestTemplate来实现异步网络请求；</p>
<p>那么WebClient又是一个什么东西呢，它是怎样替代<code>AsyncRestTemplate</code>来实现异步请求的呢，接下来我们将进入Spring Web工具篇中，比较重要的WebClient系列知识点，本文为第一篇，基本使用姿势一览</p>
<!-- more -->
<h2> I. 项目环境</h2>
<p>我们依然采用SpringBoot来搭建项目，版本为 <code>2.2.1.RELEASE</code>, <code>maven3.2</code>作为构建工具，<code>idea</code>作为开发环境</p>
<h3> 1. pom依赖</h3>
<p>SpringBoot相关的依赖就不贴出来了，有兴趣的可以查看源码，下面是关键依赖</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>请注意一下上面的两个依赖包，对于使用<code>WebClient</code>，主要需要引入<code>spring-boot-starter-webflux</code>包</p>
<h3> 2. 测试REST接口</h3>
<p>接下来我们直接在这个项目中写几个用于测试的REST接口，因为项目引入的webflux的依赖包，所以我们这里也采用webflux的注解方式，新增用于测试的GET/POST接口</p>
<blockquote>
<p>对于WebFlux用法不太清楚的小伙伴也没有关系，WebClient的发起的请求，后端是基于传统的Servlet也是没有问题的；关于WebFlux的知识点，将放在WebClient系列博文之后进行介绍</p>
</blockquote>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>针对上面的两个POST方法，虽然参数都是Body，但是一个有<code>@RequestBody</code>，一个没有，这里需要额外注意</p>
<p>从下图也可以看出，两者的区别之处</p>
<figure><img src="/imgs/200709/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> II. WebClient使用说明</h2>
<p>接下来我们将进入WebClient的使用说明，主要针对最常见的GET/POST请求姿势进行实例展示，目标是看完下面的内容之后，可以愉快的进行<strong>最基本</strong>（手动加强语气）的GET/POST请求发送</p>
<p>以下所有内容，参考or启发与官方文档: <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web-reactive.html#webflux-client" target="_blank" rel="noopener noreferrer">https://docs.spring.io/spring/docs/current/spring-framework-reference/web-reactive.html#webflux-client</a></p>
<h3> 1. WebClient创建姿势</h3>
<p>一般有三种获得WebClient的方式，基于<code>WebClient#create</code>创建默认的WebClient，基于<code>WebClient#builder</code>创建有自定义需求的WebClient，基于已有的<code>webclient#mutate</code>创建</p>
<h4> a. create方式</h4>
<p>这种属于最常见，也是最基础的创建方式，通常有两种case</p>
<ul>
<li><code>WebClient.create()</code></li>
<li><code>WebClient.create(String baseUrl)</code>：与上面一个最主要的区别在于指定了baseUrl，后面再发起的请求，就不需要重复这个baseUrl了；
<ul>
<li>举例说明：baseUrl指定为<code>http://127.0.0.1:8080</code>；那么后面的请求url，直接填写<code>/get</code>, <code>/header</code>, <code>/post</code>这种path路径即可</li>
</ul>
</li>
</ul>
<p>下面给出一个实例说明</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> b. builder方式</h4>
<p>builder方式最大的区别在于它可以为<code>WebClient</code> "赋能", 比如我们希望所有的请求都有通用的请求头、cookie等，就可以通过<code>builder</code>的方式，在创建<code>WebClient</code>的时候就进行指定</p>
<p>官方支持的可选配置如下：</p>
<ul>
<li><code>uriBuilderFactory</code>: Customized UriBuilderFactory to use as a base URL.</li>
<li><code>defaultHeader</code>: Headers for every request.</li>
<li><code>defaultCookie</code>: Cookies for every request.</li>
<li><code>defaultRequest</code>: Consumer to customize every request.</li>
<li><code>filter</code>: Client filter for every request.</li>
<li><code>exchangeStrategies</code>: HTTP message reader/writer customizations.</li>
<li><code>clientConnector</code>: HTTP client library settings.</li>
</ul>
<blockquote>
<p>关于上面这些东西有啥用，怎么用，会在后续的系列博文中逐一进行介绍，这里就不详细展开；有兴趣的小伙伴可以关注收藏一波</p>
</blockquote>
<p>给出一个设置默认Header的实例</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> c. mutate方式</h4>
<p>这种方式主要是在一个已经存在的<code>WebClient</code>基础上，再创建一个满足自定义需求的<code>WebClient</code></p>
<p>为什么要这样呢？</p>
<ul>
<li>因为WebClient一旦创建，就是不可修改的</li>
</ul>
<p>下面给出一个在builder创建基础上，再添加cookie的实例</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> d. 测试输出</h4>
<p>查看项目源码的小伙伴，会看到上面三个代码片段是在同一个方法内部，测试输出如下</p>
<figure><img src="/imgs/200709/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>你会看到一个有意思的地方，第一种基础的创建方式输出在第二种之后，这个是没有问题的哈（有疑问的小伙伴可以看一下文章开头，我们介绍WebClient的起因是啥）</p>
<h3> 2. GET请求</h3>
<p>上面其实已经给出了GET的请求姿势，一般使用姿势也比较简单，我们需要重点关注一下这个传参问题</p>
<p>常见的使用姿势</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>get的传参，除了在uri中直接写死之外，还有几种常见的写法</p>
<h4> a. uri参数</h4>
<p><strong>可变参数</strong></p>
<p>查看源码的小伙伴，可以看到uri方法的接口声明为一个可变参数，所以就有一种uri用占位<code>{}</code>表示参数位置，后面的参数对应参数值的时候用方式</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>请注意，上面两个参数的case中，p1对应的是<code>一灰灰</code>，p2对应的是<code>18</code>；这里的p1和p2可以替换为任意的其他字符，它们是按照顺序进行填充的，即第一个参数值填在第一个<code>{}</code>坑位</p>
<p><strong>map参数映射</strong></p>
<p>另外一种方式就是通过map来绑定参数名与参数值之间的映射关系</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> b. 获取ResponseEntity</h4>
<p>请仔细观察上面的使用姿势，调用了<code>retrieve()</code>方法，这个主要就是用来从返回结果中“摘出”<code>responseBody</code>，那么如果我们希望后去返回的请求头，返回的状态码，则需要将这个方法替换为<code>exchange()</code></p>
<p>下面给出一个获取返回的请求头实例</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>和前面的时候姿势大同小异，至于flatMap这些知识点会放在后续的WebFlux中进行介绍，这里知道它是用来ResponseBody格式转换关键点即可</p>
<h4> c. 测试返回</h4>
<p>测试输出结果如下（当然实际输出顺序和上面定义的先后也没有什么关系）</p>
<figure><img src="/imgs/200709/02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 3. POST请求</h3>
<p>对于post请求，我们一般最长关注的就是基本的表单传参和json body方式传递，下面分别给与介绍</p>
<h4> a. 表单参数</h4>
<p>借助<code>MultiValueMap</code>来保存表单参数用于提交</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面注释了一行<code>contentType(MediaType.APPLICATION_FORM_URLENCODED)</code>，因为默认的ContentType就是这个了，所以不需要额外指定（当然手动指定也没有任何毛病）</p>
<p>除了上面这种使用姿势之外，在官方教程上，还有一种写法，特别注意下面这种写法的传参是用的<code>body</code>，而上面是<code>bodyValue</code>，千万别用错，不然...</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> b. json body传参</h4>
<p>post一个json串，可以说是比较常见的case了，在WebClient中，使用这种方式特别特别简单，感觉比前面那个还方便</p>
<ul>
<li>指定ContentType</li>
<li>传入Object对象</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> c. 测试输出</h4>
<figure><img src="/imgs/200709/03.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 4. 小结</h3>
<p>本文为WebClient系列第一篇，介绍WebClient的基本使用姿势，当然看完之后，发起GET/POST请求还是没有什么问题的；但是仅限于此嘛？</p>
<ul>
<li>builder创建方式中，那些可选的条件都是啥，有什么用，什么场景下会用呢？</li>
<li>请求超时时间可设置么？</li>
<li>可以同步阻塞方式获取返回结果嘛？</li>
<li>代理怎么加</li>
<li><code>event-stream</code>返回方式的数据怎么处理</li>
<li>如何上传文件</li>
<li>Basic Auth身份鉴权</li>
<li>异步线程池可指定么，可替换为自定义的么</li>
<li>返回非200状态码时，表现如何，又该如何处理</li>
<li>....</li>
</ul>
<p>后续的系列博文将针对上面提出or尚未提出的问题，一一进行介绍，看到的各位大佬按按鼠标点赞收藏评论关注加个好友呗</p>
<h2> II. 其他</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/222-web-client" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/222-web-client</a></li>
</ul>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="SpringBoot"/>
    <category term="WEB系列"/>
    <category term="WebClient"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2020-07-09T09:22:09.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
</feed>