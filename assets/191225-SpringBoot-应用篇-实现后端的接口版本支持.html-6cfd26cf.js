const e=JSON.parse('{"key":"v-cb0f2bce","path":"/spring/web/%E5%AE%9E%E4%BE%8B/191225-SpringBoot-%E5%BA%94%E7%94%A8%E7%AF%87-%E5%AE%9E%E7%8E%B0%E5%90%8E%E7%AB%AF%E7%9A%84%E6%8E%A5%E5%8F%A3%E7%89%88%E6%9C%AC%E6%94%AF%E6%8C%81.html","title":"4.实现后端的接口版本支持（应用篇）","lang":"zh-CN","frontmatter":{"order":4,"title":"4.实现后端的接口版本支持（应用篇）","tag":["RequestCondition","应用"],"category":["SpringBoot","WEB系列","应用篇"],"date":"2019-12-25T10:36:25.000Z","keywords":"Spring SpringBoot SpringMVC RequestCondition HandlerMapping ApiVersion","description":"作为一个主职的后端开发者，在平时的工作中，最讨厌的做的事情可以说是参数校验和接口的版本支持了。对于客户端的同学来说，业务的历史包袱会小很多，当出现不兼容的业务变动时，直接开发新的就好；然而后端就没有这么简单了，历史的接口得支持，新的业务也得支持，吭哧吭哧的新加一个服务接口，url又不能和之前的相同，怎么办？只能在某个地方加一个类似v1, v2... 那么有没有一种不改变url，通过其他的方式来支持版本管理的方式呢？ 本文将介绍一种，利用请求头来传递客户端版本，在相同的url中寻找最适合的这个版本请求的接口的实例case 主要用到的知识点为: RequestCondition RequestMappingHandlerMapping","head":[["meta",{"property":"og:url","content":"https://liuyueyi.github.io/tutorial/spring/web/%E5%AE%9E%E4%BE%8B/191225-SpringBoot-%E5%BA%94%E7%94%A8%E7%AF%87-%E5%AE%9E%E7%8E%B0%E5%90%8E%E7%AB%AF%E7%9A%84%E6%8E%A5%E5%8F%A3%E7%89%88%E6%9C%AC%E6%94%AF%E6%8C%81.html"}],["meta",{"property":"og:site_name","content":"一灰灰的站点"}],["meta",{"property":"og:title","content":"4.实现后端的接口版本支持（应用篇）"}],["meta",{"property":"og:description","content":"作为一个主职的后端开发者，在平时的工作中，最讨厌的做的事情可以说是参数校验和接口的版本支持了。对于客户端的同学来说，业务的历史包袱会小很多，当出现不兼容的业务变动时，直接开发新的就好；然而后端就没有这么简单了，历史的接口得支持，新的业务也得支持，吭哧吭哧的新加一个服务接口，url又不能和之前的相同，怎么办？只能在某个地方加一个类似v1, v2... 那么有没有一种不改变url，通过其他的方式来支持版本管理的方式呢？ 本文将介绍一种，利用请求头来传递客户端版本，在相同的url中寻找最适合的这个版本请求的接口的实例case 主要用到的知识点为: RequestCondition RequestMappingHandlerMapping"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-02-10T04:50:05.000Z"}],["meta",{"property":"article:tag","content":"RequestCondition"}],["meta",{"property":"article:tag","content":"应用"}],["meta",{"property":"article:published_time","content":"2019-12-25T10:36:25.000Z"}],["meta",{"property":"article:modified_time","content":"2023-02-10T04:50:05.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"4.实现后端的接口版本支持（应用篇）\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2019-12-25T10:36:25.000Z\\",\\"dateModified\\":\\"2023-02-10T04:50:05.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"I. 应用场景","slug":"i-应用场景","link":"#i-应用场景","children":[{"level":3,"title":"1. 约定","slug":"_1-约定","link":"#_1-约定","children":[]},{"level":3,"title":"2. 规则","slug":"_2-规则","link":"#_2-规则","children":[]}]},{"level":2,"title":"II. 应用实现","slug":"ii-应用实现","link":"#ii-应用实现","children":[{"level":3,"title":"1. 接口定义","slug":"_1-接口定义","link":"#_1-接口定义","children":[]},{"level":3,"title":"2. HandlerMapping接口选择","slug":"_2-handlermapping接口选择","link":"#_2-handlermapping接口选择","children":[]}]},{"level":2,"title":"III. 测试","slug":"iii-测试","link":"#iii-测试","children":[{"level":3,"title":"case1. 方法上添加版本","slug":"case1-方法上添加版本","link":"#case1-方法上添加版本","children":[]},{"level":3,"title":"case2. 类版本+方法版本","slug":"case2-类版本-方法版本","link":"#case2-类版本-方法版本","children":[]}]},{"level":2,"title":"IV. 其他","slug":"iv-其他","link":"#iv-其他","children":[{"level":3,"title":"0. 项目&相关博文","slug":"_0-项目-相关博文","link":"#_0-项目-相关博文","children":[]}]}],"git":{"createdTime":1676004605000,"updatedTime":1676004605000,"contributors":[{"name":"YiHui","email":"bangzewu@126.com","commits":1}]},"readingTime":{"minutes":5.65,"words":1694},"filePathRelative":"spring/web/实例/191225-SpringBoot-应用篇-实现后端的接口版本支持.md","localizedDate":"2019年12月25日","excerpt":"<p>作为一个主职的后端开发者，在平时的工作中，最讨厌的做的事情可以说是参数校验和接口的版本支持了。对于客户端的同学来说，业务的历史包袱会小很多，当出现不兼容的业务变动时，直接开发新的就好；然而后端就没有这么简单了，历史的接口得支持，新的业务也得支持，吭哧吭哧的新加一个服务接口，url又不能和之前的相同，怎么办？只能在某个地方加一个类似<code>v1</code>, <code>v2</code>...</p>\\n<p>那么有没有一种不改变url，通过其他的方式来支持版本管理的方式呢？</p>\\n<blockquote>\\n<p>本文将介绍一种，利用请求头来传递客户端版本，在相同的url中寻找最适合的这个版本请求的接口的实例case</p>\\n</blockquote>\\n<p>主要用到的知识点为:</p>\\n<ul>\\n<li>RequestCondition</li>\\n<li>RequestMappingHandlerMapping</li>\\n</ul>\\n","copyright":{},"autoDesc":true}');export{e as data};
