const e=JSON.parse('{"key":"v-205b6168","path":"/column/app/spi/SPI%E6%A1%86%E6%9E%B6%E5%AE%9E%E7%8E%B0%E4%B9%8B%E6%97%85%E4%B8%80%EF%BC%9A%E8%83%8C%E6%99%AF%E4%BB%8B%E7%BB%8D.html","title":"1. SPI框架实现之旅一：背景介绍","lang":"zh-CN","frontmatter":{"order":1,"title":"1. SPI框架实现之旅一：背景介绍","date":"2017-05-26T10:46:42.000Z","tag":["Java","技术方案"],"category":["Quick系列","QuickSpi"],"description":"背景介绍 SPI的全名为Service Provider Interface，简单的总结下java spi机制的思想。我们系统里抽象的各个模块，往往有很多不同的实现方案，比如日志模块的方案，xml解析模块、jdbc模块的方案等。面向的对象的设计里，我们一般推荐模块之间基于接口编程，模块之间不对实现类进行硬编码。一旦代码里涉及具体的实现类，就违反了可拔插的原则，如果需要替换一种实现，就需要修改代码。为了实现在模块装配的时候能不在程序里动态指明，这就需要一种服务发现机制。 java spi就是提供这样的一个机制：为某个接口寻找服务实现的机制","head":[["meta",{"property":"og:url","content":"https://liuyueyi.github.io/tutorial/column/app/spi/SPI%E6%A1%86%E6%9E%B6%E5%AE%9E%E7%8E%B0%E4%B9%8B%E6%97%85%E4%B8%80%EF%BC%9A%E8%83%8C%E6%99%AF%E4%BB%8B%E7%BB%8D.html"}],["meta",{"property":"og:site_name","content":"一灰灰的站点"}],["meta",{"property":"og:title","content":"1. SPI框架实现之旅一：背景介绍"}],["meta",{"property":"og:description","content":"背景介绍 SPI的全名为Service Provider Interface，简单的总结下java spi机制的思想。我们系统里抽象的各个模块，往往有很多不同的实现方案，比如日志模块的方案，xml解析模块、jdbc模块的方案等。面向的对象的设计里，我们一般推荐模块之间基于接口编程，模块之间不对实现类进行硬编码。一旦代码里涉及具体的实现类，就违反了可拔插的原则，如果需要替换一种实现，就需要修改代码。为了实现在模块装配的时候能不在程序里动态指明，这就需要一种服务发现机制。 java spi就是提供这样的一个机制：为某个接口寻找服务实现的机制"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-07-31T12:28:49.000Z"}],["meta",{"property":"article:tag","content":"Java"}],["meta",{"property":"article:tag","content":"技术方案"}],["meta",{"property":"article:published_time","content":"2017-05-26T10:46:42.000Z"}],["meta",{"property":"article:modified_time","content":"2024-07-31T12:28:49.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"1. SPI框架实现之旅一：背景介绍\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2017-05-26T10:46:42.000Z\\",\\"dateModified\\":\\"2024-07-31T12:28:49.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"1. 背景","slug":"_1-背景","link":"#_1-背景","children":[{"level":3,"title":"什么是SPI","slug":"什么是spi","link":"#什么是spi","children":[]},{"level":3,"title":"什么场景可以用","slug":"什么场景可以用","link":"#什么场景可以用","children":[]},{"level":3,"title":"可以怎么用","slug":"可以怎么用","link":"#可以怎么用","children":[]}]},{"level":2,"title":"2. 小目标","slug":"_2-小目标","link":"#_2-小目标","children":[]},{"level":2,"title":"3. 技术储备","slug":"_3-技术储备","link":"#_3-技术储备","children":[]},{"level":2,"title":"4. 设计思路","slug":"_4-设计思路","link":"#_4-设计思路","children":[]},{"level":2,"title":"5. 其他","slug":"_5-其他","link":"#_5-其他","children":[{"level":3,"title":"博客系列链接：","slug":"博客系列链接","link":"#博客系列链接","children":[]},{"level":3,"title":"项目: QuickAlarm","slug":"项目-quickalarm","link":"#项目-quickalarm","children":[]},{"level":3,"title":"个人博客： Z+|blog","slug":"个人博客-z-blog","link":"#个人博客-z-blog","children":[]},{"level":3,"title":"声明","slug":"声明","link":"#声明","children":[]},{"level":3,"title":"扫描关注","slug":"扫描关注","link":"#扫描关注","children":[]}]}],"git":{"createdTime":1722428929000,"updatedTime":1722428929000,"contributors":[{"name":"yihui","email":"bangzewu@126.com","commits":1}]},"readingTime":{"minutes":6.56,"words":1968},"filePathRelative":"column/app/spi/SPI框架实现之旅一：背景介绍.md","localizedDate":"2017年5月26日","excerpt":"<h1> 背景介绍</h1>\\n<blockquote>\\n<p>SPI的全名为Service Provider Interface，简单的总结下java spi机制的思想。我们系统里抽象的各个模块，往往有很多不同的实现方案，比如日志模块的方案，xml解析模块、jdbc模块的方案等。面向的对象的设计里，我们一般推荐模块之间基于接口编程，模块之间不对实现类进行硬编码。一旦代码里涉及具体的实现类，就违反了可拔插的原则，如果需要替换一种实现，就需要修改代码。为了实现在模块装配的时候能不在程序里动态指明，这就需要一种服务发现机制。 java spi就是提供这样的一个机制：为某个接口寻找服务实现的机制</p>\\n</blockquote>","copyright":{},"autoDesc":true}');export{e as data};
