const e=JSON.parse('{"key":"v-672fc8dc","path":"/spring/web/%E5%AE%9E%E4%BE%8B/220123-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8B%E4%BB%8E0%E5%88%B01%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%AE%9A%E4%B9%89web%E5%8F%82%E6%95%B0%E6%98%A0%E5%B0%84%E5%99%A8.html","title":"8.从0到1实现自定义web参数映射器","lang":"zh-CN","frontmatter":{"order":8,"title":"8.从0到1实现自定义web参数映射器","tag":["请求参数"],"category":["SpringBoot","WEB系列","Request"],"date":"2022-01-23T19:54:25.000Z","keywords":["SpringBoot","RequestParam","驼峰","下划线","HandlerMethodArgumentResolver","SpringBoot系列之从0到1实现自定义web参数映射器"],"description":"SpringBoot系列之从0到1实现自定义web参数映射器 在使用SpringMVC进行开发时，接收请求参数属于基本功，当我们希望将传参与项目中的对象关联起来时，最常见的做法是默认的case（即传参name与我们定义的name保持一致），当存在不一致，需要手动指定时，通常是借助注解@RequestParam来实现，但是不知道各位小伙伴是否有发现，它的使用是有缺陷的 @RequestParam不支持配置在类的属性上 如果我们定义一个VO对象来接收传承，这个注解用不了,如当我们定义一个Java bean(pojo)来接收参数时，若是get请求，post表单请求时，这个时候要求传参name与pojo的属性名完全匹配，如果我们有别名的需求场景，怎么整？ 最简单的如传参为: user_id=110&amp;user_name=一灰灰 而接收参数的POJO为 public class ViewDo { private String uesrId; private String userName; }","head":[["meta",{"property":"og:url","content":"https://liuyueyi.github.io/tutorial/spring/web/%E5%AE%9E%E4%BE%8B/220123-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8B%E4%BB%8E0%E5%88%B01%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%AE%9A%E4%B9%89web%E5%8F%82%E6%95%B0%E6%98%A0%E5%B0%84%E5%99%A8.html"}],["meta",{"property":"og:site_name","content":"一灰灰的站点"}],["meta",{"property":"og:title","content":"8.从0到1实现自定义web参数映射器"}],["meta",{"property":"og:description","content":"SpringBoot系列之从0到1实现自定义web参数映射器 在使用SpringMVC进行开发时，接收请求参数属于基本功，当我们希望将传参与项目中的对象关联起来时，最常见的做法是默认的case（即传参name与我们定义的name保持一致），当存在不一致，需要手动指定时，通常是借助注解@RequestParam来实现，但是不知道各位小伙伴是否有发现，它的使用是有缺陷的 @RequestParam不支持配置在类的属性上 如果我们定义一个VO对象来接收传承，这个注解用不了,如当我们定义一个Java bean(pojo)来接收参数时，若是get请求，post表单请求时，这个时候要求传参name与pojo的属性名完全匹配，如果我们有别名的需求场景，怎么整？ 最简单的如传参为: user_id=110&amp;user_name=一灰灰 而接收参数的POJO为 public class ViewDo { private String uesrId; private String userName; }"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-02-10T04:50:05.000Z"}],["meta",{"property":"article:tag","content":"请求参数"}],["meta",{"property":"article:published_time","content":"2022-01-23T19:54:25.000Z"}],["meta",{"property":"article:modified_time","content":"2023-02-10T04:50:05.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"8.从0到1实现自定义web参数映射器\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2022-01-23T19:54:25.000Z\\",\\"dateModified\\":\\"2023-02-10T04:50:05.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"I. 项目搭建","slug":"i-项目搭建","link":"#i-项目搭建","children":[{"level":3,"title":"1. 项目依赖","slug":"_1-项目依赖","link":"#_1-项目依赖","children":[]}]},{"level":2,"title":"II. 别名映射","slug":"ii-别名映射","link":"#ii-别名映射","children":[{"level":3,"title":"0. 知识点概要说明","slug":"_0-知识点概要说明","link":"#_0-知识点概要说明","children":[]},{"level":3,"title":"1. 自定义注解","slug":"_1-自定义注解","link":"#_1-自定义注解","children":[]},{"level":3,"title":"2. 自定义参数处理器","slug":"_2-自定义参数处理器","link":"#_2-自定义参数处理器","children":[]},{"level":3,"title":"3. 注册与测试","slug":"_3-注册与测试","link":"#_3-注册与测试","children":[]},{"level":3,"title":"4. 小结","slug":"_4-小结","link":"#_4-小结","children":[]}]},{"level":2,"title":"III. 不能错过的源码和相关知识点","slug":"iii-不能错过的源码和相关知识点","link":"#iii-不能错过的源码和相关知识点","children":[{"level":3,"title":"0. 项目","slug":"_0-项目","link":"#_0-项目","children":[]},{"level":3,"title":"1. 微信公众号: 一灰灰Blog","slug":"_1-微信公众号-一灰灰blog","link":"#_1-微信公众号-一灰灰blog","children":[]}]}],"git":{"createdTime":1676004605000,"updatedTime":1676004605000,"contributors":[{"name":"YiHui","email":"bangzewu@126.com","commits":1}]},"readingTime":{"minutes":8.04,"words":2412},"filePathRelative":"spring/web/实例/220123-SpringBoot系列之从0到1实现自定义web参数映射器.md","localizedDate":"2022年1月23日","excerpt":"<blockquote>\\n<p>SpringBoot系列之从0到1实现自定义web参数映射器</p>\\n</blockquote>\\n<p>在使用SpringMVC进行开发时，接收请求参数属于基本功，当我们希望将传参与项目中的对象关联起来时，最常见的做法是默认的case（即传参name与我们定义的name保持一致），当存在不一致，需要手动指定时，通常是借助注解<code>@RequestParam</code>来实现，但是不知道各位小伙伴是否有发现，它的使用是有缺陷的</p>\\n<ul>\\n<li><code>@RequestParam</code>不支持配置在类的属性上</li>\\n</ul>\\n<p>如果我们定义一个VO对象来接收传承，这个注解用不了,如当我们定义一个Java bean(pojo)来接收参数时，若是get请求，post表单请求时，这个时候要求传参name与pojo的属性名完全匹配，如果我们有别名的需求场景，怎么整？</p>\\n<p>最简单的如传参为: <code>user_id=110&amp;user_name=一灰灰</code></p>\\n<p>而接收参数的POJO为</p>\\n<div class=\\"language-java line-numbers-mode\\" data-ext=\\"java\\"><pre class=\\"language-java\\"><code><span class=\\"token keyword\\">public</span> <span class=\\"token keyword\\">class</span> <span class=\\"token class-name\\">ViewDo</span> <span class=\\"token punctuation\\">{</span>\\n  <span class=\\"token keyword\\">private</span> <span class=\\"token class-name\\">String</span> uesrId<span class=\\"token punctuation\\">;</span>\\n  <span class=\\"token keyword\\">private</span> <span class=\\"token class-name\\">String</span> userName<span class=\\"token punctuation\\">;</span>\\n<span class=\\"token punctuation\\">}</span>\\n</code></pre><div class=\\"line-numbers\\" aria-hidden=\\"true\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div>","copyright":{},"autoDesc":true}');export{e as data};
