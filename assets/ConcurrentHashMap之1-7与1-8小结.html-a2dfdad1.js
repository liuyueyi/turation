const e=JSON.parse('{"key":"v-d85da3ea","path":"/java/jdk/%E6%BA%90%E7%A0%81/ConcurrentHashMap%E4%B9%8B1-7%E4%B8%8E1-8%E5%B0%8F%E7%BB%93.html","title":"ConcurrentHashMap之1.7与1.8小结","lang":"zh-CN","frontmatter":{"title":"ConcurrentHashMap之1.7与1.8小结","tag":["Java","JDK"],"category":["Java","JDK","容器"],"date":"2018-05-14T10:01:40.000Z","description":"I. ConcurrentHashMap 两种实现方式小结 1. 锁分段机制 HashMap的底层数据结构是数组+hash链表的方式，非线程安全 ConcurrentHashMap 采用锁分段机制，底层数据结构为二维数组，其中第一层是Segment的数组，每个Segment持有一把独立的锁，而Segment的结构和HashMap很相似；这就是锁分段机制；线程安全 关注几个点： ConcurrentHashMap 如何定位 Segment, 如何定位 HashEntry 修改的加锁逻辑，如何进行扩容 读数据时，如何做到不加锁但保证线程安全的？","head":[["meta",{"property":"og:url","content":"https://liuyueyi.github.io/tutorial/java/jdk/%E6%BA%90%E7%A0%81/ConcurrentHashMap%E4%B9%8B1-7%E4%B8%8E1-8%E5%B0%8F%E7%BB%93.html"}],["meta",{"property":"og:site_name","content":"一灰灰的站点"}],["meta",{"property":"og:title","content":"ConcurrentHashMap之1.7与1.8小结"}],["meta",{"property":"og:description","content":"I. ConcurrentHashMap 两种实现方式小结 1. 锁分段机制 HashMap的底层数据结构是数组+hash链表的方式，非线程安全 ConcurrentHashMap 采用锁分段机制，底层数据结构为二维数组，其中第一层是Segment的数组，每个Segment持有一把独立的锁，而Segment的结构和HashMap很相似；这就是锁分段机制；线程安全 关注几个点： ConcurrentHashMap 如何定位 Segment, 如何定位 HashEntry 修改的加锁逻辑，如何进行扩容 读数据时，如何做到不加锁但保证线程安全的？"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-08-06T00:41:18.000Z"}],["meta",{"property":"article:tag","content":"Java"}],["meta",{"property":"article:tag","content":"JDK"}],["meta",{"property":"article:published_time","content":"2018-05-14T10:01:40.000Z"}],["meta",{"property":"article:modified_time","content":"2024-08-06T00:41:18.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"ConcurrentHashMap之1.7与1.8小结\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2018-05-14T10:01:40.000Z\\",\\"dateModified\\":\\"2024-08-06T00:41:18.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"I. ConcurrentHashMap 两种实现方式小结","slug":"i-concurrenthashmap-两种实现方式小结","link":"#i-concurrenthashmap-两种实现方式小结","children":[{"level":3,"title":"1. 锁分段机制","slug":"_1-锁分段机制","link":"#_1-锁分段机制","children":[]},{"level":3,"title":"2. Node + CAS + Synchronized","slug":"_2-node-cas-synchronized","link":"#_2-node-cas-synchronized","children":[]}]}],"git":{"createdTime":1722595318000,"updatedTime":1722904878000,"contributors":[{"name":"yihui","email":"bangzewu@126.com","commits":2}]},"readingTime":{"minutes":4.89,"words":1467},"filePathRelative":"java/jdk/源码/ConcurrentHashMap之1-7与1-8小结.md","localizedDate":"2018年5月14日","excerpt":"<h2> I. ConcurrentHashMap 两种实现方式小结</h2>\\n<h3> 1. 锁分段机制</h3>\\n<p>HashMap的底层数据结构是数组+hash链表的方式，非线程安全</p>\\n<p>ConcurrentHashMap 采用锁分段机制，底层数据结构为二维数组，其中第一层是Segment的数组，每个Segment持有一把独立的锁，而Segment的结构和HashMap很相似；这就是锁分段机制；线程安全</p>\\n<p>关注几个点：</p>\\n<ul>\\n<li>ConcurrentHashMap 如何定位 Segment, 如何定位 HashEntry</li>\\n<li>修改的加锁逻辑，如何进行扩容</li>\\n<li>读数据时，如何做到不加锁但保证线程安全的？</li>\\n</ul>\\n","copyright":{},"autoDesc":true}');export{e as data};
