const e=JSON.parse('{"key":"v-4e24687c","path":"/column/app/trace-watch-dog/08.%E5%80%9F%E5%8A%A9AOP%E6%8F%90%E4%BE%9B%E9%9D%9E%E4%BE%B5%E5%85%A5%E7%9A%84%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF.html","title":"8.借助AOP提供非侵入的使用姿势","lang":"zh-CN","frontmatter":{"order":8,"title":"8.借助AOP提供非侵入的使用姿势","tag":["trace-watch-dog"],"category":["技术组件"],"date":"2024-08-28T18:19:48.000Z","keywords":["Java","trace"],"description":"再前面完成封装的TraceWatch，进一步简化了使用体验，但是依然存在一个明显的缺陷，对业务代码的侵入性较强，需要再业务代码中，进行主动的埋点 对应常年和Spring打交道的java开发者来说，一个很容易想到的优化方案就是借助AOP来简化业务代码的侵入，接下来我们就看一下，如何借助Spring的AOP能力，对我们之前提供的TraceWatch做一个能力增强 1. 方案设计 对于某个链路的耗时统计，首先确定有一个方法作为耗时记录的入口，表示开始记录耗时，然后就是再执行的过程中，发现有需要统计耗时的方法，则通过Around环绕切面来计算耗时，最后再入口方法执行完毕之后，输出耗时情况即可","head":[["meta",{"property":"og:url","content":"https://liuyueyi.github.io/tutorial/column/app/trace-watch-dog/08.%E5%80%9F%E5%8A%A9AOP%E6%8F%90%E4%BE%9B%E9%9D%9E%E4%BE%B5%E5%85%A5%E7%9A%84%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF.html"}],["meta",{"property":"og:site_name","content":"一灰灰的站点"}],["meta",{"property":"og:title","content":"8.借助AOP提供非侵入的使用姿势"}],["meta",{"property":"og:description","content":"再前面完成封装的TraceWatch，进一步简化了使用体验，但是依然存在一个明显的缺陷，对业务代码的侵入性较强，需要再业务代码中，进行主动的埋点 对应常年和Spring打交道的java开发者来说，一个很容易想到的优化方案就是借助AOP来简化业务代码的侵入，接下来我们就看一下，如何借助Spring的AOP能力，对我们之前提供的TraceWatch做一个能力增强 1. 方案设计 对于某个链路的耗时统计，首先确定有一个方法作为耗时记录的入口，表示开始记录耗时，然后就是再执行的过程中，发现有需要统计耗时的方法，则通过Around环绕切面来计算耗时，最后再入口方法执行完毕之后，输出耗时情况即可"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-08-28T11:39:50.000Z"}],["meta",{"property":"article:tag","content":"trace-watch-dog"}],["meta",{"property":"article:published_time","content":"2024-08-28T18:19:48.000Z"}],["meta",{"property":"article:modified_time","content":"2024-08-28T11:39:50.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"8.借助AOP提供非侵入的使用姿势\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-08-28T18:19:48.000Z\\",\\"dateModified\\":\\"2024-08-28T11:39:50.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"1. 方案设计","slug":"_1-方案设计","link":"#_1-方案设计","children":[{"level":3,"title":"1.1 整体实现流程","slug":"_1-1-整体实现流程","link":"#_1-1-整体实现流程","children":[]},{"level":3,"title":"1.2 方案细节确认","slug":"_1-2-方案细节确认","link":"#_1-2-方案细节确认","children":[]}]},{"level":2,"title":"2. AOP实现","slug":"_2-aop实现","link":"#_2-aop实现","children":[{"level":3,"title":"2.0 前置依赖","slug":"_2-0-前置依赖","link":"#_2-0-前置依赖","children":[]},{"level":3,"title":"2.1 注解定义","slug":"_2-1-注解定义","link":"#_2-1-注解定义","children":[]},{"level":3,"title":"2.2 传播属性定义","slug":"_2-2-传播属性定义","link":"#_2-2-传播属性定义","children":[]},{"level":3,"title":"2.3 切面实现","slug":"_2-3-切面实现","link":"#_2-3-切面实现","children":[]},{"level":3,"title":"2.4 自动注册","slug":"_2-4-自动注册","link":"#_2-4-自动注册","children":[]}]},{"level":2,"title":"3. 使用示例与小结","slug":"_3-使用示例与小结","link":"#_3-使用示例与小结","children":[{"level":3,"title":"3.1 使用示例","slug":"_3-1-使用示例","link":"#_3-1-使用示例","children":[]},{"level":3,"title":"3.2 小结","slug":"_3-2-小结","link":"#_3-2-小结","children":[]}]}],"git":{"createdTime":1724845190000,"updatedTime":1724845190000,"contributors":[{"name":"yihui","email":"bangzewu@126.com","commits":1}]},"readingTime":{"minutes":9.25,"words":2776},"filePathRelative":"column/app/trace-watch-dog/08.借助AOP提供非侵入的使用姿势.md","localizedDate":"2024年8月28日","excerpt":"<p>再前面完成封装的<code>TraceWatch</code>，进一步简化了使用体验，但是依然存在一个明显的缺陷，对业务代码的侵入性较强，需要再业务代码中，进行主动的埋点</p>\\n<p>对应常年和Spring打交道的java开发者来说，一个很容易想到的优化方案就是借助AOP来简化业务代码的侵入，接下来我们就看一下，如何借助Spring的AOP能力，对我们之前提供的<code>TraceWatch</code>做一个能力增强</p>\\n<h2> 1. 方案设计</h2>\\n<p>对于某个链路的耗时统计，首先确定有一个方法作为耗时记录的入口，表示开始记录耗时，然后就是再执行的过程中，发现有需要统计耗时的方法，则通过<code>Around</code>环绕切面来计算耗时，最后再入口方法执行完毕之后，输出耗时情况即可</p>","copyright":{},"autoDesc":true}');export{e as data};
