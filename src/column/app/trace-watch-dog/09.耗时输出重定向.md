---
order: 9
title: 9.耗时输出重定向
tag:
  - trace-watch-dog
category:
  - 技术组件
date: 2024-08-31 18:19:48
keywords:
  - Java
  - trace
---

前面实现的耗时分布输出直接以日志的方式进行打印，在实际的业务场景中，可能希望以其他的方式（比如Prometheus）来收集耗时，基于这种场景，我们的组件又可以怎么进行演进呢？

### 1. 控制日志是否输出

首先我们来看一下，若我不希望输出日志，最简单的实现方式就是直接在`TraceRecoder`中添加变量，用于控制是否进行输出日志

首先改造一下`DefaultTraceRecoder`，新增`logEnable`变量

```java
/**
 * 控制是否打印日志的条件
 */
private boolean logEnable;

public DefaultTraceRecoder() {
    this(AsyncUtil.executorService, "TraceDog", true);
}

public DefaultTraceRecoder(ExecutorService executorService, String task, boolean logEnable) {
    this.traceName = task;
    list = new CopyOnWriteArrayList<>();
    // 支持排序的耗时记录
    cost = new ConcurrentSkipListMap<>();
    this.executorService = TtlExecutors.getTtlExecutorService(executorService);
    this.markExecuteOver = false;
    this.logEnable = logEnable;
    start(task);
    MdcUtil.setGlobalTraceId(MdcUtil.fetchGlobalMsgIdForTraceRecoder());
}
```


接着是输出日志的时候，加一个判断

```java
@Override
public Map<String, Long> prettyPrint() {
    // 在格式化输出时，要求所有任务执行完毕
    if (!this.markExecuteOver) {
        this.allExecuted();
    }

    if (!logEnable) {
        return cost;
    }

    // 省略
    ...
}
```

除此之外，我们还需要改造一下 `trace-watch-dog-spring` 工程中的 `@TraceDog` 注解，需要新增一个是否输入日志的逻辑

考虑到适用的场景，我们新增两个属性来判定是否输出日志

- `boolean logEnable() default true`: 简单版，控制是否输出日志
- `String logSpEL() default "";` SpEL版，根据动态参数来判断是否输出日志

上面两个属性搭配使用；当不存在 `logSpEL` 时，我们直接以 `logEnable` 来判断是否要打印日志；若存在 `logSpEL`，那么我们就要要求上面两个同时为`true`才能输出日志; 

核心的实现就是`logSpEL`的执行

```java
private Boolean buildLogCondition(ProceedingJoinPoint joinPoint, TraceDog dog) {
    if (!dog.logEnable()) {
        return false;
    }

    if (dog.logSpEL() == null || dog.logSpEL().isEmpty()) {
        return true;
    }

    StandardEvaluationContext context = new StandardEvaluationContext();
    context.setBeanResolver(new BeanFactoryResolver(applicationContext));

    // 将请求参数也作为上下文参数
    MethodSignature methodSignature = ((MethodSignature) joinPoint.getSignature());
    String[] parameterNames = methodSignature.getParameterNames();
    Object[] args = joinPoint.getArgs();
    for (int i = 0; i < parameterNames.length; i++) {
        context.setVariable(parameterNames[i], args[i]);
    }
    return (Boolean) parser.parseExpression(dog.logSpEL()).getValue(context);
}
```

从上面的实际实现来看，控制是否打印日志比较简单，那么这个真的有用么？

下面给出几个应用场景：

- 某个执行链路，我们希望测试环境打印日志，生产环境不打印日志（根据运行环境判断是否需要打印日志）
- 某个执行链路，我们通过一个动态的配置来控制是否需要打印日志，当需要进行排查耗时情况分析时，打开配置输出日志；其他情况则进行关闭


### 2. 日志输出重定向

到目前为止，我们所有的耗时输出都是基于控制台/日志文件，当我们的项目集成了类似Prometheus监控系统时，我们可能更希望将耗时上报到Prometheus，因此就有了输出重定向的诉求

为了支持输出重定向，我们新增一个扩展，在`prettyPrint`方法中，根据用户自定义的实现来处理

先定义一个函数方法

```java
@FunctionalInterface
public interface CostOutput {

    /**
     * 输出
     *
     * @param cost      任务耗时分布
     * @param traceName Trace
     */
    void output(Map<String, Long> cost, String traceName);
}
```

接入两个参数，其中 `cost` 记录总耗时 + 各子任务的耗时，traceName 表示入口任务名，主要用于获取总耗时

然后调整一下 `DefaultTraceRecoder`

1. 新增`private List<CostOutput> output;` 保存输出重定向的规则
2. 添加默认的`log.info`输出规则
3. 支持传入自定义的输出重定向规则

```java
private List<CostOutput> output;

public DefaultTraceRecoder() {
    this(AsyncUtil.executorService, "TraceDog", true);
}

public DefaultTraceRecoder(ExecutorService executorService, String task, boolean logEnable) {
    this.traceName = task;
    list = new CopyOnWriteArrayList<>();
    // 支持排序的耗时记录
    cost = new ConcurrentSkipListMap<>();
    this.executorService = TtlExecutors.getTtlExecutorService(executorService);
    this.markExecuteOver = false;
    this.logEnable = logEnable;
    this.output = new ArrayList<>();
    // 默认加载全局的输出重定向规则
    this.output.addAll(TraceWatch.getDefaultOutputList());
    start(task);
    MdcUtil.setGlobalTraceId(MdcUtil.fetchGlobalMsgIdForTraceRecoder());
}

/**
 * 新增一个耗时定向
 *
 * @param costOutput
 * @return
 */
public DefaultTraceRecoder addOutput(CostOutput costOutput) {
    output.add(costOutput);
    return this;
}
```

调整下 `prettyPrint` 方法的实现

```java
@Override
public Map<String, Long> prettyPrint() {
    // 在格式化输出时，要求所有任务执行完毕
    if (!this.markExecuteOver) {
        this.allExecuted();
    }

    if (!logEnable) {
        return cost;
    }

    // 根据自定义规则，对耗时输出进行处理
    output.forEach(o -> o.output(cost, traceName));
    return cost;
}
```

然后就是默认的日志输出

```java
public class LogOutput {
    private static final Logger log = LoggerFactory.getLogger(DefaultTraceRecoder.class);

    /**
     * 输出日志
     *
     * @param cost      耗时分布
     * @param traceName 总任务
     */
    public static void logPrint(Map<String, Long> cost, String traceName) {
        StringBuilder sb = new StringBuilder();
        sb.append('\n');
        long totalCost = cost.get(traceName);
        sb.append("TraceWatch '").append(traceName).append("': running time = ").append(totalCost).append(" ms");
        sb.append('\n');
        if (cost.isEmpty()) {
            sb.append("No task info kept");
        } else {
            sb.append("---------------------------------------------\n");
            sb.append("ms         %     Task name\n");
            sb.append("---------------------------------------------\n");
            NumberFormat pf = NumberFormat.getPercentInstance();
            pf.setMinimumIntegerDigits(2);
            pf.setMinimumFractionDigits(2);
            pf.setGroupingUsed(false);
            for (Map.Entry<String, Long> entry : cost.entrySet()) {
                if (entry.getKey().equals(traceName)) {
                    // 总耗时情况，不打印在分布中
                    continue;
                }

                sb.append(entry.getValue()).append("\t\t");
                sb.append(pf.format(entry.getValue() / (double) totalCost)).append("\t\t");
                sb.append(entry.getKey()).append("\n");
            }
        }

        if (LoggerFactory.getILoggerFactory() instanceof NOPLoggerFactory) {
            // 若项目中没有Slfj4的实现，则直接使用标准输出
            System.out.printf("\n---------------------\n%s\n--------------------\n%n", sb);
        } else if (log.isInfoEnabled()) {
            log.info("\n---------------------\n{}\n--------------------\n", sb);
        }
    }
}
```

在 `TraceWatch` 中维持全局的重定向规则

```java
public class TraceWatch {

    private static final TransmittableThreadLocal<ITraceRecoder> THREAD_LOCAL = new TransmittableThreadLocal<>();

    private static Set<CostOutput> defaultOutputList;

    static {
        defaultOutputList = new HashSet<>();
        defaultOutputList.add(LogOutput::logPrint);
    }

    /**
     * 注册全局的输出
     *
     * @param costOutput
     */
    public static void registerOutput(CostOutput costOutput) {
        defaultOutputList.add(costOutput);
    }

    /**
     * 获取默认的输出规则
     *
     * @return
     */
    public static Set<CostOutput> getDefaultOutputList() {
        return defaultOutputList;
    }
}
```

我们在输出重定向的实现中，主要是借助函数方法来提供能力增强，由于`TraceRecoder`都是以实例的方式来运行的，如果一个自定义的重定向，需要在每个使用地方都手动注册，显然对使用者极不友好，因此我们提供了全局的注册逻辑，这样就可以实现一次注册，全局生效；同时单个实例也可以有自己的个性化逻辑

