<?xml version="1.0" encoding="utf-8"?><?xml-stylesheet type="text/xsl" href="https://liuyueyi.github.io/tutorial/rss.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <atom:link href="https://liuyueyi.github.io/tutorial/rss.xml" rel="self" type="application/rss+xml"/>
    <title>一灰灰的站点</title>
    <link>https://liuyueyi.github.io/tutorial/</link>
    <description>一灰灰的全网知识站点</description>
    <language>zh-CN</language>
    <pubDate>Tue, 30 Jul 2024 04:32:05 GMT</pubDate>
    <lastBuildDate>Tue, 30 Jul 2024 04:32:05 GMT</lastBuildDate>
    <generator>vuepress-plugin-feed2</generator>
    <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
    <copyright>Copyright by 一灰灰blog</copyright>
    <image>
      <title>一灰灰的站点</title>
      <url>https://liuyueyi.github.io/tutorial/logo.svg</url>
      <link>https://liuyueyi.github.io/tutorial/</link>
    </image>
    <category>IM</category>
    <category>技术管理</category>
    <category>Spring源码</category>
    <category>扩展点</category>
    <category>分布式</category>
    <category>设计模式</category>
    <category>高可用</category>
    <category>理论基础</category>
    <category>SpringBoot</category>
    <category>基础系列</category>
    <category>配置</category>
    <category>DB系列</category>
    <category>WEB系列</category>
    <category>Response</category>
    <category>WebSocket</category>
    <category>中间件</category>
    <category>Caffiene</category>
    <category>初始化</category>
    <category>Liquebase</category>
    <category>Mybatis</category>
    <category>email</category>
    <category>应用篇</category>
    <category>JWT</category>
    <category>DB</category>
    <category>Mongo</category>
    <category>Java</category>
    <category>编程技巧</category>
    <category>JDK</category>
    <item>
      <title>QuickAlarm</title>
      <link>https://liuyueyi.github.io/tutorial/column/app/alarm/</link>
      <guid>https://liuyueyi.github.io/tutorial/column/app/alarm/</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">QuickAlarm</source>
      <description>应用专栏</description>
      <pubDate>Mon, 29 Jul 2024 11:14:32 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 应用专栏</h1>
]]></content:encoded>
    </item>
    <item>
      <title>应用专栏</title>
      <link>https://liuyueyi.github.io/tutorial/column/app/</link>
      <guid>https://liuyueyi.github.io/tutorial/column/app/</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">应用专栏</source>
      <description>应用专栏</description>
      <pubDate>Mon, 29 Jul 2024 08:58:55 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 应用专栏</h1>
]]></content:encoded>
    </item>
    <item>
      <title>技术架构</title>
      <link>https://liuyueyi.github.io/tutorial/column/arch/</link>
      <guid>https://liuyueyi.github.io/tutorial/column/arch/</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">技术架构</source>
      <description>架构专栏 分布式专栏 《分布式高可用》</description>
      <pubDate>Mon, 29 Jul 2024 08:58:55 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 架构专栏</h1>
<h2> 分布式专栏</h2>
<ul>
<li><a href="/tutorial/column/arch/distribute/" target="blank">《分布式高可用》</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>技术管理</title>
      <link>https://liuyueyi.github.io/tutorial/column/tech/</link>
      <guid>https://liuyueyi.github.io/tutorial/column/tech/</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">技术管理</source>
      <description>从0到1做技术管理</description>
      <pubDate>Mon, 29 Jul 2024 08:58:55 GMT</pubDate>
      <content:encoded><![CDATA[<h2> <a href="/tutorial/column/tech/manager/" target="blank">从0到1做技术管理</a></h2>
]]></content:encoded>
    </item>
    <item>
      <title>01.实时聊天应用简介</title>
      <link>https://liuyueyi.github.io/tutorial/column/app/im/01.%E5%AE%9E%E6%97%B6%E8%81%8A%E5%A4%A9%E5%BA%94%E7%94%A8%E7%AE%80%E4%BB%8B.html</link>
      <guid>https://liuyueyi.github.io/tutorial/column/app/im/01.%E5%AE%9E%E6%97%B6%E8%81%8A%E5%A4%A9%E5%BA%94%E7%94%A8%E7%AE%80%E4%BB%8B.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">01.实时聊天应用简介</source>
      <description>1. IM简介 1.1 什么是实时聊天应用？ 实时聊天应用，又称即时通讯（Instant Messaging，简称IM），是一个允许两人或多人通过网络实时聊天应用，又称即时通讯（Instant Messaging，简称IM），是一个允许两人或多人通过网络实时传递文字消息、文件、语音与视频交流的系统。这类应用软件有两种架构形式：C/S架构和B/S架构。在C/S架构中，用户需要下载并安装客户端软件才能使用，例如微信、QQ等；而在B/S架构中，用户只需通过浏览器就可以进行聊天。 实时聊天应用具有极高的&amp;quot;实时性&amp;quot;和&amp;quot;可靠性&amp;quot;，消息的传递几乎没有延迟，且不会丢失。因此，这类应用被广泛应用于各种社交互动领域，如个人通信、商务沟通、企业协作等。</description>
      <category>IM</category>
      <pubDate>Wed, 27 Dec 2023 10:06:46 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 1. IM简介</h2>
<h3> 1.1 什么是实时聊天应用？</h3>
<p>实时聊天应用，又称即时通讯（Instant Messaging，简称IM），是一个允许两人或多人通过网络实时聊天应用，又称即时通讯（Instant Messaging，简称IM），是一个允许两人或多人通过网络实时传递文字消息、文件、语音与视频交流的系统。这类应用软件有两种架构形式：C/S架构和B/S架构。在C/S架构中，用户需要下载并安装客户端软件才能使用，例如微信、QQ等；而在B/S架构中，用户只需通过浏览器就可以进行聊天。</p>
<p>实时聊天应用具有极高的"实时性"和"可靠性"，消息的传递几乎没有延迟，且不会丢失。因此，这类应用被广泛应用于各种社交互动领域，如个人通信、商务沟通、企业协作等。</p>
<h3> 1.2 实时聊天应用的应用场景</h3>
<p>实时聊天应用的应用场景非常广泛，以下是一些常见的应用场景：</p>
<ol>
<li>
<p>社交沟通：即时通信 IM 为应用于社交沟通提供能力支持，可实现单聊、群聊、弹幕等多种聊天模式，支持文字、图片、语音、短视频等多种消息类型。实时消息推送满足消息到达率的要求，并可与实时音视频 TRTC 共同实现实时音视频通话，有效提升用户粘性与活跃度。</p>
</li>
<li>
<p>在线协作和协同编辑：对于需要多用户协同工作的应用，如协同编辑文档或绘图，WebSocket 的实时性使得用户能够看到其他用户的操作。</p>
</li>
<li>
<p>视频会议和聊天：视频会议、聊天等高实时性的场景，都适合使用IM来做。</p>
</li>
<li>
<p>抽奖和互动游戏：这些需要高实时性反馈的活动，也是实时聊天应用的典型应用场景。</p>
</li>
<li>
<p>股票基金实时报价、体育实况更新：这些需要实时信息更新的场景，可以利用实时聊天应用的特性，快速准确地将信息传递给用户。</p>
</li>
<li>
<p>基于位置的应用：例如Uber、滴滴等打车软件，可以利用实时聊天应用获取司机的位置信息，提高服务的便捷性和效率。</p>
</li>
</ol>
<h2> 2. WebSocket简介</h2>
<h3> 2.1 什么是WebSocket</h3>
<p>WebSocket是一种在单个TCP连接上进行全又向通信的协议。它是建立在TCP/IP协议之上，独立于HTTP协议，可以允许客户端和服务器之间进行双向通信。这种持久化的协议能够大幅度减少网络延迟和数据传输的开销，并提高资源利用率。</p>
<p>WebSocket的工作原理是，首先，客户端和服务端需要通过握手来建立连接。在握手成功之后，就会形成一条持久的连接通道，使得数据可以双向实时传输，一旦连接建立，服务端可以在任何时候将数据主动推送到客户端。这种方式不仅减少了频繁请求导致的网络延迟，还提高了用户体验。</p>
<p>此外，WebSocket还支持跨域通信，使得不同的域名、端口或协议之间的数据交换变得更容易。并且，WebSocket协议的端口是80，这使得其能够在大多数网络环境中顺利工作。</p>
<h3> 2.2 WebSocket与HTTP的区别</h3>
<p>WebSocket和HTTP是两种完全不同的网络协议，它们在通信方式、连接方式以及应用场景上都存在显著的差异。</p>
<p>首先，两者的通信方式不同。WebSocket是一种双向通信协议，能够实现客户端与服务器间实时双向信息传输。这意味着，服务器可以在任何时候将数据“推送”到客户端。而HTTP协议则是单向的，信息传送总是从客户端发起，服务器对请求做出响应。</p>
<p>其次，两者的连接方式也有所不同。WebSocket在建立连接时，需要经历一次由服务器和客户端进行的握手过程。一旦连接建立，该连接就会持续保持，直到被明确终止。这与HTTP的无状态连接方式形成了鲜明的对比，后者的每次数据传输都需要建立新的TCP连接。</p>
<p>此外，WebSocket和HTTP在应用场景上也各有所长。WebSocket由于其双向通信和长连接的特性，常被用于如聊天应用、实时通知等需要频繁、实时交互的场景；而HTTP协议则更多地用在需要获取或提交资源（如网页、图片等）的信息交换中。</p>
<h3> 2.3 WebSocket协议</h3>
<blockquote>
<p><a href="https://datatracker.ietf.org/doc/html/rfc6455" target="_blank" rel="noopener noreferrer">RFC 6455 - The WebSocket Protocol</a></p>
</blockquote>
<h4> 2.3.1 WebSocket的工作原理</h4>
<p>WebSocket是一种在单个TCP连接上进行全双工通信的协议，它允许服务端与客户端之间进行实时数据交互，且信息传递的方式可以是服务端主动向客户端推送。这种协议是建立在TCP协议之上的，能够实现双向通讯。</p>
<p>WebSocket协议的工作流程包括以下几个步骤：</p>
<ol>
<li>
<p>握手阶段：这是建立连接时的第一个阶段。客户端向服务端发送一个HTTP请求；然后，服务器在响应头中添加一些特殊的字段，表明愿意将当前的HTTP连接升级为WebSocket连接；当客户端收到这个响应后，也会在请求头中添加类似的字段，同时，客户端还会将<code>Sec-WebSocket-Key</code>对应的值通过SHA-1算法进行编码，将编码后的值作为<code>Sec-WebSocket-Accept</code>放在请求头中；最后，服务器对<code>Sec-WebSocket-Key</code>对应的值进行同样的SHA-1编码。</p>
</li>
<li>
<p>数据传输阶段：一旦连接建立，数据就可以在客户端和服务器之间双向流动。这个阶段是全双工的，意味着数据可以同时从客户端发送到服务器，也可以从服务器发送到客户端。</p>
</li>
</ol>
<p>此外，WebSocket协议还具有以下特点：</p>
<ul>
<li>信息传输的开销较小，因为其数据帧相较于HTTP请求报文小；</li>
<li>较低的服务器资源占用。由于WebSocket的长连接特性，服务器能处理更多的并发连接。</li>
</ul>
<h4> 2.3.2 WebSocket协议的握手过程</h4>
<p>WebSocket协议的握手过程是建立WebSocket连接前的重要步骤，主要包括以下步骤：</p>
<ol>
<li>客户端通过TCP连接到服务器。</li>
<li>客户端向服务器发送HTTP/1.1协议的GET请求，这个请求通常被称为握手请求。</li>
<li>握手请求中包含了几个特定的头信息，这些信息用于指示客户端希望升级到WebSocket协议。具体来说，这些头信息包括：</li>
</ol>
<ul>
<li>Upgrade: websocket，这表示客户端希望升级到WebSocket协议。</li>
<li>Connection: Upgrade，这表示客户端希望建立持久连接。</li>
<li>Sec-WebSocket-Key: 这是一个随机的Base64编码密钥，用于安全验证。</li>
<li>Sec-WebSocket-Version: 这指示了客户端使用的WebSocket协议版本。</li>
</ul>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="4">
<li>一旦服务器接收到并验证了这些头信息，它就会返回一个响应给客户端。这个响应也是一个HTTP/1.1协议的响应，对应的HTTP状态码为101，此外还包含了一些特定的头信息，例如Upgrade和Connection头信息，指示连接已经升级到了WebSocket协议。同时，响应的正文中包含了由服务器生成的Base64编码的握手响应。</li>
</ol>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="5">
<li>一旦客户端收到服务器的响应，它就会检查响应中的头信息以及正文中的握手响应。如果一切验证无误，那么WebSocket连接就建立起来了。</li>
</ol>
<p>对应的校验机制如下：</p>
<ul>
<li>客户端应首先检查服务端返回的状态码是否为 101, 只有在 HTTP 状态码为 101 时才代表服务端同意了协议升级, 对于其它类型的状态码, 客户端应根据 HTTP 状态码的语义做相应的处理</li>
<li>客户端应检查服务端返回的响应是否包含 Upgrade 字段, 若缺失, 代表 Upgrade 未成功, 客户端应终止 WebSocket 握手</li>
<li>客户端应检查 Upgrade 字段的值是否为 websocket (该字段是大小写不敏感的, 如 websocket, WebSocket, webSocket 等都是合法的), 若不是, 客户端应终止 WebSocket 握手</li>
<li>客户端应采用如上所表述的方式校验服务端返回的 Sec-WebSocket-Accept 字段的值是否合法, 若该字段不存在或值不符合预期, 则客户端应终止 WebSocket 握手</li>
<li>若服务端返回的 Header 中包含 Sec-WebSocket-Extensions, 但其字段的值并不在客户端最初向服务端发起握手时传递的 Sec-WebSocket-Extensions 的值列表中, 则客户端应终止 WebSocket 握手</li>
<li>若服务端返回的 Header 中包含 Sec-WebSocket-Protocol, 但该字段的值并不在客户端最初向服务端发起握手时传递的 Sec-WebSocket-Protocol 的值列表中, 则客户端应终止 WebSocket 握手</li>
</ul>
<p>以上就是WebSocket协议的握手过程，这个过程确保了客户端和服务器都明确彼此将使用WebSocket协议进行通信，并且已经完成了必要的安全验证。</p>
<h4> 2.3.3 WebSocket协议的消息格式</h4>
<p>WebSocket 以 frame 为单位传输数据, frame 是客户端和服务端数据传输的最小单元, 当一条消息过长时, 通信方可以将该消息拆分成多个 frame 发送, 接收方收到以后重新拼接、解码从而还原出完整的消息, 在 WebSocket 中, frame 有多种类型, frame 的类型由 frame 头部的 Opcode 字段指示, WebSocket frame 的结构如下所示:</p>
<figure><img src="/imgs/column/im/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>Frame由两部分组成：头部和数据部分。</p>
<p>头部是一个二进制字节流，包含以下几部分内容：</p>
<ul>
<li>Fin: 这是一个1比特的标志位，用于指示当前的frame是不是消息的最后一个分段。如果一个消息被切分为多个frame进行发送，那么除了最后一个frame，其他所有frame的Fin字段都会被设置为0，而最后一个frame的Fin字段则被设置为1。当然，如果一条消息没有被切分，那么一个frame就会包含完整的消息，此时该frame的Fin字段值就为1。</li>
<li>Rsv1, Rsv2, Rsv3: 这三个标志位各占1比特，目前还没有定义具体的含义，保留给后续的应用。</li>
<li>Opcode: 这是4比特的操作码，用于指示客户端和服务器之间要执行的具体操作。比如连接建立、关闭连接、文本消息、二进制消息等。</li>
<li>Mask: 这是一个1比特的标志位，用于指示是否需要对数据进行掩码处理。如果需要掩码处理，那么在数据字段中就会出现一个4字节的掩码键。</li>
<li>Payload length: 这是16比特的长度字段，表示接下来的数据长度。因为WebSocket协议支持传输的数据长度可以是任意的，所以这个字段是必要的。</li>
<li>Masking-key: 如果Mask标志位为1，那么这个字段就会出现。它是一个4字节的字段，用于对数据进行掩码处理。</li>
</ul>
<p>数据部分就是根据Payload length字段确定的具体数据内容。</p>
<h2> 3. 实时聊天技术方案</h2>
<p>实时聊天的通讯协议主要有以下几种：</p>
<ol>
<li>
<p>XMPP（可扩展消息与存在协议）：这是一个成熟且开源的即时聊天协议，基于XMPP的开源技术有openfire(后台端)、spark(客户端)等。它的优势在于比较成熟的聊天协议，已在XMPP协议内支持单聊、群聊、加好友等功能。</p>
</li>
<li>
<p>WebSocket：它是一种在单个TCP连接上进行全双工通讯的协议，可以实现客户端与服务器之间的实时数据交互。</p>
</li>
<li>
<p>MQTT（轻量级发布/订阅消息传输协议）：它是一种轻量级的发布/订阅模式的消息传输协议，适用于低带宽、不稳定网络环境下的通信。</p>
</li>
<li>
<p>CoAP（受限应用协议）：它是一种专为受限设备设计的应用层协议，适用于物联网等场景。</p>
</li>
</ol>
<p>其中WebSocket在实时聊天应用中的优势主要体现在以下几个方面：</p>
<ol>
<li>
<p>实时性：WebSocket提供了双向通信，服务器可以主动向客户端推送数据，实现的实时性非常高，适用于实时聊天、在线协作等应用。</p>
</li>
<li>
<p>减少网络延迟：与轮询和长轮询相比，WebSocket可以显著减少网络延迟，因为不需要在每个请求之间建立和关闭连接。</p>
</li>
<li>
<p>较小的数据传输开销：WebSocket的数据帧相比于HTTP请求报文较小，减少了在每个请求中传输的开销，特别适用于需要频繁通信的应用。</p>
</li>
<li>
<p>较低的服务器资源占用：由于WebSocket的长连接特性，服务器可以处理更多的并发连接，相较于短连接有更低的资源占用。</p>
</li>
<li>
<p>跨域通信：与一些其他跨域通信方法相比，WebSocket更容易实现跨域通信。</p>
</li>
<li>
<p>效率和可扩展性：WebSocket技术提供了一种在各种应用程序中实现实时通信的强大高效手段，包括聊天应用程序、协作工具、实时通知和多人游戏。</p>
</li>
</ol>
<p>接下来我们将基于WebSocket来实现一个实时聊天应用的开发搭建</p>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/column/im/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>QuickIM聊天专栏</title>
      <link>https://liuyueyi.github.io/tutorial/column/app/im/</link>
      <guid>https://liuyueyi.github.io/tutorial/column/app/im/</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">QuickIM聊天专栏</source>
      <description>WebSocket实现实时聊天应用专栏 实时聊天应用简介 什么是实时聊天应用？ 实时聊天应用的应用场景 WebSocket在实时聊天应用中的优势 WebSocket实时聊天应用架构设计 客户端架构设计 服务器端架构设计 数据库设计 使用WebSocket实现实时聊天功能 创建WebSocket连接 发送和接收消息 处理用户加入、退出和断开连接事件 优化实时聊天应用性能 心跳机制和重连机制 消息缓存和离线消息推送 数据压缩和合并 实现实时聊天应用的附加功能 表情和图片消息的发送与显示 消息记录和历史消息查询 消息通知和提醒 WebSocket实时聊天应用的安全性考虑 WebSocket的安全性问题及解决方案 防止恶意攻击和保护用户隐私 WebSocket实时聊天应用的跨平台支持 适配不同浏览器和设备 兼容多种操作系统和网络环境 WebSocket实时聊天应用的未来发展 WebSocket在移动互联网中的应用前景 WebSocket与其他新兴技术的融合 WebSocket的标准化和规范化进展</description>
      <pubDate>Mon, 29 Jul 2024 08:58:55 GMT</pubDate>
      <content:encoded><![CDATA[<h1> WebSocket实现实时聊天应用专栏</h1>
<ol>
<li>
<p>实时聊天应用简介</p>
<ul>
<li>什么是实时聊天应用？</li>
<li>实时聊天应用的应用场景</li>
<li>WebSocket在实时聊天应用中的优势</li>
</ul>
</li>
<li>
<p>WebSocket实时聊天应用架构设计</p>
<ul>
<li>客户端架构设计</li>
<li>服务器端架构设计</li>
<li>数据库设计</li>
</ul>
</li>
<li>
<p>使用WebSocket实现实时聊天功能</p>
<ul>
<li>创建WebSocket连接</li>
<li>发送和接收消息</li>
<li>处理用户加入、退出和断开连接事件</li>
</ul>
</li>
<li>
<p>优化实时聊天应用性能</p>
<ul>
<li>心跳机制和重连机制</li>
<li>消息缓存和离线消息推送</li>
<li>数据压缩和合并</li>
</ul>
</li>
<li>
<p>实现实时聊天应用的附加功能</p>
<ul>
<li>表情和图片消息的发送与显示</li>
<li>消息记录和历史消息查询</li>
<li>消息通知和提醒</li>
</ul>
</li>
<li>
<p>WebSocket实时聊天应用的安全性考虑</p>
<ul>
<li>WebSocket的安全性问题及解决方案</li>
<li>防止恶意攻击和保护用户隐私</li>
</ul>
</li>
<li>
<p>WebSocket实时聊天应用的跨平台支持</p>
<ul>
<li>适配不同浏览器和设备</li>
<li>兼容多种操作系统和网络环境</li>
</ul>
</li>
<li>
<p>WebSocket实时聊天应用的未来发展</p>
<ul>
<li>WebSocket在移动互联网中的应用前景</li>
<li>WebSocket与其他新兴技术的融合</li>
<li>WebSocket的标准化和规范化进展</li>
</ul>
</li>
</ol>
]]></content:encoded>
    </item>
    <item>
      <title>分布式</title>
      <link>https://liuyueyi.github.io/tutorial/column/arch/distribute/</link>
      <guid>https://liuyueyi.github.io/tutorial/column/arch/distribute/</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">分布式</source>
      <description>分布式系列专题 分布式设计理论基础 高可用介绍</description>
      <pubDate>Mon, 29 Jul 2024 08:58:55 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 分布式系列专题</h2>
<ul>
<li><a href="/tutorial/column/arch/distribute/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" target="blank">分布式设计理论基础</a></li>
<li><a href="/tutorial/column/arch/distribute/%E9%AB%98%E5%8F%AF%E7%94%A8/" target="blank">高可用介绍</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>01.契机</title>
      <link>https://liuyueyi.github.io/tutorial/column/tech/manager/01.%E5%BA%8F%20%E8%BD%AC%E7%AE%A1%E7%90%86%E7%9A%84%E5%A5%91%E6%9C%BA.html</link>
      <guid>https://liuyueyi.github.io/tutorial/column/tech/manager/01.%E5%BA%8F%20%E8%BD%AC%E7%AE%A1%E7%90%86%E7%9A%84%E5%A5%91%E6%9C%BA.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">01.契机</source>
      <description>在职业发展的旅程中，每位技术人员都会面临一个关键性的选择：是继续深耕技术领域，还是转向管理岗位。这一选择不仅关乎个人的职业路径，也涉及到如何最有效地发挥自身才能的问题。 我们必须承认，人的精力和时间是有限的资源。在技术领域达到高深境界的专家，其管理能力未必同样出色，反之亦然。管理与技术，虽然同为职场上的重要角色，但它们的要求和侧重点却大相径庭。技术的焦点在于解决与机器相关的具体问题，而管理的重心则在于协调人与人的关系，优化团队的整体效能。两者之间的差异，使得在两者间寻求平衡成为一项挑战。 在过去的一年里，我深刻体会到了这一难题。我面临的困境是：我应继续深化我的技术专长，还是应该转型，投身于管理岗位。</description>
      <category>技术管理</category>
      <pubDate>Wed, 31 Jan 2024 08:53:46 GMT</pubDate>
      <content:encoded><![CDATA[<p>在职业发展的旅程中，每位技术人员都会面临一个关键性的选择：是继续深耕技术领域，还是转向管理岗位。这一选择不仅关乎个人的职业路径，也涉及到如何最有效地发挥自身才能的问题。</p>
<p>我们必须承认，人的精力和时间是有限的资源。在技术领域达到高深境界的专家，其管理能力未必同样出色，反之亦然。管理与技术，虽然同为职场上的重要角色，但它们的要求和侧重点却大相径庭。技术的焦点在于解决与机器相关的具体问题，而管理的重心则在于协调人与人的关系，优化团队的整体效能。两者之间的差异，使得在两者间寻求平衡成为一项挑战。</p>
<p>在过去的一年里，我深刻体会到了这一难题。我面临的困境是：我应继续深化我的技术专长，还是应该转型，投身于管理岗位。</p>
<p>经过一年多的实践和深思，我积累了一些关于技术和管理融合的经验和反思。我希望通过分享这些经验，能够为同行们提供一些参考，特别是那些在技术和管理之间徘徊不决的同仁。</p>
<p>以下是我个人对技术与管理结合的总结与思考，希望能够对大家有所启发，也期待与各位共同探讨，以促进我们在这一复杂领域中的成长和进步。</p>
<h2> 谈一谈职业规划</h2>
<p>关于程序员的职业规划，下面有一张网图，感觉还是很有代表性分享给大家</p>
<figure><img src="/imgs/column/manager/职业发展路线图.jpg" alt="网图来源: https://baijiahao.baidu.com/s?id=1719180248008940422" tabindex="0" loading="lazy"><figcaption>网图来源: <a href="https://baijiahao.baidu.com/s?id=1719180248008940422" target="_blank" rel="noopener noreferrer">https://baijiahao.baidu.com/s?id=1719180248008940422</a></figcaption></figure>
<p>从上图可以看出，当你实际干了几年之后，通常会出现一个分支，继续走技术，往专家、架构的方向走，还是往技术管理、项目经理的路线发展</p>
<p>就个人职业发展规划而言，我的性格倾向较为内向，并不擅长或特别偏好与人频繁互动。鉴于此，我的初步规划是沿着技术路线发展。</p>
<p>在技术路线上，我们可以进一步细分为两个方向：</p>
<ol>
<li>纯粹的技术方向，这一路径要求深厚的技术功底，专注于解决技术难题、构建系统架构，例如成为Redis、消息队列（MQ）等领域的技术专家。</li>
<li>业务专家方向，这要求深入理解业务领域，更侧重于实际业务问题的解决方案和架构能力，成为业务线中的核心力量。</li>
</ol>
<p>在我国的职场环境中，纯粹技术路径的机会相对有限。对于大多数程序员来说，成为业务专家可能是一个更加现实和贴切的选择。以下是我对于职业规划的一些思考，这些观点主要适用于面试环节或是与上级领导讨论职业发展规划时的情况。</p>
<h3> 如何谈自己的职业规划</h3>
<ol>
<li>技术路线</li>
</ol>
<p>比如我个人比较喜欢搞技术，因此想在技术这一条路线上继续往下周，通常有两个方向，一个是业务架构、一个技术架构；</p>
<p>1.1 针对业务架构方向：</p>
<p>业务架构可能更看重实际的业务解决能力，然后结合自己的实际工作经验说一下
比如：我想成为某个领域的业务专家，梳理复杂的业务模型、制定业务标准解决方案，我的规划是先希望能成为某个业务的负责人，然后再往上负责一条业务线，最后希望可以成为行业类的专家</p>
<ul>
<li>为了往这个方向发展，我做了哪些尝试，比如不仅仅局限开发的角色，会主动反推产品优化业务模型等、不断地学习相关的业务知识点，比如学习了xxxx，参加了xxx会议分享，组织了xxx业务共创会等;</li>
</ul>
<p>1.2 针对技术架构方向</p>
<p>技术架构，则可以从纯技术的角度出发，比如个人还是有很强的技术崇拜，更喜欢做一些技术上的东西，因此希望朝着主程，高级开发，系统架构的方向进行发展</p>
<ul>
<li>对于此，自己做了xxx，比如先成为团队的技术骨干，掌握日常工作的所有技术栈，时刻关心新的技术架构、技术演进，经常参加一些xxx技术会议，平时遇到问题都追本溯源，深挖原理细节，做完之后也会输出相关的复盘给别人分享； 经常思考现在工作项目的架构设计、为什么这么设计，可以怎么优化，组织技术方案评审、架构评审等等都可以谈 （当然重点突出自己做过的事情，不然一问深就露馅了）</li>
</ul>
<ol start="2">
<li>管理路线</li>
</ol>
<p>如果想做技术管理，则可以从职业的生涯规划来说，谈一下什么一个人可以走的很快，但不一定能走的很远；一个团队则可以走的更稳、更远，也希望能结合自己的技术能力 + 加上团队的力量，最大的发挥出自己的特长</p>
<p>2.1 技术管理
先简单说一下为什么想做技术管理，以及个人的忧思：比如一个人的影响范围有限，更希望能依托自己技术的优势，充分发挥一拨人的潜能，干一些有意思、有挑战、有成就感的事情</p>
<ul>
<li>基于此，平时除了做技术的事情之外，也会额外关心team leader是怎么带领团队的，然后从他身上学习xxx</li>
<li>平时也会带一些实习生、应届生，增加自己的带人能力</li>
<li>在一些日常的项目需求中，主动承担牵头人角色，积累自己项目管理的经验，比如具体的有xxx</li>
<li>经常和一些小组长、管理者聊，怎么样来调动大家的积极性，自己也经常学习一些相关视频、文章，提升自己的人际处理能力等</li>
</ul>
<p>2.2 项目经理
对技术人员而言，这条路线相当于转行了，因此要先说一下为什么想做这个：</p>
<ul>
<li>一个供参考的回答
比如说自己有很多的想法，想去充分发挥自己的才能，更喜欢做一些落地事情；或者非常擅长人际关系，资源协调。想充分体验一下不同的风景</li>
</ul>
<p>对于此，自己的努力尝试：</p>
<ul>
<li>个人性格外向，社牛，很会和被人打交道，很会维护人际关系，很会协调资源等 (优势)</li>
<li>做了xxx项目管理的学习，从一些大牛身上学到了xxx  （说明自己有在持续学习）</li>
<li>平时有提高自己的汇报、文档能力 （PM基本功）</li>
<li>在平时的项目管控中，有意思的加强自己的节奏控制能力，比如之前负责xxx项目，经过了xxx步骤，最终完美交付</li>
</ul>
<h2> 转管理的契机</h2>
<p>在我的职业生涯中，目前我正担任技术管理的职位，这已是我第二次承担此类角色。初次尝试管理职位是在一家初创公司，当时的技术负责人离职后，我便接替了他的位置。与许多人的首次管理经历相似，我缺乏管理经验，经历了一段时间的摸索和努力，最终效果却是一般。而现在，我面临着第二次管理的机会。</p>
<p>在2022年底，我转至一家新公司，这里的团队更重视管理经验而非单纯的技术能力。公司的运作模式与IT行业常见的持续迭代和维护的项目有所不同，主要是周期性项目。通常，一个项目的生命周期并不长，项目交付并回款后，主要的工作便是运维，这与外包工作的性质比较相似。加入公司后，感受很深的一点是，在现在的这个环境中，技术研发的地位非常低，一条路走技术是不长久的。</p>
<p>在这样的背景下，我在入职一个月后遇到了转变的契机。公司有一个企业电商项目需要从外部合作方转回内部进行研发和运营。可能是考虑到公司内部具备电商背景的人员较少，我就被选中参与这个项目。当然，对于这个项目，我最初是持怀疑态度，不太愿意接手，主要原因有两点：</p>
<ol>
<li>这是一个已在线运行的项目，每日成交额超过1亿，代码量达千万级别，除了代码外几乎没有任何有效文档，而我需要在半年内完全接手；并且在项目经理与我交谈时，团队的基本框架尚未建立，整个项目看起来比较不靠谱</li>
<li>当时我所在的项目组工作相对轻松，工作量小，压力不大，下班时间早，这是我从业以来经历过的最轻松的工作，按照内心想法，确实不太愿意离开现在的神仙项目组。</li>
</ol>
<p>在选择的过程中，发生了一个小插曲。我个人更倾向于留在原项目组，也与原项目组的项目经理（PM）讨论其对2023年的规划以及我能发挥的作用。PM建议我若不想加入新项目组，应尽快向公司高层表达我的立场。然而，由于高层领导忙碌，我未能找到合适的机会表达我的想法。而直接负责这个新项目的负责人先行与我交谈，然后我便加入了这个新项目。</p>
<p>之前阅读《知行》一书时，作者提到“超过80%的技术管理者，都是在没有明确表达管理意愿的情况下，被公司推到管理岗位的。”，就我个人的感受而言，在IT行业，突然被推上管理岗位的情况确实比其他行业更为常见。那么，当这样的机会来临时，我们是否真的做好了准备呢？</p>
<h2> 预设目标</h2>
<p>随着新的征程的开启，设定明确的目标对于成功至关重要。在23年初，我即将踏入新项目组并面对即将到来的挑战时，为自己设定了以下目标：</p>
<ol>
<li>迅速融入新项目，建立团队成员之间的信任，并组建一个高效的团队。</li>
<li>顺利接手项目任务，确保工作的连续性和项目的顺利交付。</li>
<li>完成从技术专家到管理角色的转变，培养出一个具有强大战斗力的团队。</li>
</ol>
<p>这些目标在当时看来可能显得有些抽象，缺乏具体的衡量指标。为了在接下来的系列分享中能够对这些目标进行详细分析，我计划在最后的总结中对它们进行深入拆解。 接下来，让我们正式开始这一段项目管理的旅程。</p>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/column/manager/职业发展路线图.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>02.准备工作</title>
      <link>https://liuyueyi.github.io/tutorial/column/tech/manager/02.%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C.html</link>
      <guid>https://liuyueyi.github.io/tutorial/column/tech/manager/02.%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">02.准备工作</source>
      <description>在中国传统文化中，有一句古老的谚语：“凡事预则立，不预则废”，这句话强调了在任何事务中，事前的规划和准备的重要性。对于我这样管理经验尚待提升，且未能拥有显著天赋优势的个体，面对新的挑战，提前进行细致的规划和准备显得尤为重要。 当前，我们正面临一个崭新的项目挑战，这个项目不仅要求我们团队展现出卓越的专业能力，更要求我们在组织和协调上达到新的高度。值得注意的，是甲方对我们团队的组长角色（包括产品、前端、后端、测试）提出了面试考核的要求，这无疑对团队的专业素质和综合能力提出了更高的标准。 在此，我必须指出，尽管这一要求在初次提出时，可能给人带来了一种被质疑或不被信任的错觉，但从专业角度看，这实际上是对项目成功完成的一种保障，也是对团队成员能力的一次全面审视。通过这样的面试考核，我们能够确保团队的每一个成员都具备足够的能力和专业知识，以应对项目中可能出现的各种挑战。</description>
      <category>技术管理</category>
      <pubDate>Thu, 01 Feb 2024 08:53:46 GMT</pubDate>
      <content:encoded><![CDATA[<p>在中国传统文化中，有一句古老的谚语：“凡事预则立，不预则废”，这句话强调了在任何事务中，事前的规划和准备的重要性。对于我这样管理经验尚待提升，且未能拥有显著天赋优势的个体，面对新的挑战，提前进行细致的规划和准备显得尤为重要。</p>
<p>当前，我们正面临一个崭新的项目挑战，这个项目不仅要求我们团队展现出卓越的专业能力，更要求我们在组织和协调上达到新的高度。值得注意的，是甲方对我们团队的组长角色（包括产品、前端、后端、测试）提出了面试考核的要求，这无疑对团队的专业素质和综合能力提出了更高的标准。</p>
<p>在此，我必须指出，尽管这一要求在初次提出时，可能给人带来了一种被质疑或不被信任的错觉，但从专业角度看，这实际上是对项目成功完成的一种保障，也是对团队成员能力的一次全面审视。通过这样的面试考核，我们能够确保团队的每一个成员都具备足够的能力和专业知识，以应对项目中可能出现的各种挑战。</p>
<p>作为项目团队的一员，我们应该（但是我并不想）积极地接受这一挑战。 为了应对这次的面试，我提前做了一些准备，当然并不算充分；对于技术上倒是没有什么好担心的，个人则主要从项目背景和管理方法论上做一些调研。</p>
<h2> 1. 背景调研</h2>
<p>原先，我并未打算详细阐述项目背景，因为目前我参与的这个项目，与典型的IT项目存在显著差异，并且涌现出许多意料之外的挑战。鉴于这些挑战在后续的分享中可能会以各种形式不断显现，我认为有必要阐明下此项目的具体形态。当然由于某些特殊原因，我将对于项目的相关背景会做一些脱敏处理;</p>
<p>业务类型： 垂直行业的ToB领域的电子商城</p>
<p>项目归属： 我所在的公司的兄弟企业的核心支柱</p>
<p>原运营方： 外部分供方</p>
<p>任务目标： 将项目从外部分供方完整的迁移到新的项目组，并按约定实现合同约定的各专项任务</p>
<p>当然再开始之初，上面这些背景中我只知道上面的业务类型 + 任务目标，其他的就不太清楚了；从现在往回看，这个背景中，最值得说的是这个项目的多方关系</p>
<h3> 项目组织关系</h3>
<figure><img src="/imgs/column/manager/02_项目关系图.jpg" alt="项目关系图" tabindex="0" loading="lazy"><figcaption>项目关系图</figcaption></figure>
<p>这个组织关系看起来有点怪，商城这个项目的所有权在<code>孙公司B-1</code>手中，他们自己又有产研团队，为啥不自己接，而是让我所在<code>孙公司A-1</code>来接产研呢？</p>
<p>两方面原因：</p>
<ol>
<li><code>孙公司B-1</code> 尝试自己承接，没接下来（题外话：这个项目业务及代码的复杂性确实有些离谱）</li>
<li>集团总部的直接任务下发，我所在的<code>孙公司A-1</code>的使命就是承接集团的信息化工作</li>
</ol>
<p>再说句题外话，我所在的<code>孙公司A-1</code>愿意接这个项目吗？ 答案是否订的，核心原因就一点，没有利益（即不赚钱，还责任多）</p>
<p>从项目的组织关系就可以看出，这个项目的工作模式好不起来，如何协调多方利益是个非常大挑战（还好我不是项目经理，不然我就直接投降了），对于技术管理而言，难受的就是外部协作沟通，后面会准备一篇专文来说我这一年的愉(bie)快(qu)体验</p>
<h3> 项目业务背景</h3>
<p>一个垂直领域面向企业端的电子商城，再开始之处，对于这个商城我所有能获取到的信息就是借助搜索引擎找到的商城主站，本想体验一下这个商城有哪些功能板块，具体的业务形态，结果不让注册、未登录的用户只能看到商品详情，连价格也看不到...，所以再实际进场这个项目之前，我对它的了解两个概念 “TOB" + “电子商城”</p>
<p>以我个人的实际体会来说，建议大家再到一个新的项目组做技术管理之前，做好背景调研是一个非常重要的前置工作，比如大家都是这个领域的新手、你怎么快速脱颖而出？ 若只有你是新来的、你怎么让别人信服你？ 很，但是又很幸运，项目组内了解过这个项目的产研不过两三人，且了解得都不算多，所以我的小白表现并不算突出</p>
<p>基于我个人的实际经历，我强烈建议在加入一个新的项目团队并担任技术管理职责之前，进行充分的背景调研是至关重要的。这一步骤对于项目的顺利进行和您的个人发展都至关重要。</p>
<ol>
<li>
<p><strong>行业知识储备</strong>：在进入一个全新的领域时，首要任务是积累相关的行业知识和术语。这可以通过阅读行业报告、研究市场趋势、分析竞争对手以及与行业专家交流来实现。</p>
</li>
<li>
<p><strong>项目历史了解</strong>：深入了解项目的历史发展，包括之前的成功案例和遇到的挑战，可以帮助您更好地理解项目的现状和未来的方向。</p>
</li>
<li>
<p><strong>技术栈掌握</strong>：熟悉项目所使用的技术和工具，这对于技术管理者来说是基础。您需要了解这些技术的优缺点，以及它们如何适应项目需求。</p>
</li>
<li>
<p><strong>团队动态分析</strong>：了解团队成员的技能、经验和工作风格，以及他们在项目中的角色和责任，有助于建立有效的沟通和合作。</p>
</li>
<li>
<p><strong>业务流程理解</strong>：深入理解企业端电子商城的业务流程，包括供应链管理、库存控制、订单处理等，这是确保技术解决方案与业务需求相匹配的关键。</p>
</li>
<li>
<p><strong>风险评估</strong>：识别潜在的风险点，并为可能出现的问题制定应对策略。</p>
</li>
<li>
<p><strong>建立信任</strong>：作为新加入的成员，您需要通过展示您的专业知识、沟通能力和领导才能来赢得团队的信任。这可能包括提供有价值的见解、积极参与讨论和决策过程，以及在必要时提供指导和支持。</p>
</li>
</ol>
<p>显然这一块我的工作做的并不合格，但幸运的是，团队中对该项目有深入了解的成员并不多。这意味着，尽管我是新手，但我的不足并没有立即凸显出来。然而，这并不意味着可以忽视背景调研的重要性。</p>
<h2> 2. 技术管理方法论学习</h2>
<p>由于之前的管理经验不够成熟，或者说不成体系，因此再面对这个新的转机时，求助一下外援楼仔（他的公众号就是“楼仔”，干货满满），学习下相关的方法论，当时的目的比较简单，一个是应付甲方爸爸的面试，另外一个则是规划一下后面怎么带队</p>
<figure><img src="/imgs/column/manager/02_管理经验图谱.png" alt="项目关系图" tabindex="0" loading="lazy"><figcaption>项目关系图</figcaption></figure>
<p>上图是之前准备的管理经验图谱，接下来会从两个方面进行细说</p>
<h3> 2.1 团队管理方法论</h3>
<blockquote>
<p>事先声明：市面上有很多的团队管理书籍及相关理论，以下内容仅个人看法、一家之谈，由于我个人经验有限、知识储备不足，如有错漏，误导之处，还请海涵</p>
</blockquote>
<p>首先这里明确一点，团队管理并不局限于自己所在团队内的相关工作，从我们自己所处的阶层来说，可以区分为向上汇报、横向沟通以及向下管理，还有一个对外的沟通这里没有提及，后续补上</p>
<figure><img src="/imgs/column/manager/02_团队管理.png" alt="团队管理" tabindex="0" loading="lazy"><figcaption>团队管理</figcaption></figure>
<h4> 向上汇报</h4>
<p>向上沟通对我个人而言是一个非常有挑战的事情，但是它又是对每一个技术管理者而言，不得不面对的事情</p>
<p>就我个人的感触而言，向上沟通主要有下面几个困扰：</p>
<ol>
<li>对上层的天然敬畏，就像我们小时候怕家长、老师一样，能绕着就绕着，能不沟通就不沟通</li>
<li>不知道怎么聊，纯业务/技术的聊天会很干，聊闲话的又不会找主题，拿捏不好尺度和分寸</li>
<li>听不懂潜台词，这感觉是好多技术人的通病</li>
<li>不懂如何拒绝或影响上级的决策</li>
</ol>
<p>上面是一些向上汇报的实际问题，前期的准备也不可能把所有的答案都搞到，或者说即便有标准答案在手，我也不一定执行得起来</p>
<p>因此再这一环节，准备先抓核心，为什么要向上汇报，目的是什么，以什么形式展开，有什么可以注意的事项，所以我准备的方法论比较简单，主要用于规范自己的行为</p>
<ul>
<li>目的：阶段性成果上报--邀功，寻求上级协助--请外援，大事拍板--不想背锅，获取上级才知道的信息--不当傻子</li>
<li>形式：汇报时以PPT, 简明扼要的文档，准备充分的演讲方式进行； 闲聊时，没啥形式可说了</li>
<li>注意：
<ul>
<li>大方向的汇报，不拘泥于细节</li>
<li>提问题时，梳理现状，问题是什么，我们给出的解决方案，希望得到的资源是什么</li>
<li>汇报成绩时，有条理的列成绩，有数据效果支撑，有总结，有规划</li>
<li>找老板关系的点汇报，而不是你关心的点</li>
</ul>
</li>
</ul>
<h4> 横向沟通</h4>
<p>横向沟通主要是指和你同层级的技术管理、另外的团队之间的沟通协作，对于研发团队而言，跨团队的交流非常普遍，比如前后端协作，研发测试，研发产品都属于这一类</p>
<p>横向沟通的目的比较存粹，<code>信息同步、目标拉齐</code></p>
<p>对于技术管理者而言，我们需要提前了解业务动向，知道产品准备做哪些规划，我们现在的资源是否足以应对产品接下来的计划，协作的团队是否可以跟上等等问题；切记在自己啥也不了解的情况下，接了需求，给团队带来无法交付的任务</p>
<p>其次对于技术管理者而言，横向沟通这里还有一个常见的场景就是帮助团队内的小伙伴和其他团队人员的协作，由于身份地位的问题，你组内成员的话语权没有你的大，他们在跨团队的推动中往往会遇到很多他们解决不了的问题，作为一个靠谱的领导者，不应对此视而不见、全部视为他们自己应该解决的问题，该站出来时就得站出来，能抗得住事、帮团队解决困难是建立个人领导力必不可少的要求</p>
<h4> 向下管理</h4>
<p>团队内管理，可以说是技术管理的任务重心，从方法论中学到的核心点在于：</p>
<ul>
<li>
<p>建立权威：让人信服</p>
<ul>
<li>常见的形式: 早会、日报/周报等机制</li>
<li>目的： 掌握团队的整体情况，了解每个人的工作饱和度，盯紧项目进度，提前评估风险</li>
</ul>
</li>
<li>
<p>维持信任关系：</p>
<ul>
<li>形式：通过1v1的聊天，了解团队内成员的诉求</li>
<li>以身作则，言必行</li>
<li>平等交流，信息透明</li>
<li>日常活动中拉近关系</li>
</ul>
</li>
<li>
<p>培养备份</p>
<ul>
<li>找一个自己的backup，实现互助</li>
<li>多认可，争取权益</li>
</ul>
</li>
</ul>
<h3> 2.2 项目管理方法论</h3>
<p>关于项目管理的方法论将主要从项目流程管理与风险进度管理进行说明，关于这块的内容就不进行展开，有兴趣的小伙伴请关注第六篇</p>
<figure><img src="/imgs/column/manager/02_项目管理.png" alt="项目管理" tabindex="0" loading="lazy"><figcaption>项目管理</figcaption></figure>
<h4> 项目流程管理</h4>
<ol>
<li>建立需求池机制</li>
</ol>
<p>主要目的是方便管理者了解短期、长期的产品项目规划，提前做好资源准备</p>
<p>其次需要针对需求池中的任务进行优先级划分，根据不同优先级来安排研发计划</p>
<ol start="2">
<li>做好提前沟通</li>
</ol>
<p>对于技术管理而言，最好是提前与产品沟通需求说明书，判断是否再团队的可承受范围内，需求是否可以进行拆解，是否合理</p>
<p>这里对于技术管理提了一个要求，有足够的精力识别这些任务，可以判断它的合理性以及预估大致的工期，然后对大方向的讨论控制在私下的与产品的沟通中，避免在需求评审中发生争执，给团队内同学造成不好的影响</p>
<ol start="3">
<li>评审机制</li>
</ol>
<p>建立研发流程中的通用评审机制，如需求方案评审，研发的反串讲，技术方案评审，代码review</p>
<p>通常而言，上面的几个评审中，需求方案评审不可缺少（除非是非常简单，显示样式的小调整，改个显示字段等），反串讲和技术方案的评审，一般是面向业务/技术复杂的多人协作的需求，一般来讲，有技术方案评审的需求，代码review也不建议省略</p>
<p>评审必然拉会，当会议一多，就会占据研发人员的工作时间，牢记一条  "小事大会，大事小会，重要的事不开会"</p>
<ol start="4">
<li>排期</li>
</ol>
<p>需求评审之后，通常我们就需要出排期，但是我们往往只会将开发时间安排进来，一个完整的排期，正常需要</p>
<ul>
<li>开发</li>
<li>自测</li>
<li>联调</li>
<li>上线</li>
<li>回归验证</li>
</ul>
<p>一个合理的任务排期，请确保要给自己预留足够的缓冲时间来应付各种突发状况（如请假、临时任务插入打断等）</p>
<p>除了上面排期需要考虑的事项之外，我们在安排进度计划时，需要考虑需求的优先级，将高优先级的先做，往前排，尽量优先保障</p>
<ol start="5">
<li>开发上线</li>
</ol>
<p>发测试 -&gt; 预发 -&gt; 生产</p>
<ol start="6">
<li>效果追踪</li>
</ol>
<p>这一环节通常是我们研发关注的较少的一点，需求上线之后，不出问题我们基本上就不会再花时间留意关注；但是作为一个技术管理而言，如何评估我们的产出、衡量我们的工作价值呢？</p>
<ul>
<li>再需求or项目上线之后，再跟踪一段时间，看下具体表现情况如何，收集相关数据指标</li>
<li>通过效果的追踪反馈，一方面让我们能更清晰的了解业务，另一方面也可以认识到自己的工作价值</li>
</ul>
<h4> 风险管控</h4>
<p>风险管理是每位管理者必须面对的挑战，尤其是当遇到理解深度和合作态度各异的业务方时，这一挑战尤为显著。</p>
<p><strong>1. 交付进度风险</strong></p>
<ul>
<li>时间管理：在项目排期阶段，应当预留合理的时间缓冲，以应对潜在的延误。同时，需实施持续的项目进度监控，确保研发迭代按计划推进，从而降低整体交付风险。</li>
</ul>
<p>若在项目执行过程中，发现由于评估过于乐观导致无法按期交付，应立即与业务方进行沟通，探讨是否可能调整交付时间表或简化需求。在极端情况下，可能需要重新分配资源或采取加班措施以确保项目按期完成。</p>
<ul>
<li>倒排期需求处理：对于具有严格时限的需求，需要细致地进行任务拆分和优先级排序。</li>
</ul>
<p>优先保障高优先级任务的完成，而低优先级任务则相应推迟。确保至少具备最小功能集的按时上线交付能力，以便在意外情况发生时，能够有备选方案减轻损失。</p>
<ol start="2">
<li>交付质量风险</li>
</ol>
<ul>
<li>功能质量保证：确保交付的功能无重大缺陷，且不会对主流程造成影响，这需要与测试团队建立良好的合作关系。</li>
<li>安全保障：确保交付的功能不存在安全漏洞，保护系统免受潜在威胁。</li>
</ul>
<ol start="3">
<li>其他非预期风险</li>
</ol>
<p>在项目管理中，总存在不可预测的风险。对此，没有固定的应对策略，但需要提前做好心理准备，并制定灵活的应急计划。</p>
<ul>
<li>人员变动风险：如裁员或团队重组等情况，需提前规划人力资源的备份计划。</li>
<li>需求变更风险：对于需求的变化，需要保持灵活性，及时调整项目计划以适应新的要求。</li>
<li>突发事件应对：如员工请假、更高优先级任务的插入、多任务并行开发等情况，需制定相应的风险管理策略，以确保项目的顺利进行。</li>
</ul>
<h3> 小结</h3>
<p>程序员转型为技术管理者是一个重大的职业发展步骤，它要求你不仅要精通技术，还要掌握管理技能。 以下是一些来自于网络的建议，也风险给阅读本文的小伙伴</p>
<ol>
<li>
<p><strong>提升沟通技巧</strong>：</p>
<ul>
<li>学习如何清晰、有效地与团队成员和其他部门沟通。</li>
<li>练习将复杂的技术问题解释给非技术人员听。</li>
</ul>
</li>
<li>
<p><strong>培养团队领导能力</strong>：</p>
<ul>
<li>主动承担更多责任，比如领导小型项目或指导新员工。</li>
<li>阅读领导力相关书籍，参加相关的工作坊或研讨会。</li>
</ul>
</li>
<li>
<p><strong>了解管理理论和实践</strong>：</p>
<ul>
<li>阅读有关管理的书籍，学习不同的管理风格和理论。</li>
<li>考虑报名参加管理类课程或获得相关证书。</li>
</ul>
</li>
<li>
<p><strong>掌握项目管理知识</strong>：</p>
<ul>
<li>学习项目管理的基础知识，包括如何制定计划、监控进度和管理预算。</li>
<li>熟悉使用项目管理工具，如Microsoft Project、JIRA等。</li>
</ul>
</li>
<li>
<p><strong>增强商业意识</strong>：</p>
<ul>
<li>理解公司的商业模式、市场定位以及产品战略。</li>
<li>学习基础的商业和财务知识。</li>
</ul>
</li>
<li>
<p><strong>人员管理技能</strong>：</p>
<ul>
<li>学习如何激励团队成员，进行绩效评估和职业规划。</li>
<li>了解如何处理工作中的冲突和建立有效的团队文化。</li>
</ul>
</li>
<li>
<p><strong>关注技术和行业趋势</strong>：</p>
<ul>
<li>持续学习新技术、工具和方法论，了解它们对团队和业务的潜在影响。</li>
</ul>
</li>
<li>
<p><strong>扩展人际网络</strong>：</p>
<ul>
<li>与其他技术管理人员建立联系，交流经验和观点。</li>
<li>加入专业组织和参与行业会议。</li>
</ul>
</li>
<li>
<p><strong>时间管理和优先级设定</strong>：</p>
<ul>
<li>学习如何高效地管理自己的时间，平衡管理职责和技术工作。</li>
<li>练习确定任务优先级，以有效达成目标。</li>
</ul>
</li>
<li>
<p><strong>获取反馈和自我反思</strong>：</p>
<ul>
<li>定期向同事和上级寻求关于你管理和领导能力的反馈。</li>
<li>定期进行自我反思，识别改进空间。</li>
</ul>
</li>
<li>
<p><strong>实践经验</strong>：</p>
<ul>
<li>在当前的编程职位上寻找机会承担更多管理职责。</li>
<li>参与跨部门的项目，增加管理经验。</li>
</ul>
</li>
<li>
<p><strong>心理准备</strong>：</p>
<ul>
<li>准备好接受从纯技术角色到更多涉及协调和人际关系的工作的转变。</li>
<li>调整心态，接受你可能不再有太多时间亲自编码的现实。</li>
</ul>
</li>
</ol>
<p>在项目管理的准备工作中，确实存在众多需要考虑的因素。对于初学者而言，试图同时关注所有细节可能会造成注意力分散，导致无法在任何方面达到最佳状态。因此，识别自己的弱点并集中力量突破最为关键。</p>
<p>基于此，我的准备策略聚焦于两个核心领域：项目背景的熟悉度以及管理方法论的掌握。</p>
<ul>
<li>项目背景熟悉</li>
</ul>
<p>提前了解项目的业务环境、组织关系，能迅速发挥自己的能量</p>
<ul>
<li>管理方法论</li>
</ul>
<p>掌握项目管理的核心原则和方法论，如敏捷管理、水平瀑布模型或混合方法等项目管理方法（上面没有细说），团队人员管理、梯度建设等</p>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/column/manager/02_项目关系图.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>03.入职新项目</title>
      <link>https://liuyueyi.github.io/tutorial/column/tech/manager/03.%E5%85%A5%E8%81%8C%E6%96%B0%E9%A1%B9%E7%9B%AE.html</link>
      <guid>https://liuyueyi.github.io/tutorial/column/tech/manager/03.%E5%85%A5%E8%81%8C%E6%96%B0%E9%A1%B9%E7%9B%AE.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">03.入职新项目</source>
      <description>在职业生涯中，从研发岗位转向技术管理职位，通常有以下几种路径：或是在现有团队中逐步晋升，自然而然地承担起领导职责；或是把握时机，接受上级的任命，实现角色的转变；亦或是通过跳槽，以空降的形式进入新的组织。而我的情况则是跳槽到新的公司，再一个项目组苟了一段时间，突然被调到一个新的项目组，作为十人左右的后端研发组长，结合了上面的二三两种途径；再真实入项之前，首先面临的挑战是接受业务方的面试和评估，以确定我是否满足他们对于该岗位的专业要求。 因此，在这篇文章中，我们将从两个关键的角度出发，深入探讨加入新项目时需要关注的各项事宜。 1. 入项面试 在上一篇文章中，我们概述了新项目的背景情况。这是一个从零开始组建的全新项目组，由项目经理（PM）负责从无到有地构建团队。该团队的服务对象是兄弟单位，其首要任务是将整个项目的产品研发工作，从委托的第三方外部公司，完全迁移至这个新成立的项目组来承担。</description>
      <category>技术管理</category>
      <pubDate>Wed, 07 Feb 2024 09:27:46 GMT</pubDate>
      <content:encoded><![CDATA[<p>在职业生涯中，从研发岗位转向技术管理职位，通常有以下几种路径：或是在现有团队中逐步晋升，自然而然地承担起领导职责；或是把握时机，接受上级的任命，实现角色的转变；亦或是通过跳槽，以空降的形式进入新的组织。而我的情况则是跳槽到新的公司，再一个项目组苟了一段时间，突然被调到一个新的项目组，作为十人左右的后端研发组长，结合了上面的二三两种途径；再真实入项之前，首先面临的挑战是接受业务方的面试和评估，以确定我是否满足他们对于该岗位的专业要求。</p>
<p>因此，在这篇文章中，我们将从两个关键的角度出发，深入探讨加入新项目时需要关注的各项事宜。</p>
<h2> 1. 入项面试</h2>
<p>在上一篇文章中，我们概述了新项目的背景情况。这是一个从零开始组建的全新项目组，由项目经理（PM）负责从无到有地构建团队。该团队的服务对象是兄弟单位，其首要任务是将整个项目的产品研发工作，从委托的第三方外部公司，完全迁移至这个新成立的项目组来承担。</p>
<p>对于团队的配置，标准构成包括产品组、前端组、测试组以及后台组，其中后台组进一步细分为业务、中台和订单处理三个关键部分。</p>
<p>此次参与的面试者则主要是产品组长、前端组长、测试组长以及后端组长。而面试官则由上级公司的分管领导以及业务方公司的高层管理人员共同组成。他们不仅评估面试者的专业能力，还会考察我们是否能够与各小组长协作，推动项目的整体研发工作。</p>
<h3> 1.1 面试准备</h3>
<p>本次面试与常规的求职简历投递所经历的面试环节相比，存在显著的差异。它主要倾向于对应聘者进行岗位胜任能力的评估，即一场以任职资格考核为主导的面试。不论是面对哪一种面试类型，我们的基本目标始终不变，即全面而准确地展现自身所具备的专业能力，并在此基础上，通过有效的沟通和展示，提升面试官对我们与目标职位匹配程度的认识和评价。</p>
<p>那么怎样才能增强我们的表现力呢？ 俗话说 “三军未动，粮草先行”，做一件事情的前期准备工作，非常重要；同样的我们需要做一些面试准备，但是这次的面试主题与形式不是很确定，我们的准备工作很难做到有的放矢，那么这种情况下，我该做什么？</p>
<h4> a. 确定主题</h4>
<p>在大多数情况下，成熟个体所展现的行为和动作。都带有明确的目标导向；作为参与的一方，我们有必要提前深入理解并掌握这一目标的本质。</p>
<p>简单来讲，就是我们需要尽可能的去搞清楚，这次面试的面试官是哪些人，目的是什么，怎么样的表现才是对方希望看到的</p>
<p>以我们常见的求职面试为例，通常会有技术面、领导面、HR面等几个环节，那么每个面试环节的目的就相对明确了</p>
<ol>
<li>技术面：这一阶段的主要目的是评估求职者的技术实力，以确定他们是否具备满足岗位要求的能力。因此，对于求职者来说，他们需要在这个阶段充分展示自己的技术能力，包括解决实际问题的能力，以证明自己具备完成工作的技术能力。</li>
<li>领导面：这一阶段的主要目的是评估求职者的综合能力，包括技术能力和领导潜力，以及他们的价值观是否与公司的文化相匹配。因此，求职者需要在这一阶段展示自己的项目管理能力、跨团队协作能力、沟通能力、逻辑思维能力和表达能力等软实力，以给领导者留下自己是一个可靠、能抗压的员工的印象。</li>
<li>HR面：这一阶段的主要目的是评估求职者的稳定性，以及他们对薪资等待遇的期望是否合理。在这一阶段，求职者需要表达自己的职业规划和期望，同时也需要合理地争取自己的权益。</li>
</ol>
<p>总的来说，每个面试阶段都有其特定的目的，求职者需要根据这些目的来准备和表现，以便更好地通过面试，获得理想的工作机会。</p>
<p>那么以本次述职面试来说，面临这种信息不明确的述职面试时，理解面试的目标至关重要。从提供的内容来看，此次面试的核心目标似乎在于评估参与者是否具备承担特定项目产研（产品研发）工作的能力。因此，组织方可能会专注于以下几个方面：</p>
<ol>
<li>技术能力：评估参与者是否具有完成项目所需的专业技术和实践经验。</li>
<li>项目管理：考察参与者是否有策划和管理整个产品研发过程的能力。</li>
<li>团队协作：判断参与者在团队合作中的沟通、协调能力以及领导力。</li>
<li>问题解决：测试参与者面对研发过程中可能出现的问题的应对策略和解决问题的能力。</li>
<li>适应性和学习能力：了解参与者适应新挑战的能力和学习新技术的速度。</li>
<li>压力管理：评估参与者在面对紧张工期或高难度任务时的抗压能力和稳定性。</li>
</ol>
<p>鉴于此，为了在面试中表现出色，我们可以做以下努力：</p>
<ul>
<li>准备充分，确保对相关技术和项目细节有深入的理解；</li>
<li>能够举例说明过往成功管理和执行项目的实例；</li>
<li>展示出良好的团队精神和领导潜力；</li>
<li>准备好针对可能遇到的技术或管理挑战的解决方案；</li>
<li>证明自己的学习能力和适应变化的能力；</li>
<li>显示出在压力下保持冷静和效率的能力。</li>
</ul>
<h4> b. 预设问题及回答</h4>
<p>基于上面的分析，结合我自己在这个项目组的定位，这个面试过程大概率会问两方面的内容</p>
<ol>
<li>技术能力评估</li>
</ol>
<p>对于技术问题，更多的应该是一些场景类、或者实际应用难点的解决方案之类的问题，不太会出现零散的知识点</p>
<p>这个就没什么好准备的，因为没啥方向，只能靠自身积累与临场发挥</p>
<ol start="2">
<li>团队管理评估</li>
</ol>
<p>这方面的问题大概率也是跑不了，核心就在于是否有自己的管理方法论，如何发挥出团队内1+1 &gt; 2的能力；在这里我们就可以提前给自己预设一些相关问题</p>
<ul>
<li>
<p><strong>如何保证你们的团队战斗力？</strong></p>
</li>
<li>
<p><strong>这一次的项目迁移，你准备怎么做？</strong></p>
</li>
<li>
<p><strong>跨团队部门的项目推进怎么进行？</strong></p>
</li>
<li>
<p><strong>如果有临时的、非常紧急的需求，怎么保障？</strong></p>
</li>
</ul>
<p>（在面试过程中，有两个问题确实比较相关，后面详细再说）</p>
<h4> c. 准备提问</h4>
<p>一般来说，面试的最后都会预留给面试者提问机会，请把握这个机会，在每次的面试过程中都准备几个问题，面对不同的面试官抛出不同的问题，这种时候，对方的答案其实并不重要，重要的是你想借助这个问题，表现出来的个人特质</p>
<p>还是以找工作的面试为例，给出几个通用的问题示例</p>
<p>技术面问题可以是</p>
<ol>
<li>咱们这个项目除了平时日常的需求交付之外，还会有一些性能优化、重构迭代、技术瓶颈之类的问题么？</li>
<li>团队的技术氛围怎么样，有没有一些技术分享之类的活动</li>
</ol>
<p>领导面的问题可以是</p>
<ol>
<li>日常的需求交付主要是项目内就可以完成交付了么？会出现跨团队、跨部门的交流么？</li>
<li>团队规模怎么样，今年的主要目标是什么，现在达成了多少，如果我来可以在这里扮演什么样的角色，有什么可以发挥的地方？</li>
</ol>
<h3> 1.2 面试过程</h3>
<p>这一次的面试，算是我职业生涯中的一个特殊的经历了，面试官有六位，还有一位主持... （这么多人，说不紧张是真有点虚）</p>
<p>抛开一些无关痛痒的细节，对一些有意思的问题下面进行一个复盘</p>
<h4> 1.2.1 技术问题</h4>
<p>所有的面试官中，只有一个是技术出身，问了两个相对常见的技术问题</p>
<p><strong>电商的超售问题怎么解决</strong></p>
<blockquote>
<p>比较常见的一个技术面问题，那么这个问题怎么回答呢？ 首先再回答这个问题之前，认清自己的定位，我来是并不是只做一个高级码农的，所以这个问题的回答就不应该仅局限再技术的解决方案上，不妨站在更高的角度，从业务视角来看这个问题</p>
</blockquote>
<p>下面是我针对这个问题的回答：</p>
<p>超售在电商系统中是一个相对常见的问题，但是怎么处理这个问题，一般根据实际的业务场景可以区分为两种，一类是我货就这么多，超卖的这些我发不了，因此不允许出现超售；另外一类则没有严格的库存限制，多卖一些也没关系，今天没货，明天可以有，因此允许超售卖一些</p>
<p>对于第一种情况，属于存粹的技术问题，对库存卡得比较严，比如秒杀，本来就是活动价卖，如果超售我就亏了；所以我们先从技术角度出发，来看一下如何杜绝超售这种问题</p>
<p>超售问题在电商系统中确实是一个常见的挑战，需要根据实际的业务场景来选择合适的解决方案。以下是对四种方案的简要解释：</p>
<ol>
<li>
<p><strong>方案1 - 数据库写锁</strong>：</p>
<ul>
<li>这是最直接的方法，通过在数据库添加写锁来确保库存扣减操作的串行执行。</li>
<li><strong>优点</strong>：实现简单，逻辑清晰。</li>
<li><strong>缺点</strong>：在高并发情况下，性能和用户体验可能较差。</li>
</ul>
</li>
<li>
<p><strong>方案2 - 分布式锁</strong>：</p>
<ul>
<li>使用分布式锁机制来控制并发操作，减少数据库长时间锁竞争带来的压力。</li>
<li><strong>优点</strong>：减轻了数据库的压力。</li>
<li><strong>缺点</strong>：实现相对复杂，需要考虑锁的管理和维护。</li>
</ul>
</li>
<li>
<p><strong>方案3 - 乐观锁+事务</strong>：</p>
<ul>
<li>结合乐观锁和事务机制来替换数据库写锁，实现库存扣减。</li>
<li><strong>优点</strong>：相比直接使用数据库写锁，性能更好。</li>
<li><strong>缺点</strong>：实现方式更复杂，需要处理冲突解决和回滚。</li>
</ul>
</li>
<li>
<p><strong>方案4 - Redis计数器</strong>：</p>
<ul>
<li>利用Redis的高性能特性，使用其自增/减计数器功能来进行库存管理。</li>
<li><strong>优点</strong>：可以提供更高的性能和吞吐量。</li>
<li><strong>缺点</strong>：需要额外的后台任务进行库存校准，或者在低库存时进行事前校准。</li>
</ul>
</li>
</ol>
<p>对于第二种情况，即允许一定程度的超售，商家需要从业务角度出发进行库存管理和超售处理，我作为商家应该如何做自己的库存管理</p>
<ol>
<li>
<p><strong>Case 1 - 充足库存</strong>：</p>
<ul>
<li>如果商家拥有充足的库存，超售一些不会对运营造成影响，可以正常处理订单。</li>
</ul>
</li>
<li>
<p><strong>Case 2 - 预留余量</strong>：</p>
<ul>
<li>在设置库存时，预留一定的余量，允许出现一些超售。这样即使发生超售，也不会立即导致缺货问题。</li>
</ul>
</li>
<li>
<p><strong>Case 3 - 多平台库存调拨</strong>：</p>
<ul>
<li>如果商家同时在多个平台上销售商品，可以在不同平台之间进行库存调拨。例如，当一个平台发生超售时，可以从其他平台的库存中调拨商品来补充。</li>
</ul>
</li>
<li>
<p><strong>Case 4 - 多层库存模型设计</strong>：</p>
<ul>
<li>设计多层库存模型，如三层库存模型：销售库存、可售库存和实物库存。通过区分不同层次的库存，可以更好地管理库存和预测需求。</li>
</ul>
</li>
</ol>
<p>在这个场景中，商家采用了一种动态的库存管理策略，这种策略考虑了实物库存、预计到货数量以及在不同销售平台上的销售需求。以下是对这种策略的详细说明：</p>
<p><strong>实物库存</strong>：</p>
<ul>
<li>这是指在全国范围内各个仓库中实际存储的商品数量。实物库存是商家当前可用的库存，可以直接用于满足顾客订单的需求。</li>
</ul>
<p><strong>预计到货数量</strong>：</p>
<ul>
<li>这是指商家根据生产计划或供应链信息预计在将来某个时间点会到达仓库的商品数量。这部分库存虽然还未到货，但商家有信心它将在未来成为可用库存。</li>
</ul>
<p><strong>可售库存</strong>：</p>
<ul>
<li>可售库存是实物库存和预计到货数量的总和。它代表了商家认为可以用于销售的总库存量。这个数字是商家愿意对外承诺的销售数量，它考虑了未来一段时间内库存的补充情况。</li>
</ul>
<p><strong>平台销售库存</strong>：</p>
<ul>
<li>商家会根据不同电商平台的销售渠道和市场需求，将可售库存分配到各个平台。例如，京东分配800个，天猫分配600个，拼多多分配1000个。这些数字反映了商家在各个平台上愿意销售的库存量，并且可以根据实际销售情况进行调整。</li>
</ul>
<p>通过这种多层次的库存模型，商家能够更灵活地管理库存，应对超售风险，并优化跨平台的库存分配。这种策略使得商家能够在保证服务质量的同时，最大化销售机会和利润。</p>
<p><strong>电商系统，与很多的三方系统交互，怎么确保交互一定会成功呢</strong></p>
<p>回答这个问题时，很多小伙伴会会不自觉地将自身定位于接口调用方的角色，这样就容易导致回答不够全面；除了扮演接口调用方的角色之外，我们在多方系统交互中，同样可能充当接口提供方的角色；因此，对于这一问题的回应，应当从接口调用方和接口提供方这两个不同的维度进行深入分析</p>
<p>一个简单的回答如下：</p>
<p>与外部系统的交互非常常见，站在自身的角度，通常有两种类型，一个是我们的服务依赖外部提供的接口，还有一类则是别人依赖我们的接口；下面我们将分别进行说明</p>
<p><strong>对于外部的接口依赖场景：</strong></p>
<p>在实际的业务场景中，对外部接口的依赖程度不同，可能对业务连续性产生重大影响。特别是在强依赖的情况下，外部接口的可靠性直接关系到我们自身业务的稳定运行。以下是针对强依赖场景的一些常见管理和应对策略：</p>
<ol>
<li>
<p><strong>冗余设计</strong>：建立备份系统或服务，以便在主服务不可用时切换。这可以包括部署多个外部服务实例或使用不同的服务提供商。</p>
</li>
<li>
<p><strong>故障转移（Failover）机制</strong>：实现自动故障转移到备用系统或服务，以减少停机时间。这要求有快速的故障检测和恢复机制。</p>
</li>
<li>
<p><strong>重试策略</strong>：为失败的请求实现自动重试逻辑，特别是在临时性问题（如网络抖动）引起的失败情况下。</p>
</li>
<li>
<p><strong>限流与熔断</strong>：通过限流防止系统过载，以及使用熔断器模式来预防系统性故障传播，一旦检测到异常行为，熔断器会“断开”，避免进一步的调用。</p>
</li>
<li>
<p><strong>服务降级</strong>：在外部服务不可用时，提供有限的或后备的功能，保证核心业务的持续运行。</p>
</li>
<li>
<p><strong>接口缓存</strong>：对于外部接口的结果进行缓存，减少外部接口的调用次数，降低出现问题的概率</p>
</li>
</ol>
<p>对于弱依赖，也有多种处理策略可以采用，以降低外部接口不稳定对业务的影响。以下是几种常见的处理方式：</p>
<ol>
<li><strong>降级策略</strong>：在弱依赖的情境下，当外部接口出现问题或访问延迟较高时，可以选择不调用该接口，或者使用备份方案来替代原有的服务。这种策略通常不会影响核心业务流程的进行，因为弱依赖通常不是完成业务流程所必需的。</li>
<li><strong>同步改异步</strong>：将同步的阻塞调用改为异步的非阻塞调用，可以提升系统的响应速度和用户体验。例如，在用户购票成功后，而不是立即执行推送消息的操作，系统可以在后台发送一个推送消息的异步任务，由消息队列消费这个任务来实现用户消息的推送。这样即使推送服务暂时不可用，也不会影响主要的购票流程。</li>
<li><strong>限流与熔断</strong>：对于可能引起系统不稳定的弱依赖服务，实行限流措施可以避免过多的请求压力传递到下游服务。而熔断机制则可以在检测到异常行为时自动中断服务调用，避免系统被进一步拖垮。</li>
<li><strong>监控与预警</strong>：通过实时监控系统的健康状况和性能指标，一旦检测到问题，可以及时触发警报并采取相应措施，比如启动备用系统或执行其他应急计划。</li>
<li><strong>依赖治理</strong>：建立一套强弱依赖治理机制，通过科学手段持续稳定地获取应用间的依赖关系、流量和强弱数据。这些数据可以用于指导系统改造、故障应对决策等场景，提前发现潜在的依赖问题，避免它们影响用户体验。</li>
</ol>
<p><strong>对于提供接口给外部的场景：</strong></p>
<p>这种主要是别人依赖我们的接口，当然也属于三方系统交互；常见有两种方式，一个是外部主动调用接口的<code>拉模式</code>，另外一个则是我们回调通知对方的<code>推模式</code></p>
<p>对于"拉模式"，问题就演变成如何保证我们接口的可用性，那么我们可以采用的策略有：</p>
<ul>
<li>集群模式提供，解决单点问题</li>
<li>接口熔断限流，防刷，避免被外部方无节制的调用打挂</li>
<li>通过缓存、并发、代码优化等方式，提高接口的性能</li>
<li>设置降级策略，当接口不可用时，切换降级方案对外提供支持</li>
<li>添加报警监控，实时感知异常，减少故障时长</li>
</ul>
<p>对于"推模式"，这个对于接口设计方而言，一个设计重点是<code>尽最大努力通知对方</code>，因此我们需要重点考虑的是；</p>
<ul>
<li>确保不漏推： 如将回调的任务持久化，当回调成功之后才将这个任务标记完成； 通过后台任务不断的扫描这些需要回调通知的任务，确保都会推送到</li>
<li>设置最大重试次数：不应该因为一个任务永不成功，导致无限重试，每个任务设置一个阶梯的重试时间间隔，超过最大次数之后不再回调</li>
</ul>
<p>最后再对上面的回答做一个总结，对于三方系统的交互，无法保障100%的成功率，对于系统设计本身，我们应该通过实际的业务场景、重要层级，设置不同接口的可用性，如我们常说的四个9，五个9；我们的设计理念应该是最大程度的保证可用，并且再真的出现问题时，及时发现，立马相应，快速修复，减少问题的影响范围</p>
<h4> 1.2.2 其他问题</h4>
<p><strong>为什么从互联网企业跳槽到现在这里？ 对现在公司的企业信息化怎么看</strong></p>
<p>出乎预料的一个问题，再面试当前这个公司时都没人问这个，结果这次居然被问道了；再听到这个问题时，有一些懵，也有些措手不及。已经回忆不起当时怎么回答的，当然从事后的反馈来看，应该答得还可以。</p>
<p>这个问题本身的答案并不重要，我更想说一下面对这种没有固定答案、且自己之前没有思考准备过的问题时，我们应该怎么处理</p>
<p>首先，遇到意料之外的问题时，不要着急回答，现在脑子里简单过一下，大致想一下回答框架；当然在实际的面试过程中，不可能留给我们很多空白时间来思考，因此一个简单实用的应对方案即，再缓慢的将问题复述一遍，一边拖延时间，一边找这个问题中的关键词</p>
<p>接着将上面的关键词进行拆分，将一个问题拆分成多个子问题，分别进行回复；再这个过程中，我们需要重点注意回复的技巧，正如我们写文不可能通篇一个大段一样，我们的回复也需要分个一二三，不管这个一二三条的逻辑关系是否合适，但是我们重点需要的就是给人一个条理清晰的认知</p>
<p>其次，再回答时，注意避重就轻，将问题转移到自己熟悉的领域，可以通过自问自答的方式来转移话题，比如上面问题中，我一直是搞互联网的对企业信息化没有了解过，那么我就可以这样回答</p>
<p>我为什么会从互联网行业转到这里呢？因为我个人之前一直再互联网内的公司工作，可以简单的从我的过往履历中说一下我对互联网的看法，我再xxx干的xxx .... 最后再提一下，对于企业信息化，这块由于之前没怎么接触过，但是我个人又比较喜欢接触新事务，从之前的服务人、到现在的服务企业，感觉是一个非常有意思、有挑战的事情，也正好可以打开我个人的视角</p>
<p><strong>对即将接受的这个项目了解多少</strong></p>
<p>回答套路如上，具体结果省略</p>
<p><strong>项目的产研迁移，怎么保证不出问题的同时，又能支持任务的迭代交付？</strong></p>
<p>这个问题虽然看着比较具体化，但实际上，是一个相对通用的问题模板；对于考核一个人，能否完成我们的要求时，比较常见，就是看一下这个事情交给你之后，准备怎么干，有没有目标计划，有没有行动章法</p>
<p>回答这样的问题，首先就是认清自己的定位，小兵还是攻坚，百夫长or统帅？</p>
<p>以我个人的实际场景来说，本身是来当研发组长角色，因此更多的需要站在能否以技术leader的角色，带领大家完成这个系统的迁移，那么这个过程中对我的要求是什么呢？</p>
<ul>
<li>再团队内培养他人对自己的信任感</li>
<li>能攻坚、能做任务分配拆解</li>
<li>发挥团队力量，完成任务目标</li>
</ul>
<p>对于这个项目的开展，我们首先需要搭建对应的成员班底，因为这个项目毕竟是将一个生产运行的系统，从外部迁移到新组建的项目团队，因此对于我们的人员要求较高，所以我们会优先从公司内抽调一些资深靠谱的小伙伴，来作为前期的攻坚手； 对于我们个人而言，需要做的事情则主要围绕在目标制定、任务拆解、结果校验上，大家前期以事驱动，新逐渐的团队，不存在明显的责任划分，根据大家的实际表现，来动态调整职责任务的分配。再团队内部，第一阶段目标主要是以磨合为主，养成大家的配合默契，同时也是对我个人的挑战，一个是再这个过程中充分的展现自己的能力，让别人可以信服自己，其次则需要再这个阶段认清团队成员的梯度情况，然后根据不同的人来制定不同的目标，以小步快跑的方式，实现一个一个目标，从而完成最后的项目迁移</p>
<p>针对这个工作展开，之前有准备一个思维导图如下，可以按照这个进行回复</p>
<figure><img src="/imgs/column/manager/03_工作展开.jpg" alt="工作展开思维导图" tabindex="0" loading="lazy"><figcaption>工作展开思维导图</figcaption></figure>
<p><strong>领导的临时紧急任务，如何支撑？再有限的时间内，确实完成不了，怎么处理？</strong></p>
<p>在实际工作中，我们经常会遇到领导突然下达的紧急任务。在这种情况下，我们首先需要考虑的不仅仅是如何去完成这个任务，更重要的是要理解这个任务的重要性和合理性，以及领导的核心诉求和他期望的结果。我们需要从结果出发，逆向思考这个任务的合理性，以及是否有更合适的方法来实现这个结果。在技术层面，往往有多种方法可以达到相同的效果，但它们的成本可能会有很大的差异。</p>
<p>一旦我们确定了这个任务必须被处理，我们就需要开始分析并拆解这个任务，识别出哪些部分是核心的，哪些部分是耗时的。我们可以优先处理那些核心且容易实现的任务，并将这些任务交给能力强的同事。对于那些既核心又难以处理的任务，我们可以专门指派人员来处理。这里所说的任务拆解，实际上更像是我们常说的任务优先级设定，我们需要优先保证高优先级的需求得到满足。</p>
<p>当我们在分配任务优先级和人力资源之后，如果发现时间仍然不够，我们应该如何处理呢？</p>
<ul>
<li>针对这种情况，我们首先需要考虑是否是人力资源不足。如果是，我们可以通过协调人力，增加人手来解决。如果可以通过加班来赶进度，那么我们可以牺牲一些个人的休息时间，加班赶工。</li>
<li>如果增加人力无法解决问题，我们可以考虑将任务分为多个阶段，按照最小的迭代单元进行分批交付。在截止日期之前，我们可以先上线部分功能，确保整体功能的可用性，然后再逐步完善。</li>
<li>如果我们在有限的时间内连最小的迭代单元都无法完成，那么我们可以考虑使用临时方案进行交付。例如，我们可以先用模拟数据或者静态页面来暂时替代。</li>
</ul>
<p>以上是基于任务工作量评估的处理策略。当然，在执行过程中，我们也需要关注每日的进度同步，及时上报问题和风险。除了保证功能的交付，我们还需要关注交付的质量，上线后需要密切关注，并进行长期的跟踪和优化。</p>
<h3> 1.3 小结</h3>
<p>在面试过程中，无论是入职新项目的面试还是一般的面试，以下几点是非常重要的：</p>
<ol>
<li><strong>前期准备</strong>：了解公司背景、职位要求和面试流程。研究可能的面试问题并准备好回答。确保自己的简历和求职信准确无误，突出自己的优势和与职位相关的经验。</li>
<li><strong>条理性回答</strong>：在回答问题时，尽量按照一二三四的分段式回答，清晰地表达自己的观点和想法。</li>
<li><strong>语速与语调</strong>：注意回答的语速，不要过快也不要过慢，确保清晰可懂。语调要自然，避免单调。</li>
<li><strong>减少小动作</strong>：保持良好的身体语言，减少不必要的手势或面部表情，以提高个人的印象分。</li>
</ol>
<p>对于重要的面试，如年终/中述职或晋级答辩，可以采取以下策略：</p>
<ul>
<li><strong>模拟面试</strong>：找一些小伙伴充当面试官，进行多次模拟面试，以便熟悉面试流程和提高应对能力。</li>
<li><strong>自我录音</strong>：如果找不到人进行模拟面试，可以通过手机录音的方式记录自己的回答过程，之后回放并分析，找出不足之处进行针对性的改进。</li>
<li><strong>持续练习</strong>：面试技巧的提升需要时间和练习，不断练习总会带来进步。</li>
</ul>
<p>下面也是我再面试完毕之后，主持这场面试的项目经理给我的反馈，整体评价是再几个面试者中最高的（通过这一次的面试，我本人再PM这里也刷了一波存在感，留下了非常好的印象，后续的工作展开也确实得到了很多的优待帮助）</p>
<figure><img src="/imgs/column/manager/03_面试反馈.jpg" alt="面试结果反馈" tabindex="0" loading="lazy"><figcaption>面试结果反馈</figcaption></figure>
<h2> 2. 职责认知</h2>
<p>进入新的项目组之后，很容易想到的就是如何融入团队，但是在这里，对于技术管理而言，我则更想说一下，如何对自己做好角色认知和角色定位</p>
<p>如果我们是以研发的角色进入一个新的团队，那么我们的自我定位则比较明确，快速熟悉项目、能迅速上手，做需求交付；那么做技术管理而言呢？</p>
<p>同样的对于我个人而言，面对即将进入的项目组，同样面临这些问题。我来干什么？ 上面的领导希望我干什么？ 我又能干什么？</p>
<p>接下来我将从角色定位、职责要求说一下我个人对这些的理解</p>
<h3> 2.1 角色定位</h3>
<p>从研发到管理，必然是存在一些改变的，假定看我这些水文的都是资深的研发小伙伴，接下来的视角将重点放在从“研发工程师”到“技术管理”的角色转变上</p>
<blockquote>
<p>以下内容，主要摘抄于 《知行-技术人的管理之路 by 刘建国》</p>
</blockquote>
<h4> 2.1.1 职责使命</h4>
<p>对于研发而言，我们的职责就是干好上级分配的活，或者更进一步，对于一些资深的小伙伴而言，老板有一个想法，我们可以从技术的视角来做拆解、、分配、落地、执行/亦或者判断是否有必要做这个事情</p>
<p>对于管理者而言，不是自己来做这些任务的研发执行，更多的则是让其他的小伙伴来做最终的落地，比如上面资深小伙伴的任务拆解、分配、推进等大多都是技术管理的工作要求。这通常也意味着，上级只是帮我们设定一个目标，剩下做什么、怎么做，都是我们需要考虑的</p>
<h4> 2.1.2 负责对象</h4>
<p>对于研发而言，通常我们只需要对自己负责，做好自己的工作内容即可</p>
<p>对于管理者而言，向下需要对自己的团队负责，整体团队的成长、绩效、输出、口碑都是需要自己来维护与经营打造；向上则需要对自己的领导负责，有没有浪费公司资源，顺利完成公司分配的任务，达成or超出既定的目标</p>
<h4> 2.1.3 关注焦点</h4>
<p>对于研发而言，一般是过程导向，关注脚下，是否有一步一步将工作执行到位</p>
<p>对于管理者而言，通常则是目标和结果导向，我们有没有完成既定的目标，后面准备做什么</p>
<h4> 2.1.4 工作内容与能力要求</h4>
<p>对于研发而言，主要是靠个人的专业能力作为产出，做需求、任务的实现交付，项目系统的运营维护；因此技术专业性通常是核心且最重要的衡量指标</p>
<p>对于管理者而言，出了技术判断力之外，还需要目标管理能力、团队规划能力、项目管理能力、沟通协调能力、团队建设能力等等，需要看方向的、带人的、做事的更加多维和立体的能力</p>
<h4> 2.1.5 任务来源</h4>
<p>对于研发而言，任务一般来自于上级安排，主要是听指挥</p>
<p>对于管理者而言，出了上级安排的任务之外，更多的需要自己筹划、然后再主动去与上级沟通确认，从被动接活到主动“找事”</p>
<h4> 2.1.6 实施手段</h4>
<p>对于研发而言，通常都是动手实干，亲力亲为，主要的贡献就来自于自己的专业产出</p>
<p>对于管理者而言，更多的是统筹，靠整个团队一起来完成</p>
<h4> 2.1.7 合作维度</h4>
<p>对于研发而言，合作的通常是和平级的小伙伴，一起做好研发工作，常见的合作对象是共同参与的研发、测试、产品、ui等</p>
<p>对于管理者而言，合作的对象就比较丰富了，如需要和上级合作规划好整个团队的目标，和下级合作做好落地执行，和平级管理者合作完成联合项目，有时候还需要和平级的上、下级去一起协调资源和进度</p>
<h4> 2.1.8 合作关系</h4>
<p>从团队成员的合作关系来看，对于研发者而言，与团队内成员是“竞争与合作”的关系，日常的工作大多需要共同协作推进，但是大家应该也都经历过资源的竞争、绩效的争取</p>
<p>对于管理者而言，在团队内一个显著的区别则是不应再有竞争的关系了，我们和团队应该处于全面合作的关系，对于管理者的评价标准更多的是看整个团队的产出</p>
<h4> 2.1.9 思维方式</h4>
<p>对于研发而言，通常是执行的思维方式，如何将一件事情落地，更关注过程与实时细节； 通常研发的估算排期比较保守，因为他们需要确保能完成才愿意答应</p>
<p>对于管理者而言，虽然也考虑风险和成本，但是更习惯于去关注做一件事能带来的可能性收益，并以此来判断是否值得投入资源去做，这种更多的是“规划思维”</p>
<p>由于管理者总是在盘算和筹划一些可能会对公司和团队有价值的事情，而没有仔细考虑风险和成本，所以在工程师的眼中，管理者时不时会提出一些“不靠谱”的期望和需求，但这正是两个角色关注的东西不同造成的。而这恰恰是一种很好的合作与互补</p>
<h4> 2.1.10 技术视角</h4>
<p>对于研发而言，技术是核心生产力，用来保障我们做好实施的主要手段，更多的是以运用的角度来看待技术</p>
<p>对于管理者而言，技术是达成目标的手段之一，通常是结合实际场景，判断这个技术是否合理，当前最优，经常需要做一些技术决策。对于技术管理者而言，切忌技术崇拜，不能为了追求时髦而引入各种没什么用的技术栈</p>
<h4> 2.1.11 小结</h4>
<p>接下来以表格的方式将上面的对比进行小结如下</p>
<table>
<thead>
<tr>
<th>维度</th>
<th>工程师</th>
<th>管理者</th>
</tr>
</thead>
<tbody>
<tr>
<td>职责使命</td>
<td>拉好车-做好自己手头的工作就无咎</td>
<td>驾好车-引领整个团队往前走</td>
</tr>
<tr>
<td>负责对象</td>
<td>对自己负责 , "管好自己就可以了"</td>
<td>对公司(上级)和团队(下级)都负责</td>
</tr>
<tr>
<td>关注焦点</td>
<td>过程导向:脚下的路</td>
<td>目标和结果导向:是否达成目标</td>
</tr>
<tr>
<td>工作内容</td>
<td>内容单纯 , 主要靠专业能力</td>
<td>多维立体 , 所需能力维度大幅增加</td>
</tr>
<tr>
<td>任务来源</td>
<td>上级安排</td>
<td>自己主动规划&amp;向上沟通</td>
</tr>
<tr>
<td>实施手段</td>
<td>主要靠自己</td>
<td>主要靠团队</td>
</tr>
<tr>
<td>合作维度</td>
<td>平级合作为主, 维度单一</td>
<td>360 度合作, 维度立体</td>
</tr>
<tr>
<td>合作关系</td>
<td>和团队成员是平级竞合关系</td>
<td>和团队成员是全面合作关系</td>
</tr>
<tr>
<td>思维方式</td>
<td>执行思维, 习惯关注确定性风险</td>
<td>规划思维, 习惯关注可能性收益</td>
</tr>
<tr>
<td>技术视角</td>
<td>技术实施视角</td>
<td>技术评估视角</td>
</tr>
</tbody>
</table>
<p>角色认知的改变，并不是一蹴而就的，需要你我们不断的自我审视和有意识的纠偏，这也是我们做转变的第一道门槛。</p>
<h3> 2.2 职责要求</h3>
<p>上面是认识到角色的定位，我们知道应该往什么样的方向进行转变自己，但是接下来我们应该做些什么呢？</p>
<p>简单来讲，我来这个项目，到底是让我来干嘛的!</p>
<p>接下来我将以个人实际的体验，来反推一下，一个技术管理的职责要求</p>
<h4> 2.2.1 任务清单</h4>
<p>因为这是一个新组建的项目团队，初期目标就是将系统从外部团队接手到项目内，所以给我的任务就比较清晰了</p>
<ol>
<li>人员招聘，团队组建</li>
<li>研发管理流程规范制定</li>
<li>项目迁移，外部对接</li>
<li>需求交付，任务实施</li>
</ol>
<p>对于项目前期，需要干的事情实际上比较明显，无非就是 <code>团队建设</code> + <code>标准规范</code> + <code>任务交付</code>，至于接下来怎么来做些事情，我会再之后的文章中分段说明</p>
<h4> 2.2.2 管理图谱</h4>
<p>下面是一个我个人感觉很有收获的图谱，同样分享给各位小伙伴，当然由于我个人能力有限，以下图谱的内容，再后续的阐释中，可能会有一些偏差谬误之处，还请多批评指正</p>
<figure><img src="/imgs/column/manager/03_管理图谱.png" alt="管理图谱" tabindex="0" loading="lazy"><figcaption>管理图谱</figcaption></figure>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/column/manager/03_工作展开.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>04. 团队组建</title>
      <link>https://liuyueyi.github.io/tutorial/column/tech/manager/04.%E5%9B%A2%E9%98%9F%E7%BB%84%E5%BB%BA.html</link>
      <guid>https://liuyueyi.github.io/tutorial/column/tech/manager/04.%E5%9B%A2%E9%98%9F%E7%BB%84%E5%BB%BA.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">04. 团队组建</source>
      <description>接下来我们将进入第二章节内容，如何进行团队搭建。 既然是作为技术管理，那必然还是有几个小兵再自己手下的，如果自己管理自己，那也算不上是管理了。 团队搭建的第一篇，当然是找人，填充团队空缺了。 通常一个团队的对外表现形式，与团队负责人本身有很强的关系，如果让你来组建你的团队班底，你会怎么做呢？ 正好我现在的团队成员都是我从0到1拉起来的人头，接下来我将从招人和带人两块来说一下如何做团队成员的搭建</description>
      <category>技术管理</category>
      <pubDate>Fri, 01 Mar 2024 09:27:46 GMT</pubDate>
      <content:encoded><![CDATA[<p>接下来我们将进入第二章节内容，如何进行团队搭建。 既然是作为技术管理，那必然还是有几个小兵再自己手下的，如果自己管理自己，那也算不上是管理了。</p>
<p>团队搭建的第一篇，当然是找人，填充团队空缺了。 通常一个团队的对外表现形式，与团队负责人本身有很强的关系，如果让你来组建你的团队班底，你会怎么做呢？</p>
<p>正好我现在的团队成员都是我从0到1拉起来的人头，接下来我将从招人和带人两块来说一下如何做团队成员的搭建</p>
<!-- more -->
<h2> 1. 招人</h2>
<p>一二线的技术管理，一般不会有完整的人事权，即想招多少人、招什么样的人、决定要不要某一个候选人都不是我们能拍板的。通常来说，我们拥有建议权，那么对于招人，我们可以怎么做呢？</p>
<p>当由我们来执行团队搭建时，首先需要定好基调，想好我想要什么样的人，解决什么样的问题，截止时间是什么时候，下面是我再团队搭建之初，思考的几个维度</p>
<figure><img src="/imgs/column/manager/04_团队成员招聘.png" alt="团队成员招聘思维导图" tabindex="0" loading="lazy"><figcaption>团队成员招聘思维导图</figcaption></figure>
<h3> 1.1 团队规划，定人力要求</h3>
<p>当一项事情交给我们时，我们首要需要考虑的就是这个事情的目标是什么，有没有什么限制要求，结果的考核标准是什么。对于招人这件事呢，同样如此</p>
<p>首先需要搞清楚，上级领导给我的团队规划，准备了几个人头，团队成员配比是什么（资深高中初级别各多少人），另外还得摸清楚给了我们多长时间来完成这件事</p>
<p>请注意，上面说的这些，可能会遇到上面无法给出准确结论的场景，对于上级管理而言，他更清楚的是要干什么事情，我能投入多少资源。 因此对于我们来说，上面这几个指标则是由我们来提供，具体的输出呢，则由目标+预算来进行推测</p>
<p>下面是我个人的一点认识，不一定完全准确，仅供参考</p>
<ul>
<li>一个重要且紧急的活，优先是达成目标，资源没有明显限制时
<ul>
<li>找一批基础能力过硬，协作能力强的小伙伴</li>
</ul>
</li>
<li>一个重要且紧急的活，资源预算有限时：
<ul>
<li>找一两个能力强，剩下的选择靠谱基础扎实，听指挥的小伙伴</li>
</ul>
</li>
<li>一个重要不紧急的活，会持续建设，合理的预算
<ul>
<li>按金字塔的梯度模型搭建团队</li>
</ul>
</li>
</ul>
<p>还是以我所在的团队定位来看，上面的几个指标要求：</p>
<ol>
<li>团队人员14人（含我, 内分两组），在途3人，待招 10 人，预留一人补充名额</li>
<li>PM要求，全部是能独挡一面的研发，优选高级</li>
<li>一个月内完成团队组建</li>
</ol>
<p>从上面的指标来看，要求并不算低，再新一线城市，找一个高级研发都不太容易，更何况是在一个月内找十来个</p>
<p>所以我们需要适当调整上级的预期，领导需要来即能迅速干活的人，那么是不是非高级不可呢？ 从干活这个视角来看，实际上一些能做好交付的中级研发同样可以胜任，那么完全而已和领导沟通一下，再有限的时间内，全找高级的难度太大，可以通过预留一些中级的名额来降低人员招聘进度不利的风险</p>
<blockquote>
<p>在这里需要简单说一下我们对高中初的定位（研发最高定位就是高级，再往上就是技术经理和架构）</p>
<p>高级: 可胜任新系统的搭建，能实现复杂任务的拆解、分配、交付，独立负责一到多个独立的系统
中级: 交付的任务可独立自主完成，做一些简单的任务拆解与实现交付
初级: 再告知如何做的基础上，可以实现独立自主的开发</p>
</blockquote>
<h3> 1.2 团队标签，定人员基调</h3>
<p>建立人设，打造个人标签这个事情最近这些年可以说非常流行了，对人如此，同样的对于团队依然适用。 一个成熟且成功的团队，再外人的眼中一定会有一些显著的特色，如果我们有机会构建一个自己的团队，那么再这个团队标签的打造上，请多花一点时间和精力</p>
<p>打造人设/标签这个对我们研发而言，通常来说属于比较朝纲的问题，对于个人，出了有意的经营之外，更多的是个人特质的外在表现，给人的印象和感觉；对于团队，作为领头羊，如果不主动经营，基本上这个事情很难实现，关于这一块我没有什么值得说到的成功经验，浅述一下个人的尝试路径</p>
<p><strong>确定团队定位</strong></p>
<p>首先要知晓打造团队标签，主要是给其他的团队、上级领导看的，从结果来反向看过程，要想做好这件事情，当然必须先摸清楚上级对我们团队的定位和预期；</p>
<p>如果上面要求我们响应迅速、机动能力强，那就把团队往“敏捷”的代名词上靠</p>
<p>如果上面要求我们稳定、高质量，那就重点关注每个任务的交付质量，让“靠谱”这个属性贯彻到底</p>
<p>如果上面要求我们自主、积极创新，那就需要关注团队的活跃性以及主管能动性了</p>
<p>总的来说，再职场，对于非创造性的岗位要求来说，盯着目标往前冲的路线带来的好处是远大于飘散的随机发挥的</p>
<p><strong>明确团队使命</strong></p>
<p>明确团队的使命，这个命题感觉有点大，一个刚搭建的团队，说实话又能有使命感呢？ 我们又不是组建复仇者联盟！</p>
<p>这里说的明确使命，务实一点可以理解为明确责任，可以直接从项目的责任书、上级的规划蓝图、团队定位等方面来明确责任与义务，提炼使命口号； 特别是对于团队leader而言，这一点较为重要，当我们弄清楚这一点之后，才会更好的去把握，我们招的这一拨人，应该满足什么样的特质，用什么的方式来凝聚团队战斗力</p>
<p>比如以我现在的团队来看，目前对外营造的标签，主要为 “专业” + “攻坚” + “和谐”，当然这些结论都是再日后的协作过程中，逐渐给其他人留下的印象，我最开始希望打造的只有“专业”这一点，所以我再招人的时候，设置了几个基础的要求</p>
<ul>
<li>有相关的行业背景</li>
<li>五年+的工作经验</li>
<li>沟通表达简洁、顺畅</li>
</ul>
<h3> 1.3 团队相性，定协作模式</h3>
<p>人有相性，团队当然也有。 由于我们是团队leader，那我能不能融入这个团队，或者这个团队的氛围和我的管理方式、个人习惯是否有不可调和的冲突，这些是需要我们重点考虑的</p>
<p>既然是搭建自己的团队，那这一点就很比较好执行了，首选的肯定是组建一个符合自己性格特点的团队，增加自己的舒适感也可以有效的减少管理的成本。</p>
<p>所以，再开始之前，先深刻认识一下自己，我是什么样的人，我想要什么样的人，我得团队应该是什么样的一个表现</p>
<p>同样以我个人举例，我本人属于偏技术侧，不喜欢与人battler，推崇简洁、高效，为人相对随和，因此我希望我一起合作的小伙伴 “有技术追求、做事高效、且性格同样温和”，技术牛批但是性格比较刚的不要，容易产生负面情绪的不要，容易急躁的不要，做事毛糙粗心大意的不要</p>
<blockquote>
<p>在这里自我申辩一下，由于我个人不希望我将有限的精力放在人事之上，因此很迅速的定下了我不想合作的特质，从现实来讲，这同样可以减少我们筛人的成本</p>
</blockquote>
<h3> 1.4 人员招聘</h3>
<p>以上都属于招人的前置过程，当明确我要招一些什么样的人之后，自然的就将进入真实的招聘过程； 有一说一，招人实际上一个非常耗时间、精力的一件事情，如何再短短的半小时、一小时之内，选择你今后战斗的小伙伴，这并不容易，当然每个资深的面试官都有自己的心得，简单说一下我个人的准备及执行过程</p>
<p><strong>准备阶段</strong></p>
<ul>
<li>提前准备几个通用的面试问题
<ul>
<li>技术方面：高级和中级，设置不同的面试题</li>
<li>工作习惯：是否养成良好的工作习惯，可以通过日常的工作流程中识别</li>
</ul>
</li>
<li>设定最低的过线标准
<ul>
<li>技术基本线： 基本功，实际解决问题能力，碰到未遇到的问题的处理思路</li>
<li>协作基本线： 沟通 + 工作习惯 + 性格</li>
</ul>
</li>
</ul>
<p><strong>执行过程</strong></p>
<blockquote>
<p>为了提高效率，再具体的执行过程中，我的一些操作有点为难面试者的嫌疑😂</p>
<p>下面是我之前招人的一般流程，并不带有普适性，谨慎参考</p>
</blockquote>
<ol>
<li>让面试者自我定位，属于初中高那一级</li>
<li>根据自我衡量，抛出准备的面试题
<ul>
<li>能基本回答完整的，继续下一轮</li>
<li>回答得比较差的，就准备两个简单的问题，走个流程迅速解决战斗</li>
</ul>
</li>
<li>工作习惯的交流
<ul>
<li>日常的需求交付模式、怎么和其他人协同开发</li>
<li>一个紧急的任务交过来了，怎么落地？</li>
</ul>
</li>
<li>了解对方的诉求，判断是否可以满足</li>
</ol>
<h3> 1.5 小结</h3>
<p>总的来说，招人是一个累活，我个人非常不喜欢干这件事情，主要原因在于我并不善于识人，再短短的交流时间内，很难说到底是遗漏了一个千里马/还是放入了一个滥竽充数的南郭先生</p>
<p>我个人的一些理论经验不一定行之有效，这里仅供一个参考，三步规划，一步执行</p>
<ol>
<li>明确团队规划，确定人员招聘计划</li>
<li>打造团队标签，明确人员组成</li>
<li>确定团队相性，制定候选人标准基线</li>
<li>面试过程：准备面试题库 + 设定达标底线</li>
</ol>
<h2> 2. 带人</h2>
<p>一个成熟的团队，除了健全的工作机制之外，还需要具备较低的融入成本。对于技术管理而言，无论是否实际带领团队，如何打造一个新人友好的环境都是我们的职责之一。</p>
<figure><img src="/imgs/column/manager/04_带人.png" alt="带人思维导图" tabindex="0" loading="lazy"><figcaption>带人思维导图</figcaption></figure>
<p>上面是我个人对带人的一点看法，除了建立良好的融入机制之外，这里也分别对新人初级小伙伴以及中高级成熟的职场人做了一些区分，由于层级不同，我们投入的时间、精力以及重点当然也会有侧重</p>
<h3> 2.1 初级成员融入</h3>
<p>对于初级的小伙伴，他们的实际经验、技术背景、工作习惯方面可能都存在欠缺，因此对于引领他们快速融入团队的“导师”，需要投入更多的时间关注</p>
<ol>
<li>首先，通过交流和交付任务来评估他们的真实能力水平。这有助于我们了解他们的基线，并为他们提供个性化的指导</li>
<li>制定节点计划
<ul>
<li>业务熟悉计划表：帮助他们逐步了解和熟悉业务领域</li>
<li>技术栈学习计划表：确保他们能够快速掌握当前项目的技术栈基础知识点，目标是能够无障碍地使用这些技术</li>
</ul>
</li>
<li>项目工作方式宣贯
<ul>
<li>提前告知项目的协作规范和开发规范</li>
<li>在初期，重点关注成员的工作模式执行情况，及时进行纠正和指导</li>
</ul>
</li>
<li>任务需求试点
<ul>
<li>从简单的任务开始，逐渐分配更具挑战性的任务</li>
<li>前期聚焦于特定的业务或系统，待熟悉后再进行扩展</li>
</ul>
</li>
<li>定期进行一对一沟通
<ul>
<li>通过面对面的交流，了解他们的团队融入情况，解答个人的疑惑，并根据他们的反馈动态调整任务分配</li>
<li>前期可以增加沟通的频率（如每天下班后聊5分钟，每周进行半小时的深入交流），随着他们的成长，可以逐渐降低沟通的频率</li>
</ul>
</li>
</ol>
<h3> 2.2 高级成员融入</h3>
<p>针对中高级研发人员，凭借多年的工作经验，通常都已经形成了自己独特的工作习惯。因此，在引导他们融入团队的过程中，我们的目标是加速这一融入过程，并最大限度地减少他们的疏离感和陌生感，驯熟的熟悉当前团队的工作习惯和协作模式。以下是我的一些看法：</p>
<ol>
<li>在入职初期，进行一次全面的业务和架构介绍 (这种方式比单纯地阅读文档和代码更为高效)
<ul>
<li>首先，通过整体的介绍，让新成员对业务和架构有一个宏观的认识</li>
<li>然后再让他们自主地熟悉细节</li>
</ul>
</li>
<li>明确业务领域，并优先进行掌握熟悉
<ul>
<li>为新成员明确他们即将负责的主要系统，并鼓励他们重点熟悉和掌握。</li>
<li>如果没有特定的业务需求，那么可以以修复bug为主</li>
<li>再次过程中，收集他们对业务的整体认知，包括优化建议和遇到的问题。 （从新人的视角，往往可以得到一些我们看不到的优化点）</li>
</ul>
</li>
<li>快速实现任务交付。
<ul>
<li>鼓励新成员参与需求和设计方案的讨论，从一些非核心的需求开始，迅速了解整个工作流程和规范。</li>
</ul>
</li>
<li>培养信任关系，并充分放权
<ul>
<li>中高级研发成员加入团队是为了独挡一面。一旦确认他们的能力无误，我们应该给予他们足够的权力，让他们充分发挥自己的能力。</li>
</ul>
</li>
</ol>
<h2> 3. 小结</h2>
<p>对于团队成员的组建，是一个非常考研领头人个人综合能力的一项挑战。 认清团队目标，找准自我定位，搭建成员班底这仅是第一步，如何建立良好的团队关系，充分发挥团队的战斗力，也是我们接下来需要重点考虑的点</p>
<p>接下来我将以个人的实际经历，来看一下一个新的研发团队，怎么做新项目的承接、团队成员的磨合</p>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/column/manager/04_团队成员招聘.png" type="image/png"/>
    </item>
    <item>
      <title>05. 团队磨合</title>
      <link>https://liuyueyi.github.io/tutorial/column/tech/manager/05.%E5%9B%A2%E9%98%9F%E7%A3%A8%E5%90%88.html</link>
      <guid>https://liuyueyi.github.io/tutorial/column/tech/manager/05.%E5%9B%A2%E9%98%9F%E7%A3%A8%E5%90%88.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">05. 团队磨合</source>
      <description>上一篇介绍了团队组建的过程，当团队搭建起来开始运转时，作为领头羊、团队的掌舵者，我们首先需要解决的就是团队协作问题，即我们应该再团队的磨合期做些什么，以此来实现彼此的逐步熟悉、建立信任和提高协作效率 本文组织结构的思维导图如下，基于3w原则 团队磨合思维导图 1. 什么样的团队需要磨合</description>
      <category>技术管理</category>
      <pubDate>Wed, 06 Mar 2024 09:27:46 GMT</pubDate>
      <content:encoded><![CDATA[<p>上一篇介绍了团队组建的过程，当团队搭建起来开始运转时，作为领头羊、团队的掌舵者，我们首先需要解决的就是团队协作问题，即我们应该再团队的磨合期做些什么，以此来实现彼此的逐步熟悉、建立信任和提高协作效率</p>
<p>本文组织结构的思维导图如下，基于3w原则</p>
<figure><img src="/imgs/column/manager/05_团队磨合思维导图.png" alt="团队磨合思维导图" tabindex="0" loading="lazy"><figcaption>团队磨合思维导图</figcaption></figure>
<h2> 1. 什么样的团队需要磨合</h2>
<p>再看这个命题的时，首先需要明确的是，什么样的团队需要磨合？</p>
<p>一般来说，一个成熟稳健的团队，是不需要磨合的，对于这样的团队，需要关注的是信任的融入过程是否丝滑，是否有完善的培养晋升机制</p>
<p>而需要磨合的，则往往是我们这种新组建的团队，团队成员可能是新招，也可能是来自不同的部门进行抽调组成，由于大家彼此不熟，既往的工作履历、习惯、背景都存在差异，相互的信任还未建立，从而导致团队的整体运转不够高效明朗、相互之间的协作混乱冲突。 新组建的团队，都会经历一个磨合期，对于团队的管理来说，我们需要干的就是加快这个磨合过程，迅速增强凝聚力。</p>
<h2> 2. 磨合什么</h2>
<p>对于管理者而言，我需要做什么？ 基于我个人的实际认知，分成下面几点</p>
<figure><img src="/imgs/column/manager/05_团队磨合事项.jpg" alt="团队磨合事项" tabindex="0" loading="lazy"><figcaption>团队磨合事项</figcaption></figure>
<h3> 2.1 明确目标与期望</h3>
<p>正如每个旅程都有目的地一样，每个团队当然也有自己的使命与目标。对于团队管理而言，明确要干什么当然很重要，那团队成员呢，真的重要么?</p>
<p>以我个人的实际工作体验来说，当我是一线小兵时，对于团队的整体目标，并不会特别关心，我只要知道我自己负责什么、要做什么、什么时候交付，将自己的事情做好即可。</p>
<p>当站在管理者的视角，再看上面的表述，你会发现上面的执行过程没有任何问题，只是可能出现问题的地方在于管理者对成员的定位以及任务分配，我对他的这些规划，是不是符合我们团队的整体预期？ 请牢记我们是掌舵者，这条船开往那里是由我们来决定的，当你发现团队走偏时，不用怀疑其他，90%以上可能性就是你自己的问题</p>
<h3> 2.2 标准的工作流程</h3>
<p>从研发的角色，当然时崇尚自由、探索；但是作为管理者的角色，统一的标准和基线，是减少我们工作量的重要手段</p>
<h4> 2.2.1 统一的研发流程规范</h4>
<p>只要一个公司的研发人数大于10，那么必然会有自己的研发规范（无论这个规范是明文还是潜规则，合理or不合理），这些或明文或潜规则的规范，可以简单理解为这个团队所有人认可的工作过程，比如对于研发而言，一套完整的工作流程需要遵循的有：</p>
<ul>
<li>代码分支管理</li>
<li>需求交底，反串讲</li>
<li>方案设计、评审</li>
<li>统一的编码风格</li>
<li>提测前的功能自测</li>
<li>测试验收</li>
<li>部署上线</li>
<li>线上回归验证</li>
</ul>
<h4> 2.2.2 受信服的项目管理过程</h4>
<p>这里的项目管理过程，可以简单理解为我们常见的需求交付过程，比如常见的</p>
<ul>
<li>产品需求交底</li>
<li>研发反串讲</li>
<li>研发</li>
<li>上测试，提测</li>
<li>测试通过，上预发</li>
<li>产品验收</li>
<li>上生产</li>
</ul>
<h4> 2.2.3 清晰高效的沟通机制</h4>
<p>工作上出现多人协同工作的可能性非常之高，那么必然会出现沟通，而沟通表达可能是很多研发的弱项，由于沟通的缺乏导致的信息差，对于团队管理者而言，往往是一拳重击。</p>
<h3> 2.3 共识的技术标准</h3>
<p>由于我个人是研发出身，所以会单独说一下技术标准共识的磨合，why?</p>
<p>研发，通常会有一种技术崇拜，喜欢折腾新技术，乐于尝鲜；高级的研发认为代码写得好完全不需要研发；杀鸡用牛刀的炫技写法（潜台词即设计模式并不是所有场景通用，某些时候简单的if/else比设计模式更值得）</p>
<p>但是对于团队、公司而言，稳定可持续的交付更重要，对于新技术的引入一般会很慎重，更重视代码的可维护性、阅读性</p>
<p>因此这里说的技术标准，包含但不限于以下：</p>
<ul>
<li>技术栈选型</li>
<li>编码规范</li>
<li>架构设计原则</li>
<li>通用的文档模板:</li>
<li>新技术/组件的引入原则、评审机制</li>
<li>...</li>
</ul>
<h3> 2.4 熟悉工具栈</h3>
<p>每个团队都会有自己的效率/运营工具，请不要把这些大家今后工作中，高频使用的东西“藏起来”，我们应该金align的让所有的小伙伴，可以无障碍，快速的熟悉这些，比如</p>
<ul>
<li>代码管理工具：git/svn</li>
<li>项目管理软件：jira/禅道</li>
<li>持续集成/持续部署CI/CD</li>
<li>知识库：钉钉/飞书/石墨/wiki</li>
<li>内部的运营工具等</li>
</ul>
<h3> 2.5 问题解决机制</h3>
<p>这个也是团队磨合中需要提前解决的点，这里指得问题，有两类</p>
<ul>
<li>人的问题
<ul>
<li>团队成员关系问题</li>
<li>工作习惯的冲突问题</li>
<li>外部沟通、配合障碍的问题</li>
</ul>
</li>
<li>事的问题
<ul>
<li>系统故障处理预案</li>
<li>线上问题处理机制</li>
<li>业务边界问题</li>
</ul>
</li>
</ul>
<p>人的问题，若不能提前解决，那就真如那句“人心散了，队伍就不好带了”； 事的问题，解决不好，则容易带来直接的经济or口碑损失</p>
<h3> 2.6 共享机制</h3>
<p>磨合期间，个人强烈建议需要解决的一件事情是建立一套透明的共享机制，让知识再团队内最大化的流动起来，避免出现单点问题；同时一个良好的分享氛围，也可以有效的提高团队的稳定性</p>
<p>分享主题尽量可以分散一点，不要局限在技术侧</p>
<ul>
<li>业务分享</li>
<li>技术分享</li>
<li>人文分享</li>
</ul>
<h3> 2.7 信任建立</h3>
<p>在磨合期间，需要解决信任问题，这个拖的时间越长、解决得越差，那么团队得磨合期就只会更长</p>
<p>我们需要重点解决两种信任：</p>
<ol>
<li>团队成员对领队的信任</li>
<li>团队成员相互之间的信任</li>
</ol>
<h3> 2.8 绩效与考核机制</h3>
<p>透明的绩效与考核机制，对于团队的稳定性有较大的帮助，当然一般团队的管理对绩效制定这块并不会有太大的抉择权，所以在磨合期间做好宣贯即可</p>
<h2> 3. 怎么做</h2>
<p>当我们明确上面指出的几点之后，接下来就是需要去实现、去解决。 下面将结合个人实践进行阐述</p>
<h3> 3.1 目标与期望的宣贯</h3>
<p>目标主要针对的是团队的职责、任务目标； 期望则是上级对团队的预期以及你个人对团队成员的预期</p>
<p>step1: 认清目标与期望</p>
<p>作为团队管理者，这个是自己首先需要明确的点，关注项目背景、团队的组建原因，和上级多交流，总结自己的认知然后和上级领导、横向的团队管理进行交流，确保没有大的理解偏差</p>
<p>以我所经历的这次团队组建来说，上级制定的目标比较明确</p>
<ul>
<li>短期目标： 一个月内可以承接商城的简单需求研发交付</li>
<li>中期目标： 三个月内独立原团队，完成所有研发、运营任务的研发交付</li>
<li>长期目标： 彻底掌握商城，运营商城，改进商城</li>
</ul>
<p>对我们的期望总结两字就是“专业”</p>
<p>step2: 目标同步</p>
<p>当我们搞清楚目标和期望之后，需要在一个相对正式的环境下，给团队内的所有小伙伴进行宣贯，告诉大家我们应该往哪个方向努力，这一阶段请确保每个人都明确知道中短期目标，尤其是短期目标，是否都认可，愿意往这方面去努力</p>
<p>step3: 任务拆解</p>
<p>告诉大家方向之后，作为管理者，我们还需要为他们分工，每个人应该做哪些事情以使得我们可以实现目标</p>
<p>同样以我所处的团队为例进行说明（在新的项目组，我主要负责商城的订单和中团两个团队，下面以订单为例进行说明）</p>
<p>首先圈定团队业务边界</p>
<ul>
<li>订单团队负责下单之后的所有流程</li>
</ul>
<p>针对所有业务，按人头的方式进行粗分</p>
<ul>
<li>下单到采购计划： 1人</li>
<li>订单: 1人</li>
<li>收发货：1人</li>
<li>物流：1人</li>
<li>结算：2人</li>
<li>支付：1人</li>
<li>金服：1人</li>
<li>售后评价：0人 --&gt; 在我们这个商城项目中非常不重要，因此前期不用排人</li>
</ul>
<p>step4: 明确要求</p>
<p>上面是任务分工，如果活只是派下去了，但是没有明确的要求或者时间限制，那么这个任务的执行情况恐怕并不会好，因此一个合理的任务分配，除了告诉对方要干什么之外，还需要明确时间、产出物</p>
<p>如我所属的订单团队，任务职责划分之后，定了几个使用短期的关键节点计划</p>
<ul>
<li>3天：熟悉研发运维等流程规范，应用本地能跑起来进行debug测试</li>
<li>3天：梳理出各自领域内的数据模型，最后建立各主数据的关联关系</li>
<li>1周：实际体验商城的整体流程，梳理各自领域内的主体业务逻辑</li>
<li>1月：完成一次完整的线上迭代交付流程，熟悉常见的线上运维工具</li>
</ul>
<p>step5: 阶段性验收</p>
<p>按时检验任务执行情况，对交付好的不吝称赞，对实现的不好的找一下根因，动态调整交付任务与目标</p>
<h3> 3.2 沟通机制建立</h3>
<p>这一块内容较大，后面放在团队沟通这一块的内容进行展开。 可以简单说一下团队磨合期间我的个人做法</p>
<ul>
<li>方式一： 和组内的小伙伴一起吃饭，吃饭的过程中闲聊，增进关系</li>
<li>方式二： 和组内的小伙伴1v1面对面的交流，聊工作、聊困惑、聊生活</li>
<li>方式三： 组织分享，就分享主题进行沟通讨论</li>
<li>方式四： 前期，重点关注各位组员的任务交付，主动去了解他们的执行情况，是否有问题，及时掌握第一手的信息</li>
</ul>
<h3> 3.3 建立标准的工作流程</h3>
<p>让我们从0到1建立一套标准的工作流程并不太现实，但是抄一份适用的还是比较简单的。 大部分的技术管理，都是积年的老开发，或多或少在不同的公司、团队都待过，将自己既往的工作方式，提炼重整一下，输出一份工作流程还是有可能的。若实在不行，直接将之前工作过程中，认为不错的标准拿过来直接用，也不是不行</p>
<p>在我们制定工作流程时，切记几个注意实现:</p>
<ol>
<li>邀请资深成员参与流程制定的讨论，避免采用少数服从多数的策略。这是基于团队成员的常见梯度，即初级成员通常占据大部分。</li>
<li>标准工作流程的目标是为了统一和规范我们的工作机制。我们不能盲目迷信教条和大厂的光环。如果我们采用了其他大公司的工作流程，我们需要根据我们的实际情况进行调整。</li>
<li>工作流程制定完成后，我们需要在一个正式的场合，向所有团队成员进行宣讲</li>
</ol>
<p>比如我们当时制定的几个流程规范 （后续再给大家进行介绍）</p>
<ul>
<li>git工作流规范</li>
<li>代码规范：java后端编码规范 &amp; 代码检测规范 &amp; 命名规范 &amp; 日志应用规范</li>
<li>数据库与SQL规范</li>
<li>需求自测、提测，发版上线流程规范</li>
</ul>
<h3> 3.4 熟悉工具栈</h3>
<p>这个比较简单，首先身先士卒去了解所有相关的工具栈，然后整理一个图谱和简易的使用手册，然后这个手册的维护与更新交由团队内最后一个入职的小伙伴（即将这个手册顺道做成新人手册，再新人熟悉项目的同时，同时记录自己疑惑以及对应的解答，这样也可以减小后续小伙伴的融入成本）</p>
<p>常见的工具栈包括研发 + 运维两类，如</p>
<ul>
<li>代码管理工具：git/svn</li>
<li>代码仓库：gitlab/gerrit/github/gitee等</li>
<li>项目部署：jenkins/gitlab ci等</li>
<li>代码检测：sonar</li>
<li>日志查看：grafana</li>
<li>全链路： skywalking</li>
<li>监控预警： sentry</li>
<li>Sql审核查询平台： archery/Yearning</li>
<li>api管理平台： yapi/swagger</li>
<li>研发运营管理后台：xxx（通常是自己实现的，共研发、运营使用的工作台）</li>
<li>项目管理软件：jira/禅道</li>
<li>知识库： 钉钉文档/飞书文档/Confluence Wiki等</li>
</ul>
<h3> 3.5 问题解决机制</h3>
<p>关于问题的处理，可以衍生的内容也很多，会再后续的内容中以真实案例进行展开，这里主要说一下再磨合阶段，我们可以做的努力，以及预期达到的效果</p>
<p>首先说我们的预期目标：</p>
<ol>
<li>融洽的团队关系</li>
<li>养成问题及时上报的习惯</li>
</ol>
<p>入我们现在得到共识和执行落地问题处理机制如下：</p>
<p><strong>系统问题</strong></p>
<p>为了确保线上问题能够得到有效且高效的解决，我们制定了以下通用的问题解决流程图。该流程图详细标注了从问题出现到问题解决的全过程，以指导相关人员如何进行问题处理。</p>
<ol>
<li>开放沟通的习惯：在遇到问题时，首先需要养成开放沟通的习惯。一旦发现问题，应立即上报，确保问题能够被及时捕捉并得到关注。同时，需要有人主动跟进，确保问题能够得到及时的处理。</li>
<li>问题追踪文档的建立：根据我们的问题处理模板，我们需要新建一个问题追踪文档，用于记录问题处理过程中的关键节点信息。这包括：
<ul>
<li>问题的提出：记录问题是由谁在何时提出的。</li>
<li>问题的接取：记录问题是由谁在何时接取的，并对问题的影响范围进行评估。</li>
<li>问题原因的发现：记录问题的原因是由谁在何时发现的。</li>
<li>问题的解决：记录问题是由谁在何时解决的。</li>
</ul>
</li>
<li>问题原因的分析：在问题处理过程中，我们需要对问题的原因进行深入分析，找出问题的根本原因，以便能够从根本上解决问题。</li>
<li>复盘：在问题解决后，如果必要，我们需要进行复盘，回顾问题处理的过程，总结经验教训，以便在未来遇到类似问题时，能够更加迅速、有效地进行处理。</li>
</ol>
<p><strong>人际问题</strong></p>
<ol>
<li>作为团队管理，周期性的和组内成员1v1面谈。这种沟通方式不仅有助于了解成员的工作进度和挑战，还能加强彼此之间的信任和理解，从而确保团队的高效运作。</li>
<li>在每个大型需求交付的过程中，明确指定一个负责人进行全程跟进；团队管理则对负责人的推进过程进行兜底（如与外部沟通时的协助，内部推进的站台等）</li>
<li>请注意始终为你的团队成员站台，即该护短的时候别退缩（请知晓，你的团队成员可能除了你可以依靠之外，很难再得到其他的资源，若你不能为你的团队成员解决问题，那么你的权威和威信将难以建立起来）</li>
</ol>
<h3> 3.6 共享机制</h3>
<p>在组织中，若仅对成员施加超出其常规职责范围的额外任务，而未提供相应的激励措施，尤其是当领导层自身不参与其中时，这样的任务往往难以为继。具体而言，团队内部的业务技术分享活动，正属于这类缺乏直接激励的非日常工作内容。</p>
<p>基于我个人在多个团队的经历，具备良好分享文化的团队并不多见；而一个缺乏积极分享文化的团队，通常也会在成员的技术追求和交流氛围方面表现欠缺。 共享机制的搭建，真实尝试去推动之后，发现很难，下面是我的一些尝试过程</p>
<ol>
<li>以身作则，亲自参与团队内部的知识分享，为建立分享文化奠定基础</li>
<li>制订详细的分享计划，并与团队成员进行一对一沟通，鼓励他们参与分享，协助他们确定分享的主题。</li>
<li>建立积极的反馈机制，在分享过程中充当热情的听众，确保主讲人不会因沉默而感到尴尬；每次分享结束后，与主讲人进行交流，肯定其优秀表现，并提出建设性的改进建议。</li>
</ol>
<p>通过这些措施，我努力营造一个支持性的环境中，团队成员能够感受到他们的努力被认可，并从中获得成长和满足感。</p>
<p>比如下面就是我组织团队内成员做的一个面向整个项目团队的分享专栏（最后一个主题是我的🤭）</p>
<figure><img src="/imgs/column/manager/05_分享主题.jpg" alt="分享专题" tabindex="0" loading="lazy"><figcaption>分享专题</figcaption></figure>
<h3> 3.7 建立信任</h3>
<p>这里主要说一下再团队组建初期，快速让团队成员信任自己； 不同的团队管理，采用的方式可能各不一样</p>
<p>我得执行方式则比较粗暴简单</p>
<ol>
<li>身先士卒，参与团队内成员的所有需求交付过程；让自己成为团队内的业务专家</li>
<li>技术方案的把控，参与技术设计过程，展现自己的技术能力</li>
<li>拦截所有的线上运营问题，充当团队成员的第一道门户（尤其是我们这个新组建的团队，从另外一个团队手中接手新的项目，大家对系统都不熟），给团队成员熟悉系统的时间和空间</li>
<li>参与团队成员和产品、测试、外部人员的对接过程，协助他们的推进过程</li>
<li>帮团队成员背锅，能抗事</li>
<li>主动分享（技术 + 业务 + 效率工具 + 运营排查手册）</li>
</ol>
<h3> 3.8 绩效与考核</h3>
<p>这个没什么好说的，一线的团队管理没有这个权限；后续会给大家说一下有效的 “精神激励法”</p>
<h2> 4. 小结</h2>
<p>这一篇主要介绍的是团队磨合的相关内容，对于一个刚开始带团队的技术管理而言，可能对这块不知道怎么做，一如几年前只知到莽的我。。。</p>
<p>这里总结了一下个人的实际经验，介绍了磨合什么，怎么去做的一些个人看法； 当然每个团队的实际情况不一样，并不存在通用的万能公式。总的来说，这个磨合过程，主要就是实现大家的工作同频、拉齐认知，减少团队内的龃龉；接下来一篇，我会给大家介绍一下这个磨合过程中的输出物：《如何做项目的持续交接（项目流程规范制定与宣讲）》</p>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/column/manager/05_团队磨合思维导图.png" type="image/png"/>
    </item>
    <item>
      <title>06.持续交付</title>
      <link>https://liuyueyi.github.io/tutorial/column/tech/manager/06.%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%8C%81%E7%BB%AD%E4%BA%A4%E6%8E%A5.html</link>
      <guid>https://liuyueyi.github.io/tutorial/column/tech/manager/06.%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%8C%81%E7%BB%AD%E4%BA%A4%E6%8E%A5.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">06.持续交付</source>
      <description>再团队搭建之后，我们首先面临的问题就是如何统一大家的工作模式和日常习惯。 由于每个成员的履历背景、事务认知的差异性以及既往工作经验对当前项目的适配程度高低，都将影响我们的对项目持续交付流程的制定。再正式开始之前，借助哲学的一句名言 “一切事物总是在不断发展变化之中”，因此不要妄想一蹴而就的打造一个完美的工作流程，选择一个学习成本最低且适用于当前的项目的演进，就不算是失败的决策 接下来我将以下面几块内容进行阐述 持续交付的内容拆解，基于业界理论or最佳实践模式作为输入支撑 以一线程序员视角解读交付过程 以技术管理视角接的交付过程 结合当前项目实际场景，选择适用的持续交付策略</description>
      <category>技术管理</category>
      <pubDate>Tue, 12 Mar 2024 09:27:46 GMT</pubDate>
      <content:encoded><![CDATA[<p>再团队搭建之后，我们首先面临的问题就是如何统一大家的工作模式和日常习惯。 由于每个成员的履历背景、事务认知的差异性以及既往工作经验对当前项目的适配程度高低，都将影响我们的对项目持续交付流程的制定。再正式开始之前，借助哲学的一句名言 “一切事物总是在不断发展变化之中”，因此不要妄想一蹴而就的打造一个完美的工作流程，选择一个学习成本最低且适用于当前的项目的演进，就不算是失败的决策</p>
<p>接下来我将以下面几块内容进行阐述</p>
<ol>
<li>持续交付的内容拆解，基于业界理论or最佳实践模式作为输入支撑</li>
<li>以一线程序员视角解读交付过程</li>
<li>以技术管理视角接的交付过程</li>
<li>结合当前项目实际场景，选择适用的持续交付策略</li>
</ol>
<h2> 1. 什么是持续交付</h2>
<blockquote>
<p>持续集成，持续交付，持续部署属于DevOps中的相关概念，我们这里引入“持续交付”来介绍如何搭建团队的工作流程</p>
</blockquote>
<p>首先我们简单的解读一下这里的“持续交付”的概念</p>
<p>持续交付（Continuous delivery）指的是，频繁地将软件的新版本，交付给质量团队或者用户，以供评审。如果评审通过，代码就进入生产阶段。</p>
<p>再简单一点来说，也就是作为研发人员，从产品经理那里获取到原始需求之后，从研发开始到上线之后的回归，再这一周期内，我们应该遵循什么样的规范/规则来执行</p>
<h3> 1.1 交付流程关键节点</h3>
<figure><img src="/imgs/column/manager/06_研发过程关键节点.png" alt="研发过程关键节点" tabindex="0" loading="lazy"><figcaption>研发过程关键节点</figcaption></figure>
<p>上图是一个通用的研发过程关键节点，针对这些重要的节点，抛出一些疑问事项</p>
<ol>
<li>需求串讲</li>
</ol>
<ul>
<li>即产品的需求交底过程</li>
<li>如何进行？ 目的是什么？</li>
</ul>
<ol start="2">
<li>反串讲&amp;技术方案评审</li>
</ol>
<ul>
<li>研发理解需求之后，主导的实现思路/技术方案的串讲</li>
<li>是否一定需要？ 如何进行这个过程？ 怎么评判它的执行效果</li>
</ul>
<ol start="3">
<li>研发</li>
</ol>
<ul>
<li>研发过程走什么样的开发模式， 瀑布、迭代、敏捷？</li>
<li>研发进度如何把控，如何识别风险事项？</li>
</ul>
<ol start="4">
<li>联调自测</li>
</ol>
<ul>
<li>前后端如何联调，边开发边联调，还是约定时间专项联调？</li>
<li>自测范围包含哪些，如何做自测?</li>
</ul>
<ol start="5">
<li>测试上线</li>
</ol>
<ul>
<li>测试用例怎么维护，如何评判上线标准？</li>
</ul>
<h3> 1.2 过程规范</h3>
<p>基于上面的过程节点，我们来看一下是否</p>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/column/manager/06_研发过程关键节点.png" type="image/png"/>
    </item>
    <item>
      <title>一灰灰的技术管理之路</title>
      <link>https://liuyueyi.github.io/tutorial/column/tech/manager/</link>
      <guid>https://liuyueyi.github.io/tutorial/column/tech/manager/</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">一灰灰的技术管理之路</source>
      <description>技术管理之路 序 01. 契机 02. 准备工作 03. 入职新项目</description>
      <pubDate>Mon, 29 Jul 2024 08:58:55 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 技术管理之路</h2>
<p><strong>序</strong></p>
<ul class="task-list-container">
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-0" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-0"> <a href="./01.%E5%BA%8F%20%E8%BD%AC%E7%AE%A1%E7%90%86%E7%9A%84%E5%A5%91%E6%9C%BA">01. 契机</a></label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-1" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-1"> <a href="./02.%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C">02. 准备工作</a></label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-2" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-2"> <a href="./03.%E5%85%A5%E8%81%8C%E6%96%B0%E9%A1%B9%E7%9B%AE">03. 入职新项目</a></label></li>
</ul>
<p><strong>团队搭建</strong></p>
<ul class="task-list-container">
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-3" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-3"> <a href="./04.%E5%9B%A2%E9%98%9F%E7%BB%84%E5%BB%BA">04. 招人/带人</a></label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-4" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-4"> <a href="./05.%E5%9B%A2%E9%98%9F%E7%A3%A8%E5%90%88">05. 新项目交接，团队磨合</a></label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-5" disabled="disabled"><label class="task-list-item-label" for="task-item-5"> <a href="./06.%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%8C%81%E7%BB%AD%E4%BA%A4%E6%8E%A5">06. 如何做项目的持续交接（项目流程规范制定与宣讲）</a></label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-6" disabled="disabled"><label class="task-list-item-label" for="task-item-6"> <a href="">07. 建立信任：攻坚、身先士卒</a></label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-7" disabled="disabled"><label class="task-list-item-label" for="task-item-7"> <a href="">08. 进入正轨</a></label></li>
</ul>
<p><strong>抗压与异常的应对</strong></p>
<ul class="task-list-container">
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-8" disabled="disabled"><label class="task-list-item-label" for="task-item-8"> <a href="">09. 任务过重，压力分摊</a></label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-9" disabled="disabled"><label class="task-list-item-label" for="task-item-9"> <a href="">10. 突发故障及应对方案：超付</a></label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-10" disabled="disabled"><label class="task-list-item-label" for="task-item-10"> <a href="">11. 中间序曲：转正定级</a></label></li>
</ul>
<p><strong>团队凝聚力</strong></p>
<ul class="task-list-container">
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-11" disabled="disabled"><label class="task-list-item-label" for="task-item-11"> <a href="">12. 营造团队氛围</a></label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-12" disabled="disabled"><label class="task-list-item-label" for="task-item-12"> <a href="">13. 任务分配：能者多劳？</a></label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-13" disabled="disabled"><label class="task-list-item-label" for="task-item-13"> <a href="">14. 授人以渔-软福利的宣扬：项目推进、方案设计、代码评审</a></label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-14" disabled="disabled"><label class="task-list-item-label" for="task-item-14"> <a href="">15. 人员变动：怎么看离职</a></label></li>
</ul>
<p><strong>管理沟通</strong></p>
<ul class="task-list-container">
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-15" disabled="disabled"><label class="task-list-item-label" for="task-item-15"> <a href="">16. 向上沟通与成绩汇报</a></label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-16" disabled="disabled"><label class="task-list-item-label" for="task-item-16"> <a href="">17. 横向沟通与项目协同推进</a></label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-17" disabled="disabled"><label class="task-list-item-label" for="task-item-17"> <a href="">18. 向下沟通：1to1</a></label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-18" disabled="disabled"><label class="task-list-item-label" for="task-item-18"> <a href="">19. 外部沟通/与甲方沟通</a></label></li>
</ul>
<p><strong>小结</strong></p>
<ul class="task-list-container">
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-19" disabled="disabled"><label class="task-list-item-label" for="task-item-19"> <a href="">20. 小结与展望</a></label></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>1.容器刷新前回调ApplicationContextInitializer</title>
      <link>https://liuyueyi.github.io/tutorial/spring/extend/basic/220927-Spring%E6%89%A9%E5%B1%95%E4%B9%8B%E5%AE%B9%E5%99%A8%E5%88%B7%E6%96%B0%E5%89%8D%E5%9B%9E%E8%B0%83ApplicationContextInitializer.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/extend/basic/220927-Spring%E6%89%A9%E5%B1%95%E4%B9%8B%E5%AE%B9%E5%99%A8%E5%88%B7%E6%96%B0%E5%89%8D%E5%9B%9E%E8%B0%83ApplicationContextInitializer.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">1.容器刷新前回调ApplicationContextInitializer</source>
      <description>本文将作为Spring系列教程中源码版块的第一篇，整个源码系列将分为两部分进行介绍；单纯的源码解析，大概率是个吃力没人看的事情，因此我们将结合源码解析，一个是学习下别人的优秀设计，一个是站在源码的角度看一下我们除了日常的CURD之外，还可以干些啥</description>
      <category>Spring源码</category>
      <category>扩展点</category>
      <pubDate>Tue, 27 Sep 2022 19:26:11 GMT</pubDate>
      <content:encoded><![CDATA[<p>本文将作为Spring系列教程中源码版块的第一篇，整个源码系列将分为两部分进行介绍；单纯的源码解析，大概率是个吃力没人看的事情，因此我们将结合源码解析，一个是学习下别人的优秀设计，一个是站在源码的角度看一下我们除了日常的CURD之外，还可以干些啥</p>
<!-- more -->
<p>在Spring的启动过程中，一系列的操作步骤中，提供了很多的扩展点，供我们来增强；简单来说就是提供了很多的钩子，这样当我们在某个节点执行前后，想干点其他的事情时，可以很简单的支持；本文介绍的<code>ApplicationContextInitializer</code>，spring容器在刷新之前会回调这个接口，从而实现在spring容器未初始化前，干一些用户希望做的事情</p>
<h2> I. 项目准备</h2>
<p>本文创建的实例工程采用<code>SpringBoot 2.2.1.RELEASE</code> + <code>maven 3.5.3</code> + <code>idea</code>进行开发</p>
<p>具体的SpringBoot项目工程创建就不赘述了，核心的pom文件，无需额外的依赖</p>
<p>配置文件 <code>application.yml</code>， 也没有什么特殊的配置</p>
<p>源码工程参考文末的源码</p>
<h2> II. 容器刷新前扩展点实例</h2>
<h3> 1. 自定义ApplicationContextInitializer</h3>
<p>当我们希望实现一个自定义的上下文初始化时，非常简单，实现上面这个接口就行了，如</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 扩展点注册</h3>
<p>上面自定义一个扩展点，如何使它生效呢？</p>
<p>官方提供了三种方式，如在启动时，直接进行注册: <code>springApplication.addInitializers(new ApplicationContextInitializer01());</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当我们的扩展点是放在一个jar包中对外提供时，使用上面的启动注册方式显然是不可行的，此时更推荐的做法就是通过Spring的SPI机制进行注册</p>
<p>在资源目录下的<code>META-INF/spring.factories</code>文件中进行注册</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>说明</strong></p>
<ul>
<li>上面SPI的机制非常推荐大家使用，在之前的文章中，<code>AutoConfiguration</code>的注册通常也是使用这种方式</li>
</ul>
<p>除了上面的两种注册方式之外，另外还有一个配置文件的方式，在配置文件<code>application.properties</code> 或 <code>application.yml</code>中，如下配置</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>启动测试</strong></p>
<p>上面三种注册方式，我们实现三个自定义的扩展点，然后启动之后，看一下实际输出</p>
<figure><img src="/imgs/220927/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>上面的输出，可以简单的得出一个结论，不同注册方式的优先级（为了更合理的验证下面的观点，推荐大家修改下上面三个自定义扩展点名，排除掉是因为扩展名导致的排序问题）</p>
<ul>
<li>配置文件注册 &gt; SPI注册 &gt; 启动时注册</li>
</ul>
<h3> 3. 执行顺序指定</h3>
<p>对于自定义的扩展点实现，当存在顺序关系时，我们可以通过<code>@Order</code>注解来实现， 如当上面的三个扩展点都是通过启动方式注册时</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出实例如下</p>
<figure><img src="/imgs/220927/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p><strong>接着重点来了</strong></p>
<ul>
<li>若上面的三个自定义实现，不是相同的注册方式，如将03采用配置文件方式进行注册，那么01, 02 依然是启动注册</li>
<li>则顺序是 03 &gt; 02 &gt; 01</li>
<li>即 <code>@Order</code>注解修饰的顺序，并不能打破  <strong>配置文件 &gt; SPI &gt; 启动方式注册的顺序</strong></li>
</ul>
<p>关于自定义实现类的执行顺序，规则如下</p>
<ul>
<li>配置文件 &gt; SPI &gt; 启动方式</li>
<li>相同的注册方式，可以通过 <code>@Order</code> 注解进行修饰，值越小则优先级越高</li>
</ul>
<h3> 4. 使用场景示例</h3>
<p>最后我们再来看一下，这个扩展点到底有什么用，我们再什么场景下会用到这个呢？</p>
<p>一个经常可以看到的应用场景如通过它来指定需要激活的配置文件</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但是一般也很少见到有人这么干，因为直接使用配置参数就行了，那么有场景需要这么做么？</p>
<p>答案当然是有的，比如现在广为流行的docker容器部署，当我们希望每次都是打同一个镜像，然后在实际运行的时候，根据不同的环境来决定当前镜像到底启用哪些配置文件，这时就有用了</p>
<p>比如我们通过容器的环境参数 <code>app.env</code> 来获取当前运行的环境，如果是prod，则激活<code>application-prod.yml</code>; 如果是test，则激活<code>application-test.yml</code></p>
<p>那么此时可以这么干</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 5. 小结</h3>
<p>本文作为扩展点的第一篇，通过实现<code>ApplicationContextInitializer</code>接口，从而达到在spring容器刷新之前做某些事情的目的</p>
<p>通常自定义的ApplicationContextInitializer有三种注册方式，按照优先级如下</p>
<ul>
<li>配置文件 &gt; SPI方式 &gt; 启动方式注册</li>
<li>相同的注册方式中，可以使用<code>@Order</code>注解来指定优先级，值越小优先级越高</li>
</ul>
<p>最后还给出了一个可以应用得实例场景，即如何实现一个镜像在不同的环境中启动运行</p>
<p>下一个扩展点我们将介绍如何通过<code>BeanDefinitionRegistryPostProcessor</code>来实现非Spring生态的Bean加载使用</p>
<h2> III. 不能错过的源码和相关知识点</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/220927/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>2.自定义bean注册扩展机制BeanDefinitionRegistryPostProcessor</title>
      <link>https://liuyueyi.github.io/tutorial/spring/extend/basic/221026-Spring%E6%89%A9%E5%B1%95%E7%82%B9%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89bean%E6%B3%A8%E5%86%8C.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/extend/basic/221026-Spring%E6%89%A9%E5%B1%95%E7%82%B9%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89bean%E6%B3%A8%E5%86%8C.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">2.自定义bean注册扩展机制BeanDefinitionRegistryPostProcessor</source>
      <description>接着上一篇容器刷新前的扩展点，我们继续往下走；接下来来到的就是bean的定义扩展处，它是在Spring容器刷新之后，应用的bean定义加载完成、实例化之前提供的切入点，主要是通过实现BeanDefinitionRegistryPostProcessor接口的两个方法，来实现自定义的bean定义，或者对已注册的bean进行修改or代理替换 本文将带来的知识点如下： BeanDefinitionRegistryPostProcessor： 基本使用姿势 postProcessBeanDefinitionRegistry 方法 优先于 postProcessBeanFactory 方法执行 实现自定义的bean注册，实现对容器的bean定义进行修改</description>
      <category>Spring源码</category>
      <category>扩展点</category>
      <pubDate>Wed, 26 Oct 2022 14:45:41 GMT</pubDate>
      <content:encoded><![CDATA[<p>接着上一篇容器刷新前的扩展点，我们继续往下走；接下来来到的就是bean的定义扩展处，它是在Spring容器刷新之后，应用的bean定义加载完成、实例化之前提供的切入点，主要是通过实现<code>BeanDefinitionRegistryPostProcessor</code>接口的两个方法，来实现自定义的bean定义，或者对已注册的bean进行修改or代理替换</p>
<p>本文将带来的知识点如下：</p>
<ul>
<li>BeanDefinitionRegistryPostProcessor： 基本使用姿势</li>
<li><code>postProcessBeanDefinitionRegistry</code> 方法 优先于  <code>postProcessBeanFactory</code> 方法执行</li>
<li>实现自定义的bean注册，实现对容器的bean定义进行修改</li>
</ul>
<!-- more -->
<h2> I. 项目准备</h2>
<p>本文创建的实例工程采用<code>SpringBoot 2.2.1.RELEASE</code> + <code>maven 3.5.3</code> + <code>idea</code>进行开发</p>
<p>具体的SpringBoot项目工程创建就不赘述了，核心的pom文件，无需额外的依赖； 配置文件 <code>application.yml</code>， 也没有什么特殊的配置</p>
<p><strong>说明</strong></p>
<ul>
<li>源码工程参考文末的源码</li>
<li>虽然本文是基于 <code>2.2.1.RELEASE</code> 版本进行实测；实际上这些基础的扩展点，在更高的版本中表现也不会有太大的变动，基本上可以无修改复现</li>
</ul>
<h2> II. 自定义bean注册</h2>
<p>有关注过博主一灰灰的朋友，应该在我之前的文章中可以翻到bean的动态注册的内容，其中其实也介绍到通过<code>BeanDefinitionRegistryPostProcessor</code>来实现bean的动态注册，有兴趣的小伙伴可以翻一下，链接如下</p>
<blockquote>
<ul>
<li><a href="https://spring.hhui.top/spring-blog/2018/10/13/181013-SpringBoot%E5%9F%BA%E7%A1%80%E7%AF%87Bean%E4%B9%8B%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8C/" target="_blank" rel="noopener noreferrer">【基础系列】Bean之动态注册 | 一灰灰Blog</a></li>
</ul>
</blockquote>
<p>接下来我们开始进入正题</p>
<h3> 1. 自定义bean注册</h3>
<p>现在我们定义一个普通的bean对象，也定义了几个常见的bean初始化之后的回调方法，顺带验证两个知识点</p>
<ul>
<li>自定义注册的bean是否表现和普通的bean一致</li>
<li>初始化后的方法执行的顺序</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>再定义一个bean，构造方法依赖其他的bean</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来我们再看一下这两个bean如何进行注册</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>bean的注册从上面的代码来看比较简单，先看DemoBean的注册</p>
<p><strong>方法： <code>postProcessBeanDefinitionRegistry</code></strong></p>
<p>在这个方法中进行简单的bean注册，除了上面这个稍显复杂的注册方式之外，也可以使用更简单的策略，如下，省略掉<code>BeanDefinitionBuilder.genericBeanDefinition</code>第二个参数</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个方法内的bean注册，更适用于简单的bean对象注册，如当其构造方法依赖其他的bean时，放在这个方法中好像没辙，此时则放在第二个方法中就更合适了</p>
<p><strong>方法： <code>postProcessBeanFactory</code></strong></p>
<p>这个方法的参数是BeanFactory，可以通过它获取其他的bean对象，因此适用于DemoBeanWrapper的注册了，当然除了上面的使用姿势之外，也可以如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2.bean注册知识点</h3>
<p>单独看上面的代码可能对知识点理解不够直观清晰，那么我们就进行知识点归纳一下</p>
<p><strong>bean注册方式</strong></p>
<p>如何生成Bean的定义 <code>BeanDefinition</code> ?</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>两个方法的选择</strong></p>
<ul>
<li><code>postProcessBeanDefinitionRegistry</code> 方法执行先于 <code>postProcessBeanFactory</code></li>
<li><code>postProcessBeanDefinitionRegistry</code> 在bean实例化之前触发，可用于注册简单的自定义bean对象</li>
<li><code>postProcessBeanFactory</code>: 若bean的定义中需要依赖其他的bean对象，则放在这个方法内实现，通过BeanFactory参数获取其他bean</li>
</ul>
<h3> 3. bean定义扩展</h3>
<p>文章开头介绍了除了自定义bean之外，还可以做一些其他的操作，如针对现有的bean定义进行修改，下面给一个基础的demo，针对一个已有的bean，设置它的init方法</p>
<p>新增一个普通的bean对象</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后我们通过修改bean注册，来指定bean加载完之后，执行init方法，在前面的<code>AutoBeanDefinitionRegistryPostProcessor</code>中进行扩展</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后我们将整个项目执行以下，看下会输出些啥</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从上面的输出也可以看出，我们的几个自定义bean都被正常的加载、注入，依赖使用也没有什么问题；而且从日志输出还可以看出bean初始化后的触发方法，也有先后顺序</p>
<ul>
<li><code>@PostConstruct</code> &gt; <code>InitializingBean#afterPropertiesSet</code> &gt;  <code>init-method</code> (这个可以理解为xml定义bean中的初始化方法, @Bean注解中的initMethod)</li>
</ul>
<h3> 4. 小结</h3>
<p>最后进入大家喜闻乐见的知识点汇总环节，本文中主要介绍的是bean定义加载之后、实例化之前的扩展点<code>BeanDefinitionRegistryPostProcessor</code></p>
<h4> 4.1 知识点一：核心方法说明</h4>
<p>通过它，我们可以实现自定义的bean注册，也可以实现对现有的bean定义进行扩展修改；有两个方法</p>
<p><strong>postProcessBeanDefinitionRegistry</strong></p>
<ul>
<li>执行顺序在下面的方法之前，通常是在bean实例化之前被触发</li>
<li>适用于通用的bean注册定义</li>
</ul>
<p><strong>postProcessBeanFactory</strong></p>
<ul>
<li>其参数为BeanFactory，因此可以通过它获取Spring容器中的其他bean对象</li>
</ul>
<h4> 4.2 知识点二：bean注册</h4>
<p><strong>bean注册方式</strong></p>
<p>如何生成Bean的定义 <code>BeanDefinition</code> ?</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 4.3 知识点三：使用场景</h4>
<p>看完本文之后，勤于思考的小伙伴可能就会想，这个东西到底有啥用，有真实的应用场景么？</p>
<p><strong>自定义bean注册实例场景</strong></p>
<p>这个应用场景就非常的典型了，用过mybatis的小伙伴都知道，我们会定义一个Mapper接口，用于与对应的xml文件进行映射，那么这些mapper接口是怎么注册到Spring容器的呢？</p>
<ul>
<li>核心实现 <code>org.mybatis.spring.mapper.MapperScannerConfigurer</code></li>
<li>借助<code>BeanDefinitionRegistryPostProcessor</code>与<code>ClassPathBeanDefinitionScanner</code>来实现扫描相关的类，并注册bean</li>
</ul>
<p><strong>bean定义修改实例场景</strong></p>
<p>对于已有的bean定义进行修改，同样也有一个应用场景，在SpringCloud中，有个<code>RefreshAutoConfiguration#RefreshScopeBeanDefinitionEnhancer</code></p>
<p>它会捞出<code>HikariDataSource</code>数据源bean对象，添加<code>RefreshScope</code>的能力增强，支持配置文件的动态加载</p>
<p>从而实现数据源配置的热加载更新（不发版，直接改数据库连接池，是不是很方便？）</p>
<h4> 4.4 知识点四：bean初始化后执行方法先后顺序</h4>
<p>我们知道在bean创建之后执行某些方法有多种策略，那么不同的方式先后顺序是怎样的呢？</p>
<p>bean创建到销毁的先后执行顺序如下</p>
<ul>
<li>构造方法</li>
<li>@PostConstruct修饰的方法</li>
<li>InitializingBean接口的实现方法</li>
<li>xml/@Bean中定义的initMethod</li>
<li>@PreDestroy bean销毁前的执行方法</li>
</ul>
<h4> 其他</h4>
<p>本文为Spring扩展点系列中的第二篇，接下来的扩展知识点同样是bean定义之后，实例化之前的<code>BeanFactoryPostProcessor</code>，那么这两个究竟又有什么区别呢？ 应用场景又有什么区别呢？我是一灰灰，欢迎关注我的Spring专栏，咱们下文见</p>
<ul>
<li><a href="https://hhui.top/spring-extention/" target="_blank" rel="noopener noreferrer">一灰灰的Spring专栏</a></li>
</ul>
<h2> III. 不能错过的源码和相关知识点</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-extention/101-bean-definition" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-extention/101-bean-definition</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>Spring扩展点专栏</title>
      <link>https://liuyueyi.github.io/tutorial/spring/extend/basic/</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/extend/basic/</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">Spring扩展点专栏</source>
      <pubDate>Mon, 29 Jul 2024 08:58:55 GMT</pubDate>
    </item>
    <item>
      <title>分布式设计模式综述</title>
      <link>https://liuyueyi.github.io/tutorial/column/arch/distribute/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/01.%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%BB%BC%E8%BF%B0.html</link>
      <guid>https://liuyueyi.github.io/tutorial/column/arch/distribute/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/01.%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%BB%BC%E8%BF%B0.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">分布式设计模式综述</source>
      <description>天天说分布式分布式，那么我们是否知道什么是分布式，分布式会遇到什么问题，有哪些理论支撑，有哪些经典的应对方案，业界是如何设计并保证分布式系统的高可用呢？ 1.架构设计 这一节将从一些经典的开源系统架构设计出发，来看一下，如何设计一个高质量的分布式系统； 而一般的设计出发点，无外乎 冗余：简单理解为找个备胎，现任挂掉之后，备胎顶上 拆分：不能让一个人承担所有的重任，拆分下，每个人负担一部分，压力均摊 1.1 主备架构 给现有的服务搭建一个备用的服务，两者功能完全一致，区别在于平时只有主应用对外提供服务能力；而备应用则只需要保证与主应用能力一致，随时待机即可，并不用对外提供服务；当主应用出现故障之后，将备应用切换为主应用，原主应用下线；迅速的主备切换可以有效的缩短故障时间</description>
      <category>分布式</category>
      <category>设计模式</category>
      <pubDate>Fri, 08 Jul 2022 19:27:54 GMT</pubDate>
      <content:encoded><![CDATA[<p>天天说分布式分布式，那么我们是否知道什么是分布式，分布式会遇到什么问题，有哪些理论支撑，有哪些经典的应对方案，业界是如何设计并保证分布式系统的高可用呢？</p>
<h2> 1.架构设计</h2>
<p>这一节将从一些经典的开源系统架构设计出发，来看一下，如何设计一个高质量的分布式系统；</p>
<p>而一般的设计出发点，无外乎</p>
<ul>
<li>冗余：简单理解为找个备胎，现任挂掉之后，备胎顶上</li>
<li>拆分：不能让一个人承担所有的重任，拆分下，每个人负担一部分，压力均摊</li>
</ul>
<h3> 1.1 主备架构</h3>
<p>给现有的服务搭建一个备用的服务，两者功能完全一致，区别在于平时只有主应用对外提供服务能力；而备应用则只需要保证与主应用能力一致，随时待机即可，并不用对外提供服务；当主应用出现故障之后，将备应用切换为主应用，原主应用下线；迅速的主备切换可以有效的缩短故障时间</p>
<p>基于上面的描述，主备架构特点比较清晰</p>
<ul>
<li>采用冗余的方案，加一台备用服务</li>
<li>缺点就是资源浪费</li>
</ul>
<p>其次就是这个架构模型最需要考虑的则是如何实现主备切换？</p>
<ul>
<li>人工</li>
<li>VIP(虚拟ip) + keepalived 机制</li>
</ul>
<h3> 1.2 主从架构</h3>
<p>主从一般又叫做读写分离，主提供读写能力，而从则只提供读能力</p>
<p>鉴于当下的互联网应用，绝大多数都是读多写少的场景；读更容易成为性能瓶颈，所以采用读写分离，可以有效的提高整个集群的响应能力</p>
<p>主从架构可以区分为：一主多从 + 一主一从再多从，以mysql的主从架构模型为例进行说明</p>
<figure><img src="/imgs/column/distribute/220708/mysql03.jpg" alt="MySql主从" tabindex="0" loading="lazy"><figcaption>MySql主从</figcaption></figure>
<p>主从模式的主要特点在于</p>
<ul>
<li>添加从，源头依然是数据冗余的思想</li>
<li>读写分离：主负责读写，从只负责读，可以视为负载均衡策略</li>
<li>从需要向主同步数据，所若有的从都同步与主，对主的压力依然可能很大；所以就有了主从从的模式</li>
</ul>
<p>关键问题则在于</p>
<ul>
<li>主从延迟</li>
<li>主的写瓶颈</li>
<li>主挂之后如何选主</li>
</ul>
<h3> 1.3 多主多从架构</h3>
<p>一主多从面临单主节点的瓶颈问题，那就考虑多主多从的策略，同样是主负责提供读写，从提供读；</p>
<p>但是这里有一个核心点在于多主之间的数据同步，如何保证数据的一致性是这个架构模型的重点</p>
<p>如MySql的双主双从可以说是一个典型的应用场景，在实际使用的时候除了上面的一致性之外，还需要考虑主键id冲突的问题</p>
<h3> 1.4 普通集群模式</h3>
<p>无主节点，集群中所有的应用职能对等，没有主次之分（当下绝大多数的业务服务都属于这种），一个请求可以被集群中任意一个服务响应；</p>
<p>这种也可以叫做去中心化的设计模式，如redis的集群模式，eureka注册中心，以可用性为首要目标</p>
<p>对于普通集群模式而言，重点需要考虑的点在于</p>
<ul>
<li>资源竞争：如何确保一个资源在同一时刻只能被一个业务操作
<ul>
<li>如现在同时来了申请退款和货物出库的请求，如果不对这个订单进行加锁，两个请求同时响应，将会导致发货又退款了，导致财货两失</li>
</ul>
</li>
<li>数据一致性：如何确保所有的实例数据都是一致的，或者最终是一致的
<ul>
<li>如应用服务使用jvm缓存，那么如何确保所有实例的jvm缓存一致？</li>
<li>如Eureka的分区导致不同的分区的注册信息表不一致</li>
</ul>
</li>
</ul>
<h3> 1.5 数据分片架构</h3>
<blockquote>
<p>这个分片模型的描述可能并不准确，大家看的时候重点理解一下这个思想</p>
</blockquote>
<p>前面几个的架构中，采用的是数据冗余的方式，即所有的实例都有一个全量的数据，而这里的数据分片，则从数据拆分的思路来处理，将全量的数据，通过一定规则拆分到多个系统中，每个系统包含部分的数据，减小单个节点的压力，主要用于解决数据量大的场景</p>
<p>比如redis的集群方式，通过hash槽的方式进行分区</p>
<p>如es的索引分片存储</p>
<h3> 1.6 一灰灰的小结</h3>
<p>这一节主要从架构设计层面对当前的分布式系统所采用的方案进行了一个简单的归类与小结，并不一定全面，欢迎各位大佬留言指正</p>
<p>基于冗余的思想：</p>
<ul>
<li>主备</li>
<li>主从</li>
<li>多主多从</li>
<li>无中心集群</li>
</ul>
<p>基于拆分的思想：</p>
<ul>
<li>数据分片</li>
</ul>
<blockquote>
<p>对于拆分这一块，我们常说的分库分表也体现的是这一思想</p>
</blockquote>
<h2> 2.理论基础</h2>
<p>这一小节将介绍分布式系统中的经典理论，如广为流程的CAP/BASE理论，一致性理论基础paxios,raft，信息交换的Gossip协议，两阶段、三阶段等</p>
<p>本节主要内容参考自</p>
<ul>
<li><a href="https://cloud.tencent.com/developer/article/1662426" target="_blank" rel="noopener noreferrer">一致性算法-Gossip协议详解 - 腾讯云开发者社区-腾讯云</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/41228196" target="_blank" rel="noopener noreferrer">P2P 网络核心技术：Gossip 协议 - 知乎</a></li>
<li><a href="https://blog.51cto.com/u_15060467/2678779" target="_blank" rel="noopener noreferrer">从Paxos到Raft，分布式一致性算法解析_mb5fdb0a87e2fa1的技术博客_51CTO博客</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/338628717" target="_blank" rel="noopener noreferrer">【理论篇】浅析分布式中的 CAP、BASE、2PC、3PC、Paxos、Raft、ZAB - 知乎</a></li>
</ul>
<h3> 2.1 CAP定理</h3>
<p>CAP 定理指出，分布式系统 <strong>不可能</strong> 同时提供下面三个要求：</p>
<ul>
<li>Consistency：一致性
<ul>
<li>操作更新完成并返回客户端之后，所有节点数据完全一致</li>
</ul>
</li>
<li>Availability：可用性
<ul>
<li>服务一直可用</li>
</ul>
</li>
<li>Partition tolerance：分区容错性
<ul>
<li>分布式系统在遇到某节点或网络分区故障的时候，仍然能够对外提供满足<strong>一致性</strong>和<strong>可用性</strong>的服务</li>
</ul>
</li>
</ul>
<p>通常来讲P很难不保证，当服务部署到多台实例上时，节点异常、网络故障属于常态，根据不同业务场景进行选择</p>
<p>对于服务有限的应用而言，首选AP，保证高可用，即使部分机器异常，也不会导致整个服务不可用；如绝大多数的前台应用都是这种</p>
<p>对于数据一致性要求高的场景，如涉及到钱的支付结算，CP可能更重要了</p>
<p>对于CAP的三种组合说明如下</p>
<table>
<thead>
<tr>
<th>选择</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>CA</td>
<td>放弃分区容错性，加强一致性和可用性，其实就是传统的单机场景</td>
</tr>
<tr>
<td>AP</td>
<td>放弃一致性（这里说的一致性是强一致性），追求分区容错性和可用性，这是很多分布式系统设计时的选择，例如很多NoSQL系统就是如此</td>
</tr>
<tr>
<td>CP</td>
<td>放弃可用性，追求一致性和分区容错性，基本不会选择，网络问题会直接让整个系统不可用</td>
</tr>
</tbody>
</table>
<h3> 2.2 BASE理论</h3>
<p>base理论作为cap的延伸，其核心特点在于放弃强一致性，追求最终一致性</p>
<ul>
<li>Basically Available: 基本可用
<ul>
<li>指分布式系统在出现故障的时候，允许损失部分可用性，即保证核心可用</li>
<li>如大促时降级策略</li>
</ul>
</li>
<li>Soft State：软状态
<ul>
<li>允许系统存在中间状态，而该中间状态不会影响系统整体可用性</li>
<li>MySql异步方式的主从同步，可能导致的主从数据不一致</li>
</ul>
</li>
<li>Eventual Consistency：最终一致性
<ul>
<li>最终一致性是指系统中的所有数据副本经过一定时间后，最终能够达到一致的状态</li>
</ul>
</li>
</ul>
<p>基于上面的描述，可以看到BASE理论适用于大型高可用可扩展的分布式系统</p>
<p>注意其不同于ACID的强一致性模型，而是通过牺牲强一致性 来获得可用性，并允许数据在一段时间内是不一致的，但最终达到一致状态</p>
<h3> 2.3 PACELEC 定理</h3>
<blockquote>
<p>这个真没听说过，以下内容来自:</p>
<ul>
<li><a href="https://medium.com/@nishantparmar/distributed-system-design-patterns-2d20908fecfc" target="_blank" rel="noopener noreferrer">Distributed System Design Patterns | by Nishant | Medium</a></li>
</ul>
</blockquote>
<ul>
<li>如果有一个分区（'P'），分布式系统可以在可用性和一致性（即'A'和'C'）之间进行权衡;</li>
<li>否则（'E'），当系统在没有分区的情况下正常运行时，系统可以在延迟（'L'）和一致性（'C'）之间进行权衡。</li>
</ul>
<figure><img src="/imgs/column/distribute/220708/peace.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>定理（PAC）的第一部分与CAP定理相同，ELC是扩展。整个论点假设我们通过复制来保持高可用性。因此，当失败时，CAP定理占上风。但如果没有，我们仍然必须考虑复制系统的一致性和延迟之间的权衡。</p>
<h3> 2.4 Paxos共识算法</h3>
<blockquote>
<p>Paxos算法解决的问题是分布式共识性问题，即一个分布式系统中的各个进程如何就某个值（决议）通过共识达成一致</p>
</blockquote>
<p>基于上面这个描述，可以看出它非常适用于选举；其工作流程</p>
<ul>
<li>一个或多个提议进程 (Proposer) 可以发起提案 (Proposal)，</li>
<li>Paxos算法使所有提案中的某一个提案，在所有进程中达成一致。 系统中的多数派同时认可该提案，即达成了一致</li>
</ul>
<p>角色划分:</p>
<ul>
<li>Proposer: 提出提案Proposal，包含编号 + value</li>
<li>Acceptor: 参与决策，回应Proposers的提案；当一个提案，被半数以上的Acceptor接受，则该提案被批准
<ul>
<li>每个acceptor只能批准一个提案</li>
</ul>
</li>
<li>Learner: 不参与决策，获取最新的提案value</li>
</ul>
<h3> 2.5 Raft算法</h3>
<blockquote>
<p>推荐有兴趣的小伙伴，查看</p>
<ul>
<li><a href="http://thesecretlivesofdata.com/raft/" target="_blank" rel="noopener noreferrer">Raft 算法动画演示</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/32052223" target="_blank" rel="noopener noreferrer">Raft算法详解 - 知乎</a></li>
</ul>
</blockquote>
<p>为了解决paxos的复杂性，raft算法提供了一套更易理解的算法基础，其核心流程在于：</p>
<p>leader接受请求，并转发给follow，当大部分follow响应之后，leader通知所有的follow提交请求、同时自己也提交请求并告诉调用方ok</p>
<p>角色划分：</p>
<ul>
<li>Leader：领导者，接受客户端请求，并向Follower同步请求，当数据同步到大多数节点上后告诉Follower提交日志</li>
<li>Follow: 接受并持久化Leader同步的数据，在Leader告之日志可以提交之后，提交</li>
<li>Candidate：Leader选举过程中的临时角色，向其他节点拉选票，得到多数的晋升为leader，选举完成之后不存在这个角色</li>
</ul>
<figure><img src="/imgs/column/distribute/220708/raft03.jpg" alt="raft共识流程" tabindex="0" loading="lazy"><figcaption>raft共识流程</figcaption></figure>
<h3> 2.6 ZAB协议</h3>
<blockquote>
<p>ZAB(Zookeeper Atomic Broadcast) 协议是为分布式协调服务ZooKeeper专门设计的一种支持崩溃恢复的一致性协议，基于该协议，ZooKeeper 实现了一种 主从模式的系统架构来保持集群中各个副本之间的数据一致性。</p>
<ul>
<li><a href="https://segmentfault.com/a/1190000037550497" target="_blank" rel="noopener noreferrer">zookeeper核心之ZAB协议就这么简单！</a></li>
</ul>
</blockquote>
<p>主要用于zk的数据一致性场景，其核心思想是Leader再接受到事务请求之后，通过给Follower，当半数以上的Follower返回ACK之后，Leader提交提案，并向Follower发送commit信息</p>
<p><strong>角色划分</strong></p>
<ul>
<li>Leader: 负责整个Zookeeper 集群工作机制中的核心
<ul>
<li>事务请求的唯一调度和处理者，保证集群事务处理的顺序性</li>
<li>集群内部各服务器的调度者</li>
</ul>
</li>
<li>Follower：Leader的追随者
<ul>
<li>处理客户端的非实物请求，转发事务请求给 Leader 服务器</li>
<li>参与事务请求 Proposal 的投票</li>
<li>参与 Leader 选举投票</li>
</ul>
</li>
<li>Observer：是 zookeeper 自 3.3.0 开始引入的一个角色，
<ul>
<li>它不参与事务请求 Proposal 的投票，</li>
<li>也不参与 Leader 选举投票</li>
<li>只提供非事务的服务（查询），通常在不影响集群事务处理能力的前提下提升集群的非事务处理能力。</li>
</ul>
</li>
</ul>
<figure><img src="/imgs/column/distribute/220708/zab00.jpg" alt="ZAB消息广播" tabindex="0" loading="lazy"><figcaption>ZAB消息广播</figcaption></figure>
<h3> 2.7 2PC协议</h3>
<blockquote>
<p>two-phase commit protocol，两阶段提交协议，主要是为了解决强一致性，中心化的强一致性协议</p>
</blockquote>
<p><strong>角色划分</strong></p>
<ul>
<li>协调节点(coordinator)：中心化</li>
<li>参与者节点(partcipant)：多个</li>
</ul>
<p><strong>执行流程</strong></p>
<p>协调节点接收请求，然后向参与者节点提交 <code>precommit</code>，当所有的参与者都回复ok之后，协调节点再给所有的参与者节点提交<code>commit</code>，所有的都返回ok之后，才表明这个数据确认提交</p>
<p>当第一个阶段，有一个参与者失败，则所有的参与者节点都回滚</p>
<figure><img src="/imgs/column/distribute/220708/2pc00.jpg" alt="2pc流程" tabindex="0" loading="lazy"><figcaption>2pc流程</figcaption></figure>
<p><strong>特点</strong></p>
<p>优点在于实现简单</p>
<p>缺点也很明显</p>
<ul>
<li>协调节点的单点故障</li>
<li>第一阶段全部ack正常，第二阶段存在部分参与者节点异常时，可能出现不一致问题</li>
</ul>
<h3> 2.8 3PC协议</h3>
<blockquote>
<p><a href="https://segmentfault.com/a/1190000012534071" target="_blank" rel="noopener noreferrer">分布式事务：两阶段提交与三阶段提交 - SegmentFault 思否</a></p>
</blockquote>
<p>在两阶段的基础上进行扩展，将第一阶段划分两部，cancommit + precommit，第三阶段则为 docommit</p>
<p><strong>第一阶段 cancommit</strong></p>
<p>该阶段协调者会去询问各个参与者是否能够正常执行事务，参与者根据自身情况回复一个预估值，相对于真正的执行事务，这个过程是轻量的</p>
<p><strong>第二阶段 precommit</strong></p>
<p>本阶段协调者会根据第一阶段的询盘结果采取相应操作，若所有参与者都返回ok，则协调者向参与者提交事务执行(单不提交)通知；否则通知参与者abort回滚</p>
<p><strong>第三阶段 docommit</strong></p>
<p>如果第二阶段事务未中断，那么本阶段协调者将会依据事务执行返回的结果来决定提交或回滚事务，若所有参与者正常执行，则提交；否则协调者+参与者回滚</p>
<p>在本阶段如果因为协调者或网络问题，导致参与者迟迟不能收到来自协调者的 commit 或 rollback 请求，那么参与者将不会如两阶段提交中那样陷入阻塞，而是等待超时后继续 commit，相对于两阶段提交虽然降低了同步阻塞，但仍然无法完全避免数据的不一致</p>
<p><strong>特点</strong></p>
<ul>
<li>降低了阻塞与单点故障：
<ul>
<li>参与者返回 CanCommit 请求的响应后，等待第二阶段指令，若等待超时/协调者宕机，则自动 abort，降低了阻塞；</li>
<li>参与者返回 PreCommit 请求的响应后，等待第三阶段指令，若等待超时/协调者宕机，则自动 commit 事务，也降低了阻塞；</li>
</ul>
</li>
<li>数据不一致问题依然存在
<ul>
<li>比如第三阶段协调者发出了 abort 请求，然后有些参与者没有收到 abort，那么就会自动 commit，造成数据不一致</li>
</ul>
</li>
</ul>
<h3> 2.9 Gossip协议</h3>
<blockquote>
<p>Gossip 协议，顾名思义，就像流言蜚语一样，利用一种随机、带有传染性的方式，将信息传播到整个网络中，并在一定时间内，使得系统内的所有节点数据一致。Gossip 协议通过上面的特性，可以保证系统能在极端情况下（比如集群中只有一个节点在运行）也能运行</p>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/41228196" target="_blank" rel="noopener noreferrer">P2P 网络核心技术：Gossip 协议 - 知乎</a></li>
</ul>
</blockquote>
<p>主要用在分布式数据库系统中各个副本节点同步数据之用，这种场景的一个最大特点就是组成的网络的节点都是对等节点，是非结构化网络</p>
<p><strong>工作流程</strong></p>
<ul>
<li>周期性的传播消息，通常周期时间为1s</li>
<li>被感染的节点，随机选择n个相邻节点，传播消息</li>
<li>每次传播消息都选择还没有发送过的节点进行传播</li>
<li>收单消息的节点，不会传播给向它发送消息的节点</li>
</ul>
<figure><img src="/imgs/column/distribute/220708/gossip.gif" alt="Gossip传播示意图" tabindex="0" loading="lazy"><figcaption>Gossip传播示意图</figcaption></figure>
<p><strong>特点</strong></p>
<ul>
<li>扩展性：允许节点动态增加、减少，新增的节点状态最终会与其他节点一致</li>
<li>容错：网络中任意一个节点宕机重启都不会影响消息传播</li>
<li>去中心化：不要求中心节点，所有节点对等，任何一个节点无需知道整个网络状况，只要网络连通，则一个节点的消息最终会散播到整个网络</li>
<li>一致性收敛：协议中的消息会以一传十、十传百一样的指数级速度在网络中快速传播，因此系统状态的不一致可以在很快的时间内收敛到一致。消息传播速度达到了 logN</li>
<li>简单：Gossip 协议的过程极其简单，实现起来几乎没有太多复杂性</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>消息延迟：节点只会随机向少数几个节点发送消息，消息最终是通过多个轮次的散播而到达全网的，因此使用 Gossip 协议会造成不可避免的消息延迟</li>
<li>消息冗余：节点会定期随机选择周围节点发送消息，而收到消息的节点也会重复该步骤，导致消息的冗余</li>
</ul>
<h3> 2.10 一灰灰的小结</h3>
<p>本节主要介绍的是分布式系统设计中的一些常见的理论基石，如分布式中如何保障一致性，如何对一个提案达成共识</p>
<ul>
<li>BASE，CAP，PACELEC理论：构建稳定的分布式系统应该考虑的方向</li>
<li>paxos,raft共识算法</li>
<li>zab一致性协议</li>
<li>gossip消息同步协议</li>
</ul>
<h2> 3.算法</h2>
<p>这一节将主要介绍下分布式系统中的经典的算法，比如常用于分区的一致性hash算法，适用于一致性的Quorum NWR算法，PBFT拜占庭容错算法，区块链中大量使用的工作量证明PoW算法等</p>
<h3> 3.1 一致性hash算法</h3>
<p>一致性hash算法，主要应用于数据分片场景下，有效降低服务的新增、删除对数据复制的影响</p>
<p>通过对数据项的键进行哈希处理映射其在环上的位置，然后顺时针遍历环以查找位置大于该项位置的第一个节点，将每个由键标识的数据分配给hash环中的一个节点</p>
<figure><img src="/imgs/column/distribute/220708/hash.jpg" alt="一致性hash算法" tabindex="0" loading="lazy"><figcaption>一致性hash算法</figcaption></figure>
<p>一致散列的主要优点是增量稳定性; 节点添加删除，对整个集群而言，仅影响其直接邻居，其他节点不受影响。</p>
<p><strong>注意：</strong></p>
<ul>
<li>redis集群实现了一套hash槽机制，其核心思想与一致性hash比较相似</li>
</ul>
<h3> 3.2 Quorum NWR算法</h3>
<blockquote>
<p>用来保证数据冗余和最终一致性的投票算法，其主要数学思想来源于鸽巢原理</p>
<ul>
<li><a href="https://developer.aliyun.com/article/53498" target="_blank" rel="noopener noreferrer">分布式系统之Quorum （NRW）算法-阿里云开发者社区</a></li>
</ul>
</blockquote>
<ul>
<li>N 表示副本数，又叫做复制因子（Replication Factor）。也就是说，N 表示集群中同一份数据有多少个副本</li>
<li>W，又称写一致性级别（Write Consistency Level），表示成功完成 W 个副本更新写入，才会视为本次写操作成功</li>
<li>R 又称读一致性级别（Read Consistency Level），表示读取一个数据对象时需要读 R 个副本, 才会视为本次读操作成功</li>
</ul>
<p>Quorum NWR算法要求每个数据拷贝对象 都可以投1票，而每一个操作的执行则需要获取最小的读票数，写票数；通常来讲写票数W一般需要超过N/2，即我们通常说的得到半数以上的票才表示数据写入成功</p>
<p>事实上当W=N、R=1时，即所谓的WARO(Write All Read One)。就是CAP理论中CP模型的场景</p>
<h3> 3.3 PBFT拜占庭算法</h3>
<p>拜占庭算法主要针对的是分布式场景下无响应，或者响应不可信的情况下的容错问题，其核心分三段流程，如下</p>
<figure><img src="/imgs/column/distribute/220708/bzt.jpg" alt="拜占庭算法" tabindex="0" loading="lazy"><figcaption>拜占庭算法</figcaption></figure>
<p>假设集群节点数为 N，f个故障节点(无响应)和f个问题节点(无响应或错误响应),f+1个正常节点，即 3f+1=n</p>
<ul>
<li>客户端向主节点发起请求，主节点接受请求之后，向其他节点广播 pre-prepare 消息</li>
<li>节点接受pre-prepare消息之后，若同意请求，则向其他节点广播 prepare 消息；</li>
<li>当一个节点接受到2f+1个prepare新消息，则进入commit阶段，并广播commit消息</li>
<li>当收到 2f+1 个 commit 消息后（包括自己），代表大多数节点已经进入 commit 阶段，这一阶段已经达成共识，于是节点就会执行请求，写入数据</li>
</ul>
<p>相比 Raft 算法完全不适应有人作恶的场景，PBFT 算法能容忍 (n 1)/3 个恶意节点 (也可以是故障节点)。另外，相比 PoW 算法，PBFT 的优点是不消耗算 力。PBFT 算法是O(n ^ 2) 的消息复杂度的算法，所以以及随着消息数 的增加，网络时延对系统运行的影响也会越大，这些都限制了运行 PBFT 算法的分布式系统 的规模，也决定了 PBFT 算法适用于中小型分布式系统</p>
<h3> 3.4 PoW算法</h3>
<p>工作量证明 (Proof Of Work，简称 PoW)，同样应用于分布式下的一致性场景，区别于前面的raft, pbft, paxos采用投票机制达成共识方案，pow采用工作量证明</p>
<p>客户端需要做一定难度的工作才能得出一个结果，验证方却很容易通过结果来检查出客户端是不是做了相应的工作，通过消耗一定工作浪，增加消息伪造的成本，PoW以区块链中广泛应用而广为人知，下面以区块链来简单说一下PoW的算法应用场景</p>
<p>以BTC的转账为例，A转n个btc给B，如何保证不会同时将这n个币转给C？</p>
<ul>
<li>A转账给B，交易信息记录在一个区块1中</li>
<li>A转账给C，交易信息被记录在另一个区块2中</li>
<li>当区块1被矿工成功提交到链上，并被大多数认可（通过校验区块链上的hash值验证是否准确，而这个hash值体现的是矿工的工作量），此时尚未提交的区块2则会被抛弃</li>
<li>若区块1被提交，区块2也被提交，各自有部分人认可，就会导致分叉，区块链中采用的是优选最长的链作为主链，丢弃分叉的部分（这就属于区块链的知识点了，有兴趣的小伙伴可以扩展下相关知识点，这里就不展开了）</li>
</ul>
<p>PoW的算法，主要应用在上面的区块提交验证，通过hash值计算来消耗算力，以此证明矿工确实有付出，得到多数认可的可以达成共识</p>
<h3> 3.5 一灰灰的小结</h3>
<p>本节主要介绍了下当前分布式下常见的算法，</p>
<ul>
<li>分区的一致性hash算法: 基于hash环，减少节点动态增加减少对整个集群的影响；适用于数据分片的场景</li>
<li>适用于一致性的Quorum NWR算法: 投票算法，定义如何就一个提案达成共识</li>
<li>PBFT拜占庭容错算法: 适用于集群中节点故障、或者不可信的场景</li>
<li>区块链中大量使用的工作量证明PoW算法: 通过工作量证明，认可节点的提交</li>
</ul>
<h2> 4.技术思想</h2>
<p>这一节的内容相对前面几个而言，并不太容易进行清晰的分类；主要包含一些高质量的分布式系统的实践中，值得推荐的设计思想、技术细节</p>
<h3> 4.1 CQRS</h3>
<blockquote>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/115685384" target="_blank" rel="noopener noreferrer">DDD 中的那些模式 — CQRS - 知乎</a></li>
<li><a href="https://www.infoq.cn/article/wdlpjosudoga34jutys9" target="_blank" rel="noopener noreferrer">详解CQRS架构模式_架构_Kislay Verma_InfoQ精选文章</a></li>
</ul>
</blockquote>
<p>Command Query Responsibility Segregation 即我们通俗理解的读写分离，其核心思想在于将两类不同操作进行分离，在独立的服务中实现</p>
<figure><img src="/imgs/column/distribute/220708/cqrs.jpg" alt="cqrs" tabindex="0" loading="lazy"><figcaption>cqrs</figcaption></figure>
<p>用途在于将领域模型与查询功能进行分离，让一些复杂的查询摆脱领域模型的限制，以更为简单的 DTO 形式展现查询结果。同时分离了不同的数据存储结构，让开发者按照查询的功能与要求更加自由的选择数据存储引擎</p>
<h3> 4.2 复制负载平衡服务</h3>
<blockquote>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/34191846" target="_blank" rel="noopener noreferrer">分布式系统设计:服务模式之复制负载平衡服务 - 知乎</a></li>
<li><a href="https://www.runoob.com/w3cnote/balanced-algorithm.html" target="_blank" rel="noopener noreferrer">负载均衡调度算法大全 | 菜鸟教程</a></li>
</ul>
</blockquote>
<p>复制负载平衡服务(Replication Load Balancing Service, RLBS)，可以简单理解为我们常说的负载均衡，多个相同的服务实例构建一个集群，每个服务都可以响应请求，负载均衡器负责请求的分发到不同的实例上，常见的负载算法</p>
<table>
<thead>
<tr>
<th>算法</th>
<th>说明</th>
<th>特点</th>
</tr>
</thead>
<tbody>
<tr>
<td>轮询</td>
<td>请求按照顺序依次分发给对应的服务器</td>
<td>优点简单，缺点在于未考虑不同服务器的实际性能情况</td>
</tr>
<tr>
<td>加权轮询</td>
<td>权重高的被分发更多的请求</td>
<td>优点：充分利用机器的性能</td>
</tr>
<tr>
<td>最少连接数</td>
<td>找连接数最少的服务器进行请求分发,若所有服务器相同的连接数，则找第一个选择的</td>
<td>目的是让优先让空闲的机器响应请求</td>
</tr>
<tr>
<td>少连接数慢启动时间</td>
<td>刚启动的服务器，在一个时间段内，连接数是有限制且缓慢增加</td>
<td>避免刚上线导致大量的请求分发过来而超载</td>
</tr>
<tr>
<td>加权最少连接</td>
<td>平衡服务性能 + 最少连接数</td>
<td></td>
</tr>
<tr>
<td>基于代理的自适应负载均衡</td>
<td>载主机包含一个自适用逻辑用来定时监测服务器状态和该服务器的权重</td>
<td></td>
</tr>
<tr>
<td>源地址哈希法</td>
<td>获取客户端的IP地址，通过哈希函映射到对应的服务器</td>
<td>相同的来源请求都转发到相同的服务器上</td>
</tr>
<tr>
<td>随机</td>
<td>随机算法选择一台服务器</td>
<td></td>
</tr>
<tr>
<td>固定权重</td>
<td>最高权重只有在其他服务器的权重值都很低时才使用。然而，如果最高权重的服务器下降，则下一个最高优先级的服务器将为客户端服务</td>
<td>每个真实服务器的权重需要基于服务器优先级来配置</td>
</tr>
<tr>
<td>加权响应</td>
<td>服务器响应越小其权重越高，通常是基于心跳来判断机器的快慢</td>
<td>心跳的响应并不一定非常准确反应服务情况</td>
</tr>
</tbody>
</table>
<h3> 4.3 心跳机制</h3>
<p>在分布式环境里中，如何判断一个服务是否存活，当下最常见的方案就是心跳</p>
<p>比如raft算法中的leader向所有的follow发送心跳，表示自己还健在，避免发生新的选举；</p>
<p>比如redis的哨兵机制，也是通过ping/pong的心跳来判断节点是否下线，是否需要选新的主节点；</p>
<p>再比如我们日常的业务应用得健康监测，判断服务是否正常</p>
<h3> 4.4 租约机制</h3>
<p>租约就像一个锁，但即使客户端离开，它也能工作。客户端请求有限期限的租约，之后租约到期。如果客户端想要延长租约，它可以在租约到期之前续订租约。</p>
<p>租约主要是了避免一个资源长久被某个对象持有，一旦对方挂了且不会主动释放的问题；在实际的场景中，有两个典型的应用</p>
<p><strong>case1 分布式锁</strong></p>
<p>业务获取的分布式锁一般都有一个有效期，若有效期内没有主动释放，这个锁依然会被释放掉，其他业务也可以抢占到这把锁；因此对于持有锁的业务方而言，若发现在到期前，业务逻辑还没有处理完，则可以续约，让自己继续持有这把锁</p>
<p>典型的实现方式是redisson的看门狗机制</p>
<p><strong>case2 raft算法的任期</strong></p>
<p>在raft算法中，每个leader都有一个任期，任期过后会重新选举，而Leader为了避免重新选举，一般会定时发送心跳到Follower进行续约</p>
<h3> 4.5 Leader &amp; Follow</h3>
<p>这个比较好理解，上面很多系统都采用了这种方案，特别是在共识算法中，由领导者负责代表整个集群做出决策，并将决策传播到所有其他服务器</p>
<p>领导者选举在服务器启动时进行。每个服务器在启动时都会启动领导者选举，并尝试选举领导者。除非选出领导者，否则系统不接受任何客户端请求</p>
<h3> 4.6 Fencing</h3>
<p>在领导者-追随者模式中，当领导者失败时，不可能确定领导者已停止工作，如慢速网络或网络分区可能会触发新的领导者选举，即使前一个领导者仍在运行并认为它仍然是活动的领导者</p>
<p>Fencint是指在以前处于活动状态的领导者周围设置围栏，使其无法访问集群资源，从而停止为任何读/写请求提供服务</p>
<ul>
<li>资源屏蔽：系统会阻止以前处于活动状态的领导者访问执行基本任务所需的资源。</li>
<li>节点屏蔽：系统会阻止以前处于活动状态的领导者访问所有资源。执行此操作的常见方法是关闭节点电源或重置节点。</li>
</ul>
<h3> 4.7 Quorum法定人数</h3>
<p>法定人数，常见于选举、共识算法中，当超过Quorum的节点数确认之后，才表示这个提案通过(数据更新成功)，通常这个法定人数为 = 半数节点 + 1</p>
<h3> 4.8 High-Water mark高水位线</h3>
<p>高水位线，跟踪Leader（领导者）上的最后一个日志条目，且该条目已成功复制到&gt;quorum（法定人数）的Follow（跟谁者），即表示这个日志被整个集群接受</p>
<p>日志中此条目的索引称为高水位线索引。领导者仅公开到高水位线索引的数据。</p>
<p>如Kafka：为了处理非可重复读取并确保数据一致性，Kafka broker会跟踪高水位线，这是特定分区的最大偏移量。使用者只能看到高水位线之前的消息。</p>
<h3> 4.9 Phi 累计故障检测</h3>
<p>Phi Accrual Failure Detection,使用历史检测信号信息使阈值自适应</p>
<p>通用的应计故障检测器不会判断服务器是否处于活动状态，而是输出有关服务器的可疑级别。</p>
<p>如Cassandra（Facebook开源的分布式NoSql数据库）使用 Phi 应计故障检测器算法来确定群集中节点的状态</p>
<h3> 4.10 Write-ahead Log预写日志</h3>
<p>预写日志记录是解决操作系统中文件系统不一致的问题的高级解决方案，当我们提交写到操作系统的文件缓存，此时业务会认为已经提交成功；但是在文件缓存与实际写盘之间会有一个时间差，若此时机器宕机，会导致缓存中的数据丢失，从而导致完整性缺失</p>
<p>为了解决这个问题，如mysql，es等都采用了预写日志的机制来避免这个问题</p>
<p>MySql：</p>
<ul>
<li>事务提交的流程中，先写redolog precommit， 然后写binlog，最后再redolog commit；当redolog记录成功之后，才表示事务执行成功；</li>
<li>因此当出现上面的宕机恢复时，则会加载redologo，然后重放对应的命令，来恢复未持久化的数据</li>
</ul>
<p>ElasticSearch:</p>
<ul>
<li>在内存中数据生成段写到操作系统文件缓存前，会先写事务日志，出现异常时，也是从事务日志进行恢复</li>
</ul>
<h3> 4.11 分段日志</h3>
<p>将日志拆分为多个较小的文件，而不是单个大文件，以便于操作。</p>
<p>单个日志文件在启动时读取时可能会增长并成为性能瓶颈。较旧的日志会定期清理，并且很难对单个大文件执行清理操作。</p>
<p>单个日志拆分为多个段。日志文件在指定的大小限制后滚动。使用日志分段，需要有一种将逻辑日志偏移量（或日志序列号）映射到日志段文件的简单方法。</p>
<p>这个其实也非常常见，比如我们实际业务应用配置的log，一般都是按天、固定大小进行拆分，并不会把所有的日志都放在一个日志文件中</p>
<p>再比如es的分段存储，一个段就是一个小的存储文件</p>
<h3> 4.12 checksum校验</h3>
<p>在分布式系统中，在组件之间移动数据时，从节点获取的数据可能会损坏。</p>
<p>计算校验和并将其与数据一起存储。</p>
<p>要计算校验和，请使用 MD5、SHA-1、SHA-256 或 SHA-512 等加密哈希函数。哈希函数获取输入数据并生成固定长度的字符串（包含字母和数字）;此字符串称为校验和。</p>
<p>当系统存储某些数据时，它会计算数据的校验和，并将校验和与数据一起存储。当客户端检索数据时，它会验证从服务器接收的数据是否与存储的校验和匹配。如果没有，则客户端可以选择从另一个副本检索该数据。</p>
<p>HDFS和Chubby将每个文件的校验和与数据一起存储。</p>
<h3> 4.13 一灰灰的小结</h3>
<p>这一节很多内容来自下面这篇博文，推荐有兴趣的小伙伴查看原文</p>
<ul>
<li><a href="https://medium.com/@nishantparmar/distributed-system-design-patterns-2d20908fecfc" target="_blank" rel="noopener noreferrer">Distributed System Design Patterns | by Nishant | Medium</a></li>
</ul>
<p>这一节主要简单的介绍了下分布式系统中应用到的一些技术方案，如有对其中某个技术有兴趣的小伙伴可以留言，后续会逐一进行补全</p>
<h2> 5.分布式系统解决方案</h2>
<p>最后再介绍一些常见的分布式业务场景及对应的解决方案，比如全局唯一的递增ID-雪花算法，分布式系统的资源抢占-分布式锁，分布式事务-2pc/3pc/tcc ，分布式缓存等</p>
<h3> 5.1 缓存</h3>
<p>缓存实际上并不是分布式独有的，这里把它加进来，主要是因为实在是应用得太广了，无论是应用服务、基础软件工具还是操作系统，大量都可以见到缓存的身影</p>
<p>缓存的核心思想在于： 借助更高效的IO方式，来替代代价昂贵的IO方式</p>
<p>如：</p>
<ul>
<li>redis的性能高于mysql</li>
<li>如内存的读写，远高于磁盘IO，文件IO</li>
<li>磁盘顺序读写 &gt; 随机读写</li>
</ul>
<p>用好缓存可以有效提高应用性能，下面以一个普通的java前台应用为例说明</p>
<ul>
<li>JVM缓存 -&gt; 分布式缓存(redis/memcache) -&gt; mysql缓存 -&gt; 操作系统文件缓存 -&gt; 磁盘文件</li>
</ul>
<p>缓存面临的核心问题，则在于</p>
<ul>
<li>一致性问题：缓存与db的一致性如何保障（相信大家都听说过或者实际处理过这种问题）</li>
<li>数据完整性：比如常见的先写缓存，异步刷新到磁盘，那么缓存到磁盘刷新这段时间内，若宕机导致数据丢失怎么办？
<ul>
<li>TIP: 上面这个问题可以参考mysql的redolog</li>
</ul>
</li>
</ul>
<h3> 5.2 全局唯一ID</h3>
<p>在传统的单体架构中，业务id基本上是依赖于数据库的自增id来处理；当我们进入分布式场景时，如我们常说的分库分表时，就需要我们来考虑如何实现全局唯一的业务id了，避免出现在分表中出现冲突</p>
<p>全局唯一ID解决方案：</p>
<ul>
<li>uuid</li>
<li>数据库自增id表</li>
<li>redis原子自增命令</li>
<li>雪花算法 (原生的，扩展的百度UidGenerator, 美团Leaf等)</li>
<li>Mist 薄雾算法</li>
</ul>
<h3> 5.3 分布式锁</h3>
<p>常用于分布式系统中资源控制，只有持有锁的才能继续操作，确保同一时刻只会有一个实例访问这个资源</p>
<p>常见的分布式锁有</p>
<ul>
<li>基于数据库实现分布式锁</li>
<li><a href="https://hhui.top/spring-db/09.%E5%AE%9E%E4%BE%8B/20.201030-springboot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8Bredis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%BA%94%E7%94%A8%E7%AF%87/" target="_blank" rel="noopener noreferrer">Redis实现分布式锁（应用篇） | 一灰灰Learning</a></li>
<li><a href="https://hhui.top/spring-middle/03.zookeeper/02.210415-springboot%E6%95%B4%E5%90%88zookeeper%E4%BB%8E0%E5%88%B01%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/" target="_blank" rel="noopener noreferrer">从0到1实现一个分布式锁 | 一灰灰Learning</a></li>
<li>etcd实现分布式锁</li>
<li>基于consul实现分布式锁</li>
</ul>
<h3> 5.4 分布式事务</h3>
<p>事务表示一组操作，要么全部成功，要么全部不成功；单机事务通常说的是数据库的事务；而分布式事务，则可以简单理解为多个数据库的操作，要么同时成功，要么全部不成功</p>
<p>更确切一点的说法，分布式事务主要是要求事务的参与方，可能涉及到多个系统、多个数据资源，要求它们的操作要么都成功，要么都回滚；</p>
<p>一个简单的例子描述下分布式事务场景：</p>
<p><strong>下单扣库存</strong></p>
<ul>
<li>用户下单，付钱</li>
<li>此时订单服务，会生成订单信息</li>
<li>支付网关，会记录付款信息，成功or失败</li>
<li>库存服务，扣减对应的库存</li>
</ul>
<p>一个下单支付操作，涉及到三个系统，而分布式事务则是要求，若支付成功，则上面三个系统都应该更新成功；若有一个操作失败，如支付失败，则已经扣了库存的要回滚（还库存），生成的订单信息回滚（删掉--注：现实中并不会去删除订单信息，这里只是用于说明分布式事务，请勿带入实际的实现方案）</p>
<p>分布式事务实现方案：</p>
<ul>
<li>2PC: 前面说的两阶段提交，就是实现分布式事务的一个经典解决方案</li>
<li>3PC: 三阶段提交</li>
<li>TCC：补偿事务，简单理解为应用层面的2PC</li>
<li>SAGA事务</li>
<li>本地消息表</li>
<li>MQ事务方案</li>
</ul>
<h3> 5.5 分布式任务</h3>
<p>分布式任务相比于我们常说单机的定时任务而言，可以简单的理解为多台实例上的定时任务，从应用场景来说，可以区分两种</p>
<ul>
<li>互斥性的分布式任务
<ul>
<li>即同一时刻，集群内只能有一个实例执行这个任务</li>
</ul>
</li>
<li>并存式的分布式任务
<ul>
<li>同一时刻，所有的实例都可以执行这个任务</li>
<li>续考虑如何避免多个任务操作相同的资源</li>
</ul>
</li>
</ul>
<p>分布式任务实现方案：</p>
<ul>
<li>Quartz Cluster</li>
<li>XXL-Job</li>
<li>Elastic-Job</li>
<li>自研：
<ul>
<li>资源分片策略</li>
<li>分布式锁控制的唯一任务执行策略</li>
</ul>
</li>
</ul>
<h3> 5.6 分布式Session</h3>
<blockquote>
<p>Session一般叫做会话，Session技术是http状态保持在服务端的解决方案，它是通过服务器来保持状态的。我们可以把客户端浏览器与服务器之间一系列交互的动作称为一个 Session。是服务器端为客户端所开辟的存储空间，在其中保存的信息就是用于保持状态。因此，session是解决http协议无状态问题的服务端解决方案，它能让客户端和服务端一系列交互动作变成一个完整的事务。</p>
</blockquote>
<p>单机基于session/cookie来实现用户认证，那么在分布式系统的多实例之间，如何验证用户身份呢？这个就是我们说的分布式session</p>
<p>分布式session实现方案：</p>
<ul>
<li>session stick：客户端每次请求都转发到同一台服务器(如基于ip的hash路由转发策略）</li>
<li>session复制: session生成之后，主动同步给其他服务器</li>
<li>session集中保存：用户信息统一存储，每次需要时统一从这里取(也就是常说的redis实现分布式session方案)</li>
<li>cookie: 使用客户端cookie存储session数据，每次请求时携带这个</li>
</ul>
<h3> 5.7 分布式链路追踪</h3>
<p>分布式链路追踪也可以叫做全链路追中，而它可以说是每个开发者的福音，通常指的是一次前端的请求，将这个请求过程中，所有涉及到的系统、链路都串联起来，可以清晰的知道这一次请求中，调用了哪些服务，有哪些IO交互，瓶颈点在哪里，什么地方抛出了异常</p>
<p>当前主流的全链路方案大多是基于google的<code>Dapper</code> 论文实现的</p>
<p>全链路实现方案</p>
<ul>
<li>zipkin</li>
<li>pinpoint</li>
<li>SkyWalking</li>
<li>CAT</li>
<li>jaeger</li>
</ul>
<h3> 5.8 布隆过滤器</h3>
<p>Bloom过滤器是一种节省空间的概率数据结构，用于测试元素是否为某集合的成员。</p>
<p>布隆过滤器由一个长度为 m 比特的位数组（bit array）与 k 个哈希函数（hash function）组成的数据结构。</p>
<p>原理是当一个元素被加入集合时，通过 K 个散列函数将这个元素映射成一个位数组中的 K 个点，把它们置为 1。</p>
<p>检索时，我们只要看看这些点是不是都是 1 就大约知道集合中有没有它了，也就是说，如果这些点有任何一个 0 ，则被检元素一定不在；如果都是 1 ，则被检元素很可能在。</p>
<p>关于布隆过滤器，请牢记一点</p>
<ul>
<li>判定命中的，不一定真的命中</li>
<li>判定没有命中的，则一定不在里面</li>
</ul>
<figure><img src="/imgs/column/distribute/220708/bloom-filter.png" alt="布隆过滤器" tabindex="0" loading="lazy"><figcaption>布隆过滤器</figcaption></figure>
<p>常见的应用场景，如</p>
<ul>
<li>防止缓存穿透</li>
<li>爬虫时重复检测</li>
</ul>
<h3> 5.9 一灰灰的小结</h3>
<p>分布式系统的解决方案当然不局限于上面几种，比如分布式存储、分布式计算等也属于常见的场景，当然在我们实际的业务支持过程中，不太可能需要让我们自己来支撑这种大活；而上面提到的几个点，基本上或多或少会与我们日常工作相关，这里列出来当然是好为了后续的详情做铺垫</p>
<h2> 6.一灰灰的总结</h2>
<h3> 6.1 综述</h3>
<p>这是一篇概括性的综述类文章，可能并没有很多的干货，当然也限于“一灰灰”我个人的能力，上面的总结可能并不准确，如有发现，请不吝赐教</p>
<p>全文总结如下</p>
<p>常见的分布式架构设计方案：</p>
<ul>
<li>主备，主从，多主多从，普通无中心集群，数据分片架构</li>
</ul>
<p>分布式系统中的理论基石：</p>
<ul>
<li>CAP， BASE, PACELEC</li>
<li>共识算法：paxos, raft, zab</li>
<li>一致性协议：2pc, 3pc</li>
<li>数据同步：gossip</li>
</ul>
<p>分布式系统中的算法：</p>
<ul>
<li>分区的一致性hash算法: 基于hash环，减少节点动态增加减少对整个集群的影响；适用于数据分片的场景</li>
<li>适用于一致性的Quorum NWR算法: 投票算法，定义如何就一个提案达成共识</li>
<li>PBFT拜占庭容错算法: 适用于集群中节点故障、或者不可信的场景</li>
<li>区块链中大量使用的工作量证明PoW算法: 通过工作量证明，认可节点的提交</li>
</ul>
<p>分布式系统解决方案：</p>
<ul>
<li>分布式缓存</li>
<li>全局唯一ID</li>
<li>分布式锁</li>
<li>分布式事务</li>
<li>分布式任务</li>
<li>分布式会话</li>
<li>分布式链路追踪</li>
<li>布隆过滤器</li>
</ul>
<h3> 6.2 题外话</h3>
<p>最后总结一下这篇耗时两周写完的“心血巨作”（有点自吹了哈），准备这篇文章确实花了很大的精力，首先我个人对于分布式这块的理解并不能算深刻，其次分布式这块的理论+实践知识特别多，而且并不是特别容易上手理解，在输出这篇文章的同时，遇到一些疑问点我也会去查阅相关资料去确认，整个过程并不算特别顺利； 那么为什么还要去做这个事情呢？</p>
<ol>
<li>咸鱼太久了，想做一些有意思的东西，活跃一下大脑</li>
<li>准备依托于《分布式专栏》来将自己的知识体系进行归纳汇总，让零散分布在大脑中的知识点能有一个脉络串联起来</li>
<li>不想做架构的码农不是好码农，而想成为一个好的架构，当然得做一些基础准备，向业务精品学习取经</li>
</ol>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/column/distribute/220708/mysql03.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>分布式系统的8个谬误</title>
      <link>https://liuyueyi.github.io/tutorial/column/arch/distribute/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/02.%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%848%E4%B8%AA%E8%B0%AC%E8%AF%AF.html</link>
      <guid>https://liuyueyi.github.io/tutorial/column/arch/distribute/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/02.%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%848%E4%B8%AA%E8%B0%AC%E8%AF%AF.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">分布式系统的8个谬误</source>
      <description>你在分布式系统上工作吗？微服务，Web API，SOA，Web服务器，应用服务器，数据库服务器，缓存服务器，负载均衡器 - 如果这些描述了系统设计中的组件，那么答案是肯定的。分布式系统由许多计算机组成，这些计算机协调以实现共同的目标。 20多年前，Peter Deutsch和James Gosling定义了分布式计算的8个谬误。这些是许多开发人员对分布式系统做出的错误假设。从长远来看，这些通常被证明是错误的，导致难以修复错误。 8个谬误是： 网络可靠。 延迟为零。 带宽是无限的。 网络是安全的。 拓扑不会改变。 有一个管理员。 运输成本为零。 网络是同质的。</description>
      <category>分布式</category>
      <category>设计模式</category>
      <pubDate>Thu, 14 Jul 2022 07:27:54 GMT</pubDate>
      <content:encoded><![CDATA[<p>你在分布式系统上工作吗？微服务，Web API，SOA，Web服务器，应用服务器，数据库服务器，缓存服务器，负载均衡器 - 如果这些描述了系统设计中的组件，那么答案是肯定的。分布式系统由许多计算机组成，这些计算机协调以实现共同的目标。</p>
<p>20多年前，Peter Deutsch和James Gosling定义了分布式计算的8个谬误。这些是许多开发人员对分布式系统做出的错误假设。从长远来看，这些通常被证明是错误的，导致难以修复错误。</p>
<p>8个谬误是：</p>
<ol>
<li>网络可靠。</li>
<li>延迟为零。</li>
<li>带宽是无限的。</li>
<li>网络是安全的。</li>
<li>拓扑不会改变。</li>
<li>有一个管理员。</li>
<li>运输成本为零。</li>
<li>网络是同质的。</li>
</ol>
<p>让我们来看看每个谬误，讨论问题和潜在的解决方案。</p>
<h2> 1.网络可靠</h2>
<h3> 问题</h3>
<blockquote>
<p>通过网络呼叫将失败。</p>
</blockquote>
<p>今天的大多数系统都会调用其他系统。您是否正在与第三方系统（支付网关，会计系统，CRM）集成？你在做网络服务电话吗？如果呼叫失败会发生什么？如果您要查询数据，则可以进行简单的重试。但是如果您发送命令会发生什么？我们举一个简单的例子：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>如果我们收到HTTP超时异常会怎么样？如果服务器没有处理请求，那么我们可以重试。但是，如果它确实处理了请求，我们需要确保我们不会对客户进行双重收费。您可以通过使服务器具有幂等性来实现此目的。这意味着如果您使用相同的收费请求拨打10次，则客户只需支付一次费用。如果您没有正确处理这些错误，那么您的系统是不确定的。处理所有这些情况可能会非常复杂。</p>
<h3> 解决方案</h3>
<p>因此，如果网络上的呼叫失败，我们能做什么？好吧，我们可以自动重试。排队系统非常擅长这一点。它们通常使用称为存储和转发的模式。它们在将消息转发给收件人之前在本地存储消息。如果收件人处于脱机状态，则排队系统将重试发送邮件。MSMQ是这种排队系统的一个例子。</p>
<p>但是这种变化将对您的系统设计产生重大影响。您正在从请求/响应模型转移到触发并忘记。由于您不再等待响应，因此您需要更改系统中的用户行程。您不能只使用队列发送替换每个Web服务调用。</p>
<h3> 结论</h3>
<p>你可能会说网络现在更可靠 - 而且它们是。但事情发生了。硬件和软件可能会出现故障 - 电源，路由器，更新或补丁失败，无线信号弱，网络拥塞，啮齿动物或鲨鱼。是的，鲨鱼：在一系列鲨鱼叮咬之后，谷歌正在加强与Kevlar的海底数据线。</p>
<p>还有人为因素。人们可以开始DDOS攻击，也可以破坏物理设备。</p>
<p>这是否意味着您需要删除当前的技术堆栈并使用消息传递系统？并不是的！您需要权衡失败的风险与您需要进行的投资。您可以通过投资基础架构和软件来最小化失败的可能性。在许多情况下，失败是一种选择。但在设计分布式系统时，您确实需要考虑失败的问题。</p>
<h2> 2.延迟是零</h2>
<h3> 问题</h3>
<blockquote>
<p>通过网络拨打电话不是即时的。</p>
</blockquote>
<p>内存呼叫和互联网呼叫之间存在七个数量级的差异。您的应用程序应该是网络感知。这意味着您应该清楚地将本地呼叫与远程呼叫分开。让我们看看我在代码库中看到的一个例子：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>没有进一步检查，这看起来很好。但是，有两个远程呼叫。第2行进行一次调用以获取文档摘要列表。在第5行，还有另一个调用，它检索有关每个文档的更多信息。这是一个经典的Select n + 1问题。为了解决网络延迟问题，您应该在一次调用中返回所有必需的数据。一般的建议是本地调用可以细粒度，但远程调用应该更粗粒度。这就是为什么分布式对象和网络透明度的想法死了。但是，即使每个人都同意分布式对象是一个坏主意，有些人仍然认为延迟加载总是一个好主意：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>您不希望财产获取者进行网络呼叫。但是，每个。 在上面的代码中调用实际上可以触发数据库之旅。</p>
<h3> 解决方案</h3>
<h4> 带回您可能需要的所有数据</h4>
<p>如果您进行远程呼叫，请确保恢复可能需要的所有数据。网络通信不应该是唠叨的。</p>
<h4> 将Data Closer移动到客户端</h4>
<p>另一种可能的解决方案是将数据移近客户端。如果您正在使用云，请根据客户的位置仔细选择可用区。缓存还可以帮助最小化网络呼叫的数量。对于静态内容，内容交付网络（CDN）是另一个不错的选择。</p>
<h4> 反转数据流</h4>
<p>删除远程调用的另一个选项是反转数据流。我们可以使用Pub / Sub并在本地存储数据，而不是查询其他服务。这样，我们就可以在需要时获取数据。当然，这会带来一些复杂性，但它可能是工具箱中的一个很好的工具。</p>
<h3> 结论</h3>
<p>虽然延迟可能不是LAN中的问题，但当您转移到WAN或Internet时，您会注意到延迟。这就是为什么将网络呼叫与内存中的呼叫明确分开是很重要的。在采用微服务架构模式时，您应该牢记这一点。您不应该只使用远程调用替换本地呼叫。这可能会使你的系统变成分布式的大泥球。</p>
<h2> 3.带宽是无限的</h2>
<h3> 问题</h3>
<blockquote>
<p>带宽是有限的。</p>
</blockquote>
<p>带宽是网络在一段时间内发送数据的容量。到目前为止，我还没有发现它是一个问题，但我可以看到为什么它在某些条件下可能是一个问题。虽然带宽随着时间的推移而有所改善，但我们发送的数据量也有所增加。与通过网络传递简单DTO的应用相比，视频流或VoIP需要更多带宽。带宽对于移动应用程序来说更为重要，因此开发人员在设计后端API时需要考虑它。</p>
<p>错误地使用ORM也会造成伤害。我见过开发人员在查询中过早调用.ToList（）的示例，因此在内存中加载整个表。</p>
<h3> 解决方案</h3>
<h4> 领域驱动的设计模式</h4>
<p>那么我们怎样才能确保我们不会带来太多数据呢？域驱动设计模式可以帮助：</p>
<ul>
<li>首先，您不应该争取单一的企业级域模型。您应该将域划分为有界上下文。</li>
<li>要避免有界上下文中的大型复杂对象图，可以使用聚合模式。聚合确保一致性并定义事务边界。</li>
</ul>
<h4> 命令和查询责任隔离</h4>
<p>我们有时会加载复杂的对象图，因为我们需要在屏幕上显示它的一部分。如果我们在很多地方这样做，我们最终会得到一个庞大而复杂的模型，对于写作和阅读来说都是次优的。另一种方法可以是使用命令和查询责任隔离 - CQRS。这意味着将域模型分为两部分：</p>
<ul>
<li>在写模式将确保不变保持真实的数据是一致的。由于写模型不关心视图问题，因此可以保持较小且集中。</li>
<li>该读取模型是视图的担忧进行了优化，所以我们可以获取所有所需的特定视图中的数据（例如，我们的应用程序的屏幕）。</li>
</ul>
<h3> 结论</h3>
<p>在第二个谬误（延迟不是0）和第三个谬误（带宽是无限的）之间有延伸，您应该传输更多数据，以最大限度地减少网络往返次数。您应该传输较少的数据以最小化带宽使用。您需要平衡这两种力量，并找到通过线路发送的_正确_数据量。</p>
<p>虽然您可能不会经常遇到带宽限制，但考虑传输的数据非常重要。更少的数据更容易理解。数据越少意味着耦合越少。因此，只传输您可能需要的数据。</p>
<h2> 4.网络是安全的</h2>
<h3> 问题</h3>
<blockquote>
<p>网络并不安全。</p>
</blockquote>
<p>这是一个比其他人更多的媒体报道的假设。您的系统仅与最薄弱的链接一样安全。坏消息是分布式系统中有很多链接。您正在使用HTTPS，除非与不支持它的第三方遗留系统进行通信。您正在查看自己的代码，寻找安全问题，但正在使用可能存在风险的开源库。一个OpenSSL的漏洞允许人们通过盗取SSL / TLS保护的数据。Apache Struts中的一个错误允许攻击者在服务器上执行代码。即使你正在抵御所有这些，仍然存在人为因素。恶意DBA可能错放数据库备份。今天的攻击者掌握着大量的计算能力和耐心。所以问题不在于他们是否会攻击你的系统，而是什么时候。</p>
<h3> 解决方案</h3>
<h4> 深度防御</h4>
<p>您应该使用分层方法来保护您的系统。您需要在网络，基础架构和应用程序级别进行不同的安全检查。</p>
<h4> 安全心态</h4>
<p>在设计系统时要牢记安全性。十大漏洞列表在过去5年中没有发生太大变化。您应遵循安全软件设计的最佳实践，并检查常见安全漏洞的代码。您应该定期搜索第三方库以查找新漏洞。常见漏洞和暴露列表可以提供帮助。</p>
<h4> 威胁建模</h4>
<p>威胁建模是一种识别系统中可能存在的安全威胁的系统方法。首先确定系统中的所有资产（数据库中的用户数据，文件等）以及如何访问它们。之后，您可以识别可能的攻击并开始执行它们。我建议阅读高级API安全性的第2章，以便更好地概述威胁建模。</p>
<h3> 结论</h3>
<p>唯一安全的系统是关闭电源的系统，不连接到任何网络（理想情况下是在一个有形模块中）。它是多么有用的系统！事实是，安全是艰难而昂贵的。分布式系统中有许多组件和链接，每个组件和链接都是恶意用户的可能目标。企业需要平衡攻击的风险和概率与实施预防机制的成本。</p>
<p>攻击者手上有很多耐心和计算能力。我们可以通过使用威胁建模来防止某些类型的攻击，但我们无法保证100％的安全性。因此，向业务部门明确表示这一点是个好主意，共同决定投资安全性的程度，并制定安全漏洞何时发生的计划。</p>
<h2> 5.拓扑不会改变</h2>
<h3> 问题</h3>
<blockquote>
<p>网络拓扑不断变化。</p>
</blockquote>
<p>网络拓扑始终在变化。有时它会因意外原因而发生变化 - 当您的应用服务器出现故障并需要更换时。很多时候它是故意的 - 在新服务器上添加新进程。如今，随着云和容器的增加，这一点更加明显。弹性扩展 - 根据工作负载添加或删除服务器的能力 - 需要一定程度的网络灵活性。</p>
<h3> 解决方案</h3>
<h4> 摘要网络的物理结构</h4>
<p>您需要做的第一件事是抽象网络的物理结构。有几种方法可以做到这一点：</p>
<ul>
<li>停止硬编码IP - 您应该更喜欢使用主机名。通过使用URI，我们依靠DNS将主机名解析为IP。</li>
<li>当DNS不够时（例如，当您需要映射IP和端口时），则使用发现服务。</li>
<li>Service Bus框架还可以提供位置透明性。</li>
</ul>
<h4> 无价值的，而非重要的</h4>
<p>通过将您的服务器视为没有价值的，而不是很重要的，您确保没有服务器是不可替代的。这一点智慧可以帮助您进入正确的思维模式：任何服务器都可能出现故障（从而改变拓扑结构），因此您应该尽可能地自动化。</p>
<h4> 测试</h4>
<p>最后一条建议是测试你的假设。停止服务或关闭服务器，看看您的系统是否仍在运行。像Netflix的Chaos Monkey这样的工具可以通过随机关闭生产环境中的VM或容器来实现这一目标。通过带来痛苦，您更有动力构建一个可以处理拓扑更改的更具弹性的系统。</p>
<h3> 结论</h3>
<p>十年前，大多数拓扑结构并没有经常改变。但是当它发生时，它可能发生在生产中并引入了一些停机时间。如今，随着云和容器的增加，很难忽视这种谬误。你需要为失败做好准备并进行测试。不要等到它在生产中发生！</p>
<h2> 6.有一位管理员</h2>
<h3> 问题</h3>
<blockquote>
<p>这个知道一切的并不存在。</p>
</blockquote>
<p>嗯，这个看起来很明显。当然，没有一个人知道一切。这是一个问题吗？只要应用程序运行顺利，它就不是。但是，当出现问题时，您需要修复它。因为很多人触摸了应用程序，知道如何解决问题的人可能不在那里。</p>
<p>有很多事情可能会出错。一个例子是配置。今天的应用程序在多个商店中存储配置：配置文件，环境变量，数据库，命令行参数。没有人知道每个可能的配置值的影响是什么。</p>
<p>另一件可能出错的事情是系统升级。分布式应用程序有许多移动部件，您需要确保它们是同步的。例如，您需要确保当前版本的代码适用于当前版本的数据库。如今，人们关注DevOps和持续交付。但支持零停机部署并非易事。</p>
<p>但是，至少这些东西都在你的控制之下。许多应用程序与第三方系统交互。这意味着，如果它们失效，你可以做的事情就不多了。因此，即使您的系统有一名管理员，您仍然无法控制第三方系统。</p>
<h3> 解决方案</h3>
<h4> 每个人都应对释放过程负责</h4>
<p>这意味着从一开始就涉及Ops人员或系统管理员。理想情况下，他们将成为团队的一员。尽早让系统管理员了解您的进度可以帮助您发现限制因素。例如，生产环境可能具有与开发环境不同的配置，安全限制，防火墙规则或可用端口。</p>
<h4> 记录和监控</h4>
<p>系统管理员应该拥有用于错误报告和管理问题的正确工具。你应该从一开始就考虑监控。分布式系统应具有集中式日志。访问十个不同服务器上的日志以调查问题是不可接受的方法。</p>
<h4> 解耦</h4>
<p>您应该在系统升级期间争取最少的停机时间。这意味着您应该能够独立升级系统的不同部分。通过使组件向后兼容，您可以在不同时间更新服务器和客户端。</p>
<p>通过在组件之间放置队列，您可以暂时将它们分离。这意味着，例如，即使后端关闭，Web服务器仍然可以接受请求。</p>
<h4> 隔离第三方依赖关系</h4>
<p>您应该以不同于您拥有的组件的方式处理控制之外的系统。这意味着使您的系统更能适应第三方故障。您可以通过引入抽象层来减少外部依赖的影响。这意味着当第三方系统出现故障时，您将找到更少的地方来查找错误。</p>
<h3> 结论</h3>
<p>要解决这个谬论，您需要使系统易于管理。DevOps，日志记录和监控可以提供帮助。您还需要考虑系统的升级过程。如果升级需要数小时的停机时间，则无法部署每个sprint。没有一个管理员，所以每个人都应该对发布过程负责。</p>
<h2> 7.运输成本为零</h2>
<h3> 问题</h3>
<blockquote>
<p>运输成本_不是_零。</p>
</blockquote>
<p>这种谬论与第二个谬误有关，即 延迟为零。通过网络传输内容在时间和资源上都有代价。如果第二个谬误讨论了时间方面，那么谬误＃7就会解决资源消耗问题。</p>
<p>这种谬论有两个不同的方面：</p>
<h4> 网络基础设施的成本</h4>
<p>网络基础设施需要付出代价。服务器，SAN，网络交换机，负载平衡器以及负责此设备的人员 - 所有这些都需要花钱。如果您的系统是在内部部署的，那么您需要预先支付这个价格。如果您正在使用云，那么您只需为您使用的内容付费，但您仍然需要付费。</p>
<h4> 序列化/反序列化的成本</h4>
<p>这种谬误的第二个方面是在传输级别和应用程序级别之间传输数据的成本。序列化和反序列化会消耗CPU时间，因此需要花钱。如果您的应用程序是内部部署的，那么如果您不主动监视资源消耗，则会隐藏此成本。但是，如果您的应用程序部署在云端，那么这笔费用就会非常明显，因为您需要为使用的内容付费。</p>
<h3> 解决方案</h3>
<p>关于基础设施的成本，你无能为力。您只能确保尽可能高效地使用它。SOAP或XML比JSON更昂贵。JSON比像Google的Protocol Buffers这样的二进制协议更昂贵。根据系统的类型，这可能或多或少重要。例如，对于与视频流或VoIP有关的应用，传输成本更为重要。</p>
<h3> 结论</h3>
<p>您应该注意运输成本以及应用程序正在执行的序列化和反序列化程度。这并不意味着您应该优化，除非需要它。您应该对资源消耗进行基准测试和监控，并确定运输成本是否对您有用。</p>
<h2> 8.网络是同质的</h2>
<h3> 问题</h3>
<blockquote>
<p>网络_不是_同质的。</p>
</blockquote>
<p>同质网络是使用类似配置和相同通信协议的计算机网络。拥有类似配置的计算机是一项艰巨的任务。例如，您几乎无法控制哪些移动设备可以连接到您的应用。这就是为什么重点关注标准协议。</p>
<h3> 解决方案</h3>
<p>您应该选择标准格式以避免供应商锁定。这可能意味着XML，JSON或协议缓冲区。有很多选择可供选择。</p>
<h3> 结论</h3>
<p>您需要确保系统的组件可以相互通信。使用专有协议会损害应用程序的互操作性。</p>
<h2> 设计分布式系统很难</h2>
<p>这些谬论发表于20多年前。但他们今天仍然坚持，其中一些比其他人更多。我认为今天许多开发人员都知道它们，但我们编写的代码并没有显示出来。</p>
<p>我们必须接受这些事实：网络不可靠，不安全并且需要花钱。带宽有限。网络的拓扑结构将发生变化。其组件的配置方式不同。意识到这些限制将有助于我们设计更好的分布式系统。</p>
<h2> 参考文章</h2>
<p>原文标题 <a href="https://dzone.com/articles/understanding-the-8-fallacies-of-distributed-syste" target="_blank" rel="noopener noreferrer">《Understanding the 8 Fallacies of Distributed Systems》</a></p>
<p>作者：Victor Chircu</p>
<p>译者：February</p>
<p>译文： <a href="https://cloud.tencent.com/developer/article/1370391" target="_blank" rel="noopener noreferrer">https://cloud.tencent.com/developer/article/1370391</a></p>
]]></content:encoded>
    </item>
    <item>
      <title>什么是分布式系统</title>
      <link>https://liuyueyi.github.io/tutorial/column/arch/distribute/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/03.%E4%BB%80%E4%B9%88%E6%98%AF%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F.html</link>
      <guid>https://liuyueyi.github.io/tutorial/column/arch/distribute/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/03.%E4%BB%80%E4%B9%88%E6%98%AF%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">什么是分布式系统</source>
      <description>分布式的概念存在年头有点久了，在正式进入我们《分布式专栏》之前，感觉有必要来聊一聊，什么是分布式，分布式特点是什么，它又有哪些问题，在了解完这个概念之后，再去看它的架构设计，理论奠基可能帮助会更大 本文将作为专栏的第0篇，将从三个方面来讲述一下我理解的&amp;quot;分布式系统&amp;quot; 分布式系统的特点 分布式系统面临的挑战 如何衡量一个分布式系统 1.分布式系统特点 什么是分布式系统，看一下wiki上的描述 1.1 定义 分布式系统（distributed system）是建立在网络之上的软件系统。正是因为软件的特性，所以分布式系统具有高度的内聚性和透明性。因此，网络和分布式系统之间的区别更多的在于高层软件（特别是操作系统），而不是硬件</description>
      <category>分布式</category>
      <category>设计模式</category>
      <pubDate>Sat, 13 Aug 2022 19:27:54 GMT</pubDate>
      <content:encoded><![CDATA[<p>分布式的概念存在年头有点久了，在正式进入我们《分布式专栏》之前，感觉有必要来聊一聊，什么是分布式，分布式特点是什么，它又有哪些问题，在了解完这个概念之后，再去看它的架构设计，理论奠基可能帮助会更大</p>
<p>本文将作为专栏的第0篇，将从三个方面来讲述一下我理解的"分布式系统"</p>
<ul>
<li>分布式系统的特点</li>
<li>分布式系统面临的挑战</li>
<li>如何衡量一个分布式系统</li>
</ul>
<h2> 1.分布式系统特点</h2>
<p>什么是分布式系统，看一下wiki上的描述</p>
<h3> 1.1 定义</h3>
<p>分布式系统（distributed system）是建立在网络之上的软件系统。正是因为软件的特性，所以分布式系统具有高度的内聚性和透明性。因此，网络和分布式系统之间的区别更多的在于高层软件（特别是操作系统），而不是硬件</p>
<ul>
<li><a href="https://baike.baidu.com/item/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/4905336" target="_blank" rel="noopener noreferrer">分布式系统（建立在网络之上的软件系统）_百度百科</a></li>
</ul>
<p>分布式操作系统（Distributed operating system），是一种软件，它是许多独立的，网络连接的，通讯的，并且物理上分离的计算节点的集合[1]。每个节点包含全局总操作系统的一个特定的软件子集。每个软件子集是两个不同的服务置备的复合物[2]。第一个服务是一个普遍存在的最小的内核，或微内核，直接控制该节点的硬件。第二个服务是协调节点的独立的和协同的活动系统管理组件的更高级别的集合。这些组件抽象微内核功能，和支持用户应用程序[3]。</p>
<ul>
<li><a href="https://zh.m.wikipedia.org/zh-hans/%E5%88%86%E5%B8%83%E5%BC%8F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F" target="_blank" rel="noopener noreferrer">分布式操作系统 - 维基百科，自由的百科全书</a></li>
</ul>
<p>Distributed system: is a system in which components located on networked computers communicate and coordinate their actions by passing messages. The components interact with each other in order to achieve a common goal[3].</p>
<ul>
<li><a href="https://computersciencewiki.org/index.php/Distributed_systems" target="_blank" rel="noopener noreferrer">Distributed systems - Computer Science Wiki</a></li>
</ul>
<p>虽然上面几个描述不完全相同，但是含义其实也差不了太多；基于我个人的理解，用大白话来描述一下分布式系统，就是“一个系统的服务能力，由网络上多个节点共同提供”，正如其名的“分布一词”</p>
<p>在了解完分布式系统的概念之后，接下来抓住其主要特点，来加深这个分布式的理解</p>
<h3> 1.2 分布性</h3>
<p>分布式系统分布在多个节点（可以理解为多个计算机），这些节点可以是网络上任意的一台计算机，即在空间上没有原则性的限制</p>
<h3> 1.3 对等性</h3>
<p>分布式系统中有很多的节点，这些节点之间没有主从、优劣直说，它们应该是对等的，从服务能力来说，访问分布式系统中的任何一个节点，整个服务请求应该都是等价的</p>
<p>看到这里可能就会有一个疑问了，分布式系统中经典主从架构，数据拆分架构，就不满足这个对等特性了啊（这个问题先留着，后续再详情中进行解答）</p>
<h3> 1.4 自治性</h3>
<p>分布式系统中的各个节点都有自己的计算能力，各自具有独立的处理数据的功能。通常，彼此在地位上是平等的，无主次之分，既能自治地进行工作，又能利用共享的通信线路来传送信息，协调任务处理。</p>
<h3> 1.5 并发性</h3>
<p>分布式系统既然存在多个节点，那么天然就存在多个节点的同事响应请求的能力，即并发性支持，如何做好分布式系统的并发控制则是所有分布式系统需要解决的一个问题</p>
<h2> 2. 分布式系统面临的问题</h2>
<p>当系统分布在多个节点之上时，自然而然就带来了很多单机场景下不会有问题，如经典的 <a href="https://hhui.top/%E5%88%86%E5%B8%83%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/02.%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%848%E4%B8%AA%E8%B0%AC%E8%AF%AF/" target="_blank" rel="noopener noreferrer">分布式系统的8个谬误 | 一灰灰Learning</a></p>
<h3> 2.1 全局时钟</h3>
<p>分布式系统的多个节点，如何保证每个节点的时钟一致？这个是需要重点考虑的问题</p>
<p>我们知道大名鼎鼎的分布式主键生成算法 “雪花算法” 就是利用了机器时钟来作为算法因子，如果一个系统的多个节点不能保证时钟统一，那这个算法的唯一性将无法得到保障</p>
<h3> 2.2 网络延迟、异常</h3>
<p>网络是有开销的，多个节点之间的通信是有成本的，既然存在网络的开销、或异常状况，那么如何保证多个节点的数据一致性呢？ 当无法保证数据的一致性时，如何提供分布式系统的对等性呢？</p>
<p>在经典的CAP理论中，对于P（网络分区）一般都是需要保障的，一个系统存在多个计算节点，那么网络问题将不可避免，网络分区必然会存在</p>
<h3> 2.3 数据一致性</h3>
<p>如何保证所有节点中的数据完全一致是一个巨大的挑战，这个问题比较好理解，我们操作分布式系统中的一个节点实现数据修改，如果要保证数据一致性，则要求所有的节点，同步收到这个修改</p>
<p>但是我们需要注意的时，网络是不可靠的，且网络的传输是存在延迟的，如何衡量数据的一致性和服务的可用性则是我们在设计一个分布式系统中需要取舍的</p>
<h3> 2.4 节点异常</h3>
<p>机器宕机属于不可抗力因素，如果分布式系统中的一个节点宕机了，整个系统会怎么样？要如何确保机器宕机也不会影响系统的可用性呢？ 机器恢复之后，又应该如何保证数据的一致性呢？ 又应该如何判断一个节点是否正常呢？</p>
<h3> 2.5 资源竞争</h3>
<p>前面说到分布式系统天然支持并发，那么随之而来的问题则是如何资源竞争的问题；当一个资源同一时刻只允许一个实例访问时，怎么处理？多个系统同时访问一个资源是否会存在数据版本差异性（如经典的ABA问题）、数据一致性问题？</p>
<p>基于这个问题，分布式锁可以说是应运而生，相信各位开发大佬都不会陌生这个知识点</p>
<h3> 2.6 全局协调</h3>
<p>这个协调怎么理解呢？ 举几个简单的实例</p>
<ul>
<li>如何判断分布式系统中那些节点正常提供服务，那些节点故障</li>
<li>如一个任务希望在分布式系统中只执行一次，那么应该哪个节点执行这个任务呢？</li>
<li>如一组有先后顺序的请求发送给分布式系统，但是由于网络问题，可能出现后面的请求先被系统接收到，这种场景怎么处理呢？</li>
<li>一个用户已经登录，如何在所有节点中确认他的身份呢？</li>
</ul>
<h3> 2.7 一灰灰的小结</h3>
<p>实际上分布式系统面临的挑战并不止于上面这些，一个具体的系统面临的问题可能各不相同，但总的来说，分布式系统的理论基础会给我们非常好的指引方向，这一节推荐查看 * <a href="https://hhui.top/%E5%88%86%E5%B8%83%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/01.%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%BB%BC%E8%BF%B0/" target="_blank" rel="noopener noreferrer">分布式设计模式综述 | 一灰灰Learning</a></p>
<h2> 3. 分布式系统的衡量指标</h2>
<p>最后再来看一下如何衡量一个分布式系统的“好差”，它的指标有哪些</p>
<h3> 3.1 性能指标</h3>
<p>常见的性能指标如rt, QPS, TPS来判断一个系统的承载能力，重点关注是哪个要点</p>
<ul>
<li>响应延迟</li>
<li>并发能力</li>
<li>事务处理能力</li>
</ul>
<h3> 3.2 可用性</h3>
<p>这个就是传说中你的系统达到几个9的那个指标，即系统的异常时间占总的可用时间的比例</p>
<p>统的可用性可以用系统停服务的时间与正常服务的时间的比例来衡量，也可以用某功能的失败次数与成功次数的比例来衡量。可用性是分布式的重要指标，衡量了系统的鲁棒性，是系统容错能力的体现。</p>
<h3> 3.3 扩展性</h3>
<p>系统的可扩展性(scalability)指分布式系统通过扩展集群机器规模提高系统性能（吞吐、延迟、并发）、存储容量、计算能力的特性</p>
<p>最简单来讲，就是你的系统能不能直接加机器，来解决性能瓶颈，如果能加机器，有没有上限（如由于数据库的连接数限制了机器的数量上限， 如机器加到某个程度之后，服务能力没有明显提升）</p>
<h3> 3.4 一致性</h3>
<p>分布式系统为了提高可用性，总是不可避免的使用副本的机制，从而引发副本一致性的问题。越是强的一致的性模型，对于用户使用来说使用起来越简单</p>
<h2> 4. 总结</h2>
<p>这一篇文章相对来说比较干燥，全是文字描述，介绍下什么是分布式系统，分布系统的特点及面对的问题和衡量指标，提炼一下关键要素，如下</p>
<p>分布式系统的特点</p>
<ul>
<li>分布性</li>
<li>对等性</li>
<li>并发性</li>
<li>自治性</li>
</ul>
<p>分布式系统面临的挑战</p>
<ul>
<li>全局时钟</li>
<li>网络延迟、异常</li>
<li>数据一致性</li>
<li>节点异常</li>
<li>资源竞争</li>
<li>全局协调</li>
</ul>
<p>分布式系统衡量指标</p>
<ul>
<li>性能指标</li>
<li>可用性</li>
<li>扩展性</li>
<li>一致性</li>
</ul>
<p>最后强烈推荐阅读下面两个万字干货</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247487507&amp;idx=1&amp;sn=9c4ff02747e8335ee5e3c7765cc80b3c&amp;chksm=fce70bbfcb9082a9a8d972af80f19a9b66a5425c949bc400872727cc2da9f401047a5a523ac4&amp;token=1624762777&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">1w5字详细介绍分布式系统的38个技术方案</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247487533&amp;idx=1&amp;sn=cd07d5d601986fd3911858ea5f3a18d4&amp;chksm=fce70b81cb908297fe66eac564028a6c7ef197f8f10921c4dfe05cf8d433b5ee45566099e467&amp;token=1624762777&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">基于MySql,Redis,Mq,ES的高可用方案解析</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>分布式常用的设计模式</title>
      <link>https://liuyueyi.github.io/tutorial/column/arch/distribute/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link>
      <guid>https://liuyueyi.github.io/tutorial/column/arch/distribute/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">分布式常用的设计模式</source>
      <description>分布式系统的设计与实现过程中，常用到的一些协议和设计模式介绍，本专题将作为分布式的理论知识科普，为各位看官打开视野 主要内容将包含并不限于以下内容： 如CAP、BASE，gossip协议 如主从、切片、热备、Leader选举策略等 如一致性hash、布隆过滤器、全局自增序列号、心跳机制等 分布式设计模式综述 分布式系统的8个谬误 什么是分布式系统</description>
      <pubDate>Mon, 29 Jul 2024 08:58:55 GMT</pubDate>
      <content:encoded><![CDATA[<p>分布式系统的设计与实现过程中，常用到的一些协议和设计模式介绍，本专题将作为分布式的理论知识科普，为各位看官打开视野</p>
<p>主要内容将包含并不限于以下内容：</p>
<ul class="task-list-container">
<li>
<p>如CAP、BASE，gossip协议</p>
</li>
<li>
<p>如主从、切片、热备、Leader选举策略等</p>
</li>
<li>
<p>如一致性hash、布隆过滤器、全局自增序列号、心跳机制等</p>
</li>
<li class="task-list-item">
<p><input type="checkbox" class="task-list-item-checkbox" id="task-item-0" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-0"> <a href="01.%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%BB%BC%E8%BF%B0">分布式设计模式综述</a></label></p>
</li>
<li class="task-list-item">
<p><input type="checkbox" class="task-list-item-checkbox" id="task-item-1" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-1"> <a href="02.%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%848%E4%B8%AA%E8%B0%AC%E8%AF%AF">分布式系统的8个谬误</a></label></p>
</li>
<li class="task-list-item">
<p><input type="checkbox" class="task-list-item-checkbox" id="task-item-2" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-2"> <a href="03.%E4%BB%80%E4%B9%88%E6%98%AF%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F">什么是分布式系统</a></label></p>
</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>01.常见的高可用技术方案</title>
      <link>https://liuyueyi.github.io/tutorial/column/arch/distribute/%E9%AB%98%E5%8F%AF%E7%94%A8/01.%E5%B8%B8%E8%A7%81%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88.html</link>
      <guid>https://liuyueyi.github.io/tutorial/column/arch/distribute/%E9%AB%98%E5%8F%AF%E7%94%A8/01.%E5%B8%B8%E8%A7%81%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">01.常见的高可用技术方案</source>
      <description>大家好我是一灰灰，本文将接着前文 1w5字详细介绍分布式系统的那些技术方案 文章基础上，进行实际的案例解析</description>
      <category>分布式</category>
      <category>高可用</category>
      <pubDate>Fri, 08 Jul 2022 08:53:44 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>大家好我是一灰灰，本文将接着前文 <a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247487507&amp;idx=1&amp;sn=9c4ff02747e8335ee5e3c7765cc80b3c&amp;chksm=fce70bbfcb9082a9a8d972af80f19a9b66a5425c949bc400872727cc2da9f401047a5a523ac4&amp;token=309565785&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">1w5字详细介绍分布式系统的那些技术方案</a> 文章基础上，进行实际的案例解析</p>
</blockquote>
<p>高可用对于当下的系统而言，可以说是一个硬指标，常年专注于业务开发的我们，对于高可用最直观的感觉可能就是祈祷应用不要出问题，不要报错；即便有问题，也最好不是我们的业务代码逻辑导致的，如果是服务器、DB、中间件(如注册中心、配置中心等)的异常那就抛给对应的sre, dba；然而常在河边走，哪有不湿鞋，为了保障服务的高可用，我们可以从哪些方面进行努力呢？</p>
<p>本文将作为高可用的开篇，通过简述一些常用的系统的高可用方案，给大家介绍一下我们可以从哪些方面努力让我们的系统达到高可用，主要涉及到的系统如下</p>
<ul>
<li>缓存：Redis</li>
<li>数据库：MySql</li>
<li>消息队列：RabbitMQ</li>
<li>搜索: ElasticSearch</li>
</ul>
<h2> 1 redis高可用策略</h2>
<p>redis广泛应用于缓存的业务场景，当然也有将其当做持久化存储的nosql数据库使用，这些都不重要，重点是redis在提供服务的时候，是如何支持高可用的呢？</p>
<p>redis官方支持了四种策略：</p>
<ul>
<li>数据持久化</li>
<li>主从同步</li>
<li>哨兵模式</li>
<li>集群</li>
</ul>
<p>除以上姿势之外，我们自己在使用时还可以选择根据业务场景使用不同的redis实例（即传说中的不把所有鸡蛋放在一个篮子里）</p>
<p>接下来将针对redis的几种高可用策略进行简述说明</p>
<h3> 1.1 数据持久化</h3>
<blockquote>
<p>官方手册: <a href="https://redis.io/docs/manual/persistence/" target="_blank" rel="noopener noreferrer">Redis persistence</a></p>
</blockquote>
<p>持久化是在高可用、一致性的场景中经常会看到的一种技术手段；</p>
<p>在高可用的场景中，数据的持久化主要是为了解决在服务出现问题（如宕机）之后，可以快速恢复并对外继续提供服务能力；</p>
<p>redis官方提供了两种持久化策略</p>
<ul>
<li>AOF: 将更新的操作命令记录在对应的日志文件中，在重启的时候采用“回放”策略，将所有的命令重新执行一遍来实现场景恢复</li>
<li>RDB: 定时存储redis中的数据快照到数据文件中，在重启的时候，加载rdb文件，恢复所有的数据</li>
</ul>
<p>简单来讲AOF记录的是操作动作，采用回放执行的机制进行恢复；RDB则相当于数据落盘，重新读取加载的机制进行恢复</p>
<p><strong>注：AOF RDB可以一起工作，没有排他性</strong></p>
<h3> 1.2 主从方式</h3>
<p>虽然redis性能爆炸，但是单机依然存在性能瓶颈；当我们遇到单机的性能瓶颈的时候，一般怎么做？</p>
<p>没错，加机器</p>
<p>redis也支持多机服务，比如常见的一主多从策略：</p>
<ul>
<li>主机：提供读写能力</li>
<li>从机：只提供读</li>
</ul>
<p>针对绝大多数读多写少的场景，我们可以起多个redis实例，其中一个设置为主，提供所有的写请求；其他的实例则设置为从，客户端通过负载策略路由到不同的从redis，从而实现流量分摊；</p>
<p>同时也因为有多个实例，所以单台或几台实例下线，对整个服务的可用性影响并不会太大（及时摘除故障机器，其他的实例依然可以正常提供服务；当然前提是流量所示太大把其他的实例也打挂，那就gg了）</p>
<figure><img src="/imgs/column/distribute/220708/redis00.jpg" alt="redis主从模式" tabindex="0" loading="lazy"><figcaption>redis主从模式</figcaption></figure>
<p>主从模式还有一个变种，叫做从从模式，主要是为了解决主redis的同步压力，改成主 -&gt; 从，然后由一个从同步给其他的从实例，具体架构图如下</p>
<figure><img src="/imgs/column/distribute/220708/redis01.jpg" alt="redis主从从模式" tabindex="0" loading="lazy"><figcaption>redis主从从模式</figcaption></figure>
<p>使用主从、主从从模式实现高可用可算是分布式系统的经典策略，其主要思想在于：</p>
<ul>
<li>多实例提供服务，实现负载均衡</li>
<li>每个实例<strong>冗余</strong>一份全量数据</li>
</ul>
<h3> 1.3 哨兵模式</h3>
<blockquote>
<p>官方手册: <a href="https://redis.io/docs/manual/sentinel/" target="_blank" rel="noopener noreferrer">High availability with Redis Sentinel</a></p>
</blockquote>
<p>哨兵模式主要是为了解决主从模式中，主机宕机的场景，由于主机本身存在单点，所以主节点对成了高可用的关键因素了；那么如果实现主节点宕机之后，自动选择一个新的主节点，这样不就可以提高系统的可用性了么； redis官方提供的机制就是 - 哨兵模式</p>
<p>主要工作原理：</p>
<ul>
<li>哨兵：监听redis实例，判断是否存活（不太对外提供服务能力）</li>
<li>通过 PING 命令，检查与主从服务器之间的连接情况，若正常相应，则认为存活；否则认为<code>主观下线</code></li>
<li>当 <code>n/2 + 1</code>半数以上哨兵认为主节点下线，则认为主节点<code>客观下线</code>，尝试选新的主节点</li>
<li>从所有从节点中，选择与之前主库相似度最高的从节点作为新的主库</li>
</ul>
<figure><img src="/imgs/column/distribute/220708/redis02.jpg" alt="哨兵模式" tabindex="0" loading="lazy"><figcaption>哨兵模式</figcaption></figure>
<p>哨兵模式，可以理解为探活 + 选主，而这也常见于各大分布式系统的技术方案中</p>
<h3> 1.4 集群模式</h3>
<blockquote>
<p>官方手册: <a href="https://redis.io/docs/manual/scaling/" target="_blank" rel="noopener noreferrer">Scaling with Redis Cluster</a></p>
</blockquote>
<p>相比于主从模式的全量冗余，redis的集群策略在在于数据分片，每个实例上存储部分的数据；而不是全量数据，从而解决数据量大的场景下，对于redis服务本身以及数据同步的压力</p>
<p>集群模式的特点在于多个实例，构建成一个实例，每个实例上存储部分的数据；redis并没有采用一致性hash来做数据分布，而是使用特有的slots插槽机制，来实现数据的hash映射</p>
<figure><img src="/imgs/column/distribute/220708/redis03.jpg" alt="集群模式" tabindex="0" loading="lazy"><figcaption>集群模式</figcaption></figure>
<p>集群模式，主要特点在于数据分片，每个实例存部分数据，其思路在于<strong>拆分</strong></p>
<p>从上面的图中也可以看出，集群一般与主从搭配使用，集群中的每个分片对应的是主从模式的redis服务，从而加强高可用</p>
<h3> 1.5 小结</h3>
<p>这一节主要介绍的是redis的高可用策略，从中也可以看到很多经典的技术方案</p>
<ul>
<li>持久化：RDB数据落盘加载方式 + AOF记录操作命令用于回放策略</li>
<li>主从，主从从：全量数据冗余、读写请求分离，负载均衡的思想；核心问题在于主节点挂掉之后需要人工参与手动指定主库</li>
<li>哨兵机制：PING/PONG的探活机制，监听主节点，宕机之后自动选主，确保高可用；核心问题在于所有的实例冗余相同的一份数据，数据量大时不友好</li>
<li>集群：数据分片，每个实例提供部分服务能力</li>
</ul>
<p>看到这里的小伙伴自然会想到，为什么redis会提供这些不同的策略？它们各自的应用场景是什么，优缺点是啥？这些疑问就放在后续的redis高可用详解中介绍</p>
<p>相关博文：</p>
<ul>
<li><a href="https://redis.io/docs/manual/scaling/" target="_blank" rel="noopener noreferrer">Scaling with Redis Cluster | Redis</a></li>
<li><a href="https://mp.weixin.qq.com/s/gofXUXKD_ZelbOJDinHs4g" target="_blank" rel="noopener noreferrer">Redis高可用策略 - 楼仔</a></li>
<li><a href="https://xie.infoq.cn/article/6c3500c66c3cdee3d72b88780" target="_blank" rel="noopener noreferrer">redis系列之——高可用（主从、哨兵、集群）诸葛小猿</a></li>
</ul>
<h2> 2 MySql高可用策略</h2>
<p>MySql数据库的高可用策略就比较多了，同样也非常的经典；仅仅主节点的保活策略就非常多了；在这里将主要的重心放在MySql的高可用架构主备、主从、一主多从，多主多从上，至于主节点故障时转移策略则放在后续详细的文章中进行介绍</p>
<h3> 2.1 数据持久化</h3>
<p>对于每个开发者而言，大多都听说过数据库的ACID特性，其中的D对应的就是这里说到的持久化；区别于redis的持久化，以MySql的InnoDB引擎为例，其持久化涉及到多个日志文件(undo log,redo log,binlog)，缓存区(buffer)，磁盘(idb文件)</p>
<p>接下来看一下完整的数据更新/插入的流程</p>
<figure><img src="/imgs/column/distribute/220708/mysql00.jpg" alt="mysql数据持久化流程图" tabindex="0" loading="lazy"><figcaption>mysql数据持久化流程图</figcaption></figure>
<p>接下来描述一下核心思想：</p>
<ul>
<li>数据更新策略：总是更新缓存的内容（缓存未命中，则从磁盘加载到缓存）</li>
<li>先写undolog日志文件：记录之前的数据，支持mvcc、支持回滚就靠它</li>
<li>redolog记录的两阶段提交：（先是prepare，待binlog写完之后，再次更新状态为commit）</li>
<li>最后异步刷新缓存数据到磁盘</li>
</ul>
<p>虽然上面的描述比较简单，但是这里的知识点非常多，如</p>
<ul>
<li>为什么先更新缓存，最后异步刷磁盘？
<ul>
<li>核心在于操作内存的速度 &gt;&gt; 操作磁盘</li>
</ul>
</li>
<li>undolog作用是什么，怎么支持mvcc，实现事务回滚的？
<ul>
<li>保障事务原子性的关键所在，数据行非主键变更时，记录修改前的数据到undolog，并指向它，其他sql读这个undolog中的副本数据从而支持mvcc，回滚时则是根据undo log进行逻辑恢复</li>
</ul>
</li>
<li>redolog作用是什么，为什么两阶段方案？
<ul>
<li>主要保障事务的持久性，当数据库异常宕机之后，可以通过重新执行redo log来恢复未及时落盘的数据；两阶段的主要目的是为了解决redolog与binlog的一致性问题，避免出现redolog第一阶段成功，但是binlog失败导致不一致问题</li>
<li>redolog属于innodb引擎，固定大小，环形结构覆盖写策略；内部同样是先写缓存，再刷磁盘的策略</li>
</ul>
</li>
</ul>
<p>更多详情内容，后面到mysql的专题时再详细介绍</p>
<h3> 2.2 主备架构</h3>
<p>保证高可用的一个最简单策略就是“冗余”，也就是我们这里说到的主备架构，对mysql而言，就是我启动两个实例；一个主库对外提供读写服务，一个备库，冗余主库的所有数据内容，并不对外提供服务；</p>
<p>当主库gg之后，然后备库升级，切换为主库</p>
<blockquote>
<p>话说这个思想和古代的储君制非常像了，平时都是皇帝总领朝堂，太子就当吉祥物；皇帝驾崩之后，太子就晋升为皇帝（论备胎的重要性）</p>
</blockquote>
<figure><img src="/imgs/column/distribute/220708/mysql01.jpg" alt="MySql主备" tabindex="0" loading="lazy"><figcaption>MySql主备</figcaption></figure>
<p>主备的最大特点就是多备一台实例，在出问题时顶上，当然缺点就很明显了，严重的资源浪费</p>
<h3> 2.3 主从架构</h3>
<p>主从和前面mysql的思路差不多，主从模式一般又叫做读写分离，即写主库，读从库；相比于主备而言，最主要的突破点在于另外一个mysql实例不会干放着，而是尤其来承担读请求</p>
<figure><img src="/imgs/column/distribute/220708/mysql02.jpg" alt="MySql主从" tabindex="0" loading="lazy"><figcaption>MySql主从</figcaption></figure>
<p>主从的核心思想在于读写分离</p>
<h3> 2.4 一主多从</h3>
<p>在前面主从的基础上多挂几个从库，主要出发点在于当前的互联网场景下，绝大多数的应用都是读多写少，通过挂多个从库，可以有效提供整体服务的性能指标</p>
<p>同样一主多从的模式，也会区分为主从 + 主从从两种，后者则主要是为了减少主库的同步压力，下图为核心4架构模型</p>
<figure><img src="/imgs/column/distribute/220708/mysql03.jpg" alt="MySql主从" tabindex="0" loading="lazy"><figcaption>MySql主从</figcaption></figure>
<h3> 2.5 多主多从</h3>
<p>一主多从可以解决读多写少的场景，但总会出现写瓶颈的场景；在不考虑分库分表的业务手段之前（这种方式也可以理解为数据分片，类似上面说到的redis集群模式），仅仅从mysql的架构模式出发，自然会想到的策略就是多个主库提供写能力，这就是我们说的多主多从的架构了</p>
<figure><img src="/imgs/column/distribute/220708/mysql04.jpg" alt="MySql主从" tabindex="0" loading="lazy"><figcaption>MySql主从</figcaption></figure>
<p>多主多从，其中每个主库都可以独立对外提供写请求；从库则对外提供读请求</p>
<p>需要注意的是主库之间的数据同步，即一个写请求落到一个任意一个主库之后，所有的主库都会同步这个写操作</p>
<h3> 2.6 主库切换策略、主从同步策略</h3>
<p>前面介绍的是几种不同的主从架构特点，主要通过主、备/从来新增实例来提高可用性；但是还有两个非常重要的点没有细说，一个是故障之后，如何确定新的主库；另外一个则是主从/主主之间的数据如何同步，如何保证数据的一致性；</p>
<p>接下来我们将简单的介绍下mysql中常见的一些做法（更详细的当然留在后面的专题）</p>
<h4> 主库切换策略</h4>
<p><strong>VIP + KeepAlived</strong></p>
<ul>
<li>vip: 即virtual ip虚拟ip</li>
<li>KeepAlived: 保活脚本</li>
</ul>
<p>其主要思路在于外部通过VIP访问mysql实例(主从/主主)，而KeepAlived用于检测主库是否存活，当挂掉之后，VIP偏移到另外一个主库（或者选一个从库作为主库）上，从而实现自动的切主流程</p>
<p>缺点：</p>
<ul>
<li>级联复制(主-&gt;从-&gt;从这种复制模式叫做级联复制)或者一主多从在切换之后，其他从实例需要重新配置连接新主</li>
</ul>
<p><strong>MHA</strong></p>
<p>Master High Avaliable 主库高可用机制，也是当下很多公司采用的策略；其包含一套完整的工具，在检测到主库不可用后，会自动将同步到最接近主库的slave提升为master，然后将其他的slave指向新的master</p>
<p>其优点非常明显，通常可以实现十秒内的主从切换，扩展MySql节点也非常方便；而缺点则在于主要监控主库</p>
<p><strong>MXC</strong></p>
<p>PXC（Percona XtraDB Cluster）是一个完全开源的 MySQL 高可用解决方案。它将 Percona Server、Percona XtraBackup 与 Galera 库集成在一起，以实现多主复制的 MySQL 集群</p>
<p>其核心特点在于写请求会自动同步到其他节点，要求在所有的节点都验证之后才会提交，保证数据的强一致性</p>
<p>因此缺点就在于木桶效应，性能取决于最差的那个节点</p>
<p><strong>MGR/InnoDB Cluste</strong></p>
<p>MySQL 5.7 推出了 MGR（MySQL Group Replication），与 PXC 类似，也实现了多节点数据写入和强一致性的特点。MGR 采用 GCS（Group Communication System）协议同步数据，GCS 可保证消息的原子性</p>
<p>外部连接通过 MySql router与一组mysql实例进行交互，当主库切换时，mysql router会自动切换到新的主节点</p>
<p><strong>Xenon</strong></p>
<p>给予Raft协议的MySql高可用和复制性管理工具，无中心化选主，支持秒级切换</p>
<h4> 主从同步策略</h4>
<p>当存在主从库时，必然会存在同步问题，如何保障主库与从库数据的一致性呢？</p>
<p><strong>主从同步流程</strong></p>
<p>主从同步主要借助Binlog来实现，这个在前面的图中有简单的体现，下面则是相对完整的同步流程</p>
<figure><img src="/imgs/column/distribute/220708/mysql05.jpg" alt="MySql主从数据同步" tabindex="0" loading="lazy"><figcaption>MySql主从数据同步</figcaption></figure>
<ul>
<li>主库生成binlog日志文件
<ul>
<li>statement:记录具体引起改动的操作语句，比如insert xxxxx，缺点是某些函数会导致数据不一致（如now()）</li>
<li>row:基于数据行的，原来数据行是xx值改为了yy 值，缺点是数据量大</li>
<li>mixed: 上面两个混用</li>
</ul>
</li>
<li>从库的io线程拉主库的binlog日志，写入自己的relaylog(中继日志)，然后由sql线程读取relaylog日志进行回放，实现数据同步</li>
</ul>
<p><strong>主从同步策略</strong></p>
<p>使用主从之后，在实际的业务开发中，最最常遇到的问题就是主从延迟，即主库数据已经写入了，但是读从库却读不到对应的数据，这个就是主从延迟了，它直接导致数据的不一致；当然一般这种影响还好，但是如果因为主从延迟，现在主库挂了，所有的从库都没有最新的记录，这不就导致数据丢失了么，会导致严重的数据一致性问题</p>
<p>所以在主从同步的策略上，有下面几种</p>
<p>case1:异步复制</p>
<p>主库完成写请求之后，理解返回结果，并不关心从库是否同步接收处理，此时就可能出现上面说的，主库挂了之后，所有从库还存在未同步的数据，导致数据丢失</p>
<p>case2:半同步复制</p>
<p>为了避免出现上面的问题，我们要求最少有一个从库同步完之后，才响应用户端请求，这样表明主库宕机之后还有个兜底的</p>
<p>case3:全同步复制</p>
<p>这个更激进一点，要求所有的从库都同步完，才算真正的ok，保证强一致性，缺点则在于性能会受到影响</p>
<h3> 2.7 小结</h3>
<p>这一小节主要介绍的是MySql的高可用策略，从架构方面出发，有主备，主从，一主多从，多主多从，同时也简单的介绍了下如何实现主库的自动切换(MHA,MXC,MGR等)、主从数据同步流程，同步策略；如果想了解更详细的内容，请移步到mysql的高可用专题</p>
<p>下面小结一下保持高可用的主要思路</p>
<ul>
<li>通过冗余来实现高可用：如主备</li>
<li>读写分离，实现负载均衡：主从、主从从模式</li>
<li>数据持久化策略：操作内存(buffer)，异步刷盘，两阶段提交保障一致性</li>
</ul>
<p>相关博文:</p>
<ul>
<li><a href="https://dev.mysql.com/doc/refman/8.0/en/mysql-innodb-cluster-introduction.html" target="_blank" rel="noopener noreferrer">官方文档 InnoDB Cluster</a></li>
<li><a href="https://www.php.cn/mysql-tutorials-488418.html" target="_blank" rel="noopener noreferrer">读完搞懂MySQL持久化和回滚（图文详解）-mysql教程</a></li>
<li><a href="https://mp.weixin.qq.com/s/3ICMQUF_vQpuDm2nHi1qqw" target="_blank" rel="noopener noreferrer">MySQL 常用高可用方案</a></li>
<li><a href="https://blog.csdn.net/weixin_47019016/article/details/114740096" target="_blank" rel="noopener noreferrer">MySQL高可用之PXC详解_现实如此呀的博客-CSDN博客_pxc</a></li>
<li><a href="https://www.51cto.com/article/606556.html" target="_blank" rel="noopener noreferrer">一文看懂MySQL的异步复制、全同步复制与半同步复制</a></li>
</ul>
<h2> 3. RabbitMq高可用方案</h2>
<p>消息中间件也是大家或多或少会接触的一类系统，接下来将以RabbitMq来看一下它的高可用是如何实现的</p>
<h3> 3.1 数据持久化</h3>
<p>不同于前面MySql必然会持久化，RabbitMq的数据持久化是可选的，当我们对数据的完整性要求高时，最好开启持久化</p>
<p>首先简单看一下rabbitmq的模型</p>
<figure><img src="/imgs/column/distribute/220708/rabbitmq00.jpg" alt="RabbitMq架构" tabindex="0" loading="lazy"><figcaption>RabbitMq架构</figcaption></figure>
<p>我们这里说的持久化主要指</p>
<ul>
<li>exchange持久化: 即exchange本身不会因为rabbitmq宕机而被删除，需要手动指定durable=true</li>
<li>topic持久化：消费者通过topic从exchange中读取消息，需要指定durable=true，避免出现宕机后队列中的消息丢失</li>
<li>msg消息持久化：即生产者投递到echange的消息，需要持久化到磁盘</li>
</ul>
<p>注意rabbitmq的消息持久化也是先写到buffer，然后再定时刷新到磁盘；</p>
<p>当我们为了保障数据的完整性时，一般会开启消息的确认机制/事务机制，每次投递等到mq回复一个确认ack之后，才表示真正的投递成功，而mq的应答则是在消息的持久化之后进行</p>
<h3> 3.2 主备模式</h3>
<p>同前面的MySql的主备，主节点提供读写，备节点同步主节点的数据，不对外提供服务能力；当主节点挂了之后，启用备节点对外服务，原主节点恢复之后则作为备节点存在</p>
<h3> 3.3 Shovel远程模式</h3>
<blockquote>
<p>官方文档： * <a href="https://www.rabbitmq.com/shovel.html" target="_blank" rel="noopener noreferrer">Shovel Plugin — RabbitMQ</a></p>
</blockquote>
<p>远程模式可以实现双活的一种模式，简称 shovel 模式，所谓的 shovel 就是把消息进行不同数据中心的复制工作，可以跨地域的让两个 MQ 集群互联，远距离通信和复制。</p>
<ul>
<li>Shovel 就是我们可以把消息进行数据中心的复制工作，我们可以跨地域的让两个 MQ 集群互联。</li>
</ul>
<figure><img src="/imgs/column/distribute/220708/rabbitmq01.jpg" alt="RabbitMq远程模式" tabindex="0" loading="lazy"><figcaption>RabbitMq远程模式</figcaption></figure>
<p>如上图，有两个异地的 MQ 集群（可以是更多的集群），当用户在地区 1 这里下单了，系统发消息到 1 区的 MQ 服务器，发现 MQ 服务已超过设定的阈值，负载过高，这条消息就会被转到 地区 2 的 MQ 服务器上，由 2 区的去执行后面的业务逻辑，相当于分摊我们的服务压力。</p>
<h3> 3.4 镜像模式</h3>
<p>如下图，用 KeepAlived 做了 HA-Proxy 的高可用，然后有 3 个节点的 MQ 服务，消息发送到主节点上，主节点通过 mirror 队列把数据同步到其他的 MQ 节点，这样来实现其高可靠</p>
<figure><img src="/imgs/column/distribute/220708/rabbitmq02.jpg" alt="RabbitMq镜像模式" tabindex="0" loading="lazy"><figcaption>RabbitMq镜像模式</figcaption></figure>
<p>镜像模式的主要特点在于每个mq实例都包含一份完整的数据镜像，内部有一个master选举算法，通过VIP对外提供连接</p>
<ul>
<li>consumer，任意连接一个节点，若连上的不是master，请求会转发给master，为了保证消息的可靠性，consumer回复ack给master后，master删除消息并广播所有的slaver去删除。</li>
<li>publisher ，任意连接一个节点，若连上的不是master，则转发给master，由master存储并转发给其他的slaver存储。
如果master挂掉，则从slaver中选择消息队列最长的为master，</li>
</ul>
<h3> 3.5 普通集群模式</h3>
<p>exchange，buindling再所有的节点上都会保存一份，但是queue只会存储在其中的一个节点上，但是所有的节点都会存储一份queue的meta信息</p>
<p>如果生产者连接的是另外一个节点，将会把消息转发到存储该队列的节点上。如果消费者连接了非存储队列的节点取数据，则从存储消息的节点拉取数据。</p>
<p>其核心特点在于：</p>
<ul>
<li>数据拆分存储，若纯消息的节点挂了，则只能等待它恢复之后才能正常工作</li>
</ul>
<h3> 3.6 多活模式</h3>
<blockquote>
<p>这个模式我的理解也不够深刻，以下内容来自于网上摘录，待后面到rabbitmq专题之后调研后进一步阐述</p>
</blockquote>
<p>rabbitMQ 部署架构采用双中心模式(多中心)，那么在两套(或多套)数据中心各部署一套 rabbitMQ 集群，各中心的rabbitMQ 服务除了需要为业务提供正常的消息服务外，中心之间还需要实现部分队列消息共享</p>
<figure><img src="/imgs/column/distribute/220708/rabbitmq03.jpg" alt="RabbitMq镜像模式" tabindex="0" loading="lazy"><figcaption>RabbitMq镜像模式</figcaption></figure>
<p>federation 插件是一个不需要构建 cluster ，而在 brokers 之间传输消息的高性能插件，federation 插件可以在 brokers 或者 cluster 之间传输消息，连接的双方可以使用不同的 users 和 virtual hosts，双方也可以使用不同版本的 rabbitMQ 和 erlang。</p>
<p>federation 插件使用 AMQP 协议通信，可以接受不连续的传输。federation 不是建立在集群上的，而是建立在单个节点上的，如图上黄色的 rabbit node 3 可以与绿色的 node1、node2、node3 中的任意一个利用 federation 插件进行数据同步。</p>
<h3> 3.7 小结</h3>
<p>rabbitmq的高可用机制的方案也比较好理解</p>
<ul>
<li>主备模式</li>
<li>镜像模式：全量冗余一份数据，主对外提供服务，可以实现自动切主</li>
<li>普通集群模式：数据拆分到集群的实例中，consumer/publisher连接到实例之后，会从具体持有exchange/topic的实例上拉数据</li>
<li>远程模式：适用于多中心的场景，将消息转发给其他中心的实例</li>
</ul>
<p>这里采用的高可用思路也无外乎常见的几种：持久化 + 数据冗余 + 拆分</p>
<p>相关博文：</p>
<ul>
<li><a href="https://spring.hhui.top/spring-blog/2020/02/12/200212-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B9%8BRabbitMq%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%E5%B0%8F%E7%BB%93/" target="_blank" rel="noopener noreferrer">【MQ系列】RabbitMq核心知识点小结 | 一灰灰Blog</a></li>
<li><a href="https://www.jianshu.com/p/b7cc32b94d2a" target="_blank" rel="noopener noreferrer">RabbitMQ 的4种集群架构</a></li>
<li><a href="http://www.liaoqiqi.com/post/215" target="_blank" rel="noopener noreferrer">rabbitmq消息一致性问题 - Knight's Blog</a></li>
</ul>
<h2> 4. ElasticSearch高可用方案</h2>
<p>接下来我们再看一下现在非常流行的分布式搜索引擎ElasticSearch是如何保证高可用的</p>
<h3> 4.1 集群</h3>
<blockquote>
<p>Elasticsearch 是一个分布式、RESTful 风格的搜索和数据分析引擎</p>
<p>by 官网描述</p>
</blockquote>
<p>对于es而言，通常都是集群方式对外提供服务，每启动一个实例叫做一个节点(Node)，每个节点会定义一个节点名(Node Name)，集群名(Cluster Name)，相同集群名的节点会构建为一个集群；</p>
<figure><img src="/imgs/column/distribute/220708/es00.jpg" alt="ES集群" tabindex="0" loading="lazy"><figcaption>ES集群</figcaption></figure>
<p>上图包含了es集群的核心要素：</p>
<ul>
<li>每个节点包含集群名 + 节点名两个属性，相同集群名的节点挂在一个集群内</li>
<li>节点启动之后，开始PING其他节点（连接上后会得到对应节点所在集群的所有信息）</li>
<li>节点发现主要靠Zen Discover来实现，选举也是靠它来实现</li>
</ul>
<p>选举主要流程如下</p>
<figure><img src="/imgs/column/distribute/220708/es01.jpg" alt="ES选举" tabindex="0" loading="lazy"><figcaption>ES选举</figcaption></figure>
<ul>
<li>选举同样也是依赖Zen Discover来实现</li>
<li>每个节点上报自己任务的主节点，然后票数最多的就是主节点；票数相同的情况下，根据ID排序，选第一个</li>
</ul>
<p>上面就是es集群的构建与主节点的选举过程；es支持任意节点数目的集群（1- N），无法完全依赖投票的机制来选主，而是通过一个规则。</p>
<p>只要所有的节点都遵循同样的规则，得到的信息都是对等的，选出来的主节点肯定是一致的。</p>
<p>但分布式系统的问题就出在信息不对等的情况，这时候很容易出现脑裂（Split-Brain）的问题。</p>
<p>大多数解决方案就是设置一个 Quorum 值，要求可用节点必须大于 Quorum（一般是超过半数节点），才能对外提供服务。而 Elasticsearch 中，这个 Quorum 的配置就是 <code>discovery.zen.minimum_master_nodes</code>，当<strong>候选主节点</strong>的个数超过这个参数值时，开始选举，选主完成之后对外提供服务</p>
<p>ES作为分布式、近实时搜索系统，天然支持集群的服务能力，通过Zen Discover来实现节点通信、集群管理、选主</p>
<h3> 4.2 脑裂问题</h3>
<p>上面提到了脑裂，接下来简单看一下ES是如何解决脑裂问题的</p>
<blockquote>
<p>脑裂：由于网络或者集群健康监测问题，导致整个集群出现多个master节点，这种现象就是脑裂</p>
</blockquote>
<p>es对节点进行了角色划分</p>
<ul>
<li>数据节点：负责数据的存储和相关的操作(CURD，聚合)等，因此对机器性能要求较高</li>
<li>候选主节点：拥有选举权和被选举权，主节点在候选主节点中评选出来，负责创建索引、删除索引、跟踪哪些节点是群集的一部分，并决定哪些分片分配给哪些的节点、追踪集群中节点的状态等</li>
</ul>
<blockquote>
<p>一个节点，可以即是数据节点，又是候选主节点，但是注意它们两者的定位，主节点对机器性能要求没有数据节点高，当一台机器既是数据节点又是主节点时，可能出现长耗时、耗资源的请求导致主节点服务异常；</p>
<p>通常更推荐的方案是使用性能低一点的作为候选主节点，性能高的作为数据节点</p>
</blockquote>
<figure><img src="/imgs/column/distribute/220708/es02.jpg" alt="ES角色划分" tabindex="0" loading="lazy"><figcaption>ES角色划分</figcaption></figure>
<p>接下来看下脑裂出现的情况</p>
<ul>
<li>网络问题，导致分区：即部分节点连接不到主节点，认为它挂了，然后选举出现的主节点</li>
<li>主节点负载、响应延迟：主节点由于负载过高、或者响应超时，导致重新选举新的主节点</li>
</ul>
<p>解决方案：</p>
<ul>
<li>适当调大ping timeout响应时间，避免因为网络、主节点性能问题导致的选举</li>
<li>设置最少选举节点数大于候选主节点的半数，这样只要有半数以上的候选节点存活，则可以选举出一个主节点；而当可用节点数小于半数时，不参与选举，集群无法使用，也不会出现状态异常的情况</li>
<li>角色分离：数据节点 + 候选主节点不放在一台机器上；</li>
</ul>
<p>在有主节点的系统中，一般都需要考虑脑裂问题，常见的策略无非是：</p>
<ul>
<li>半数节点以上的投票才算有效</li>
<li>es额外提供了节点的角色定位，数据节点和候选主节点，其中只有候选主节点才有选举权和被选举权，提供一种角色分离的可选方案，来避免主节点被其他数据服务影响</li>
</ul>
<h3> 4.3 数据分片</h3>
<p>当数据量过大时，es支持自动拆分，将一个索引的上数据水平拆分到不同的数据块--分片(Shards)，为了提供可用性，每个索引在定义时除了分片之外，还会定义副本数量，这里的副本可以理解为数据冗余，其中副本和分片必然不在一个节点上，在主节点异常时，副本可以提供数据查询能力</p>
<blockquote>
<p>es默认在创建索引时，分片数为5，每个分片对应一个副本</p>
</blockquote>
<figure><img src="/imgs/column/distribute/220708/es03.jpg" alt="ES分片" tabindex="0" loading="lazy"><figcaption>ES分片</figcaption></figure>
<p>ES通过分片，将索引数据水平拆分，分片数越多，每个分片上的数据量就越少；而副本则是对应的每个分片的冗余，可以理解为主备，副本越多，消耗则越大</p>
<p>两点小说明</p>
<ul>
<li>对应副本的概念，上面的分片也叫做主分片</li>
<li>当一个数据写入/更新到分片时，只有所有的副本都更新完毕之后，才算完成（可以MySql的全同步）</li>
</ul>
<h3> 4.4 数据持久化</h3>
<p>最后再说一下es的持久化机制，与前面先说持久化不同，es这里则需要先了解上面的基本流程，索引数据需要保存到主分片上，最终落盘，接下来看一下完整的流程</p>
<p><strong>主分片数据更新流程</strong></p>
<figure><img src="/imgs/column/distribute/220708/es04.jpg" alt="ES数据更新流程" tabindex="0" loading="lazy"><figcaption>ES数据更新流程</figcaption></figure>
<p>简述一下上面的流程</p>
<ul>
<li>首先请求随机连一个es节点（这个节点叫做协调节点），然后通过路由算法，确定数据对应的主分片</li>
<li>写数据到主分片，然后同步到副本（多个副本时采用并发同步，乐观锁控制）</li>
<li>所有副本同步完成之后，主分片节点告诉协调节点最终结果，然后协调节点告诉调用者响应</li>
</ul>
<p>当数据写入到主分片上之后，接下来再看一下这个数据时如何刷新到磁盘上的</p>
<p><strong>分段存储</strong></p>
<p>索引文档以段的形式存储磁盘，即一个索引文件会划分为很多个子文件，这里的子文件就是段</p>
<blockquote>
<p>每一个段本身都是一个倒排索引，并且段具有不变性，一旦索引的数据被写入硬盘，就不可再修改；段被写入到磁盘后会生成一个提交点，提交点是一个用来记录所有提交后段信息的文件</p>
</blockquote>
<p>段的特性，有下面几个有点</p>
<ul>
<li>分段存储，可以有效避免读写时加锁的问题</li>
<li>不变性，数据只读可以高效缓存，无需考虑更新</li>
<li>一个段一旦拥有了提交点，就说明这个段只有读的权限，失去了写的权限。相反，当段在内存中时，就只有写的权限，而不具备读数据的权限，意味着不能被检索</li>
</ul>
<p>由于段不可变，所以在更新时需要额外处理</p>
<ul>
<li>新增：当前文档新增一个段</li>
<li>删除：新增一个.del文件，记录被删除的文档信息；被标记删除的文档仍然可以被检索到，只是最终返回时被移除</li>
<li>更新：删除文件中标记旧的文档删除，插入新的段</li>
</ul>
<p><strong>延迟写</strong></p>
<p>ES并不会实时将内存中的数据写入段，而是采用延迟写的策略（类似前面的写buffer，然后异步定时刷盘）</p>
<p>es先将内存数据，写入文件缓存系统(操作系统内存)，</p>
<figure><img src="/imgs/column/distribute/220708/es05.jpg" alt="ES文档写入流程" tabindex="0" loading="lazy"><figcaption>ES文档写入流程</figcaption></figure>
<blockquote>
<p>上图来自 * <a href="https://mp.weixin.qq.com/s/gvSNazpxAE78v0J7DP9K1g" target="_blank" rel="noopener noreferrer">两万字教程，带你遨游ElasticSearch</a></p>
</blockquote>
<p>注意几个事项</p>
<ul>
<li>写入文件缓存系统，之后异步落盘，可能导致丢数据，es采用事务日志的方式来处理恢复策略(即mysql的先写日志，崩溃之后做回放恢复)</li>
<li>es对外服务时，检索文件缓存系统 + 段中的文档，而内存中的数据不会被检索到（所以所es是近实时搜索引擎，因为最新写入的数据还在内存中，没有提交，立马查就查不到）</li>
<li>为了避免段过多，es会定时做合并，将很多小的段合并成大的段（合并过程中会自动移除被标记删除的文档）</li>
</ul>
<p>最后小结一下es的持久化</p>
<ul>
<li>索引分段存储，段生成checkpoint之后，则只读，因此可以全量缓存，不用考虑更新修改</li>
<li>延迟写策略：先更新内存数据，异步提交文件缓存系统，最后再由操作系统刷盘</li>
<li>内存中的数据不能被检索；文件缓存 + 段中的数据提供查询聚合，最终的结果会过滤已标记删除的文档</li>
</ul>
<p><strong>参考博文</strong></p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/gvSNazpxAE78v0J7DP9K1g" target="_blank" rel="noopener noreferrer">两万字教程，带你遨游ElasticSearch</a></li>
<li><a href="https://xie.infoq.cn/article/55095e9626718380c4072f5fb" target="_blank" rel="noopener noreferrer">ElasticSearch原理解析_elasticsearch_Chank</a></li>
</ul>
<h3> 4.5 小结</h3>
<p>这一小节主要介绍的是ES的高可用机制，包括ES的集群工作原理，选举策略；采用数据分片支持大数据场景的支持，借助副本来提高可用性；</p>
<p>ES原生支持集群</p>
<ul>
<li>角色划分：候选主节点 + 数据节点</li>
<li>数据节点：负责数据的存储和相关的操作(CURD，聚合)等，因此对机器性能要求较高</li>
<li>候选主节点：拥有选举权和被选举权，主节点在候选主节点中评选出来，负责创建索引、删除索引、跟踪哪些节点是群集的一部分，并决定哪些分片分配给哪些的节点、追踪集群中节点的状态等</li>
</ul>
<p>ES数据持久化策略</p>
<ul>
<li>索引分段存储，段生成checkpoint之后，则只读，因此可以全量缓存，不用考虑更新修改；当出现修改时，标记原来段中文档删除，在新的段写入数据</li>
<li>延迟写策略：先更新内存数据，异步提交文件缓存系统，最后再由操作系统刷盘</li>
<li>内存中的数据不能被检索；文件缓存 + 段中的数据提供查询聚合，最终的结果会过滤已标记删除的文档</li>
</ul>
<h2> 5.一灰灰的总结</h2>
<h3> 5.1  综述</h3>
<p>本片文章主要是分析当下不同应用场景下的几个主流系统的高可用策略，来看一下如何来保障的系统的高可用</p>
<p><strong>常见的高可用思路</strong></p>
<ul>
<li>冗余 （如数据副本、主备服务等）</li>
<li>拆分 （数据拆分、服务能力拆分等）</li>
<li>持久化</li>
</ul>
<p><strong>redis</strong></p>
<ul>
<li>持久化：RDB数据落盘加载方式 + AOF记录操作命令用于回放策略</li>
<li>主从，主从从：全量数据冗余、读写请求分离，负载均衡的思想；核心问题在于主节点挂掉之后需要人工参与手动指定主库</li>
<li>哨兵机制：PING/PONG的探活机制，监听主节点，宕机之后自动选主，确保高可用；核心问题在于所有的实例冗余相同的一份数据，数据量大时不友好</li>
<li>集群：数据分片，每个实例提供部分服务能力</li>
</ul>
<p><strong>mysql</strong></p>
<ul>
<li>通过冗余来实现高可用：如主备</li>
<li>读写分离，实现负载均衡：主从、主从从模式</li>
<li>数据持久化策略：操作内存(buffer)，异步刷盘，两阶段提交保障一致性</li>
</ul>
<p><strong>rabbitmq</strong></p>
<ul>
<li>主备模式</li>
<li>镜像模式：全量冗余一份数据，主对外提供服务，可以实现自动切主</li>
<li>普通集群模式：数据拆分到集群的实例中，consumer/publisher连接到实例之后，会从具体持有exchange/topic的实例上拉数据</li>
<li>远程模式：适用于多中心的场景，将消息转发给其他中心的实例</li>
</ul>
<p><strong>ElasticSearch</strong></p>
<ul>
<li>ES集群：数据节点 + 候选主节点</li>
<li>ES持久化：
<ul>
<li>延迟写策略，先更新内存，然后提交操作系统缓存，最后异步刷新到磁盘；</li>
<li>索引分段存储：段生成checkpoint之后，则只读，因此可以全量缓存，不用考虑更新修改；当出现修改时，标记原来段中文档删除，在新的段写入数据</li>
</ul>
</li>
</ul>
<h3> 5.2 主题无关</h3>
<p>在准备写本文时，原计划针对不同业务场景各挑一个经典的系统来分析下各自的高可用方案，实际写下来发现工作量有点大；就把最后的一个分布式文件系统hdfs给暂缓了（对于大多数业务开发而言，接触的机会也不会太多），这个会放在《分布式系统-案例剖析》中进行介绍</p>
<p>最近会花大量的时间精力，准备做一个高质量的《分布式专栏》，欢迎有兴趣收藏关注 一灰灰的主站</p>
<ul>
<li>专栏地址：* <a href="https://hhui.top/%E5%88%86%E5%B8%83%E5%BC%8F/" target="_blank" rel="noopener noreferrer">分布式专栏 | 一灰灰Learning</a></li>
<li>精选： * <a href="https://hhui.top/%E5%88%86%E5%B8%83%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/01.%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%BB%BC%E8%BF%B0/" target="_blank" rel="noopener noreferrer">分布式设计模式综述 | 一灰灰Learning</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/column/distribute/220708/redis00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>02.Redis、ES、Hbase的高可用方案</title>
      <link>https://liuyueyi.github.io/tutorial/column/arch/distribute/%E9%AB%98%E5%8F%AF%E7%94%A8/02.Redis%E3%80%81ES%E3%80%81Hbase%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8%E6%96%B9%E6%A1%88.html</link>
      <guid>https://liuyueyi.github.io/tutorial/column/arch/distribute/%E9%AB%98%E5%8F%AF%E7%94%A8/02.Redis%E3%80%81ES%E3%80%81Hbase%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8%E6%96%B9%E6%A1%88.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">02.Redis、ES、Hbase的高可用方案</source>
      <description>以下内容来自同事的内部分享，经得同意分享给各位小伙伴 我们常说的高可用是怎么实现的呢？单机向集群的演进中遵循哪些原则，注意哪些事项呢？集群如何协同工作？集群之间的一致性如何保障？ 纯干货，推荐看到的小伙伴仔细认证的阅读一下，相信会有不少的收获</description>
      <category>分布式</category>
      <category>高可用</category>
      <pubDate>Wed, 30 Mar 2022 08:53:44 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>以下内容来自同事的内部分享，经得同意分享给各位小伙伴</p>
<p>我们常说的高可用是怎么实现的呢？单机向集群的演进中遵循哪些原则，注意哪些事项呢？集群如何协同工作？集群之间的一致性如何保障？</p>
<p>纯干货，推荐看到的小伙伴仔细认证的阅读一下，相信会有不少的收获</p>
</blockquote>
<!-- more -->
<h2> 一.nosql发展历史</h2>
<h3> 1.关系型数据库</h3>
<p>上世纪60年代以来至今，传统的关系型数据库一直被互联网应用的作为首选数据存储系统，典型的代表产品包括有oracle、mysql等。</p>
<p>关系型数据库的核心优势在于：第一，具备事务属性，注重数据一致性，内部实现有复杂的锁机制等还包含有其它一系列机制来保障数据一致性，能够基于AID(原子性、隔离性和持久性)的基础能力而带来事务强一致性来保证我们的数据存、取安全；第二，关系型数据模式其支持的二维表格模式比较契合现实中大部分的业务场景且易于理解，因此得以快速应用和发展。</p>
<p>关系型数据库最大的缺陷在于扩展性不足，在面对大量用户的并发访问以及海量存储的存取场景下，往往很难平滑的去做到性能升级，而使得DB经常作为整个系统应用的发展瓶颈。通常情况下，关系型数据库的扩展思路分为以下两种：</p>
<p>（1）纵向扩展。纵向扩展即提升单机硬件基础设施来提升处理能力。这种方式下虽然可以换来一定的性能提升，但是单机终归是存在有性能上限的，且升级过程中往往需要停机处理而无法做到平滑升级。其整体收益成本比比较低。</p>
<p>（2）横向扩展。横向扩展即通过分片，将数据分散至多台物理节点，降低单点压力，来提升处理能力。这种方式通常是对上层应用抽象出一个逻辑数据库，背后则是将数据分散到不同的物理数据库上。整体上来说，这种方式虽然可以在大部分常规场景下带来较大的性能提升，但与此同时又会引入另一个新的问题分布式事务问题，当然还包括有跨库join、非路由键查询等其它一系列问题。</p>
<h3> 2.NoSql的诞生</h3>
<p>在随着互联网业务与场景不断发展的背景下，由于在应对海量存储数据时传统的关系型数据在扩展能力上的不足，以及出现了越来越多的场景在关系型模式下显得并不适用，典型的如OLAP数据分析类型场景。促使Nosql技术开始诞生，Nosql的核心思想在于放弃传统关系型数据库的事务强一致性与关系模式，以此换取更高的可扩展性以及面对高并发海量数据时具备更强的处理能力。</p>
<p>对于Nosql而言，其定位并不是取代关系型数据库，而是作为关系型数据库的一种补充，两者分别有各自适合的领域场景。典型的nosql产品包括：基于kv的redis、列存储的hbase、文档型数据库ES等。</p>
<h3> 3.NewSql</h3>
<p>nosql虽然具备高扩展性的优势但其实在放弃了传统关系型数据库的强事务一致性的代价下换来的。因此，在关系型数据库与nosql均存在明显局限的背景下，NewSql概念开始应运而生。NewSQL可以说是传统的RDBMS与NoSQL技术结合之下的产物。这些系统既拥有NoSQL数据库的高扩展性，又希望能保持传统数据库的事务特性。典型的产品代表如google的spanner和国内的TiDB。</p>
<h2> 二.常见的Nosql产品简介</h2>
<p>常见的nosql产品如下：</p>
<table>
<thead>
<tr>
<th><strong>产品名称</strong></th>
<th><strong>特点</strong></th>
<th><strong>适用场景</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>redis</td>
<td>1.k-v结构； 2.内存数据库； 3.高性能，单机2C4G下读可达10WQPS；</td>
<td>1.缓存； 2.分布式锁、延时队列、限流等；</td>
</tr>
<tr>
<td>ES</td>
<td>1.文档型数据库； 2.结构化查询。支持多字段查询，以及复杂的过滤和聚合统计功能； 3.近实时查询。默认1s refresh一次将内存中的数据固化生成一个新的segment，此时为该segment创建倒排索引，外部读请求才能访问到这个segment的内容；</td>
<td>1.大数量背景下的检索类场景。例如日志搜索、大宽表解决mysql跨库join问题以及作为辅助索引解决分表下的非路由键查询问题； 2.数据统计、分析； 3.全文检索；</td>
</tr>
<tr>
<td>Hbase</td>
<td>1.列存储； 2.采用块存储机制，底层数据结构采用的是LSM合并树，将随机IO写转变为一次性顺序写，相比于B+树在写性能上表现更加优秀。但读性能会更弱；</td>
<td>1.PB级数据存储规模； 2.适合写多读少的场景，例如下沉的冷数据存储； 3.OLAP数据分析类场景；</td>
</tr>
</tbody>
</table>
<h2> 三. 集群工作原理</h2>
<h3> 3.1 集群模式</h3>
<p>对于大规模数据存储系统都会面临一个问题就是如何进行横向扩展，当数据集越来越大时，一主多从的模式无法支持这么大的数据存储与访问量，此时一般情况下就会考虑进行横向扩展，将多个主从模式组合在一起对外提供服务。但是这里有两个首要问题就是如何实现数据的分片逻辑以及分片逻辑放在哪里。于是在这种背景下就会衍生出两种不同的集群模式，一种就是集中式模式，一种则是去中心化的模式。</p>
<h4> <strong>1.集中式</strong></h4>
<p>集中式集群模式下，通常会引入一个中心节点作为集群的管理者，由管理者来进行集群状态管理、故障处理以及元数据维护等，其它节点只需响应数据请求，而无需知道集群中其它节点的情况。典型的解决方案都会借助于zookeeper分布式协调服务来进行集群管理，比如Hbase、kafka等。</p>
<p>Zookeeper：维护集群中的服务状态，并提供服务故障通知；</p>
<p>master：存储和维护集群元数据，以及故障转移等集群事务处理；</p>
<figure><img src="/imgs/column/distribute/220330/00.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h4> <strong>2.去中心化</strong></h4>
<p>即P2P交互模式，客户端与集群节点直接进行交互，而非之前业界的Proxy方式。典型的集群代表如redis cluster、es集群。</p>
<p><strong>redis Cluster介绍</strong></p>
<p>redis3.0版本开始，官方正式支持集群模式。redis官方集群模式最大的两个特点在于：</p>
<p>（1）去中心化。即P2P交互模式，客户端与集群节点直接进行交互，而非业界之前的Proxy方式。</p>
<p>（2）内部自治。redis 集群模式并未像Hbase、Kafka等引入第三方组件比如ZK，来实现对集群的节点状态管理、故障转移以及元数据管理等，而是基于Gssiop协议实现集群内节点监控、状态同步，并内置选举算法实现故障自动转移，在集群内部高度自治。</p>
<p>如下图是一个三主三从的redis cluster，三个机房部署，其中一主一从构成一个分片，之间通过异步复制同步数据。节点之间基于ping-pong心跳机制相互通信感知对方状态，一旦某个机房掉线，则分片上位于另一个机房的slave会被提升为master继续对外提供服务。</p>
<figure><img src="/imgs/column/distribute/220330/01.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 3.2 数据分片</h3>
<p>分布式集群在进行横向扩展时，首要问题就是如何实现数据的分片逻辑。</p>
<p><strong>1.分片策略</strong></p>
<p>常见分片策略如下：</p>
<p>（1）hash分片。hash分片也是我们最常用的分片策略。例如ES默认采用的就是这种方式。hash分片的好处在于数据会被打的比较分散，其次不用额外存储映射关系，客户端与服务端以约定好的hash公式进行路由。但是它的问题在于如果一旦需要进行扩缩容，那么整个映射关系都会被打破，此时需要进行一次全量的rehash数据迁移，工作量非常大。所以一般情况下，在设计的时候会尽可能的让这个hash模值大一点，避免频繁的进行扩容。</p>
<p>（2）基于某一key值的范围划分。例如基于时间范围或者id范围分片。这种分片方式的优劣势其实与hash的方式是相反的。它的好处在于，当需要进行扩缩容时，不会像hash一样破坏掉全局的映射关系，只需要对部分分片的映射关系产生影响。但是这种方式的问题在于它会存在一定的热点数据问题，导致整个集群各个节点的负载不均衡。例如Habse采用的就是这种方式，HBase 表根据 RowKey 的开始和结束范围水平拆分为多个 Region，一个region就是分片。每个 Region 都包含了 StartKey 和 EndKey 之间的所有行。每个 Region 都会分配到集群的一个节点上，即 RegionServer，由它们提供读写服务。</p>
<p>（3）一致性hash。一致性hash是通过构建一个环形的hash空间，对于用户的请求，先经过hash映射到这个环上，这就是第一层的映射关系，只要这个hash的模值不变，这层关系就不会变。其次，顺着环的顺时针方向找到的第一个节点，就是负责该请求对应的节点。</p>
<p>一致性hash的优势在于当进行扩缩容时，不会破坏全局的映射关系，而导致整个rehash，发起全局的数据迁移，而只会影响局部数据的映射关系。比如缩容减少一个节点，因为第一层映射依然保持不变，原来的请求该分配到哪个节点还是在哪个节点上，只是改变了第二层从环上到节点之间的一个局部映射关系。从环上来看，只会影响这个节点的上一个节点到这个这个节点的这一段弧区间上，整个环上的其它区间由于第一层关系不变，其映射关系不会受到影响。原来去掉的这个节点之间负责的那一段弧上请求，会全部顺移到它的下一个节点，我们只需要把去掉节点负责的数据迁移到下一个节点即可，其它的所有节点不用做任何变更。</p>
<figure><img src="/imgs/column/distribute/220330/02.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p><strong>2.基于Hash槽的数据分片</strong></p>
<p>redis cluster中，数据分片借助与hash槽slot来实现，集群预先划分16384个slot，对于每个请求集群的键值对，根据key 按CRC hash算法散列生成的值唯一匹配一个slot。在redis集群中每个master节点分片负责其中一部分槽位的读写请求，而且当且仅当每个slot都有对应节点负责时，集群才会进入可用状态。当动态扩缩容时，需求将16384个slot做一次再分配，相应数据也要进行迁移。</p>
<p>redis hash槽的算法与一致性hash算法的本质思想是一样的，通过不直接建立请求到节点的映射关系，而是建立一种间接的映射关系。避免在发生扩缩容时对于传统hash算法而言因为模值的变化而打乱整个映射关系。如下图所示，将映射关系分为两层，hash槽通过槽位路由表作为中间映射，因为槽位数量是16384不会变，这样当发生扩缩容时，对于请求而言该映射到哪个槽位还是映射到哪个槽位，即Part1映射不变，只用针对Part2部分中需要迁移的slot产生影响，而并非会让全部请求受到影响；</p>
<figure><img src="/imgs/column/distribute/220330/03.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 3.3 客户端交互流程</h3>
<p><strong>Redis集群交互</strong></p>
<p>redis客户端与集群之间的交互是基于槽位映射表来进行的，该映射表类似于集群的数据分布图，其中维护着槽位与负责该槽位的节点地址信息，客户端根据该映射关系与节点进行直连交互。</p>
<p>redis客户端首次连接集群时，会从集群中拉取一份完整的槽位映射表，缓存在本地。在进行请求访问时，首先会采用CRC16冗余校验法的值对16384取模，映射到具体一个槽位，随之通过查询槽位映射表定位到具体负责该槽位的节点，进而直接与节点进行通信。对于服务端节点来说在收到请求后首先会判断该槽位是否是自己负责的槽位，如果是，则会响应客户端请求。如果不是，例如集群发生扩缩容，此时槽位发生迁移，则会返回Moved/ask指令，引导客户端重定向至正确的节点进行访问。</p>
<p>Moved指令：当迁移已经全部完成，此时该slot已经永久转交给另一个节点时，A节点会返回Moved指令。当Client收到Moved指令后，则会重定向至正确的节点再次进行访问，同时更新本地的槽位映射表，下次直接访问到正确的节点。</p>
<p>ASK指令：ASK指令主要是在迁移过程中，此时该slot的数据可能一部分位于B，而另一部分key可能还在源节点A上。此时对于读请求而言，源节点A在收到请求后，会先在自己的数据库中查找，如果存在则直接返回结果；如果不存在则说明可能已经迁移至B，则会返回ask错误指令，引导client转向目的地节点查询key；</p>
<p>当Client收到Moved/AKS指令后，会去重定向至新的节点访问，同时还会更新本地的槽位映射表，在下次访问时直接定位至正确的节点上；</p>
<figure><img src="/imgs/column/distribute/220330/04.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p><strong>ES集群交互过程</strong></p>
<p>es作为搜索引擎而言，其支持的查询条件不局限于路由key，还包括其它关键字作为条件进行查询，因此其在查询流程不太一样。</p>
<p>es默认的查询模式为query then fetch模式，此模式下整个查询分为query 和 fetch两个步骤，query步骤负责查询符合条件文档id以及汇总排序截取limit等，fetch阶段则是查询完整数据，查询过程中需要进行两次交互。</p>
<figure><img src="/imgs/column/distribute/220330/05.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>（1）client首先会将查询请求发送至任一协调节点；</p>
<p>（2）协调节点在收到请求后，会并发的将请求发送至所有的数据节点；</p>
<p>（3）数据节点在收到请求后根据查询条件在自己负责的分片上查询符合条件的文档集合，不过只取文档 id和排名相关的字段信息，并将数据集返回至协调节点；</p>
<p>（4）协调节点在收到数据节点返回的结果集后，进行汇总排序取limit等，随着得到需要返回的结果集docId集合；</p>
<p>（5）此时query阶段结束，进入fetch阶段，协调节点会根据hash算法对docId进行路由，得到对应结果分别在哪些分片节点后，再次发送请求至数据节点，fetch数据；</p>
<p>（6）数据节点根据docId查询完整结果数据，并将数据再次返回至协调节点；</p>
<p>（7）协调结果进行完数据汇总后，将数据返回至客户端；</p>
<p>除了query then fetch之外，es还有另外一种比较常见的查询模式：query and fetch**。<strong>此模式下向索引的所有分片 （ shard）都发出查询请求， 各分片执行完query 后再执行fetch，即在分片节点中做完查询、排序和截取后将完整的数据一并返回至协调节点。这种搜索方式是最快的。 因为这种查询方法只需要去 shard查询一次。 但是各个 shard 返回的结果的数量之和可能是用户要求的 size 的 n 倍。</strong></p>
<p><strong>Hbase集群交互过程</strong></p>
<p>Hbase集群与redis集群不一样，其基于ZK进行集群状态管理以及元数据维护，集群中数据节点只知道自己负责的数据分片而不知其他节点。因此，在客户端进行集群访问时，通常需要先于ZK进行一次访问，在获取路由表后，再与集群节点直连访问。kafka也是同理。</p>
<p>如下图所示，HBase集群中的读取流程大致如下所示:</p>
<figure><img src="/imgs/column/distribute/220330/06.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>（1）client首先会访问一次zk，查询集群中master节点；</p>
<p>（2）在查询到master地址信息后，Client第二次发起请求访问master，查询路由信息表，路由表中记录着每个region节点负责处理哪个范围的rowkey；</p>
<p>（3）client在查询到路由信息后，会将其缓存在本地，随之基于路由信息表，查询rowkey对应的节点地址信息；</p>
<p>（4）直连数据节点服务器，发送查询请求获取数据；</p>
<p>（5）节点服务器在收到请求后，查询对应的完整数据并将结果返回至客户端；</p>
<p></p>
<h3> 3.4 集群管理</h3>
<h4> <strong>1.集群元数据管理</strong></h4>
<p>在集中式集群中，通常情况下会直接基于第三方协调服务zk来管理和维护集群元数据，zk在作为分布式协调服务之外，本身也是一个内存数据库。不过通常为减轻zk压力以及降低对zk的依赖，因此一般情况下，集群还会基于zk选举出一个master节点，代理zk进行元数据管理和维护以及非master节点的故障转移等相关事务处理。同时，zk中也会备份一份集群的元数据信息，避免master故障后集群元数据丢失，当选举出来的新master，会从zk中拉取一份集群元数据继续进行维护。</p>
<p>在去中心化的集群中，例如redis集群下每个节点都存储有整个集群的元数据信息，包括自己以及其它节点的存活状态、负责的slot槽位信息等。各节点间基于 Gossip 协议来相互交换信息，Gossip协议又叫病毒协议，是基于流行病传播的方式在节点或者进程之间信息交换的协议，在P2P去中心化的分布式系统中应用比较广泛。</p>
<p>Gossip协议的特点在于：</p>
<p>1.去中心化。Gossip 协议不要求任何中心节点，所有节点都可以是对等的，任何一个节点无需知道整个网络状况，只要网络是连通的，就可以把消息散播到全集群。</p>
<p>2.最终一致性。数据的传播过程是由一传十十传百逐步流散开来，整个传播过程需要经历多个周期，可能需要一定的时间，不过在一个处于有界网络的集群里，理论上集群各个节点对该份信息的认知最终都将会收敛一致。</p>
<p>Redis Cluster 中的每个节点都维护一份自己视角下的当前整个集群的状态，主要包括：</p>
<p>a.集群中各节点所负责的slots信息；</p>
<p>b.集群中各节点的存活状态信息；</p>
<p>对于集群中每个节点而言，会按照一定的频率周期，从自己的节点列表中随机挑选部分最长时间没有与它进行过通信的节点，对这些节点发送ping消息，并附加上自己视角下的集群状态信息，节点在收到其他节点发送的ping消息后再回复一个pong，以交换彼此的状态信息，对于差异化数据则版本决定是否更新本地状态数据，最终集群内所有节点达成统一认知。</p>
<figure><img src="/imgs/column/distribute/220330/07.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p><strong>优点：</strong></p>
<p>（1）容错。Gossip 协议具有天然的分布式系统容错特性，集群中任何节点的状态发生变化，例如上下线都不会影响 Gossip 消息的传播，且当节点重新上线后，依然会接收集群内其他节点的状态数据，并最终与其他节点达成一致。</p>
<p><strong>缺点：</strong></p>
<p>（1）Gossip是最终一致性，当集群状态发生变更时，变更数据需要经过多伦同步，整个集群的节点才会达成一致，相比于ZK而言其感知会出现明显延迟；</p>
<p>（2）Gossip协议下，每个节点按自己的节奏频率周期性的发送消息，而由于同步全量状态信息使得Gossip包体积较大，会存在一定的网络压力。其次由于随机的发送消息，而收到消息的节点也会重复该步骤，不可避免的引起同一节点消息多次接收，增加消息处理压力。</p>
<h4> <strong>2.集群状态检测</strong></h4>
<p>对于集中式集群模式的Hbase、kafka来说，对于集群的状态检测也是基于ZooKeeper 来做的，每台节点机器在启动时，都需要事先在zookeeper中注册一个节点，zk会与该节点维持一个会话关系，基于心跳检测来感知节点的状态变化。</p>
<p>具体来说，客户端会周期性的向服务端发送PING请求来保持心跳，一旦客户端发生故障，超过限定时间后，Zookeeper服务器会判定会话超时，并基于Watch机制实时通知给Master节点，master进行元数据更新以及后续的故障转移，以此来完成对集群中节点的状态检测。</p>
<figure><img src="/imgs/column/distribute/220330/08.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>跟大多数分布式系统一样，Redis cluster也是基于heart beat来进行节点状态检测。redis内部节点基于Gossip协议通信交互，具体来说，每个节点会定期会与其它节点发送ping-pong消息进行交互，以此来感知对方是否状态发生变化。对于集群中每个节点而言，每次随机挑选5个最长时间没有与它进行过通信的节点，对这些节点发送ping消息，节点在收到其他节点发送的ping消息后再回复一个pong。每个节点根据自己是否收到pong消息的结果来感知其它节点的存活状态。</p>
<p><strong>节点上线</strong></p>
<p>Redis Cluster 加入新节点时，首先需要在客户端需要执行 CLUSTER MEET 命令，命令中需要指定新增节点的地址信息。</p>
<figure><img src="/imgs/column/distribute/220330/09.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>redis集群中任一节点在收到 MEET命令后，会根据据 MEET 命令中的 IP 地址和端口号，向新节点发送一条 MEET 消息。</p>
<p>接着，新节点在收到Meet消息后，会向节点一返回一条PONG消息。</p>
<p>节点一接收到新节点返回的PONG消息后，得知新节点已经成功的接收了自己发送的MEET消息。随着将该新节点加入自己的元数据信息库中，从而完成了新节点接入的握手操作。</p>
<p>Meet成功之后，节点一会在下次周期性信息交互过程中，将新节点加入的消息传递出去。因为节点之间基于Gossip协议进行工作，在随着时间的推移，最终集群的所有节点都感知它的存在。</p>
<p><strong>节点下线</strong></p>
<p>redis集群中节点会周期性心跳同步，当某一节点在发其ping请求后，发现某个节点超过一定未给出回复，那么它会把这个节点的状态标记为pfail预下线的状态。</p>
<figure><img src="/imgs/column/distribute/220330/10.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>节点一会在下一轮交互中，会将节点二疑似下线消息同步出去。对于节点三在同步到这条消息后，并不会直接把自己的节点列表中该故障节点的状态也标记为预下线，因为这时候可能只是该节点一个人的主观认为下线，只是先记录下来节点一在XX时间认为节点二疑似下线；同时在节点三的下一轮ping-pong中，会优先选择节点二进行交互；</p>
<figure><img src="/imgs/column/distribute/220330/11.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>随着时间的推移，经过多轮同步后，对于节点X也超时未收到节点二的PONG，也认为节点二疑似下线，此时节点X发现集群中大部分超过一半的节点都认为它下线时，节点X会把该节点二标记为fail下线状态，并同时在集群中广播该节点fail。所有收到该消息的节点在发现某节点已经被标记为fail状态时，都会更新自己的节点列表将它标记为下线状态，如果该节点是leader副本的节点，则其对应的slave节点在收到下线消息会开始进行选举，进入故障转移流程。</p>
<figure><img src="/imgs/column/distribute/220330/12.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 3.5 高可用性</h3>
<p>对于分布式存储系统而言，集群高可用保证在于解决两个前提，第一个是要保证数据的可靠性，即当节点机器出现故障时，数据不能因此出现丢失。第二，在故障发生后集群需具备自动故障转移机制。</p>
<h4> <strong>1.数据的<strong><strong>可靠性</strong></strong>保证</strong></h4>
<p>通常而言，数据的可靠性都是基于多副本机制来解决的，即构建主从模式，为每个主节点部署多个slave从节点，当主节点故障时由从节点顶替。</p>
<p>对于多副本机制而言，其核心问题在于如何解决多副本之间的一致性。在多副本数据一致性问题上，一般会有两种解决方案。一种是基于ACK应答机制下的主从复制机制；另一种是目前业界更为主流的方案，基于分布式共识算法Paxos或者Raft来解决多副本之间的一致性问题。</p>
<p><strong>主从复制+<strong><strong>ACK</strong></strong>机制</strong></p>
<p>基于ACK的应答机制十分常见，首先从同步方式上来说又分为推模式和拉模式，拉模式相对而言十分常见，例如mysql的主从复制就是拉模式。两种模式的比较如下：</p>
<table>
<thead>
<tr>
<th><strong>模式</strong></th>
<th><strong>代表产品</strong></th>
<th><strong>优劣势</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>拉</td>
<td>mysql、es\kafka等</td>
<td><strong>优势：</strong> 从节点可基于自身消费能力处理同步数据； <strong>劣势：</strong> 数据同步及时性相对差一点</td>
</tr>
<tr>
<td>推</td>
<td>redis</td>
<td><strong>优势：</strong> 数据同步相对更加及时； <strong>劣势：</strong> 从节点一旦同步过程中出现重启，则重新启动后需要再次完整的同步一次全量数据。因此，在这种模式下一般还需要配备相关的缓冲区机制。例如redis中会配置同步缓冲区，在commit之前同时会先在缓冲区中备份一份。从节点重启后同步位移还在缓冲区中，则从缓冲区增量同步进行对齐。</td>
</tr>
</tbody>
</table>
<p>从应答机制的角度上来说又分为异步复制、半同步复制与全同步复制。</p>
<p>（1）异步复制。主节点在收到写请求后，会将数据写入内存以及同步至中继日志后，进行commit提交。随后通知slave节点过来复制，slave是否成功复制主节点并不关心。对于异步复制而言，它是存在有数据丢失风险的，当master宕机时，从节点可能还没来得及复制数据。</p>
<p>（2）半同步复制。半同步复制每次都会至少有一个从节点ack应答，相对而言它可以有更强的一个数据一致性保证。但还是会存在不一致的问题的场景，比如脑裂问题，导致数据丢失。当发生网络分区时，master节点和一个从节点被划分到一个区域与其它的从节点分离，这时其它从节点发现与master失联后就会选出一个新的master来提供服务，但是原来的master并不知道自己被失联了，而且每次依然会有一个从节点给它ack应答，因此它也可以正常处理客户端请求，这个时候就会存在两个master同时对外提供服务，接收客户端的写请求，而当网络分区结束后旧的master发现有新的master了，就会向新的master看齐，丢弃掉脑裂期间客户端提交的数据了。</p>
<p>（3）全同步复制。全同步复制则是必须每个从节点都给出ack应答才提交数据，这样可以避免脑裂情况发生，因为当发生脑裂时旧master因为不能得不到所有从节点的ack应答，所以是不会处理客户端的请求写从而旧可以避免脑裂问题。但是它的问题是在于性能较低，因为需要全部副本的响应，如果其中一个节点响应较慢则会拖慢整体的提交时间。</p>
<p><strong>分布式共识算法</strong></p>
<p>对于paxos、raft这类共识算法来说，因为它采用的多数决的机制，在出现网络分区时，只会存在有一个大多数而不会同时出现两个大多数。如果master位于网络分区后的少数派中，那这个master在接收到用户请求后，由于与它连通的只有少数节点达不到超过一半节点的支持，因此它是无法提交数据的。只会由多数节点构成的集群选举出来的新master这一个master对外提供服务；如果master处于多数节点构成的集群中，对于分隔出去的少数派节点构成的集群中因为节点数量不超过一半，所以根本就选取不出来一个新master。因此对于共识算法来说天然不会出现脑裂现象，相比于主从复制+ack的做法来说它能够带来更强的一致性保证。</p>
<p>分布式共识算法核心优势在于：</p>
<p>（1）容错。因为其多数派的原则，在出现网络分区时，只要不要超过半数以上的节点不可用，整个共识系统仍然是满足大多数原则的，仍然可以正常运转，在可用性方面具备非常强的一个容错能力。</p>
<p>（2）在强一致性的同时具备一定的性能优势。相比于全同步复制而言，因为多数决的机制，每次commit并不需要全部的节点同意，因此性能上而言相比于全同步复制更具有优势。</p>
<p>因为共识算法它所带来的强一致性保证和对集群节点的超强的容错能力，所以现在越来越多的分布式存储系统在解决多副本一致性问题上都在使用共识算法，比如new sql的tidb，内部就是基于raft算法以及mysql自身也推出了MGR集群，内部就是使用的mutil-paxos算法取代传统的半同步复制来解决多副本的一致性问题。</p>
<h4> <strong>2.故障转移</strong></h4>
<p>一般来说，对于引入第三方协调服务的存储系统来说，会事先在集群中选举一个Master，此master并非我们所说的主从复制中的leader副本节点。以kafka为例，在Kafka集群中这类节点称之为Controller。当节点发生故障时，会由ZK将故障通知至Controller节点，此时触发controller节点进行故障转移。</p>
<p>按故障节点类型来说分为以下几类：</p>
<p>（1）leader副本节点故障。当故障节点为某分片的leader副本节点时，则直接会由Controller负责为该分区重新选举新的Leader副本；Controller在watch关于某leader副本节点故障后，则会直接从该leader副本节点的从节点列表中找到位移提交最大也就是数据最新的节点作为新的master。</p>
<p>（2）Controller节点故障。当故障节点为Controller自身时，则由借助于ZK从集群中的其他leader节点中选取一个新的controller节点。整个选举过程本质上也是ZK的一次分布式锁的抢占过程。当controller产生时，会从ZK中拉取一份集群元数据备份存储到本地。同时一般来说Controller节点并不是单独的物理节点实例，而是由集群中某leader分片节点担任。当controller节点故障时，同时也是leader副本节点故障，因此当新master产生后，同时还会为旧master节点的slave节点中选举新的leader副本。</p>
<p>对于redis、ES这些在集群内部实现自治的集群系统而言，则通常会在集群内部实现选举算法，来实现故障转移。</p>
<p>当集群中某节点在发现半数以上的节点都认为某节点疑似下线后，会将该节点标记为确定下线并在集群中进行广播。当slave收到节点下线通知后，判断如果是自己的master节点，则触发选举流程，开始进行故障转移。</p>
<p>以redis为例其选举算法流程如下：</p>
<figure><img src="/imgs/column/distribute/220330/13.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>（1）slave收到master下线通知，开启一个纪元，将currentEpoch+1，开启选举；</p>
<p>（2）slave计算发起投票的延时时间。对于所有有资格参选的节点来说，并不会一收到选举通知后立马就开始发起选举，而是会先延迟一段时间。其延时时间的计算基于当前slave复制的数据总量，如果总量越高比较数据越接近master，那么它的延时时间会越短，被选中的概率也就越大。</p>
<p>（3）发起投票。slave在延时时间到期后，会向集群广播投票请求；</p>
<p>（4）投票。集群中只有master节点具备投票权利，且在每个纪元中只有一次投票机会，master的投票原则是先到先得。当master收到投票请求后，会先基于自身的元数据审查该节点是否为故障节点的slave节点，如果是且当前还未给其他的slave节点投过票，则会将票投给该节点，因此理论上而言，数据越新的从节点获得票数会越高；</p>
<p>（5）票数统计。每个节点在达到指定时间后会统计自身的票数，因为每个节点只能投一次票，所以得票超过一半以上的只会有一个节点。</p>
<p>（6）广播通知。当该从节点发现自己得票一半以后，就会像整个集群中广播新master节点的消息，让其它节点都知道它已经是最新的主节点，其它的主节点在收到后会更新自己的节点表，从节点则会将它设为新的主节点，此时选举结束。如果有一些从节点发现自己既没有达到半数以上的投票，又在指定时间内没有收到新master的消息，则会开启新的纪元，再次发起选票，但是此次其它的主节点发现如果直接的节点列表中该主节点的状态不是fail状态或者对该纪元已经进行过投票，不会再进行投票。</p>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/column/distribute/220330/00.png" type="image/png"/>
    </item>
    <item>
      <title>分布式系统高可用详解</title>
      <link>https://liuyueyi.github.io/tutorial/column/arch/distribute/%E9%AB%98%E5%8F%AF%E7%94%A8/</link>
      <guid>https://liuyueyi.github.io/tutorial/column/arch/distribute/%E9%AB%98%E5%8F%AF%E7%94%A8/</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">分布式系统高可用详解</source>
      <description>本专栏将主要讲解当前常用的各大系统的高可用方案 常见的高可用技术方案 Redis/ES/HBase的高可用方案</description>
      <pubDate>Mon, 29 Jul 2024 08:58:55 GMT</pubDate>
      <content:encoded><![CDATA[<p>本专栏将主要讲解当前常用的各大系统的高可用方案</p>
<ul class="task-list-container">
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-0" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-0"> <a href="01.%E5%B8%B8%E8%A7%81%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88">常见的高可用技术方案</a></label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-1" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-1"> <a href="02.Redis%E3%80%81ES%E3%80%81Hbase%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8%E6%96%B9%E6%A1%88">Redis/ES/HBase的高可用方案</a></label></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>基础架构</title>
      <link>https://liuyueyi.github.io/tutorial/column/arch/distribute/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/</link>
      <guid>https://liuyueyi.github.io/tutorial/column/arch/distribute/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">基础架构</source>
      <description>分布式系统常见的基础架构设计说明</description>
      <pubDate>Mon, 29 Jul 2024 08:58:55 GMT</pubDate>
      <content:encoded><![CDATA[<p>分布式系统常见的基础架构设计说明</p>
]]></content:encoded>
    </item>
    <item>
      <title>理论基础</title>
      <link>https://liuyueyi.github.io/tutorial/column/arch/distribute/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/</link>
      <guid>https://liuyueyi.github.io/tutorial/column/arch/distribute/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">理论基础</source>
      <description>分布式系统相关的理论基础</description>
      <pubDate>Mon, 29 Jul 2024 08:58:55 GMT</pubDate>
      <content:encoded><![CDATA[<p>分布式系统相关的理论基础</p>
]]></content:encoded>
    </item>
    <item>
      <title>raft共识算法</title>
      <link>https://liuyueyi.github.io/tutorial/column/arch/distribute/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/Raft%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95.html</link>
      <guid>https://liuyueyi.github.io/tutorial/column/arch/distribute/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/Raft%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">raft共识算法</source>
      <description>Raft共识算法 推荐有兴趣的小伙伴，查看 Raft 算法动画演示 Raft算法详解 - 知乎</description>
      <category>分布式</category>
      <category>设计模式</category>
      <category>理论基础</category>
      <pubDate>Tue, 12 Jul 2022 19:27:54 GMT</pubDate>
      <content:encoded><![CDATA[<h1> Raft共识算法</h1>
<blockquote>
<p>推荐有兴趣的小伙伴，查看</p>
<ul>
<li><a href="http://thesecretlivesofdata.com/raft/" target="_blank" rel="noopener noreferrer">Raft 算法动画演示</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/32052223" target="_blank" rel="noopener noreferrer">Raft算法详解 - 知乎</a></li>
</ul>
</blockquote>
<p>为了解决paxos的复杂性，raft算法提供了一套更易理解的算法基础</p>
<p>角色划分：</p>
<ul>
<li>Leader：领导者，接受客户端请求，并向Follower同步请求，当数据同步到大多数节点上后告诉Follower提交日志</li>
<li>Follow: 接受并持久化Leader同步的数据，在Leader告之日志可以提交之后，提交</li>
<li>Candidate：Leader选举过程中的临时角色，向其他节点拉选票，得到多数的晋升为leader，选举完成之后不存在这个角色</li>
</ul>
<figure><img src="/imgs/column/distribute/220708/raft01.jpg" alt="Raft角色" tabindex="0" loading="lazy"><figcaption>Raft角色</figcaption></figure>
<p>Follower只响应其他服务器的请求。如果Follower超时没有收到Leader的消息，它会成为一个Candidate并且开始一次Leader选举。收到大多数服务器投票的Candidate会成为新的Leader。Leader在宕机之前会一直保持Leader的状态。</p>
<h2> 选举</h2>
<p>Raft算法将时间分为一个个的任期（term），每一个term的开始都是Leader选举。在成功选举Leader之后，Leader会在整个term内管理整个集群。如果Leader选举失败，该term就会因为没有Leader而结束。</p>
<p>Raft 使用心跳（heartbeat）来检测Leader是否存活，Leader向所有Followers周期性发送heartbeat，表示自己还活着</p>
<p>如果Follower在选举超时时间内没有收到Leader的heartbeat，就会等待一段随机的时间后发起一次Leader选举</p>
<figure><img src="/imgs/column/distribute/220708/raft02.jpg" alt="Raft选举" tabindex="0" loading="lazy"><figcaption>Raft选举</figcaption></figure>
<p>选举的核心要点在于：</p>
<ul>
<li>follower一段时间没有接受到leader的心跳，认为leader挂了，变成candidate状态。 为了避免选举冲突，这个超时时间是一个150/300ms之间的随机数</li>
<li>candidate，会重置计时器，先投自己一票，向其他节点拉选票</li>
<li>得到多数选票的晋升为主节点</li>
<li>当多个节点的选票相同，则选举失败；之后等待计时器超时的follower会变成candidate，将任期加一并开始新一轮的投票。</li>
</ul>
<h2> 日志同步</h2>
<p>Leader接受外部请求，并将请求作为LogEntries加入日志中，然后复制给其他的Follow节点，</p>
<ul>
<li>大部分结点响应时才提交日志</li>
<li>通知所有follower结点日志已提交</li>
<li>所有follower也提交日志</li>
</ul>
<figure><img src="/imgs/column/distribute/220708/raft03.jpg" alt="Raft日志同步" tabindex="0" loading="lazy"><figcaption>Raft日志同步</figcaption></figure>
<h2> 脑裂问题</h2>
<blockquote>
<p>指在一个高可用（HA）系统中，当联系着的两个节点断开联系时，本来为一个整体的系统，分裂为两个独立节点，这时两个节点开始争抢共享资源， 结果会导致系统混乱，数据损坏。</p>
</blockquote>
<p>假设<code>A~E</code>五个结点，B是leader。 如果发生“脑裂”，A、B成为一个子分区，C、D、E成为一个子分区。</p>
<ul>
<li>此时C、D、E会发生选举，选出C作为新term的leader。这样我们在两个子分区内就有了不同term的两个leader</li>
<li>这时如果有客户端写A时, 因为B无法复制日志到大部分follower所以日志处于uncommitted未提交状态。</li>
<li>而同时另一个客户端对C的写操作却能够正确完成，因为C是新的leader，它只知道D和E。</li>
<li>当网络通信恢复，B能够发送心跳给C、D、E了，却发现有新的leader了，因为C的term值更大，所以B自动降格为follower。 然后A和B都回滚未提交的日志，并从新leader那里复制最新的日志。</li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/column/distribute/220708/raft01.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>zab协议</title>
      <link>https://liuyueyi.github.io/tutorial/column/arch/distribute/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/ZAB%E5%8D%8F%E8%AE%AE.html</link>
      <guid>https://liuyueyi.github.io/tutorial/column/arch/distribute/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/ZAB%E5%8D%8F%E8%AE%AE.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">zab协议</source>
      <description>Zookeeper Atomic Broadcast, ZK原子广播协议 ZAB(Zookeeper Atomic Broadcast) 协议是为分布式协调服务ZooKeeper专门设计的一种支持崩溃恢复的一致性协议，基于该协议，ZooKeeper 实现了一种 主从模式的系统架构来保持集群中各个副本之间的数据一致性。 zookeeper核心之ZAB协议就这么简单！</description>
      <category>分布式</category>
      <category>设计模式</category>
      <category>理论基础</category>
      <pubDate>Tue, 12 Jul 2022 19:27:54 GMT</pubDate>
      <content:encoded><![CDATA[<h1> Zookeeper Atomic Broadcast, ZK原子广播协议</h1>
<blockquote>
<p>ZAB(Zookeeper Atomic Broadcast) 协议是为分布式协调服务ZooKeeper专门设计的一种支持崩溃恢复的一致性协议，基于该协议，ZooKeeper 实现了一种 主从模式的系统架构来保持集群中各个副本之间的数据一致性。</p>
<ul>
<li><a href="https://segmentfault.com/a/1190000037550497" target="_blank" rel="noopener noreferrer">zookeeper核心之ZAB协议就这么简单！</a></li>
</ul>
</blockquote>
<p><strong>角色划分</strong></p>
<ul>
<li>Leader: 负责整个Zookeeper 集群工作机制中的核心
<ul>
<li>事务请求的唯一调度和处理者，保证集群事务处理的顺序性</li>
<li>集群内部各服务器的调度者</li>
</ul>
</li>
<li>Follower：Leader的追随者
<ul>
<li>处理客户端的非实物请求，转发事务请求给 Leader 服务器</li>
<li>参与事务请求 Proposal 的投票</li>
<li>参与 Leader 选举投票</li>
</ul>
</li>
<li>Observer：是 zookeeper 自 3.3.0 开始引入的一个角色，
<ul>
<li>它不参与事务请求 Proposal 的投票，</li>
<li>也不参与 Leader 选举投票</li>
<li>只提供非事务的服务（查询），通常在不影响集群事务处理能力的前提下提升集群的非事务处理能力。</li>
</ul>
</li>
</ul>
<p><strong>消息广播</strong></p>
<figure><img src="/imgs/column/distribute/220708/zab00.jpg" alt="ZAB消息广播" tabindex="0" loading="lazy"><figcaption>ZAB消息广播</figcaption></figure>
<p>leader再接收到事务请求之后，将请求转换为事务Proposal提案，leader会为每个follower创建一个队列，将该事务proposal放入响应队列，保证事务的顺序性；</p>
<p>然后再在队列中按照顺序向其它节点广播该提案；</p>
<p>follower收到后会将其以事务的形式写入到本地日志中，并且向leader发送Ack信息确认</p>
<p>有一半以上的follower返回Ack信息时， leader会提交该提案并且向其它节点发送commit信息</p>
<p><strong>事务有序性</strong></p>
<p>队列 + 事务递增ID（ZXID）来保证提案的有序性，</p>
<p>ZXID:</p>
<ul>
<li>高32位：纪元epoch，新选举一个leader，纪元+1</li>
<li>低32位：计数器counter，单调递增的数字</li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/column/distribute/220708/zab00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>三阶段协议</title>
      <link>https://liuyueyi.github.io/tutorial/column/arch/distribute/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E4%B8%89%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4%E5%8D%8F%E8%AE%AE.html</link>
      <guid>https://liuyueyi.github.io/tutorial/column/arch/distribute/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E4%B8%89%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4%E5%8D%8F%E8%AE%AE.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">三阶段协议</source>
      <description>在两阶段的基础上进行扩展，将第一阶段划分两部，cancommit + precommit，第三阶段则为 docommit 第一阶段 cancommit 该阶段协调者会去询问各个参与者是否能够正常执行事务，参与者根据自身情况回复一个预估值，相对于真正的执行事务，这个过程是轻量的 第二阶段 precommit 本阶段协调者会根据第一阶段的询盘结果采取相应操作，询盘结果主要有 3 种： 第一阶段响应 步骤 所有的参与者都返回确定 1.协调者向所有的事务参与者发送事务执行通知 2.参与者收到通知后执行事务但不提交 3.参与者将事务执行情况返回给客户端 一个或多个参与者返回否定信息 无法执行，向各个参与者发出 abort 通知，请求退出预备状态 协调者等待超时 同上</description>
      <category>分布式</category>
      <category>设计模式</category>
      <category>理论基础</category>
      <pubDate>Tue, 12 Jul 2022 19:27:54 GMT</pubDate>
      <content:encoded><![CDATA[<p>在两阶段的基础上进行扩展，将第一阶段划分两部，cancommit + precommit，第三阶段则为 docommit</p>
<p><strong>第一阶段 cancommit</strong></p>
<p>该阶段协调者会去询问各个参与者是否能够正常执行事务，参与者根据自身情况回复一个预估值，相对于真正的执行事务，这个过程是轻量的</p>
<p><strong>第二阶段 precommit</strong></p>
<p>本阶段协调者会根据第一阶段的询盘结果采取相应操作，询盘结果主要有 3 种：</p>
<table>
<thead>
<tr>
<th>第一阶段响应</th>
<th>步骤</th>
</tr>
</thead>
<tbody>
<tr>
<td>所有的参与者都返回确定</td>
<td>1.协调者向所有的事务参与者发送事务执行通知 <br> 2.参与者收到通知后执行事务但不提交 <br> 3.参与者将事务执行情况返回给客户端</td>
</tr>
<tr>
<td>一个或多个参与者返回否定信息</td>
<td>无法执行，向各个参与者发出 abort 通知，请求退出预备状态</td>
</tr>
<tr>
<td>协调者等待超时</td>
<td>同上</td>
</tr>
</tbody>
</table>
<figure><img src="/imgs/column/distribute/220708/3pc00.jpg" alt="3PC回滚" tabindex="0" loading="lazy"><figcaption>3PC回滚</figcaption></figure>
<p><strong>第三阶段 docommit</strong></p>
<p>如果第二阶段事务未中断，那么本阶段协调者将会依据事务执行返回的结果来决定提交或回滚事务，分为 3 种情况：</p>
<table>
<thead>
<tr>
<th>第二阶段响应</th>
<th>步骤</th>
</tr>
</thead>
<tbody>
<tr>
<td>所有的参与者都能正常执行事务</td>
<td>1.向所有参与者提交commit <br> 2.所有参与者在收到通知之后执行 commit 操作释放资源 <br> 3.参与者向协调者反馈事务提交结果</td>
</tr>
<tr>
<td>一个或多个参与者执行事务失败</td>
<td>协调者认为事务无法成功执行 <br> 1.向所有参与者提交rollback <br> 2.所有参与者执行rollback回滚 <br> 3.参与者向协调者反馈事务回滚结果</td>
</tr>
<tr>
<td>协调者等待超时</td>
<td>同上</td>
</tr>
</tbody>
</table>
<p>事务提交流程图：</p>
<figure><img src="/imgs/column/distribute/220708/3pc01.jpg" alt="3PC提交" tabindex="0" loading="lazy"><figcaption>3PC提交</figcaption></figure>
<p>事务回滚流程图：</p>
<figure><img src="/imgs/column/distribute/220708/3pc02.jpg" alt="3PC回滚" tabindex="0" loading="lazy"><figcaption>3PC回滚</figcaption></figure>
<p>在本阶段如果因为协调者或网络问题，导致参与者迟迟不能收到来自协调者的 commit 或 rollback 请求，那么参与者将不会如两阶段提交中那样陷入阻塞，而是等待超时后继续 commit，相对于两阶段提交虽然降低了同步阻塞，但仍然无法完全避免数据的不一致</p>
<p><strong>特点</strong></p>
<ul>
<li>降低了阻塞与单点故障：
<ul>
<li>参与者返回 CanCommit 请求的响应后，等待第二阶段指令，若等待超时/协调者宕机，则自动 abort，降低了阻塞；</li>
<li>参与者返回 PreCommit 请求的响应后，等待第三阶段指令，若等待超时/协调者宕机，则自动 commit 事务，也降低了阻塞；</li>
</ul>
</li>
<li>数据不一致问题依然存在
<ul>
<li>比如第三阶段协调者发出了 abort 请求，然后有些参与者没有收到 abort，那么就会自动 commit，造成数据不一致</li>
</ul>
</li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/column/distribute/220708/3pc00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>专栏</title>
      <link>https://liuyueyi.github.io/tutorial/column/</link>
      <guid>https://liuyueyi.github.io/tutorial/column/</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">专栏</source>
      <description>技术专栏 ❤️ 管理 一灰灰的技术管理 📝 架构 分布式专栏 🏪 项目 实战项目 &amp;amp; 配套教程</description>
      <pubDate>Fri, 22 Dec 2023 03:01:10 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 技术专栏</h1>
<h2> ❤️ 管理</h2>
<p><a href="tech/manager">一灰灰的技术管理</a></p>
<h2> 📝 架构</h2>
<p><a href="/tutorial/column/arch/" target="blank">分布式专栏</a></p>
<h2> 🏪 项目</h2>
<p><a href="/tutorial/column/app/" target="blank">实战项目 &amp; 配套教程</a></p>
]]></content:encoded>
    </item>
    <item>
      <title>16.从零开始：SpringBoot配置动态刷新的详细解析与实践！</title>
      <link>https://liuyueyi.github.io/tutorial/spring/basic/%E9%85%8D%E7%BD%AE/231030-SpringBoot%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E5%8A%A8%E6%80%81%E9%85%8D%E7%BD%AE%E5%88%B7%E6%96%B0%E6%96%B9%E6%A1%88.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/basic/%E9%85%8D%E7%BD%AE/231030-SpringBoot%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E5%8A%A8%E6%80%81%E9%85%8D%E7%BD%AE%E5%88%B7%E6%96%B0%E6%96%B9%E6%A1%88.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">16.从零开始：SpringBoot配置动态刷新的详细解析与实践！</source>
      <description>关于SpringBoot的自定义配置源、配置刷新之前也介绍过几篇博文；最近正好在使用apollo时，排查配置未动态刷新的问题时，看了下它的具体实现发现挺有意思的； 接下来我们致敬经典，看一下如果让我们来实现配置的动态刷新，应该怎么搞？</description>
      <category>SpringBoot</category>
      <category>基础系列</category>
      <category>配置</category>
      <pubDate>Mon, 30 Oct 2023 07:46:58 GMT</pubDate>
      <content:encoded><![CDATA[<p>关于SpringBoot的自定义配置源、配置刷新之前也介绍过几篇博文；最近正好在使用apollo时，排查配置未动态刷新的问题时，看了下它的具体实现发现挺有意思的；</p>
<p>接下来我们致敬经典，看一下如果让我们来实现配置的动态刷新，应该怎么搞？</p>
<!-- more -->
<h2> I. 配置使用姿势</h2>
<p>既然要支持配置的动态刷新，那么我们就得先看一下，在SpringBoot中，常见的配置使用姿势有哪些</p>
<h3> 1. @Value注解绑定</h3>
<p>直接通过<code>@Value</code>注解，将一个对象得成员变量与Environment中的配置进行绑定，如</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意：<code>@Value</code>支持SpEL</p>
<h3> 2. @ConfigurationProperties绑定</h3>
<p>通过<code>@ConfigurationProperties</code>注解声明一个配置类，这个类中的成员变量都是从<code>Environment</code>中进行初始化</p>
<p>如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. Environment.getProperty()直接获取配置</h3>
<p>直接从上下文中获取配置，也常见于各种使用场景中，如</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2> II. 配置刷新</h2>
<p>接下来我们看一下，如何实现配置刷新后，上面的三种使用姿势都能获取到刷新后的值</p>
<h3> 1. 自定义一个属性配置源</h3>
<p>自定义一个配置源，我们直接基于内存的<code>ConcurrentHashMap</code>来进行模拟，内部提供了一个配置更新的方法，当配置刷新之后，还会对外广播一个配置变更事件</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来就需要将这个自定义的配置元，注册到 <code>environment</code> 上下文，在这里我们可以借助<code>ApplicationContextInitializer</code>来实现，在上下文初始化前，完成自定义配置注册</p>
<blockquote>
<ul>
<li><a href="https://spring.hhui.top/spring-blog/2022/09/27/220927-Spring%E6%89%A9%E5%B1%95%E4%B9%8B%E5%AE%B9%E5%99%A8%E5%88%B7%E6%96%B0%E5%89%8D%E5%9B%9E%E8%B0%83ApplicationContextInitializer/" target="_blank" rel="noopener noreferrer">【扩展点】 容器刷新前回调ApplicationContextInitializer | 一灰灰Blog</a></li>
</ul>
</blockquote>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来注册这个扩展点，直接选择在项目启动时，进行注册</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. Environment配置刷新</h3>
<p>envionment实时获取配置的方式，支持配置刷新应该相对简单，如直接吐出一个接口，支持更新我们自定义配置源的配置，不做任何变更，这个配置应该时同时更新的</p>
<p>首先提供一个Spring的工具类，用于更简单的获取Spring上下文</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>配置更新的示例</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>执行验证一下:</p>
<figure><img src="/imgs/231030/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 3. <code>@ConfigurationProperties</code> 配置刷新</h3>
<blockquote>
<p><a href="https://spring.hhui.top/spring-blog/2023/06/27/230627-SpringBoot%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7%E9%85%8D%E7%BD%AE%E7%BB%91%E5%AE%9A%E5%AE%9E%E7%8E%B0%E4%BB%8B%E7%BB%8D/" target="_blank" rel="noopener noreferrer">【基础系列】自定义属性配置绑定极简实现姿势介绍 | 一灰灰Blog</a></p>
</blockquote>
<p>之前在介绍自定义属性配置绑定时介绍过，通过<code>Binder</code>来实现绑定配置的Config对象动态刷新，我们这里同样可以实现配置变更时，主动刷新<code>@ConfigurationProperties</code>注解绑定的属性</p>
<p>具体实现如下，</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意上面的实现，分三类：</p>
<ol>
<li><code>public &lt;T&gt; void bind(Bindable&lt;T&gt; bindable)</code>: 具体实现绑定配置刷新的逻辑</li>
</ol>
<p>核心思想就是将当前对象与environment配置进行重新绑定</p>
<ol start="2">
<li><code>public void run</code>: binder初始化</li>
</ol>
<p>在应用启动之后进行回调，确保是在environment准备完毕之后回调，获取用于属性配置绑定的binder，避免出现<code>envionment</code>还没有准备好</p>
<p>也可以借助实现<code>EnvironmentPostProcessor</code>来实现</p>
<ol start="3">
<li><code>public void refreshConfig(ConfigChangeListener.ConfigChangeEvent event)</code>： 配置刷新</li>
</ol>
<p>通过<code>@EventListener</code>监听配置变更事件，找到所有的<code>ConfigurationProperties</code>修饰对象，执行重新绑定逻辑</p>
<p>接下来我们验证一下配置变更是否会生效</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>定义一个UserConfig来接收<code>config</code>前缀开始的配置，通过update接口来更新相关配置，更新完毕之后返回UserConfig的结果</p>
<figure><img src="/imgs/231030/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 4. @Value 配置刷新</h3>
<p>最后我们再来看一下@Value注解绑定的配置的刷新策略，很久很久之前我也介绍一篇博文，如何实现动态刷新，欢迎查看</p>
<blockquote>
<p><a href="https://spring.hhui.top/spring-blog/2021/08/01/210801-SpringBoot%E5%BA%94%E7%94%A8%E7%AF%87-Value%E6%B3%A8%E8%A7%A3%E6%94%AF%E6%8C%81%E9%85%8D%E7%BD%AE%E8%87%AA%E5%8A%A8%E5%88%B7%E6%96%B0%E8%83%BD%E5%8A%9B%E6%89%A9%E5%B1%95/" target="_blank" rel="noopener noreferrer">【基础系列】SpringBoot应用篇@Value注解支持配置自动刷新能力扩展 | 一灰灰Blog</a></p>
</blockquote>
<p>其核心思想就是找出所有<code>@Value</code>绑定的成员变量，当监听到配置变更之后，通过反射的方式进行刷新</p>
<p>关键的实现如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的实现，主要利用到<code>BeanPostProcessor</code>，在bean初始化之后，扫描当前bean中是否有<code>@Value</code>绑定的属性，若有，则注册到自定义的<code>SpringValueRegistry</code>中</p>
<p><strong>注意事项：</strong></p>
<ol>
<li><code>@Value</code>有两种绑定姿势，直接放在成员变量上，以及通过方法进行注入</li>
</ol>
<p>所以上面的实现策略中，有<code>Field</code>和<code>Method</code>两种不同的处理策略；</p>
<ol start="2">
<li><code>@Value</code>支持SpEL表达式，我们需要对配置key进行解析</li>
</ol>
<p>相关的源码，推荐直接在下面的项目中进行获取，demo中的实现也是来自apollo-client</p>
<p>接下来再看一下注册配置绑定的实现，核心方法比较简单，两个，一个注册，一个刷新</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>SpringValue的构建，主要就是基于反射需要使用到的一些关键信息的组成上；可以按需进行设计补充</p>
<p>到此，关于@Value注解的配置动态刷新就已经实现了，接下来写几个demo验证一下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/231030/02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 5. 小结</h3>
<p>本文主要介绍了项目中配置的动态刷新的实现方案，也可以看作是apollo配置中心的简易实现原理，其中涉及到的知识点较多，下面做一个简单的小结</p>
<ol>
<li>配置的三种使用姿势</li>
</ol>
<ul>
<li><code>@Value</code>绑定</li>
<li><code>@ConfigurationProperties</code>绑定对象</li>
<li><code>environment.getProperty()</code></li>
</ul>
<ol start="2">
<li>自定义配置源加载</li>
</ol>
<ul>
<li><code>environment.getPropertySources().addFirst(MapPropertySource)</code></li>
</ul>
<ol start="3">
<li>配置刷新</li>
</ol>
<ul>
<li>Binder实现ConfigurationProperties刷新</li>
<li>反射实现@Value注解刷新</li>
</ul>
<h2> III. 不能错过的源码和相关知识点</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/003-self-config-binder" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/003-self-config-binder</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/231030/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>6.如何利用雪花算法生成分布式ID</title>
      <link>https://liuyueyi.github.io/tutorial/spring/db/%E5%9F%BA%E7%A1%80/231026-SpringBoot%E8%87%AA%E5%AE%9A%E4%B9%89%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95%E7%94%9F%E6%88%90%E5%88%86%E5%B8%83%E5%BC%8Fid.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/db/%E5%9F%BA%E7%A1%80/231026-SpringBoot%E8%87%AA%E5%AE%9A%E4%B9%89%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95%E7%94%9F%E6%88%90%E5%88%86%E5%B8%83%E5%BC%8Fid.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">6.如何利用雪花算法生成分布式ID</source>
      <description>系统唯一ID是我们在设计一个系统的时候常常会遇见的问题，比如常见的基于数据库自增主键生成的id，随机生成的uuid，亦或者redis自增的计数器等都属于常见的解决方案；本文我们将会重点看一下业界内大名鼎鼎的雪花算法，是如何实现分布式id的</description>
      <category>SpringBoot</category>
      <category>DB系列</category>
      <category>配置</category>
      <pubDate>Thu, 26 Oct 2023 17:28:47 GMT</pubDate>
      <content:encoded><![CDATA[<p>系统唯一ID是我们在设计一个系统的时候常常会遇见的问题，比如常见的基于数据库自增主键生成的id，随机生成的uuid，亦或者redis自增的计数器等都属于常见的解决方案；本文我们将会重点看一下业界内大名鼎鼎的雪花算法，是如何实现分布式id的</p>
<!-- more -->
<h2> I. 雪花算法</h2>
<h3> 1. 全局唯一id</h3>
<p>雪花算法主要是为了解决全局唯一id，那么什么是全局唯一id呢？它应该满足什么属性呢</p>
<p>基本属性：</p>
<ul>
<li>全局唯一性：不能出现重复的 ID 号，既然是唯一标识，这是最基本的要求；</li>
<li>趋势递增：在 MySQL InnoDB 引擎中使用的是聚集索引，由于多数 RDBMS 使用 B-tree 的数据结构来存储索引数据，在主键的选择上面我们应该尽量使用有序的主键保证写入性能；</li>
<li>单调递增：保证下一个 ID 一定大于上一个 ID，例如事务版本号、IM 增量消息、排序等特殊需求；</li>
<li>信息安全：如果 ID 是连续的，恶意用户的爬取工作就非常容易做了，直接按照顺序下载指定 URL 即可；如果是订单号就更危险了，竞争对手可以直接知道我们一天的单量。所以在一些应用场景下，会需要 ID 无规则、不规则。</li>
</ul>
<h3> 2. 雪花算法</h3>
<p>雪花算法可以说是业界内生成全局唯一id的经典算法，其基本原理也比较简单</p>
<figure><img src="/imgs/231026/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>Snowflake 以 64 bit 来存储组成 ID 的4 个部分：</p>
<ol>
<li>最高位占1 bit，值固定为 0，以保证生成的 ID 为正数；</li>
<li>中位占 41 bit，值为毫秒级时间戳；</li>
<li>中下位占 10 bit，值为机器标识id，值的上限为 1024；</li>
<li>末位占 12 bit，值为当前毫秒内生成的不同的自增序列，值的上限为 4096；</li>
</ol>
<p>从上面的结构设计来看，雪花算法的实现可以说比较清晰了，我们重点看一下它的缺陷</p>
<ol>
<li>时钟回拨问题：由于id的高位依赖于系统的时间戳，因此当服务器时间错乱或者出现时钟回拨，可能导致数据重复</li>
<li>集群规模1024台机器，每1ms单机4096个id最大限制</li>
</ol>
<h3> 3. 实现与使用</h3>
<p>目前雪花算法的实现方式较多，通常也不需要我们进行额外开发，如直接Hutool的<code>Snowflake</code></p>
<p>看下它的核心实现</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>关键实现在 <code>nextId()</code> 方法内，做了两个保护性兼容</p>
<ol>
<li>记录上次生成id的时间戳，若当前时间戳小于上次产生的时间戳，则表示出现了时钟回拨，超过一定间隔，则直接抛异常</li>
</ol>
<figure><img src="/imgs/231026/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<ol start="2">
<li>当前时间戳生成的id数量超过了4096最大值限制，则等待下一秒</li>
</ol>
<figure><img src="/imgs/231026/02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>接下来看一下实际的使用</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出如下:</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>生成的id：19位</li>
<li>单调递增，同一毫秒内，序号+1</li>
</ul>
<h3> 4. 自定义雪花算法实现</h3>
<p>在某些时候我们对雪花算法的实现有一些特殊的定制化场景，比如希望生成的id能一些更具有标识性，如以商城领域的订单数据模型为例</p>
<ul>
<li>第一位：标记订单类型， 1: 普通订单  2: 换货订单  3: 退货订单  4: 退款订单</li>
<li>第二三位：标记订单所属年份，如 22xxx，表示22年的订单；23xxx，则表示23年的订单</li>
</ul>
<p>再比如对订单的长度希望做一些限制,19位太多了，我希望16、7位的长度</p>
<p>再比如我希望调整workerId 与 datacenter之间的分配比例</p>
<p>基于以上等等原因，当我们面对需要修改雪花算法逻辑时，再知晓算法原理的基础上，完全可以自己手撸</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意上面的实现，相比较于前面HuTool的实现，有几个变更</p>
<ol>
<li>时间戳从毫秒改为秒</li>
<li>生成id前五位：年 + 天</li>
<li>workcenterId : dataCenterId = 3 : 7</li>
<li>当时钟回拨时，等待时间追上，而不是直接抛异常</li>
<li>自增序列的起始值，0/1互切</li>
</ol>
<p>接下来再看下实际的使用输出</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 5. 小结</h3>
<p>雪花算法本身的实现并不复杂，但是它的设计理念非常有意思；业界内也有不少基于雪花算法的变种实现，主要是为了解决时钟不一致及时钟回拨问题，如百度<code>UIDGenerator</code>，美团的<code>Leaf-Snowflake</code>方案</p>
<p>雪花算法其实是依赖于时间的一致性的，如果时间回拨，就可能有问题，其次机器数与自增序列虽然官方推荐是10位与12位，但正如没有万能的解决方案，只有最合适的解决方案，我们完全可以根据自己的实际诉求，对64个字节，进行灵活的分配</p>
<p>再实际使用雪花算法时，有几个注意事项</p>
<ol>
<li>雪花算法生成的id，通常是长整形，对于前端使用时，对于超过16位的数字，会出现精度问题，需要转换成String的方式传递，否则就会出现各种预料之外的事情发生</li>
<li>workId如何获取？</li>
</ol>
<ul>
<li>如：借助第三方服务(db/redis/zk)，统一为每个实例分配唯一的workId</li>
<li>如：同一个局域网内的所有应用，借助ip的最后一段来定位</li>
</ul>
<h2> II. 不能错过的源码和相关知识点</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/600-snowflake-id" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/600-snowflake-id</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/231026/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>17.压缩返回结果实例演示，让你的性能更高效！</title>
      <link>https://liuyueyi.github.io/tutorial/spring/web/Response/231108-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8B%E5%8E%8B%E7%BC%A9%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C%E5%AE%9E%E4%BE%8B%E6%BC%94%E7%A4%BA.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/web/Response/231108-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8B%E5%8E%8B%E7%BC%A9%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C%E5%AE%9E%E4%BE%8B%E6%BC%94%E7%A4%BA.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">17.压缩返回结果实例演示，让你的性能更高效！</source>
      <description>本文将介绍一个SpringBoot进阶技巧：压缩返回结果实例演示，旨在提升您的网站访问性能。 当返回的数据较大时，网络开销通常不可忽视。为了解决这个问题，我们可以考虑压缩返回的结果，以减少传输的数据量，从而降低网络开销并提高性能。对于依赖Spring生态的Java开发者来说，幸运的是SpringBoot提供了非常便捷的使用方式。 接下来，我们将介绍几种不同情况下的压缩返回的使用方式： 直接返回文本：使用text/plain作为响应类型。 返回JSON数据：使用application/json作为响应类型。 返回静态资源文件：对于静态资源文件，可以使用压缩算法进行压缩后再返回。</description>
      <category>SpringBoot</category>
      <category>WEB系列</category>
      <category>Response</category>
      <pubDate>Wed, 08 Nov 2023 10:38:11 GMT</pubDate>
      <content:encoded><![CDATA[<p>本文将介绍一个SpringBoot进阶技巧：压缩返回结果实例演示，旨在提升您的网站访问性能。</p>
<p>当返回的数据较大时，网络开销通常不可忽视。为了解决这个问题，我们可以考虑压缩返回的结果，以减少传输的数据量，从而降低网络开销并提高性能。对于依赖Spring生态的Java开发者来说，幸运的是SpringBoot提供了非常便捷的使用方式。</p>
<p>接下来，我们将介绍几种不同情况下的压缩返回的使用方式：</p>
<ul>
<li>直接返回文本：使用text/plain作为响应类型。</li>
<li>返回JSON数据：使用application/json作为响应类型。</li>
<li>返回静态资源文件：对于静态资源文件，可以使用压缩算法进行压缩后再返回。</li>
</ul>
<!-- more -->
<h2> I. 项目配置</h2>
<h3> 1. 依赖</h3>
<p>首先搭建一个标准的SpringBoot项目工程，相关版本以及依赖如下</p>
<p>本项目借助<code>SpringBoot 2.2.1.RELEASE</code> + <code>maven 3.5.3</code> + <code>IDEA</code>进行开发</p>
<p>核心依赖 <code>spring-boot-starter-web</code></p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 启动入口</h3>
<p>我们使用默认的配置进行测试，因此启动入口也可以使用最基础的</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> II. 返回结果压缩</h2>
<h3> 1. 开启gzip压缩</h3>
<p>在Spring Boot中开启压缩，只需要在配置文件中添加以下配置即可自动开启：</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意上面的两个配置，其中 <code>server.compression.enabled</code> 用于控制是否开启压缩；而<code>server.compression.min-response-size</code>则根据实际返回的大小，来决定是否需要开启压缩，上面的配置表示，只有返回的长度超过128时，才开启压缩。</p>
<p>写一个简单的demo进行验证</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>下图为实际访问对比，从两次请求的返回头来看，左边的示例表示没有开启压缩处理，而右边的示例则开启了gzip压缩。</p>
<figure><img src="/imgs/231108/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 2. 返回json对象时最小返回阈值不生效问题</h3>
<p>接下来我们再看一个特殊的场景，当我们返回的是jsonObject对象时，即便返回的内容小于前面配置的128，也会开启压缩</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/231108/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>根据上述实际表现，我们注意到一个令人费解的现象：同样返回一条数据时，如前面返回String时，不需要进行压缩；然而，当数据类型为JsonObject时，即使返回的内容小于128字节，也会启用gzip压缩。</p>
<p>这一现象的主要原因则是：</p>
<p>在Spring Boot框架中，默认情况下会对所有的json对象进行压缩处理。即使返回的数据量较小，即使未达到最小返回阈值，系统也会自动对其进行压缩操作。这样做的目的是为了减少传输的数据量并提高性能。</p>
<blockquote>
<p>即当返回的是对象，即<code>Content-Type: application/json</code>时，不会设置Content-Length，服务端无法判断长度，并且是通过<code>Transfer-Encoding: chunked</code>的方式发送给客户端，因此一定会做压缩。</p>
</blockquote>
<p>若我们希望严格按照预期来执行，那么可以通过对返回结果进行包装，补齐<code>Content-Length</code>来实现</p>
<p>自定义一个过滤器，借助<code>ContentCachingResponseWrapper</code>来包装返回结果</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>再次访问验证一下，结果和我们预期的保持一致了</p>
<figure><img src="/imgs/231108/02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 3. 返回静态资源压缩</h3>
<p>对于前后端未分离的项目，后端可能还需要返回静态资源文件，如JavaScript、CSS和图像等。在Spring Boot中，这些静态资源文件也可以被压缩并返回。为了实现这一功能，主要借助了<code>EncodedResourceResolver</code>类。</p>
<p><code>EncodedResourceResolver</code>是Spring框架中的一个类，用于解析和处理静态资源文件的编码和解码。通过使用<code>EncodedResourceResolver</code>，我们可以对静态资源文件进行压缩，并将其作为响应返回给前端。</p>
<p>一个简单的使用实例如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的配置中，表示将static资源目录下的文件，作为静态资源返回，会设置缓存时间，并开启压缩支持</p>
<p>我们可以再项目的 <code>resources/static/</code> 目录下新增一个 <code>txt.txt</code> 文件，并再其中随意补充一些内容</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>然后直接访问验证一下</p>
<figure><img src="/imgs/231108/03.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>从上面的访问示例可以看出，首次访问时，压缩返回；再次访问时，因为资源未发生变更，所以直接使用本地的缓存。这是因为浏览器在第一次请求静态资源时会将其缓存起来，以便下次访问时能够更快地加载。如果资源发生了更改，浏览器将不会使用缓存的版本，而是重新发起请求以获取最新的资源。</p>
<h3> 4. 小结</h3>
<p>最后对文中介绍的内容做一个整体的总结，在Spring Boot中开启gzip压缩可以通过以下方式实现：</p>
<ol>
<li>在配置文件中添加如下配置：</li>
</ol>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2">
<li>返回json对象时最小返回阈值不生效问题：</li>
</ol>
<p>当返回的是对象时，即使返回的内容小于前面配置的128字节，也会启用gzip压缩。这是因为在Spring Boot框架中，默认会对所有的json对象进行压缩处理。如果不想压缩，可以将返回结果进行包装，实现按需压缩。</p>
<ol start="3">
<li>返回静态资源压缩：</li>
</ol>
<p>对于前后端未分离的项目，后端可能还需要返回静态资源文件，如JavaScript、CSS和图像等。在Spring Boot中，这些静态资源文件也可以被压缩并返回。为了实现这一功能，主要借助了<code>EncodedResourceResolver</code>类，通过设置静态资源的压缩方式，并再<code>WebMvcConfigurer</code>实现中进行注册，从而实现静态资源的压缩与缓存</p>
<h2> III. 不能错过的源码和相关知识点</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/207-web-res-gzip" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/207-web-res-gzip</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/231108/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>2.从零开始学习SpringBoot整合WebSocket与STOMP协议：实用案例带你轻松入门！</title>
      <link>https://liuyueyi.github.io/tutorial/spring/web/WebSocket/231115-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8BWebScoket%E6%95%B4%E5%90%88stomp%E5%8D%8F%E8%AE%AE%E5%AE%9E%E4%BE%8B.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/web/WebSocket/231115-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8BWebScoket%E6%95%B4%E5%90%88stomp%E5%8D%8F%E8%AE%AE%E5%AE%9E%E4%BE%8B.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">2.从零开始学习SpringBoot整合WebSocket与STOMP协议：实用案例带你轻松入门！</source>
      <description>在我们的日常工作中，我们可能会遇到需要实现双向通讯的场景。为了解决这个问题，常见的实现方案包括短轮询、长轮询、SSE和WebSocket等几种方式。本文将重点介绍如何通过整合WebSocket和STOMP协议来实现双向通讯的方案, 并给出一个应用实例，带你轻松掌握如何基于SpringBoot搭建一个在线聊天系统</description>
      <category>WEB系列</category>
      <category>WebSocket</category>
      <pubDate>Wed, 15 Nov 2023 15:12:39 GMT</pubDate>
      <content:encoded><![CDATA[<p>在我们的日常工作中，我们可能会遇到需要实现双向通讯的场景。为了解决这个问题，常见的实现方案包括短轮询、长轮询、SSE和WebSocket等几种方式。本文将重点介绍如何通过整合WebSocket和STOMP协议来实现双向通讯的方案, 并给出一个应用实例，带你轻松掌握如何基于SpringBoot搭建一个在线聊天系统</p>
<!-- more -->
<h2> I. 基础知识点</h2>
<h3> 1. 相关概念释疑</h3>
<p>再开始之前，简单介绍一下文中会出现的几个术语的</p>
<p><strong>WebSocket</strong>： WebSocket是一种在单个TCP连接上进行全双工通信的协议。它使得客户端和服务器之间能够实时地进行双向数据传输，而不需要频繁地建立和关闭连接。这种机制可以提高数据传输的效率和性能。</p>
<p><strong>STOMP</strong>:  Simple Text Oriented Messaging Protocol 是一种简单而灵活的消息传递协议，它是在HTTP之上实现的。STOMP协议定义了一套简单的命令和帧格式，用于在客户端和服务器之间进行消息传递。通过使用STOMP协议，我们可以实现客户端和服务器之间的双向通讯。</p>
<p>注意：stomp协议属于websocket的子协议</p>
<h3> 2. WebSocket整合STOMP</h3>
<p>WebSocket整合STOMP协议实现双向通讯的方案，主要步骤如下：</p>
<ol>
<li>
<p>建立WebSocket连接：客户端通过JavaScript的WebSocket API与服务器建立连接。</p>
</li>
<li>
<p>发送STOMP帧：在WebSocket连接建立后，客户端和服务器就可以通过发送STOMP帧来进行通信了。STOMP帧是STOMP协议的基本单位，它定义了消息的各种操作，如订阅、发布等。</p>
</li>
<li>
<p>处理STOMP帧：服务器收到STOMP帧后，会根据帧的类型进行相应的处理。例如，如果收到一个SUBSCRIBE帧，服务器就会为客户端创建一个订阅；如果收到一个SEND帧，服务器就会将消息发送给指定的目的地。</p>
</li>
<li>
<p>关闭WebSocket连接：当客户端和服务器都完成了通信后，可以通过调用WebSocket API的close方法来关闭连接。</p>
</li>
</ol>
<h3> 3. SpringBoot整合STOMP流程</h3>
<p>SpringBoot对websocket提供了非常友好的封装，对于业务开放而言，可以简单迅速的搭建一个基于STOMP协议的websocket应用工程</p>
<figure><img src="/imgs/231115/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>上图展示了STOMP的基本工作流程。</p>
<p><strong>步骤1：初始化</strong></p>
<p>服务端：</p>
<ul>
<li>定义接收建立WebSocket连接的端点EndPoint。</li>
<li>配置消息代理Broker，用于前端订阅（subscribe），后端向该Broker写入消息后，订阅了该Broker的前端都会收到相应的消息。</li>
<li>配置路由转发规则，将用户发送的信息转发给相应的处理器（类似于<code>RequestMappingHandlerMapping</code>与@<code>RequestMapping</code>注解，在WebSocket中使用的是<code>Destination</code> + <code>@MessageMapping</code>）。</li>
</ul>
<p>客户端：</p>
<ul>
<li>与EndPoint建立连接。</li>
<li>订阅Broker，注册消息回调。</li>
</ul>
<p><strong>步骤2：通讯</strong></p>
<p>服务端：</p>
<ul>
<li>主动向Broker写入消息：使用<code>simpMessagingTemplate</code>。</li>
<li>消息应答：使用<code>@SendTo</code>注解。</li>
</ul>
<p>客户端：</p>
<ul>
<li>发送消息：调用send(xxxx)方法。</li>
<li>消息应答：触发订阅的回调函数。</li>
</ul>
<h2> II. 实例演示</h2>
<h3> 1. 项目配置</h3>
<p>首先搭建一个标准的SpringBoot项目工程，相关版本以及依赖如下</p>
<p>本项目借助<code>SpringBoot 2.2.1.RELEASE</code> + <code>maven 3.5.3</code> + <code>IDEA</code>进行开发</p>
<p>核心依赖 <code>spring-boot-starter-websocket</code>， 其中模板渲染引擎<code>thymeleaf</code>主要是集成前端页面</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. WebSocket配置</h3>
<p>正如前面流程图中介绍的，后端需要先配置一下websocket的相关信息，通过实现配置类<code>WebSocketMessageBrokerConfigurer</code>来定义</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol>
<li>定义端点： <code>registerStompEndpoints()</code></li>
<li>定义客户端与服务端通讯信息: <code>configureMessageBroker()</code></li>
</ol>
<ul>
<li>配置消息代理: <code>registry.enableSimpleBroker</code></li>
<li>配置消息转发: <code>registry.setApplicationDestinationPrefixes</code>，转发前缀可以是多个</li>
</ul>
<p>上面的配置完毕之后，对于客户端而言</p>
<ul>
<li>建立连接的路径是： <code>/ws/hello</code></li>
<li>订阅消息的路径是： <code>/topic/xxx</code>
<ul>
<li>订阅的路径全程，是由 <code>@SendTo</code>的路径来确定</li>
</ul>
</li>
<li>接收前端消息的路劲是: <code>/app/xxx</code>
<ul>
<li>后面的这个xxx，是由 <code>@MessageMapping</code>中的路径来补齐</li>
</ul>
</li>
</ul>
<h3> 3. 消息接收应答</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>实现一个非常简单的消息应答，接收客户端朝 <code>/app/hello</code> 发送的消息，然后将结果写回到 <code>/topic/hello</code> 对应的Broker，那么订阅了这个broker的客户端，都会收到这个应答消息了</p>
<p>再写一个定时器，由后端定时的向<code>/topic/hello</code>这个Broker中写入消息，模拟后台主动下发消息的场景</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4. 前端示例</h3>
<p>一个简单基础的html页面</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>核心的js逻辑，实现websocket连接建立，通讯</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意上面的实现：</p>
<ol>
<li>建立连接 <code>connect()</code></li>
</ol>
<ul>
<li>与后端定义的端点建立连接: <code>new SockJS('/ws/hello');</code></li>
<li>连接建立成功之后，订阅Broker，接收消息回传: <code>stompClient.subscribe('/topic/hello', 消息应答回调)</code></li>
</ul>
<ol start="2">
<li>发送消息</li>
</ol>
<ul>
<li>`stompClient.send("/app/hello", xxx)``</li>
</ul>
<ol start="3">
<li>断开连接</li>
</ol>
<ul>
<li><code>stompClient.disconnect();</code></li>
</ul>
<h3> 5. 演示</h3>
<p>到这里，一个完整的基于SpringBoot整合WebSocket与STOMP协议的示例应用已经搭建完成；接下来我们实际启动一下看看效果</p>
<figure><img src="/imgs/231115/01.gif" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>上面的动图展示了前端建立连接后，向后端发送信息并接收后端广播的消息的过程。由于两个客户端订阅的是同一个broker，因此后端发送的消息可以被所有客户端接收到。</p>
<p>这种交互方式类似于群组聊天，当一个人发送消息后，其他人都可以收到。</p>
<p>如果我希望通过websocket实现一个消息通知的功能，其中后端发送的消息既有广播的，也有面向个人的，那么应该如何实现呢？</p>
<p>我们下篇博文将进行详细介绍</p>
<h2> III. 不能错过的源码和相关知识点</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/203-websocket" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/203-websocket</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/231115/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>3.从零开始学习SpringBoot WebSocket身份鉴权，让你的项目更上一层楼！</title>
      <link>https://liuyueyi.github.io/tutorial/spring/web/WebSocket/231204-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8BWebSocket%E8%BA%AB%E4%BB%BD%E9%89%B4%E6%9D%83.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/web/WebSocket/231204-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8BWebSocket%E8%BA%AB%E4%BB%BD%E9%89%B4%E6%9D%83.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">3.从零开始学习SpringBoot WebSocket身份鉴权，让你的项目更上一层楼！</source>
      <description>上一篇博文介绍了如何利用STOMP和SpringBoot搭建一个能够实现相互通讯的聊天系统。通过该系统，我们了解了STOMP的基本使用方法以及一些基础概念。接下来，我们将在此基础上进行一些增强。由于聊天的本质是交流，因此我们需要知道是谁在与谁进行聊天，这就需要登录功能的支持。 接下来，我们将探讨如何为WebSocket通信添加身份验证功能。</description>
      <category>WEB系列</category>
      <category>WebSocket</category>
      <pubDate>Mon, 04 Dec 2023 09:40:04 GMT</pubDate>
      <content:encoded><![CDATA[<p>上一篇博文介绍了如何利用STOMP和SpringBoot搭建一个能够实现相互通讯的聊天系统。通过该系统，我们了解了STOMP的基本使用方法以及一些基础概念。接下来，我们将在此基础上进行一些增强。由于聊天的本质是交流，因此我们需要知道是谁在与谁进行聊天，这就需要登录功能的支持。</p>
<p>接下来，我们将探讨如何为WebSocket通信添加身份验证功能。</p>
<!-- more -->
<h2> I. 实例演示</h2>
<h3> 1. 项目配置</h3>
<p>首先搭建一个标准的SpringBoot项目工程，相关版本以及依赖如下</p>
<p>本项目借助<code>SpringBoot 2.2.1.RELEASE</code> + <code>maven 3.5.3</code> + <code>IDEA</code>进行开发</p>
<p>核心依赖 <code>spring-boot-starter-websocket</code>， 其中模板渲染引擎<code>thymeleaf</code>主要是集成前端页面</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. WebSocket配置</h3>
<p>首先我们先看一下后端的配置，对于SpringBoot整合STOMP，主要通过实现配置类<code>WebSocketMessageBrokerConfigurer</code>来定义相关的信息：</p>
<ul>
<li>注册端点Endpoint</li>
<li>定义消息转发规则</li>
<li>定义拦截器（配置消息接收、返回的相关参数）</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>有兴趣的小伙伴可以对比一下上面的Endpoint配置与之前整合STOMP的示例中的配置，两者之间存在两个主要差异：</p>
<ol>
<li><code>addEndpoint("/ws/chat/{channel}")</code></li>
</ol>
<p>这个端点并不是一个固定的值，最后一个<code>{channel}</code>是一个变量。可以理解为聊天群，不同聊天群中的信息是相互隔离的，不会出现串频的情况。</p>
<ol start="2">
<li><code>addInterceptors(authHandshakeInterceptor())</code></li>
</ol>
<p>这里设置了身份鉴权拦截器，也是本文的核心内容。在WebSocket连接建立之后，如何识别当前建立连接的用户呢？</p>
<h3> 3. 身份鉴权拦截器</h3>
<p>与SpringMVC类似，WebSocket也支持拦截器。在握手之前，可以通过识别用户身份来实现辅助操作。例如，我们可以从cookie中获取用户信息，并将其写入消息的全局属性请求头。</p>
<p>实现方式主要是通过拦截器在握手过程中进行用户身份验证，并将用户信息存储在全局属性中，以便在整个WebSocket连接的生命周期内使用。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的拦截器可以通过cookie来识别用户身份。当用户登录成功后，将用户名写入请求头uname中。这样，在后续的WebSocket通信过程中，就可以通过访问请求头uname来获取当前登录的用户信息</p>
<h3> 4. 用户登录</h3>
<p>我们还是基于springmvc搭建一个用户的登录入口，直接基于内存做一个最简单的用户登录管理</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>新增一个用户登录的入口，用户登录成功之后，将session写入cookie，有效期30天</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 5. ws聊天实现</h3>
<p>接下来我们开始写登录聊天的相关业务逻辑</p>
<p><strong>后端实现</strong></p>
<p>首先提供一个消息转发的后端接口</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意上面的实现，有几个关键信息</p>
<ol>
<li><code>@MessageMapping("/hello/{channel}")</code></li>
</ol>
<p>这里的<code>{channel}</code>是一个传参形式，表示接收不同目标来源的消息；其取值通过<code>DestinationVariable("channel") String channel</code> 来获取</p>
<p>举个简单的例子：</p>
<ul>
<li>客户端往 <code>app/hello/globalChannel</code> 发送的消息，会被后端转发给 <code>/topic/chat/globalChannel</code></li>
<li>客户端往 <code>app/hello/signleChannel</code> 发送的消息，会被后端转发给 <code>/topic/chat/signleChannel</code></li>
</ul>
<ol start="2">
<li><code>headerAccessor.getSessionAttributes().get("uname")</code></li>
</ol>
<p>从请求头中获取用户身份，没错，这里的uname就是在上面的拦截器 <code>AuthHandshakeInterceptor</code> 写入的</p>
<ol start="3">
<li>消息发送</li>
</ol>
<p>写了一个简单的工具类，实现后端给客户端发送消息， <code>WsAnswerHelper</code>实现如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>最后再给出前端访问入口</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>前端实现</strong></p>
<p>前端的实现和上一篇博文的基本没有太大差别，无非是多了一个登录</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>js实现如下</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>和之前的示例相比，区别在于建立连接之前，先调用了登录接口实现自动登录</p>
<h3> 6. 示例演示</h3>
<p>接下来我们演示一下，用户登录之后，再进行聊天的表现形式</p>
<figure><img src="/imgs/231204/00.gif" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>面的示意图也可以看出，在相同channel之间的用户可以相互通信。聊天信息前面都会带上发送这个消息的用户名。这样可以方便用户识别和区分来自不同用户的聊天信息。</p>
<h3> 7. 小结</h3>
<p>本文通过实例演示了WebSocket的身份鉴权，其底层依然是借助Cookie来实现用户身份识别。与常规的Cookie鉴权不同之处在于，在WebSocket连接的生命周期内，通过HttpSessionHandshakeInterceptor拦截器来解析用户身份，并将相关信息写入到请求头中，以供其他地方进行使用。</p>
<p>本文的主要目的是为大家演示如何实现WebSocket的身份识别验证，整体的功能相对较少。以下是一些可能的应用场景和实现方式：</p>
<ul>
<li>当一个用户加入聊天室时，系统可以通过广播一个通知来告知其他用户。具体实现方式可以是，在用户加入聊天室时，服务器将该用户的身份信息发送给所有已连接的客户端，客户端收到通知后可以在界面上显示相应的提示信息。</li>
<li>当一个用户离开聊天室时，系统同样可以通过广播一个通知来告知其他用户。具体实现方式可以是，在用户离开聊天室时，服务器将该用户的身份信息发送给所有已连接的客户端，客户端收到通知后可以在界面上移除相应的提示信息。</li>
<li>如现在一个订阅对应一个websocket连接，那么是否可以一个ws连接，通过订阅不同的topic，来实现多群组聊天的功能呢？</li>
</ul>
<p>下篇博文将探讨如何实现以下功能：</p>
<ol>
<li>当一个用户加入聊天时，系统广播一个通知。</li>
<li>当用户离开聊天时，系统广播一个通知。</li>
<li>使用一个WebSocket连接，通过订阅不同的主题来实现多群组聊天的功能。</li>
</ol>
<p>敬请期待下篇博文！我是你们的好朋友一灰灰</p>
<h2> II. 不能错过的源码和相关知识点</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-case/207-websocket-chat" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-case/207-websocket-chat</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/231204/00.gif" type="image/gif"/>
    </item>
    <item>
      <title>4.SpringBoot WebSocket进阶：如何利用消息拦截器优化聊天功能？</title>
      <link>https://liuyueyi.github.io/tutorial/spring/web/WebSocket/231218-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8BWebsocket%E6%B6%88%E6%81%AF%E6%8B%A6%E6%88%AA%E5%99%A8%E5%AE%9E%E7%8E%B0%E8%81%8A%E5%A4%A9%E6%8F%90%E9%86%92.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/web/WebSocket/231218-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8BWebsocket%E6%B6%88%E6%81%AF%E6%8B%A6%E6%88%AA%E5%99%A8%E5%AE%9E%E7%8E%B0%E8%81%8A%E5%A4%A9%E6%8F%90%E9%86%92.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">4.SpringBoot WebSocket进阶：如何利用消息拦截器优化聊天功能？</source>
      <description>在上一篇文章中，我们成功地为WebSocket的聊天应用添加了身份验证功能。然而，当时遗留了一个关键问题：当一个新用户加入群聊时，我们希望向群聊内的其他成员发送一条欢迎消息，以告知他们有新朋友加入了。那么，如何实现这一需求呢？ 接下来，我们将重点介绍如何使用ChannelInterceptor来实现加入/退出群聊的通知功能。</description>
      <category>WEB系列</category>
      <category>WebSocket</category>
      <pubDate>Mon, 18 Dec 2023 14:23:43 GMT</pubDate>
      <content:encoded><![CDATA[<p>在上一篇文章中，我们成功地为WebSocket的聊天应用添加了身份验证功能。然而，当时遗留了一个关键问题：当一个新用户加入群聊时，我们希望向群聊内的其他成员发送一条欢迎消息，以告知他们有新朋友加入了。那么，如何实现这一需求呢？</p>
<p>接下来，我们将重点介绍如何使用<code>ChannelInterceptor</code>来实现加入/退出群聊的通知功能。</p>
<!-- more -->
<h2> I. 实例演示</h2>
<h3> 1. 项目搭建</h3>
<p>项目搭建过程与前文类似，请直接参考上文 或者 查看文末的项目源码</p>
<h3> 2. WebSocket配置</h3>
<p>在之前介绍的几篇博文中，我们提到了通过实现接口<code>WebSocketMessageBrokerConfigure</code>在之前介绍的几篇博文中，我们提到了通过实现接口<code>WebSocketMessageBrokerConfigurer</code> 来进行 WebSocket 的配置。</p>
<p>本文的重点正是在这个配置类中进行实现，因此我们将借此机会回顾一下之前的内容。</p>
<ul>
<li>首先，我们需要创建一个配置类，并实现 <code>WebSocketMessageBrokerConfigurer</code> 接口。然后，我们可以重写其中的方法来配置 WebSocket 的相关参数和消息代理。</li>
<li>在 <code>configureMessageBroker</code> 方法中，我们可以指定使用的消息代理（例如：SimpleBroker）以及对应的前缀（用于路由消息）。同时，我们还可以设置订阅者模式（<code>subscriptionChannel</code>）和广播模式（<code>publisherChannel</code>），以便在不同的场景下使用不同的通信方式。</li>
<li>接下来，在 <code>registerStompEndpoints</code> 方法中，我们可以注册一个或多个端点（<code>endpoint</code>），并为每个端点指定一个路径（<code>path</code>）。这样，客户端就可以通过这个路径与服务器进行 WebSocket 通信了。</li>
<li>最后，在 <code>addInterceptors</code> 方法中，我们可以添加一些拦截器（<code>interceptor</code>），用于处理 WebSocket 连接、消息发送和接收等过程中的一些逻辑。例如，我们可以添加一个身份验证拦截器，用于验证客户端的身份信息。</li>
</ul>
<p><code>WebSocketMessageBrokerConfigurer</code> 接口允许我们配置 Stomp 协议的各种属性，包括端点、拦截器、消息转换器等。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>configureMessageBroker()方法</strong></p>
<p>配置消息代理与消息转发</p>
<ul>
<li><code>registry.enableSimpleBroker("/topic")</code>: 启用简单的消息代理，即对于客户端而言，前端需要订阅的就是这个路径，如对应 index.js中的 <code>stompClient.subscribe('/topic/hello', xx)</code></li>
<li><code>registry.setApplicationDestinationPrefixes("/app")</code>: 设置了目标转发的前缀为<code>/app</code>，客户端发送给<code>/app/xxx</code>的消息，会被转发给<code>@MessageMapping</code>注解修饰的方法</li>
</ul>
<p>如我们定义的消息转发实现</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>registerStompEndpoints()方法</strong></p>
<p>注册连接端点</p>
<ul>
<li><code>registry.addEndpoint("/ws/chat/{channel}")</code>: 添加端点，对应的就是客户端建立连接的url</li>
<li><code>.addInterceptors(authHandshakeInterceptor())</code>: 上文中用于身份识别的拦截器</li>
</ul>
<p>此外对于跨域支持，也是在这里进行设置，如在上面的链式使用中，添加 <code>.setAllowedOrigins("*")</code></p>
<p><strong>configureClientInboundChannel()方法</strong></p>
<p>用于设置接收客户端消息的相关配置参数，如线程连接参数、拦截器配置</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>关于拦截器<code>SocketInChannelInterceptor</code>为我们自定义的实现，其内部实现了我们对聊天通知的核心逻辑；咱们下一节再看它</p>
<p>请注意上面配置的taskExecutor, 上面的几个配置参数和线程池的配置参数别无二致，一般建议是使用自定义的线程池来进行管理；方便监控</p>
<p><strong>configureClientOutboundChannel()方法</strong></p>
<p>与前面的使用姿势一致，唯一的区别则在于它主要设置的是服务端返回消息给客户端的相关配置，或者拦截</p>
<h3> 3. 管道拦截</h3>
<p>在完成前面的配置后，接下来我们将进入管道拦截器的重点部分。我们的目标是在用户进入或离开群聊时，向群聊的其他成员推送一条通知。</p>
<p>为了实现这一目标，一个直观的方案是监控客户端的订阅和取消订阅操作，并在此基础上进行相应的操作。因此，我们的核心实现将基于之前定义的<code>SocketInChannelInterceptor</code>。</p>
<p>首先来看一下管道拦截器的接口签名</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对于消息广播通知，我们放在<code>afterSendCompletion</code>来实现，判断客户端的命令，对于订阅/取消订阅进行处理</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的订阅实现相对简单，主要有下面几个关键知识点：</p>
<ol>
<li>封装消息头访问器： <code>StompHeaderAccessor.wrap(message)</code>， 简化请求相关信息的获取方式</li>
<li>判断交互类型： <code>headerAccessor.getCommand()</code></li>
<li>获取请求头：</li>
</ol>
<ul>
<li><code>headerAccessor.getHeader("simpDestination")</code></li>
<li><code>message.getHeaders().get("simpDestination")</code></li>
</ul>
<p>需要注意一点：直接可以从请求头中找到客户端订阅的是哪个群组(通过<code>destination</code>)，但是对于取消订阅时，则拿不到这个信息了，因此需要客户端再取消时，将这个关键信息回传给我们</p>
<h3> 4. 前端订阅/取消订阅</h3>
<p>前面说到了需要再取消订阅的时候，告诉后端退出的是哪个群组，所以我们的客户端的使用上，需要做一些小的适配调整</p>
<p>完整的前端代码可以参考项目源码中的 <code>chat.html</code>， 下面是关键的订阅/取消订阅逻辑</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>再上面的实现中，使用一个对象<code>subscribeMap</code>来存储订阅关系，并设置了订阅的ID 正好等于订阅的<code>channel</code>, 这样在订阅/取消订阅时，都会新增一个id的请求头，如下图所示，这样后端就可以根据这个id来做离开群聊的广播通知</p>
<figure><img src="/imgs/231218/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 5. 效果演示</h3>
<p>接下来我们实际演示一下，开始订阅/和结束订阅时，其他的小伙伴是否可以收到相关的提示消息</p>
<figure><img src="/imgs/231218/01.gif" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>从上图可以比较直观的看到，当一个用户加入群聊时，其他用户/自己均可以正常收到对应的系统通知消息；离开群聊时，因为取消了订阅所以也就只有其他的小伙伴能收到系统消息，而自己是收不到的</p>
<h3> 6. 小结</h3>
<p>本文主要介绍了管道拦截器，用于在接收和发送客户端消息时进行定制开发，以满足特定需求场景。</p>
<p>目前为止，我们所讨论的都是与群聊相关的内容。然而，如果后台系统希望向用户推送私人消息，例如提醒用户在线时间过长需要休息的提示消息，应该如何实现呢？</p>
<h2> III. 不能错过的源码和相关知识点</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-case/207-websocket-chat" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-case/207-websocket-chat</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/231218/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>5.一文教你如何在SpringBoot中使用WebSocket发送消息！</title>
      <link>https://liuyueyi.github.io/tutorial/spring/web/WebSocket/231220-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8BWebSocket%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81%E7%A4%BA%E4%BE%8B.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/web/WebSocket/231220-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8BWebSocket%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81%E7%A4%BA%E4%BE%8B.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">5.一文教你如何在SpringBoot中使用WebSocket发送消息！</source>
      <description>前面介绍的几篇是消息广播，所有在群组内的小伙伴都可以收到消息；那么如果后台只想给某个用户私发消息，可以怎么实现呢？ 本文将主要介绍服务端如何给客户端发送消息</description>
      <category>WEB系列</category>
      <category>WebSocket</category>
      <pubDate>Wed, 20 Dec 2023 14:54:40 GMT</pubDate>
      <content:encoded><![CDATA[<p>前面介绍的几篇是消息广播，所有在群组内的小伙伴都可以收到消息；那么如果后台只想给某个用户私发消息，可以怎么实现呢？</p>
<p>本文将主要介绍服务端如何给客户端发送消息</p>
<!-- more -->
<h2> I. 实例演示</h2>
<h3> 1. 项目搭建</h3>
<p>项目搭建过程与前文类似，请直接参考上文 或者 查看文末的项目源码</p>
<h3> 2. WebSocket配置</h3>
<p>核心的websocket配置依然与之前一致，实现<code>WebSocketMessageBrokerConfigurer</code>接口，定义端点、消息代理、认证授权拦截器</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. 消息发送</h3>
<h4> 3.1 @SendTo 返回消息</h4>
<p>对于服务器若需要将消息发送给客户端，最简单的方式就是接收消息时，直接返回，如</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这个实现，即表示接收 <code>/app/hello</code> 发送的消息，然后将结果转发给所有订阅了  <code>/topic/hello</code> 的客户端</p>
<h4> 3.2 SimpMessagingTemplate 返回消息</h4>
<p>若我们希望更灵活的返回消息，比如后台主动的返回消息，此时则可以借助Spring封装的<code>SimpMessagingTemplate</code>来实现消息回传</p>
<p>直接通过<code>@Autowired</code>的方式注入</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的工具类，主要封装了官方提供的两种返回方式</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>虽然上面提供了两种方式，但是看一下<code>convertAndSendToUser</code>的源码实现会发现，它的底层依然调用的是<code>convertAndSend</code>，向特定用户发送消息，无非就是调整 <code>destination</code> 的取值</p>
<figure><img src="/imgs/231220/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>重点看一下<code>destination</code>的取值 = <code>this.destinationPrefix + user + destination</code> = <code>"/user/" + user + destination</code></p>
<p>所以当我们希望给特定用户发送消息时；需要用户订阅 <code>/user/destination</code> 的地址， 如下</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对于客户端而言，虽然我订阅的是 <code>/user/topic/notify</code>， 但是后台返回消息的目的地，实际上则是 <code>/user/xxxx/topic/notify</code> ，其中的xxx则是用户标识</p>
<p>现在的问题就是，这个用户的标识，是怎么确定的呢?</p>
<ul>
<li>主要就是我们前面做用户身份鉴权中介绍到的<code>HandshakeHandler</code>中定义的Principal</li>
<li>在webscoket的生命周期内，通过Principal来识别用户身份，当需要向后端发送消息时，也是基于它来确定user</li>
</ul>
<h3> 4. 使用实例</h3>
<p>比如写一个定时器，给每个3s给当前登录的用户报时</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/231220/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 5. 小结</h3>
<p>本文主要介绍的是后端如何给客户端发送消息，其中重点介绍了一下当我们希望给用户私发消息时，可以借助<code>simpMessagingTemplate.convertAndSendToUser</code>来实现，当然对应的用户也需要订阅<code>/user/xxx</code>的channel</p>
<p>到目前位置，我们的所有聊天还局限于文本的交流，如果我们希望传图，可以怎么做呢？</p>
<h2> II. 不能错过的源码和相关知识点</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-case/207-websocket-chat" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-case/207-websocket-chat</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/231220/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>7.别再为JS长整型精度丢失烦恼了！这些方法帮你轻松搞定！</title>
      <link>https://liuyueyi.github.io/tutorial/spring/web/%E5%85%B6%E4%BB%96/231027-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8B%E9%95%BF%E6%95%B4%E5%9E%8B%E7%B2%BE%E5%BA%A6%E4%B8%A2%E5%A4%B1%E9%97%AE%E9%A2%98%E4%BF%AE%E5%A4%8D%E6%96%B9%E6%A1%88.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/web/%E5%85%B6%E4%BB%96/231027-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8B%E9%95%BF%E6%95%B4%E5%9E%8B%E7%B2%BE%E5%BA%A6%E4%B8%A2%E5%A4%B1%E9%97%AE%E9%A2%98%E4%BF%AE%E5%A4%8D%E6%96%B9%E6%A1%88.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">7.别再为JS长整型精度丢失烦恼了！这些方法帮你轻松搞定！</source>
      <description>javascript以64位双精度浮点数存储所有Number类型值，即计算机最多存储64位二进制数。 但是需要注意的是Number包含了我们常说的整形、浮点型，相比较于整形而言，会有一位存储小数点的偏移位，由于存储二进制时小数点的偏移量最大为52位，计算机存储的为二进制，而能存储的二进制为62位，超出就会有舍入操作，因此 JS 中能精准表示的最大整数是 Math.pow(2, 53)，十进制即9007199254740992 大于9007199254740992的可能会丢失精度 因此对于java后端返回的一个大整数，如基于前面说到的雪花算法生成的id，前端js接收处理时，就可能出现精度问题 接下来我们以Thymeleaf模板渲染引擎，来介绍一下对于大整数的精度丢失问题的几种解决方案</description>
      <category>SpringBoot</category>
      <category>WEB系列</category>
      <category>Response</category>
      <pubDate>Fri, 27 Oct 2023 13:50:27 GMT</pubDate>
      <content:encoded><![CDATA[<p>javascript以64位双精度浮点数存储所有Number类型值，即计算机最多存储64位二进制数。 但是需要注意的是Number包含了我们常说的整形、浮点型，相比较于整形而言，会有一位存储小数点的偏移位，由于存储二进制时小数点的偏移量最大为52位，计算机存储的为二进制，而能存储的二进制为62位，超出就会有舍入操作，因此 JS 中能精准表示的最大整数是 Math.pow(2, 53)，十进制即<code>9007199254740992</code> 大于<code>9007199254740992</code>的可能会丢失精度</p>
<p>因此对于java后端返回的一个大整数，如基于前面说到的雪花算法生成的id，前端js接收处理时，就可能出现精度问题</p>
<p>接下来我们以Thymeleaf模板渲染引擎，来介绍一下对于大整数的精度丢失问题的几种解决方案</p>
<!-- more -->
<h2> I. 测试项目搭建</h2>
<h3> 1. 依赖</h3>
<p>首先搭建一个标准的SpringBoot项目工程，相关版本以及依赖如下</p>
<p>本项目借助<code>SpringBoot 2.2.1.RELEASE</code> + <code>maven 3.5.3</code> + <code>IDEA</code>进行开发</p>
<p>添加web支持，用于配置刷新演示</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 配置</h3>
<p>接下来配置一下db的相关配置 <code>application.yml</code></p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> II. 长整型适配</h2>
<p>首先我们借助Thymeleaf创建一个简单的页面，用于返回演示长整型的使用</p>
<h3> 1. 场景复现</h3>
<p>模板网页如下</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们直接借助前面实现的Snowflake来生成长整数，写一个对应的接口</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>直接访问，表现如下</p>
<figure><img src="/imgs/231027/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>从截图可以看出，再html标签中，直接使用<code>${hu}</code>获取长整型时，显示正常；</p>
<p>但是js中，获取的长整型，则出现了精度丢失问题</p>
<p>如控制台中打印的 <code>console.log("hu = ", hu);</code> 最后的几位变成了0，与实际不符</p>
<h3> 2. long转String，解决长整型问题</h3>
<p>对于长整型导致的精度问题，最容易想到也是最推荐的解决方案，即对于long类型的参数，改为String方式进行返回，让前端以String的方式进行处理，从而解决精度丢失问题</p>
<p>方案1：修改后端的返回，将长整形改String</p>
<p>如将上面的流程如下修改:</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>方案2：前端js使用String方式接收长整形</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>具体的效果就不再演示，有兴趣的小伙伴可以自己体验一下；这种方式虽然简单有效，但是对现有的项目改造还是挺大的，且很容易有遗漏；自然的，我们就会思考一下，是否有统一的处理方式来解决这种问题</p>
<h3> 3. 修改序列化方式，实现长整型转字符串</h3>
<p>作为后端，前端的使用姿势我们无法控制；为了整个程序的准确性，后端直接返回String格式通常是首选的方案；对于现下主流的前后端分离方案，后端一般是返回json格式的数据，所以要想实现统一的格式转换，自然会想到对序列化做文章</p>
<p>比如SpringBoot默认的jackson序列化框架，直接让其实现对长整型转String的转换</p>
<p>先实现一个工具类，来实现上面的诉求，支持long/bigint/bigdecimal转string</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其次就是注册一个支持长整型转String的序列化转换类<code>HttpMessageConverter</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来我们对比一下，上面注册前后，访问 '<a href="http://localhost:8080/id2" target="_blank" rel="noopener noreferrer">http://localhost:8080/id2</a>' 返回的数据格式</p>
<figure><img src="/imgs/231027/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>基于上面的输出结果，可以看到我们的目标已经实现，返回的长整型会自动转换为字符串；这样前端使用时，就不会出现精度丢失问题了（除非前端又将字符串转number）</p>
<p>上面这个是后端直接返回Json对象数据；这种解决方案适用于 <code>Thymeleaf</code> 模板渲染引擎么？</p>
<ul>
<li>直接访问一下 <code>http://localhost:8080/show</code> 看一下控制台输出</li>
<li>很遗憾的是，依然是<strong>精度丢失</strong></li>
</ul>
<p>why?</p>
<blockquote>
<p>Thymeleaf模板的参数传递，并不是通过<code>HttpMessageConverter</code>来实现的，数据转换的实现主要是靠<code>IStandardJavaScriptSerializer</code></p>
</blockquote>
<h3> 4. Thymeleaf 长整型精度丢失问题解决方案</h3>
<p>既然直接返回json数据可以通过修改序列化的转换方式来实现，那么Thymeleaf按照这个思路，应该也是可行的</p>
<p>直接通过debug，我们可以知道Thymeleaf默认使用的是<code>JacksonStandardJavaScriptSerializer</code>来对js传递的对象进行序列化</p>
<figure><img src="/imgs/231027/02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>从<code>JacksonStandardJavaScriptSerializer</code>的实现来看，比较遗憾的是它并没有支持长整型转字符串，也没有预留给我们进行注册<code>Module</code>的口子</p>
<p>因此一个粗暴的解决方案就是反射拿到它，然后进行主动注册</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面配置完毕之后，正常我们再js中获取到的长整型就会变成字符串，不会再出现精度丢失问题了；直接再次验证一下，正常输出应该如下：</p>
<figure><img src="/imgs/231027/03.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>使用反射的方式虽然可以解决我们的诉求，但是不太优雅，既然官方定义了接口，我们完全可以注册自定义实现，来解决这个问题</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后再将我们自定义的是转换类注册到<code>TemplateEngine</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 5. 小结</h3>
<p>本文的内容相对较多，但是核心的问题解决思路只有一个：</p>
<p><strong>对于长整型的精度问题，解决方案就是将长整型转换为字符串</strong></p>
<p>对应的解决方案有下面几种</p>
<ol>
<li>后端直接编码中，对于长整型的字段转换为字符串进行返回</li>
<li>前端接收时，以字符串方式接收长整形</li>
<li>后端针对json返回，通过注册自定义的<code>HttpMessageConverter</code>做统一的长整型格式化转换</li>
<li>对于Thymeleaf模板渲染引擎，通过修改<code>IStandardJavaScriptSerializer</code>支持长整型的格式转换</li>
</ol>
<p>最后再抛出一个问题，上面给出了Thymeleaf的长整形转换，但是如果我用的是Freemaker渲染引擎， 序列化工具使用的是gson, fastjson，那应该怎么处理呢？</p>
<h2> III. 不能错过的源码和相关知识点</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/600-snowflake-id" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/600-snowflake-id</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/231027/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>1.内存缓存Caffeine基本使用</title>
      <link>https://liuyueyi.github.io/tutorial/spring/basic/%E7%BC%93%E5%AD%98/230307-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8B%E5%86%85%E5%AD%98%E7%BC%93%E5%AD%98Caffeine%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/basic/%E7%BC%93%E5%AD%98/230307-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8B%E5%86%85%E5%AD%98%E7%BC%93%E5%AD%98Caffeine%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">1.内存缓存Caffeine基本使用</source>
      <description>Caffeine作为当下本地缓存的王者被大量的应用再实际的项目中，可以有效的提高服务吞吐率、qps，降低rt 本文将简单介绍下Caffeine的使用姿势</description>
      <category>SpringBoot</category>
      <category>中间件</category>
      <category>Caffiene</category>
      <pubDate>Mon, 06 Mar 2023 22:55:36 GMT</pubDate>
      <content:encoded><![CDATA[<p>Caffeine作为当下本地缓存的王者被大量的应用再实际的项目中，可以有效的提高服务吞吐率、qps，降低rt</p>
<p>本文将简单介绍下Caffeine的使用姿势</p>
<!-- more -->
<h2> 项目配置</h2>
<h3> 1. 依赖</h3>
<p>首先搭建一个标准的SpringBoot项目工程，相关版本以及依赖如下</p>
<p>本项目借助<code>SpringBoot 2.2.1.RELEASE</code> + <code>maven 3.5.3</code> + <code>IDEA</code>进行开发</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 使用实例</h2>
<p>引入上面的jar包之后，就可以进入caffeine的使用环节了；我们主要依照官方wiki来进行演练</p>
<blockquote>
<ul>
<li><a href="https://github.com/ben-manes/caffeine/wiki/Home-zh-CN" target="_blank" rel="noopener noreferrer">Home zh CN · ben-manes/caffeine Wiki</a></li>
</ul>
</blockquote>
<p>caffeine提供了四种缓存策略，主要是基于手动添加/自动添加，同步/异步来进行区分</p>
<p>其基本使用姿势于Guava差不多</p>
<h3> 1. 手动加载</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 1.1 三种失效策略</h4>
<p>注意参数设置，我们先看一下失效策略，共有下面几种</p>
<p><strong>权重：</strong></p>
<ul>
<li>maximumSize: 基于容量策略，当缓存内元素个数超过时，通过基于就近度和频率的算法来驱逐掉不会再被使用到的元素</li>
<li>maximumWeight: 基于权重的容量策略，主要应用于缓存中的元素存在不同的权重场景</li>
</ul>
<p><strong>时间：</strong></p>
<ul>
<li>expireAfterAccess: 基于访问时间</li>
<li>expireAfterWrite: 基于写入时间</li>
<li>expireAfter: 可以根据读更新写入来调整有效期</li>
</ul>
<p><strong>引用：</strong></p>
<ul>
<li>weakKeys: 保存的key为弱引用</li>
<li>weakValues: 保存的value会使用弱引用</li>
<li>softValues: 保存的value使用软引用</li>
</ul>
<p>弱引用：这允许在GC的过程中，当没有被任何强引用指向的时候去将缓存元素回收</p>
<p>软引用：在GC过程中被软引用的对象将会被通过LRU算法回收</p>
<h4> 1.2 缓存增删查姿势</h4>
<p>接下来我们看一下手动方式的使用</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>查询缓存&amp;添加缓存</strong></p>
<ul>
<li><code>getIfPresent(key)</code>: 不存在时，返回null</li>
<li><code>get(key, (key) -&gt; {value初始化策略})</code>: 不存在时，会根据第二个lambda表达式来写入数据，这个就表示的是手动加载缓存</li>
<li><code>asMap</code>: 获取缓存所有数据</li>
</ul>
<p><strong>添加缓存</strong></p>
<ul>
<li><code>put(key, val)</code>: 主动添加缓存</li>
</ul>
<p><strong>清空缓存</strong></p>
<ul>
<li><code>invalidate</code>: 主动移除缓存</li>
<li><code>invalidateAll</code>: 失效所有缓存</li>
</ul>
<p>执行完毕之后，输出日志:</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 自动加载</h3>
<p>在创建的时候，就指定缓存未命中时的加载规则</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>它的配置，与前面介绍的一致；主要的区别点在于build时，确定缓存值的获取方式</p>
<h4> 2.1 缓存使用姿势</h4>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>与前面的区别在于获取缓存值的方式</p>
<ul>
<li>get(key): 不用传第二个参数，直接传key获取对应的缓存值，如果没有自动加载数据</li>
<li>getAll(keys): 可以批量获取数据，若某个key不再缓存中，会自动加载；在里面的则直接使用缓存的</li>
</ul>
<p>实际输出结果如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3.异步手动加载</h3>
<p>异步，主要是值在获取换粗内容时，采用的异步策略；使用与前面没有什么太大差别</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 3.1 缓存使用姿势</h4>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>getIfPresent: 存在时返回CompletableFuture，不存在时返回null，因此注意npe的问题</li>
<li>get(key, Function&lt;&gt;): 第二个参数表示加载数据的逻辑</li>
<li>put(key, CompletableFuture&lt;&gt;): 手动加入缓存，注意这里也不是直接加一个具体的value到缓存</li>
<li>synchronous().invalidate() : 同步清除缓存</li>
<li>getAll: 一次获取多个缓存，同样的是在缓存的取缓存，不在的根据第二个传参进行加载</li>
</ul>
<p>与前面相比，使用姿势差不多，唯一注意的是，获取的并不是直接的结果，而是CompletableFuture，上面执行之后的输出如下：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4. 异步自动加载</h3>
<p>在定义缓存时，就指定了缓存不存在的加载逻辑；与第二个相比区别在于这里是异步加载数据到缓存中</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 4.1 缓存使用姿势</h4>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 不能错过的源码和相关知识点</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>2.内存Caffeine整合Cachebale注解</title>
      <link>https://liuyueyi.github.io/tutorial/spring/basic/%E7%BC%93%E5%AD%98/230308-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8B%E5%86%85%E5%AD%98%E7%BC%93%E5%AD%98Caffeine%E6%95%B4%E5%90%88Cachebale%E6%B3%A8%E8%A7%A3.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/basic/%E7%BC%93%E5%AD%98/230308-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8B%E5%86%85%E5%AD%98%E7%BC%93%E5%AD%98Caffeine%E6%95%B4%E5%90%88Cachebale%E6%B3%A8%E8%A7%A3.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">2.内存Caffeine整合Cachebale注解</source>
      <description>前面一片文章虽说介绍了Caffeine的使用方式，但是更多的是偏向于基础的Caffeine用法；接下来这边博文将给大家介绍一下Caffeine结合Spring的@Cacheable注解，来实现内部缓存的使用姿势</description>
      <category>SpringBoot</category>
      <category>中间件</category>
      <category>Caffiene</category>
      <pubDate>Wed, 08 Mar 2023 22:55:36 GMT</pubDate>
      <content:encoded><![CDATA[<p>前面一片文章虽说介绍了Caffeine的使用方式，但是更多的是偏向于基础的Caffeine用法；接下来这边博文将给大家介绍一下Caffeine结合Spring的<code>@Cacheable</code>注解，来实现内部缓存的使用姿势</p>
<!-- more -->
<h2> 项目配置</h2>
<h3> 1. 依赖</h3>
<p>首先搭建一个标准的SpringBoot项目工程，相关版本以及依赖如下</p>
<p>本项目借助<code>SpringBoot 2.2.1.RELEASE</code> + <code>maven 3.5.3</code> + <code>IDEA</code>进行开发</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 配置</h3>
<p>SpringBoot官方对Caffeine的集成，提供了非常好的支持，比如本文介绍的在使用 <code>@Cacheable</code> 注解来处理缓存时，我们无需额外操作，直接在配置文件来实现缓存的指定，以及对应的Caffeine相关配置限定</p>
<p>核心配置如下 application.yml</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的 spring.cache.type 主要用来表明缓存注解的具体缓存实现为 Caffeine，当然还可以是Guava、redis等</p>
<p>其次就是 <code>spring.cache.caffeine.spec</code>， 它指定了Caffeine的初始化容量大小，最大个数，失效时间等 （无特殊场景时，所有的缓存注解都是公用这个配置的）</p>
<h2> 使用实例</h2>
<h3> 1. 开启缓存注解支持</h3>
<p>首先在启动类上添加 <code>@EnableCaching</code> 注解，注意若不加则缓存不会生效</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 使用实例</h3>
<p>我们定义一个UserService，主要是用来操作用户相关信息，现在先定义一个<code>User</code>实体类</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后添加增删查</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面分别介绍了三个注解</p>
<ul>
<li>CachePut: 不管缓存有没有，都将方法的返回结果写入缓存中</li>
<li>Cacheable: 先从缓存查，没有则执行方法，并塞入缓存</li>
<li>CacheEvit: 失效缓存</li>
</ul>
<p>其次在类上还有一个<code>@CacheConfig</code>注解，主要定义了一个 <code>cacheNames</code> 属性，当我们使用缓存注解时，需要注意的是这个cacheNames必须得有，否则就会报错</p>
<p>当一个类中所有缓存公用一个cacheNames时，可以直接在类上添加<code>@CacheConfig</code>来避免在每个地方都添加指定</p>
<h3> 3. 写个测试demo</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们来实际看一下，第一次没有数据时，返回的是不是空；当有数据之后，缓存是否会命中</p>
<figure><img src="/imgs/230308/00.gif" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 4. 小结</h3>
<p>这篇博文主要介绍了SpringBoot如何整合Caffeine，结合Spring的缓存注解，基于可以说是很低成本的就让我们的方法实现缓存功能，但是请注意，有几个注意点</p>
<ol>
<li>当我并不希望所有数据公用一个缓存时，怎么处理？</li>
</ol>
<ul>
<li>比如我有一些关键数据，虽然访问频率可能没那么高，但是还每次实际读取的成本很高，又不怎么变动，我希望可以更长久的缓存；</li>
<li>如果公用一个缓存，则有可能导致它们被其他的热点数据给挤下线了（超过最大数量限制给删除了）</li>
</ul>
<ol start="2">
<li>在实际使用时，需要特别注意，加了缓存注解之后，返回的实际上是缓存中的对象，如上面返回的是User对象还好，如果返回的是一个容器，那么直接像这些容器中进行额外的添加、删除元素，是直接影响缓存结果的</li>
</ol>
<p>另外，查看本文推荐结合下面几篇博文一起享用，以获取更多的知识点</p>
<ul>
<li><a href="https://spring.hhui.top/spring-blog/2021/06/16/210616-SpringBoot%E7%BC%93%E5%AD%98%E6%B3%A8%E8%A7%A3-Cacheable-CacheEvit-CachePut%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF%E4%BB%8B%E7%BB%8D/" target="_blank" rel="noopener noreferrer">【DB系列】缓存注解@Cacheable @CacheEvit @CachePut使用姿势介绍 | 一灰灰Blog</a></li>
<li><a href="https://spring.hhui.top/spring-blog/2021/07/01/210701-SpringBoot%E7%BC%93%E5%AD%98%E6%B3%A8%E8%A7%A3-Cacheable%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89key%E7%AD%96%E7%95%A5%E5%8F%8A%E7%BC%93%E5%AD%98%E5%A4%B1%E6%95%88%E6%97%B6%E9%97%B4%E6%8C%87%E5%AE%9A/" target="_blank" rel="noopener noreferrer">【DB系列】SpringBoot缓存注解@Cacheable之自定义key策略及缓存失效时间指定 | 一灰灰Blog</a></li>
</ul>
<h2> 不能错过的源码和相关知识点</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/500-cache-caffeine" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/500-cache-caffeine</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/230308/00.gif" type="image/gif"/>
    </item>
    <item>
      <title>3.内存缓存Caffiene自定义CacheManager</title>
      <link>https://liuyueyi.github.io/tutorial/spring/basic/%E7%BC%93%E5%AD%98/230309-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8B%E5%86%85%E5%AD%98%E7%BC%93%E5%AD%98Caffiene%E8%87%AA%E5%AE%9A%E4%B9%89CacheBean.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/basic/%E7%BC%93%E5%AD%98/230309-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8B%E5%86%85%E5%AD%98%E7%BC%93%E5%AD%98Caffiene%E8%87%AA%E5%AE%9A%E4%B9%89CacheBean.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">3.内存缓存Caffiene自定义CacheManager</source>
      <description>上一篇介绍了Caffiene整合Spring的缓存注解@Cacheable，在这篇示例中，所有的缓存公用，但是实际的场景中，我们可能会更希望针对不同的场景，配置不同的缓存（比如我的关键数据，虽然访问频率可能没那么高，但是每次实际读取的成本很高，又不怎么变动，我希望可以更长久的缓存；不希望这些数据因为缓存的淘汰策略被其他的热点数据给淘汰掉），那么可以怎么处理呢？ 接下来我们来看一下两种不同的方式，来实现上面的诉求</description>
      <category>SpringBoot</category>
      <category>中间件</category>
      <category>Caffiene</category>
      <pubDate>Thu, 09 Mar 2023 17:55:36 GMT</pubDate>
      <content:encoded><![CDATA[<p>上一篇介绍了Caffiene整合Spring的缓存注解@Cacheable，在这篇示例中，所有的缓存公用，但是实际的场景中，我们可能会更希望针对不同的场景，配置不同的缓存（比如我的关键数据，虽然访问频率可能没那么高，但是每次实际读取的成本很高，又不怎么变动，我希望可以更长久的缓存；不希望这些数据因为缓存的淘汰策略被其他的热点数据给淘汰掉），那么可以怎么处理呢？</p>
<p>接下来我们来看一下两种不同的方式，来实现上面的诉求</p>
<!-- more -->
<h2> 项目配置</h2>
<h3> 1. 依赖</h3>
<p>首先搭建一个标准的SpringBoot项目工程，相关版本以及依赖如下</p>
<p>本项目借助<code>SpringBoot 2.2.1.RELEASE</code> + <code>maven 3.5.3</code> + <code>IDEA</code>进行开发</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>与前面不同，我们不需要在配置文件中指定缓存类型以及caffeine的相关条件参数，直接放在配置类中</p>
<h3> 2. 配置类</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意上面的 cacheList，其中传入的就是<code>Cache</code>对象，每个Cache对象就可以理解为一个缓存实例，重点注意构造参数中的第一个<code>customCache</code>，这个就是后面缓存具体使用时，注解中的<code>cacheNames</code>属性</p>
<h2> 使用实例</h2>
<h3> 1. SimpleCacheManager 使用实例</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>重点注意一下上面的<code>@CacheConfig</code>，它定义了这个类中的的缓存，都使用 <code>customCacheManager</code> 缓存管理器，且具体的缓存为定义的<code>customCache</code> （改成其他的会报错）</p>
<p>从上面的配置声明，也可以看出，当我们希望使用多个缓存时，可以直接如下面这种方式进行扩展即可</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. CaffeineCacheManager 方式</h3>
<p>除了上面这种方式之外，我们当然也可以再额外定义一个CacheManager，如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用上面这种方式，cacheName可以不需要指定，具体使用如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>方法的内部实现完全一致；重点看<code>@CacheConfig</code>中的属性值</p>
<ul>
<li>cacheNames 表示这个缓存前缀，没有约束限制</li>
</ul>
<h3> 3. 测试</h3>
<p>上面介绍了两种使用不同缓存的姿势：</p>
<ul>
<li>SimpleCacheManager: 定义多个Cache</li>
<li>多个CacheManager</li>
</ul>
<p>我们写个简单的验证上面两个CacheManager表示不同缓存的测试用例</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>操作步骤：</p>
<ul>
<li>anoCacheService 写入缓存</li>
<li>anoCacheService2 查看缓存，此时不应该能查到前面写入的缓存</li>
</ul>
<figure><img src="/imgs/230309/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> 不能错过的源码和相关知识点</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/501-cache-caffeine-special" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/501-cache-caffeine-special</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/230309/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>缓存</title>
      <link>https://liuyueyi.github.io/tutorial/spring/basic/%E7%BC%93%E5%AD%98/</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/basic/%E7%BC%93%E5%AD%98/</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">缓存</source>
      <description>SpringBoot 缓存相关知识点 guava caffeine</description>
      <pubDate>Thu, 21 Sep 2023 09:55:31 GMT</pubDate>
      <content:encoded><![CDATA[<p>SpringBoot 缓存相关知识点</p>
<ul>
<li>guava</li>
<li>caffeine</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>14. 编程式属性绑定Binder</title>
      <link>https://liuyueyi.github.io/tutorial/spring/basic/%E9%85%8D%E7%BD%AE/14.230618-SpringBoot%E4%B9%8B%E7%BC%96%E7%A8%8B%E5%BC%8F%E5%B1%9E%E6%80%A7%E7%BB%91%E5%AE%9ABinder.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/basic/%E9%85%8D%E7%BD%AE/14.230618-SpringBoot%E4%B9%8B%E7%BC%96%E7%A8%8B%E5%BC%8F%E5%B1%9E%E6%80%A7%E7%BB%91%E5%AE%9ABinder.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">14. 编程式属性绑定Binder</source>
      <description>SpringBoot中极大的简化了项目中对于属性配置的加载方式，可以简单的通过 @Value, @ConfigurationProperties 来实现属性配置与Java POJO对象、Bean的成员变量的绑定，那如果出现一个某些场景，需要我们手动的、通过编程式的方式，将属性配置与给定的pojo对象进行绑定，我们又应该怎么实现呢?</description>
      <category>SpringBoot</category>
      <category>基础系列</category>
      <category>配置</category>
      <pubDate>Sun, 18 Jun 2023 11:28:28 GMT</pubDate>
      <content:encoded><![CDATA[<p>SpringBoot中极大的简化了项目中对于属性配置的加载方式，可以简单的通过 <code>@Value</code>, <code>@ConfigurationProperties</code> 来实现属性配置与Java POJO对象、Bean的成员变量的绑定，那如果出现一个某些场景，需要我们手动的、通过编程式的方式，将属性配置与给定的pojo对象进行绑定，我们又应该怎么实现呢?</p>
<!-- more -->
<h2> I. 项目配置</h2>
<h3> 1. 依赖</h3>
<p>首先搭建一个标准的SpringBoot项目工程，相关版本以及依赖如下</p>
<p>本项目借助<code>SpringBoot 2.2.1.RELEASE</code> + <code>maven 3.5.3</code> + <code>IDEA</code>进行开发</p>
<h3> 2. 启动入口</h3>
<p>我们使用默认的配置进行测试，因此启动入口也可以使用最基础的</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> II. 实例演示</h2>
<h3> 1. 基础知识点Binder</h3>
<p>本文的目的主要是给大家介绍编程式的属性绑定，当然除了我们最熟悉的直接写代码，从<code>Environment</code>中获取配置之外，还可以使用Binder来更方便的实现属性绑定</p>
<p>因此我们首先来了解一下这个不太常出现在CURD的日常工作中的Binder类：</p>
<blockquote>
<p><a href="https://docs.spring.io/spring-boot/docs/current/api/org/springframework/boot/context/properties/bind/Binder.html" target="_blank" rel="noopener noreferrer">Binder JavaDoc</a></p>
</blockquote>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>两种常见的使用姿势：</p>
<ul>
<li>bind方法: 将属性绑定到对应的类上, 不会返回null</li>
<li>bindOrCreate: 将属性绑定到对应的类上, 返回结果可能为null</li>
</ul>
<h3> 2. 实例演示</h3>
<p>接下来我们看几个常见的使用姿势</p>
<h4> 2.1 配置绑定到POJO属性类</h4>
<p>直接将配置绑定到我们自定义的属性配置类上，也就是我们最常见的、可直接利用<code>@ConfigurationProperties</code>来实现的使用方式</p>
<p>我们在配置文件中，添加一个基础的配置</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来定义一个对应的属性配置类Mail</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后我们的使用姿势，将如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面的基础使用姿势之上，我们再加两个使用姿势</p>
<ul>
<li>配置不存在时，返回什么？</li>
<li>使用bind对于不存在时，如何表现</li>
</ul>
<p>微调一下上面的bindInfo()方法</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>执行之后，输出如下</p>
<figure><img src="/imgs/230618/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>从上面的输出可以看出，对于</p>
<ul>
<li>bindOrCreat 而言，若整个配置不存在，返回一个空对象，内部属性为null； bind 若相关的配置不存在，会抛异常 (这个不存在指的是配置前缀<code>demo.mail2</code>的都没有)</li>
<li>配置内的某个属性不存在，如 <code>demo.mail.user</code> 这个配置不存在时（配置中的是username），此时bind/bindOrCrate 返回的对象中，相关的属性是null (主意这种场景 bind 方法调用不会抛移异常，有兴趣的小伙伴可以实际验证一下)</li>
</ul>
<h4> 2.2 配置绑定到List对象</h4>
<p>在实际的应用场景中，配置为数组的可能性也很高，比如我有一个代理库，对应的相关配置如下</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>此时我们的实际使用姿势可以如下</p>
<ul>
<li>首先定义Proxy类</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对应的手动绑定方式</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4> 2.3 配置绑定到Map对象</h4>
<p>将属性配置绑定到一个Map的场景也不算少见，如之前写过的多数据源自主切换的实现方式中，就有这么个场景</p>
<ul>
<li><a href="https://spring.hhui.top/spring-blog/2021/01/10/210110-SpringBoot%E7%B3%BB%E5%88%97Mybatis%E5%9F%BA%E4%BA%8EAbstractRoutingDataSource%E4%B8%8EAOP%E5%AE%9E%E7%8E%B0%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E5%88%87%E6%8D%A2/" target="_blank" rel="noopener noreferrer">SpringBoot系列Mybatis基于AbstractRoutingDataSource与AOP实现多数据源切换/</a></li>
</ul>
<p>我们写一个简单的配置模拟上面的场景</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面的配置中，master/slave 为数据源名称，在下面的配置则为数据源配置信息，结构都一致；基于此，我们需要声明的配置类实际为</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>配置绑定的实现也很简单，与上面List的类似</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>执行之后的输出结果如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4> 2.4 配置转换处理</h4>
<p>上面介绍的姿势都是直接将配置绑定到对应的java对象上，那么我们是否会存在需要对配置属性进行特殊处理的场景呢？</p>
<p>这种场景当然也不算少见，如驼峰与下划线的互转，如密码之类的配置文件中属于加密填写，应用加载时需要解密之后使用等</p>
<p>对于这种场景，我们也给出一个简单的实例，在配置文件中，添加一个base64加密的数据</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对应的解析方式</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>执行之后，实际输出结果如下：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4> 2.5 绑定方法回调</h4>
<p>除了上面介绍到的属性绑定姿势之外，Binder还非常贴心的给大家提供了过程回调，给你提供更灵活的控制方式</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>同样是实现配置解密，如上面的方式也是可行的，对应的输出如</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. 小结</h3>
<p>本文的知识点比较简单，属于看过就会的范畴，但是它的实际应用场景可以说非常多；特别是当我们在某些场景下，直接使用SpringBoot的属性配置绑定不太好实现时，如动态数据源、配置的回调处理等，不妨考虑借助Binder来实现编程式的配置绑定加载</p>
<p>其次本文只介绍了Binder类的使用姿势，有好气的小伙伴，自然会想了解它的具体实现姿势，它是怎么实现配置属性与java实体类进行绑定的呢？ 类型转换如何支持的呢？ 如果让我们自己来实现配置绑定，可以怎么支持呢？</p>
<p>不妨再进一步，让我们实现一个自定义的配置加载、解析、绑定并注入到Spring容器的解决方案，可以怎么整？</p>
<h2> III. 不能错过的源码和相关知识点</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/230618/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>15.自定义属性配置绑定极简实现姿势介绍</title>
      <link>https://liuyueyi.github.io/tutorial/spring/basic/%E9%85%8D%E7%BD%AE/15.230627-SpringBoot%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7%E9%85%8D%E7%BD%AE%E7%BB%91%E5%AE%9A%E5%AE%9E%E7%8E%B0%E4%BB%8B%E7%BB%8D.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/basic/%E9%85%8D%E7%BD%AE/15.230627-SpringBoot%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7%E9%85%8D%E7%BD%AE%E7%BB%91%E5%AE%9A%E5%AE%9E%E7%8E%B0%E4%BB%8B%E7%BB%8D.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">15.自定义属性配置绑定极简实现姿势介绍</source>
      <description>使用过SpringBoot应用的小伙伴应该对它配套的配置文件application.yml不会陌生，通常我们将应用需要的配置信息，放在配置文件中，然后再应用中，就可以通过 @Value 或者 @ConfigurationProperties来引用 那么配置信息只能放在这些配置文件么？ 能否从db/redis中获取配置信息呢？ 又或者借助http/rpc从其他的应用中获取配置信息呢？ 答案当然是可以，比如我们熟悉的配置中心（apollo, nacos, SpringCloudConfig) 接下来我们将介绍一个不借助配置中心，也可以实现自定义配置信息加载的方式，并且支持配置的动态刷新</description>
      <category>SpringBoot</category>
      <category>基础系列</category>
      <category>配置</category>
      <pubDate>Tue, 27 Jun 2023 04:46:58 GMT</pubDate>
      <content:encoded><![CDATA[<p>使用过SpringBoot应用的小伙伴应该对它配套的配置文件application.yml不会陌生，通常我们将应用需要的配置信息，放在配置文件中，然后再应用中，就可以通过 <code>@Value</code> 或者 <code>@ConfigurationProperties</code>来引用</p>
<p>那么配置信息只能放在这些配置文件么？ 能否从db/redis中获取配置信息呢？ 又或者借助http/rpc从其他的应用中获取配置信息呢？</p>
<p>答案当然是可以，比如我们熟悉的配置中心（apollo, nacos, SpringCloudConfig)</p>
<p>接下来我们将介绍一个不借助配置中心，也可以实现自定义配置信息加载的方式，并且支持配置的动态刷新</p>
<!-- more -->
<h2> I. 项目配置</h2>
<h3> 1. 依赖</h3>
<p>首先搭建一个标准的SpringBoot项目工程，相关版本以及依赖如下</p>
<p>本项目借助<code>SpringBoot 2.2.1.RELEASE</code> + <code>maven 3.5.3</code> + <code>IDEA</code>进行开发</p>
<p>添加web支持，用于配置刷新演示</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 启动入口</h3>
<p>我们使用默认的配置进行测试，因此启动入口也可以使用最基础的</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> II. 自定义配置实现</h2>
<h3> 1. 方案设计</h3>
<p>我们的目标是实现一个自定义的配置信息加载，并支持配置与Spring bean对象的绑定，同时我们还需要支持这个配置的动态刷新</p>
<p>基于上面这个目标，要想实现则需要几个知识储备：</p>
<ul>
<li><a href="https://spring.hhui.top/spring-blog/2020/05/07/200507-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B9%8B%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E8%87%AA%E5%AE%9A%E4%B9%89%E9%85%8D%E7%BD%AE%E5%8A%A0%E8%BD%BD%E5%99%A8/" target="_blank" rel="noopener noreferrer">【基础系列】 实现一个自定义配置加载器（应用篇） | 一灰灰Blog</a></li>
<li><a href="https://spring.hhui.top/spring-blog/2021/01/17/210117-SpringBoot%E7%B3%BB%E5%88%97ConfigurationProperties%E9%85%8D%E7%BD%AE%E7%BB%91%E5%AE%9A%E4%B8%AD%E9%82%A3%E4%BA%9B%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%E4%BA%8B%E6%83%85/" target="_blank" rel="noopener noreferrer">【基础系列】 ConfigurationProperties配置绑定中那些你不知道的事情 | 一灰灰Blog</a></li>
<li><a href="https://spring.hhui.top/spring-blog/2021/08/01/210801-SpringBoot%E5%BA%94%E7%94%A8%E7%AF%87-Value%E6%B3%A8%E8%A7%A3%E6%94%AF%E6%8C%81%E9%85%8D%E7%BD%AE%E8%87%AA%E5%8A%A8%E5%88%B7%E6%96%B0%E8%83%BD%E5%8A%9B%E6%89%A9%E5%B1%95/" target="_blank" rel="noopener noreferrer">【基础系列】 SpringBoot应用篇@Value注解支持配置自动刷新能力扩展 | 一灰灰Blog</a></li>
<li><a href="https://spring.hhui.top/spring-blog/2023/06/18/230618-SpringBoot%E4%B9%8B%E7%BC%96%E7%A8%8B%E5%BC%8F%E5%B1%9E%E6%80%A7%E7%BB%91%E5%AE%9ABinder/" target="_blank" rel="noopener noreferrer">【基础系列】 编程式属性绑定Binder | 一灰灰Blog</a></li>
</ul>
<p>结合上面的知识点，我们主要需要实现的有三步：</p>
<ol>
<li>读取自定义的配置</li>
<li>扫描需要绑定自定义配置的bean</li>
<li>借助Binder来重新绑定bean中的定义的属性到envionment的配置参数（这里就包含了自定义的配置及默认的配置）</li>
</ol>
<h3> 2. 实现方式</h3>
<p>为了简化自定义的配置使用，我们这里直接使用一个内存缓存来模拟自定义的配置源</p>
<h4> 2.1 加载自定义配置源</h4>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意上面的实现，这里是自定义的配置源 propertySources 中包含了environment的配置信息；如果希望将自定义的配置信息源注入到environment，可以如下实现</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h4> 2.2 扫描需要绑定bean</h4>
<p>接下来我们自定义一个注解<code>@ConfDot</code>, 凡是带有这个注解的bean的成员变量，从上面的属性源中进行初始化</p>
<p>这个注解可以完全按照<code>@ConfigurationProperties</code>的来设计（实际上我们也可以直接使用<code>@ConfigurationProperties</code>注解，这样适用范围更广了）</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后借助Spring来扫描带有特定注解的bean，就可以很简单了</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 2.3 bean与配置的绑定</h4>
<p>上面两部完成之后，接下来就需要我们将配置与bean进行绑定，这里就主要使用Binder来实现我们的预期功能了</p>
<p>实现一个自定义的绑定工具类</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的实现虽然多，但是核心其实比较简单：</p>
<ol>
<li>初始化Binder对象 <code>this.binder = new Binder(getConfigurationPropertySources(), getPropertySourcesPlaceholdersResolver(), getConversionService(), getPropertyEditorInitializer());</code></li>
<li>提供绑定入口</li>
</ol>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 2.4 完整实现</h4>
<p>上面的三步实现，基本上已经将整个功能给实现了，其中<code>SelfConfigBinder</code>提供了完成的代码实现，接下来我们再将第一步与第三步的整合，来看一下完整的实现，并且提供一个配置刷新的支持</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. 测试验证</h3>
<p>接下来就是验证一下上面的设计，首先再配置文件中，添加几个默认的信息</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>绑定配置的bean对象</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这个MyConfig中的 user, pwd 从前面的配置文件中获取，然后type则此自定义的配置信息<code>configCache</code>中获取，应该是12，接下来我们首先一个访问与刷新的接口</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>实际执行测试如下图</p>
<figure><img src="/imgs/230627/00.gif" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> III. 不能错过的源码和相关知识点</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-case/003-self-config-binder" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-case/003-self-config-binder</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/230627/00.gif" type="image/gif"/>
    </item>
    <item>
      <title>1.数据库初始化-DataSourceInitializer方式</title>
      <link>https://liuyueyi.github.io/tutorial/spring/db/%E5%9F%BA%E7%A1%80/221221-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%9D%E5%A7%8B%E5%8C%96-DataSourceInitializer%E6%96%B9%E5%BC%8F.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/db/%E5%9F%BA%E7%A1%80/221221-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%9D%E5%A7%8B%E5%8C%96-DataSourceInitializer%E6%96%B9%E5%BC%8F.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">1.数据库初始化-DataSourceInitializer方式</source>
      <description>前面介绍的两篇基于配置方式的数据库初始化方式，使用起来非常简单，但是有一个非常明显的问题，如何实现表结构存在时不再初始化，不存在时才执行？ 如果数据库也不存在，也需要初始化时创建，可行么？ 接下来介绍一下如何使用DataSourceInitializer来实现自主可控的数据初始化</description>
      <category>SpringBoot</category>
      <category>DB系列</category>
      <category>初始化</category>
      <pubDate>Wed, 21 Dec 2022 11:52:03 GMT</pubDate>
      <content:encoded><![CDATA[<p>前面介绍的两篇基于配置方式的数据库初始化方式，使用起来非常简单，但是有一个非常明显的问题，如何实现表结构存在时不再初始化，不存在时才执行？ 如果数据库也不存在，也需要初始化时创建，可行么？</p>
<p>接下来介绍一下如何使用DataSourceInitializer来实现自主可控的数据初始化</p>
<!-- more -->
<h2> I. 项目搭建</h2>
<h3> 1. 依赖</h3>
<p>首先搭建一个标准的SpringBoot项目工程，相关版本以及依赖如下</p>
<p>本项目借助<code>SpringBoot 2.2.1.RELEASE</code> + <code>maven 3.5.3</code> + <code>IDEA</code>进行开发</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>本文使用MySql数据库, 版本8.0.31</p>
<h3> 2. 配置</h3>
<p>注意实现初始化数据库表操作的核心配置就在下面，重点关注</p>
<p>配置文件： <code>resources/application.yml</code></p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意上面的配置，我们新定义了一个数据库的配置项 <code>database.name</code>， 主要是为了检测database是否存在，若不存在时，创建对应的数据库时使用</p>
<p>接下来是初始化sql脚本</p>
<p><code>resources/init-schema.sql</code> 对应的初始化ddl</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>resources/init-data.sql</code> 对用的初始化dml</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2> II. 初始化</h2>
<h3> 1.初始化配置</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们这里主要是借助 DataSourceInitializer 来实现初始化，其核心有两个配置</p>
<ul>
<li>DatabasePopulator: 通过<code>addScripts</code>来指定对应的sql文件</li>
<li>DataSourceInitializer#setEnabled: 判断是否需要执行初始化</li>
</ul>
<p>接下来重点需要看的就是needInit方法，我们再这个方法里面，需要判断数据库是否存在，若不存在时，则创建数据库；然后再判断表是否存在，以此来决定是否需要执行初始化方法</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的数据库判断是否存在以及初始化的过程相对基础，直接使用了基础的Connection进行操作；这里借助了SpringUtil来获取配置信息，对应的类源码如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>到此整个初始化相关的配置已经完成；接下来我们验证一下</p>
<h3> 2.验证</h3>
<p>再项目启动成功之后，查看一下数据</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/221221/03.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 3. 小结</h3>
<p>本文主要介绍的是基于<code>DataSourceInitializer</code>来实现自主可控的数据初始化，其核心配置为</p>
<ul>
<li>DatabasePopulator: 通过<code>addScripts</code>来指定对应的sql文件</li>
<li>DataSourceInitializer#setEnabled: 判断是否需要执行初始化</li>
</ul>
<p>此外本文还介绍了如何判断数据库是否存在，当数据库不存在时，借助基础的Connection来建立连接，创建数据库；从初始化角度来看，这几篇文中介绍的方式已经足够，但是在项目制的场景下，我们需要记录数据库的版本迭代记录，下一篇将介绍如何使用liquibase来实现数据版本管理，解决初始化以及增量的迭代变更</p>
<h2> III. 不能错过的源码和相关知识点</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/221221/03.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>2.数据库初始化-datasource配置方式</title>
      <link>https://liuyueyi.github.io/tutorial/spring/db/%E5%9F%BA%E7%A1%80/221221-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%9D%E5%A7%8B%E5%8C%96-datasource%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/db/%E5%9F%BA%E7%A1%80/221221-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%9D%E5%A7%8B%E5%8C%96-datasource%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">2.数据库初始化-datasource配置方式</source>
      <description>在我们的日常业务开发过程中，如果有db的相关操作，通常我们是直接建立好对应的库表结构，并初始化对应的数据，即更常见的情况下是我们在已有表结构基础之下，进行开发； 但是当我们是以项目形式工作时，更常见的做法是所有的库表结构变更、数据的初始、更新等都需要持有对应的sql变更，并保存在项目工程中，这也是使用liqubase的一个重要场景； 将上面的问题进行简单的翻译一下，就是如何实现在项目启动之后执行相应的sql，实现数据库表的初始化？ 本文将作为初始化方式的第一篇：基于SpringBoot的配置方式实现的数据初始化</description>
      <category>SpringBoot</category>
      <category>DB系列</category>
      <category>初始化</category>
      <pubDate>Wed, 21 Dec 2022 09:57:22 GMT</pubDate>
      <content:encoded><![CDATA[<p>在我们的日常业务开发过程中，如果有db的相关操作，通常我们是直接建立好对应的库表结构，并初始化对应的数据，即更常见的情况下是我们在已有表结构基础之下，进行开发；
但是当我们是以项目形式工作时，更常见的做法是所有的库表结构变更、数据的初始、更新等都需要持有对应的sql变更，并保存在项目工程中，这也是使用liqubase的一个重要场景；
将上面的问题进行简单的翻译一下，就是如何实现在项目启动之后执行相应的sql，实现数据库表的初始化？</p>
<p>本文将作为初始化方式的第一篇：基于SpringBoot的配置方式实现的数据初始化</p>
<!-- more -->
<h2> I. 项目搭建</h2>
<h3> 1. 依赖</h3>
<p>首先搭建一个标准的SpringBoot项目工程，相关版本以及依赖如下</p>
<p>本项目借助<code>SpringBoot 2.2.1.RELEASE</code> + <code>maven 3.5.3</code> + <code>IDEA</code>进行开发</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>本文使用MySql数据库, 版本8.0.31</p>
<h3> 2. 配置</h3>
<p>注意实现初始化数据库表操作的核心配置就在下面，重点关注</p>
<p>配置文件： <code>resources/application.yml</code></p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的配置中，相比较于普通的数据库链接配置，多了几个配置项</p>
<ul>
<li>spring.datasource.initialization-mode: 取值为 always，改成其他的会导致sql不会被执行</li>
<li>spring.datasource.platform: mysql</li>
<li>spring.datasource.seprator: ;  这个表示sql之间的分隔符</li>
<li>spring.datasource.data: classpath:config-data.sql  取值可以是数组，这里存的是初始化数据的sql文件地址</li>
<li>spring.datasource.data-username:  上面data对应的sql文件执行用户名</li>
<li>spring.datasource.data-password:  上面data对应的sql文件执行用户密码</li>
<li>spring.datasource.schema: classpath:config-schema.sql   取值也可以是数组，这里存的是初始化表结构的sql文件地址</li>
</ul>
<h3> 3. 初始化sql</h3>
<p>上面指定了两个sql，一个是用于建表的ddl，一个是用于初始化数据的dml</p>
<p><code>resources/config-schema.sql</code> 文件对应的内容如下</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>resources/config-data.sql</code> 文件对应的内容如下</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2> II. 示例</h2>
<h3> 1. 验证demo</h3>
<p>接下来上面的工作准备完毕之后，在我们启动项目之后，正常就会执行上面的两个sql，我们写一个简单的验证demo</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/221221/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 2. 问题记录</h3>
<p>从上面的过程走下来，看起来很简单，但是在实际的使用过程中，很容易遇到不生效的问题，下面记录一下</p>
<h4> 2.1 只有初始化数据data.sql，没有schema.sql时，不生效</h4>
<p>当库表已经存在时，此时我们可能并没有上文中的<code>config-schema.sql</code>文件，此时对应的配置可能是</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如上面所示，当我们只指定了data时，会发现data对应的sql文件也不会被执行；即要求schema对应的sql文件也必须同时存在</p>
<p>针对上面这种情况，可以考虑将data.sql中的语句，卸载schema.sql中</p>
<h4> 2.2 版本问题导致配置不生效</h4>
<p>在SpringBoot2.5+版本，使用 <code>spring.sql.init</code> 代替上面的配置项</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>相关的配置参数说明如下</p>
<ul>
<li><code>spring.sql.init.enabled</code>：是否启动初始化的开关，默认是true。如果不想执行初始化脚本，设置为false即可。通过-D的命令行参数会更容易控制。</li>
<li><code>spring.sql.init.username</code>和<code>spring.sql.init.password</code>：配置执行初始化脚本的用户名与密码。这个非常有必要，因为安全管理要求，通常给业务应用分配的用户对一些建表删表等命令没有权限。这样就可以与datasource中的用户分开管理。</li>
<li><code>spring.sql.init.schema-locations</code>：配置与schema变更相关的sql脚本，可配置多个（默认用;分割）</li>
<li><code>spring.sql.init.data-locations</code>：用来配置与数据相关的sql脚本，可配置多个（默认用;分割）</li>
<li><code>spring.sql.init.encoding</code>：配置脚本文件的编码</li>
<li><code>spring.sql.init.separator</code>：配置多个sql文件的分隔符，默认是;</li>
<li><code>spring.sql.init.continue-on-error</code>：如果执行脚本过程中碰到错误是否继续，默认是false`</li>
</ul>
<h4> 2.3 mode配置不对导致不生效</h4>
<p>当配置完之后发，发现sql没有按照预期的执行，可以检查一下<code>spring.datasource.initialization-mode</code>配置是否存在，且值为<code>always</code></p>
<h4> 2.4 重复启动之后，报错</h4>
<p>同样上面的项目，在第一次启动时，会执行schema对应的sql文件，创建表结构；执行data对应的sql文件，初始化数据；但是再次执行之后就会报错了，会提示表已经存在</p>
<p>即初始化是一次性的，第一次执行完毕之后，请将<code>spring.datasource.initialization-mode</code>设置为<code>none</code></p>
<h3> 3. 小结</h3>
<p>本文主要介绍了项目启动时，数据库的初始化方式，当然除了本文中介绍的<code>spring.datasource</code>配置之外，还有<code>spring.jpa</code>的配置方式</p>
<p>对于配置方式不太友好的地方则在于不好自适应控制，若表存在则不执行；若不存在则执行；后面将介绍如何使用<code>DataSourceInitializer</code>来实现自主可控的数据初始化，以及更现代化一些的基于liquibase的数据库版本管理记录</p>
<h2> III. 不能错过的源码和相关知识点</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/161-schema-init" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/161-schema-init</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/221221/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>3.数据库初始化-jpa配置方式</title>
      <link>https://liuyueyi.github.io/tutorial/spring/db/%E5%9F%BA%E7%A1%80/221221-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%9D%E5%A7%8B%E5%8C%96-jpa%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/db/%E5%9F%BA%E7%A1%80/221221-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%9D%E5%A7%8B%E5%8C%96-jpa%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">3.数据库初始化-jpa配置方式</source>
      <description>上一篇博文介绍如何使用spring.datasource来实现项目启动之后的数据库初始化，本文作为数据库初始化的第二篇，将主要介绍一下，如何使用spring.jpa的配置方式来实现相同的效果</description>
      <category>SpringBoot</category>
      <category>DB系列</category>
      <category>初始化</category>
      <pubDate>Wed, 21 Dec 2022 10:59:32 GMT</pubDate>
      <content:encoded><![CDATA[<p>上一篇博文介绍如何使用<code>spring.datasource</code>来实现项目启动之后的数据库初始化，本文作为数据库初始化的第二篇，将主要介绍一下，如何使用<code>spring.jpa</code>的配置方式来实现相同的效果</p>
<!-- more -->
<h2> I. 项目搭建</h2>
<h3> 1. 依赖</h3>
<p>首先搭建一个标准的SpringBoot项目工程，相关版本以及依赖如下</p>
<p>本项目借助<code>SpringBoot 2.2.1.RELEASE</code> + <code>maven 3.5.3</code> + <code>IDEA</code>进行开发</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>本文使用MySql数据库, 版本8.0.31</p>
<h3> 2. 配置</h3>
<p>注意实现初始化数据库表操作的核心配置就在下面，重点关注</p>
<p>配置文件： <code>resources/application.yml</code></p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意上面jpa的一个配置，其次就是上一篇博文中介绍的 <code>spring.datasource.initialization-mode</code> 同样需要将配置设置为 <code>always</code></p>
<p>使用jpa的配置方式，将<code>ddl-auto</code>设置为<code>create</code>或者<code>create-drop</code>时，会自动搜索<code>@Entity</code>实体对象，并创建为对应的表</p>
<h2> II. 示例</h2>
<h3> 1. 验证demo</h3>
<p>接下来上面的工作准备完毕之后，我们先创建一个实体对象</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来我们的目标就是基于上面这个实体类生成对应的表结构</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>直接启动项目之后，到数据库中将可以查到已经创建了一个库<code>user3</code></p>
<figure><img src="/imgs/221221/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 2. 初始化数据</h3>
<p>上面的过程只是初始化了表结构，如果我们希望导入一些初始化数据，可以怎么办？</p>
<p>如上面的配置： <code>spring.jpa.hibernate.ddl-auto: update</code>，此时在资源目录下，新建 <code>data.sql</code> , 取值为</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>然后再次执行，既可以看到db中会新增一条数据</p>
<figure><img src="/imgs/221221/02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>若<code>spring.jpa.hibernate.ddl-auto: create</code>，则再资源目录下，新建<code>import.sql</code>文件，来实现数据初始化</p>
<h3> 3. 小结</h3>
<p>使用Jpa的配置方式，总体来说和前面的介绍的spring.datasource的配置方式差别不大，jpa方式主要是基于<code>@Entity</code>来创建对应的表结构，且不会出现再次启动之后重复建表导致异常的问题（注意如上面data.sql中的数据插入依然会重复执行，会导致主键插入冲突）</p>
<p>本文中需要重点关注的几个配置:</p>
<ul>
<li>spring.datasource.initialization-mode: always 同样需要设置为always</li>
<li>spring.jpa.generate-ddl: true 会根据@Entity注解的实体类生成对应数据表</li>
<li>spring.jpa.hibernate.ddl-auto: create/create-drop 这两个取值时，再创建表之后执行import.sql文件导入测试数据；若取值为update，则会执行data.sql</li>
</ul>
<p>本文作为数据初始化第二篇，推荐与前文对比阅读，收获更多的知识点 <a href="https://spring.hhui.top/spring-blog/2022/12/21/221221-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%9D%E5%A7%8B%E5%8C%96-datasource%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F/" target="_blank" rel="noopener noreferrer">【DB系列】 数据库初始化-datasource配置方式</a></p>
<h2> III. 不能错过的源码和相关知识点</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/161-schema-init" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/161-schema-init</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/221221/01.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>4.数据库版本管理Liquibase集成</title>
      <link>https://liuyueyi.github.io/tutorial/spring/db/%E5%9F%BA%E7%A1%80/221222-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86Liquibase%E9%9B%86%E6%88%90.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/db/%E5%9F%BA%E7%A1%80/221222-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86Liquibase%E9%9B%86%E6%88%90.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">4.数据库版本管理Liquibase集成</source>
      <description>前面几篇介绍了项目启动之后进行数据库初始化的几种方式，接下来我们看一下如何使用Liquibase来实现数据库版本管理</description>
      <category>SpringBoot</category>
      <category>DB系列</category>
      <category>Liquebase</category>
      <pubDate>Thu, 22 Dec 2022 12:52:35 GMT</pubDate>
      <content:encoded><![CDATA[<p>前面几篇介绍了项目启动之后进行数据库初始化的几种方式，接下来我们看一下如何使用Liquibase来实现数据库版本管理</p>
<!-- more -->
<p>SpringBoot内置了对Liquibase的支持，在项目中使用非常简单</p>
<h2> I. 项目搭建</h2>
<h3> 1. 依赖</h3>
<p>首先搭建一个标准的SpringBoot项目工程，相关版本以及依赖如下</p>
<p>本项目借助<code>SpringBoot 2.2.1.RELEASE</code> + <code>maven 3.5.3</code> + <code>IDEA</code>进行开发</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>本文使用MySql数据库, 版本8.0.31; Liquibase的核心依赖<code>liquibase-core</code>，版本推荐使用SpringBoot配套的版本，一般来讲无需特殊指定</p>
<h3> 2. 配置</h3>
<p>配置文件 <code>resources/application.yml</code></p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>关键配置为 <code>spring.liquibase.change-log</code> 和 <code>spring.liquibase.enabled</code></p>
<p>第一个指定的是change-log对应的xml文件，其内容如下</p>
<p>liquibase核心xml文件 <code>resources/liquibase/master.xml</code></p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的xml依赖了一个xml文件，如第一个主要定义的是初始化的表结构</p>
<p><code>resources/changelog/000_initial_schema.xml</code> 对应的内容如下</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面的配置文件中，核心点在 <code>&lt;changeSet&gt;</code> 其中id要求全局唯一，<code>sqlFile</code>表示这次变动对应的sql语句; 一个<code>&lt;changeSet&gt;</code>对应一次变更，注意每次变更完成之后，不能再修改（sql文件内容不能改），changeSet本身也不要再去修改</p>
<p>接下来再看一下对应的sql文件</p>
<p><code>resources/liquibase/data/init_schema_221209.sql</code>对应的schema相关的表结构定义如下</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>resources/liquibase/data/init_data_221209.sql</code>对应的初始化数据定义如下</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2> II. 项目演示</h2>
<h3> 1. 测试</h3>
<p>上面配置完毕之后，再主项目结构工程中无需特殊处理，我们写一个简单的启动测试一下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>直接执行之后看一下输出结果(再执行之前，请确保数据库已经创建成功了；若没有则会抛异常)</p>
<figure><img src="/imgs/221222/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 2. 增量变更</h3>
<p>上面演示的是初始化过程；再实际开发过程中，若存在增量的变更，比如现在需要新增一个测试数据，此时我们的操作流程可以如下</p>
<p>再<code>liquibase/</code>目录下新增一个<code>001_change_schema.xml</code>文件，后续的增量变更相关的<code>ChangeSet</code>都放在这个xml文件中；再master.xml文件中，添加上面xml文件的引入</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>其次就是 <code>resources/liquibase/changelog/001_change_schema.xml</code> 文件内容</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的<code>changeSet</code>中包含初始化相关的sql文件，内容如下</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>再次启动验证一下，是否增加了新的数据</p>
<figure><img src="/imgs/221222/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 3. 小结</h3>
<p>本文主要介绍的是SpringBoot如何结合Liquibase来实现数据库版本管理，核心知识点介绍得不多，再实际使用的时候，重点注意</p>
<p>每次变更，都新增一个 <code>&lt;changeSet&gt;</code>，且保证所有的id唯一；当变更完成之后，不要再修改对应sql文件内容</p>
<blockquote>
<p>liquibase本身也有一些相关的知识点，如版本回滚，标签语义等，下篇博文再专门介绍Liquibase本身的核心知识点</p>
</blockquote>
<p>如对项目启动之后数据初始话相关有兴趣的小伙伴，欢迎查看</p>
<ul>
<li><a href="https://spring.hhui.top/spring-blog/2022/12/21/221221-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%9D%E5%A7%8B%E5%8C%96-datasource%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F/" target="_blank" rel="noopener noreferrer">【DB系列】数据库初始化-datasource配置方式 | 一灰灰Blog</a></li>
<li><a href="https://spring.hhui.top/spring-blog/2022/12/21/221221-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%9D%E5%A7%8B%E5%8C%96-jpa%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F/" target="_blank" rel="noopener noreferrer">【DB系列】数据库初始化-jpa配置方式 | 一灰灰Blog</a></li>
<li><a href="https://spring.hhui.top/spring-blog/2022/12/21/221221-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%9D%E5%A7%8B%E5%8C%96-DataSourceInitializer%E6%96%B9%E5%BC%8F/" target="_blank" rel="noopener noreferrer">【DB系列】数据库初始化-DataSourceInitializer方式 | 一灰灰Blog</a></li>
</ul>
<h2> III. 不能错过的源码和相关知识点</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/162-liquibase" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/162-liquibase</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/221222/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>5.SQL执行日志打印的几种方式</title>
      <link>https://liuyueyi.github.io/tutorial/spring/db/%E5%9F%BA%E7%A1%80/230719-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8BDB%E6%89%A7%E8%A1%8C%E6%97%A5%E5%BF%97%E6%89%93%E5%8D%B0%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/db/%E5%9F%BA%E7%A1%80/230719-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8BDB%E6%89%A7%E8%A1%8C%E6%97%A5%E5%BF%97%E6%89%93%E5%8D%B0%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">5.SQL执行日志打印的几种方式</source>
      <description>sql日志打印，再我们日常排查问题时，某些时候帮助可以说是非常大的，那么一般的Spring项目中，可以怎么打印执行的sql日志呢？ 本文将介绍三种sql日志打印的方式： Druid打印sql日志 Mybatis自带的日志输出 基于拦截器实现sql日志输出</description>
      <category>SpringBoot</category>
      <category>DB系列</category>
      <category>Mybatis</category>
      <pubDate>Wed, 19 Jul 2023 08:52:04 GMT</pubDate>
      <content:encoded><![CDATA[<p>sql日志打印，再我们日常排查问题时，某些时候帮助可以说是非常大的，那么一般的Spring项目中，可以怎么打印执行的sql日志呢？</p>
<p>本文将介绍三种sql日志打印的方式：</p>
<ol>
<li>Druid打印sql日志</li>
<li>Mybatis自带的日志输出</li>
<li>基于拦截器实现sql日志输出</li>
</ol>
<!-- more -->
<h2> I. 项目配置</h2>
<h3> 1. 依赖</h3>
<p>首先搭建一个标准的SpringBoot项目工程，相关版本以及依赖如下</p>
<p>本项目借助<code>SpringBoot 2.2.1.RELEASE</code> + <code>maven 3.5.3</code> + <code>IDEA</code>进行开发</p>
<p>添加web支持，用于配置刷新演示</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 配置</h3>
<p>接下来配置一下db的相关配置 <code>application.yml</code></p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>关于上面配置的一些细节，后面进行细说</p>
<p>我们创建一个用于测试的数据库</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对应的myabtis-config.xml，配置我们自定义的sql日志输出拦截器</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> II. 实例</h2>
<h3> 1. mybatis默认配置</h3>
<p>我们先看一下mybatis的默认日志输出方案，首先写一个<code>money</code>数据库的db操作mapper</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来重点看一下，如需开启myabtis默认的sql日志输出，应该如何配置</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>重点看上面的 <code>mybatis.configuration.log-prefix</code> 与 <code>myabtis.configuration.log-impl</code> 这里制定了日志输出的方式</p>
<p>但是请注意，通常我们的日志是基于<code>logback/slf4j</code>来输出，默认的mybati的sql日志输出是debug级别，所以要看到输出的sql日志，还需要配置一下日志输出级别（本项目的实例中是直接控制台输出，因此不配置下面的也没有问题）</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后写个demo验证一下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/230719/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>从上图可以看出，myabtis将具体的sql执行，返回的行数等信息进行了返回，但是这个sql，并不是一个可以直接执行的，还需要我们自己来拼装一下，为了解决这个问题，可以通过 <a href="https://book.hhui.top/sql.html" target="_blank" rel="noopener noreferrer">https://book.hhui.top/sql.html</a> 来进行sql的自动拼接</p>
<h3> 2. Druid日志输出</h3>
<p>除了mybatis的默认日志之外，对于使用druid数据源的场景，也可以直接借助druid来打印执行日志</p>
<p>核心的配置如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>示例如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/230719/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>druid的默认输出日志中，并没有将请求参数打印出来，其效果相比较于mybatis而言，信息更少一些</p>
<h3> 3. 基于Mybatis的Interceptor实现方案</h3>
<p>默认的输出方案虽好，但是总有一些缺陷，如果有一些自定义的诉求，如日志输出的脱敏，不妨考虑下接下来的基于mybatis的拦截器的实现方案</p>
<p>如下面是一个自定义的日志输出拦截器, 相关知识点较多，有兴趣的小伙伴，推荐参考下文</p>
<blockquote>
<ul>
<li><a href="https://spring.hhui.top/spring-blog/2021/07/26/210726-SpringBoot%E7%B3%BB%E5%88%97Mybatis%E4%B9%8B%E6%8F%92%E4%BB%B6%E6%9C%BA%E5%88%B6Interceptor/" target="_blank" rel="noopener noreferrer">【DB系列】SpringBoot系列Mybatis之插件机制Interceptor | 一灰灰Blog</a></li>
</ul>
</blockquote>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后将第一种测试用例再跑一下，实际输出如下</p>
<figure><img src="/imgs/230719/02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 3. 小结</h3>
<p>本文主要介绍了三种常见的sql日志输出方案，原则上推荐通过自定义的插件方式来实现更符合业务需求的sql日志打印；但是，掌握了默认的myabtis日志输出方案之后，我们就可以借助配置中心，通过动态添加/修改 <code>logging.level.com.git.hui.boot.db.mapper.*</code> 来动态设置日志输出级别，再线上问题排查、尤其时场景可以复现的场景时，会有奇效哦</p>
<h2> III. 不能错过的源码和相关知识点</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/100-db-log" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/230719/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>MySql</title>
      <link>https://liuyueyi.github.io/tutorial/spring/db/%E5%9F%BA%E7%A1%80/</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/db/%E5%9F%BA%E7%A1%80/</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">MySql</source>
      <description>MySql数据库相关知识点</description>
      <pubDate>Thu, 21 Sep 2023 09:55:31 GMT</pubDate>
      <content:encoded><![CDATA[<p>MySql数据库相关知识点</p>
]]></content:encoded>
    </item>
    <item>
      <title>7.数据报表统计并定时推送用户的手把手教程</title>
      <link>https://liuyueyi.github.io/tutorial/spring/db/%E5%AE%9E%E4%BE%8B/21.220819-SpringBoot%E5%AE%9E%E6%88%98%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E6%8A%A5%E8%A1%A8%E7%BB%9F%E8%AE%A1%E5%B9%B6%E5%AE%9A%E6%97%B6%E6%8E%A8%E9%80%81%E7%94%A8%E6%88%B7.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/db/%E5%AE%9E%E4%BE%8B/21.220819-SpringBoot%E5%AE%9E%E6%88%98%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E6%8A%A5%E8%A1%A8%E7%BB%9F%E8%AE%A1%E5%B9%B6%E5%AE%9A%E6%97%B6%E6%8E%A8%E9%80%81%E7%94%A8%E6%88%B7.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">7.数据报表统计并定时推送用户的手把手教程</source>
      <description>本文节选自 《实战演练专题》 通过一个小的业务点出发，搭建一个可以实例使用的项目工程，将各种知识点串联起来; 实战演练专题中，每一个项目都是可以独立运行的，包含若干知识点，甚至可以不做修改直接应用于生产项目； 今天的实战项目主要解决的业务需求为：每日新增用户统计，生成报表，并邮件发送给相关人 本项目将包含以下知识点： 基于MySql的每日新增用户报表统计（如何统计每日新增用户，若日期不连续如何自动补0？） 定时执行报表统计任务 MyBatis + MySql数据操作 邮件发送 Thymeleaf引擎实现报表模板渲染</description>
      <category>SpringBoot</category>
      <category>中间件</category>
      <category>email</category>
      <category>应用篇</category>
      <pubDate>Fri, 19 Aug 2022 10:34:38 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>本文节选自 <a href="https://hhui.top/spring/" target="_blank" rel="noopener noreferrer">《实战演练专题》 </a></p>
</blockquote>
<p>通过一个小的业务点出发，搭建一个可以实例使用的项目工程，将各种知识点串联起来; 实战演练专题中，每一个项目都是可以独立运行的，包含若干知识点，甚至可以不做修改直接应用于生产项目；</p>
<p>今天的实战项目主要解决的业务需求为：<code>每日新增用户统计，生成报表，并邮件发送给相关人</code></p>
<p>本项目将包含以下知识点：</p>
<ul>
<li>基于MySql的每日新增用户报表统计（如何统计每日新增用户，若日期不连续如何自动补0？）</li>
<li>定时执行报表统计任务</li>
<li>MyBatis + MySql数据操作</li>
<li>邮件发送</li>
<li>Thymeleaf引擎实现报表模板渲染</li>
</ul>
<!-- more -->
<h2> I. 需求拆解</h2>
<p>需要相对来说属于比较明确的了，目的就是实现一个自动报表统计的任务，查询出每日的用户新增情况，然后推送给指定的用户</p>
<p>因此我们将很清晰的知道，我们需要干的事情</p>
<p><strong>定时任务</strong></p>
<p>这里重点放在如何来支持这个任务的定时执行，通常来说定时任务会区分为固定时刻执行 + 间隔时长执行两种（注意这种区分主要是为了方便理解，如每天五点执行的任务，也可以理解为每隔24h执行一次）</p>
<p>前者常见于<code>一次性任务</code>，如本文中的每天统计一次，这种就是相对典型的固定时刻执行的任务；</p>
<p>后者常见于<code>轮询式任务</code>，如常见的应用探活(每隔30s发一个ping消息，判断服务是否健在）</p>
<blockquote>
<p>定时任务的方案非常多，有兴趣的小伙伴可以关注一波“一灰灰blog”公众号，蹲守一个后续</p>
</blockquote>
<p>本文将直接采用Spring的定时任务实现需求场景，对这块不熟悉的小伙伴可以看一下我之前的分享的博文</p>
<blockquote>
<ul>
<li><a href="https://blog.hhui.top/hexblog/2018/08/01/180801-Spring%E4%B9%8B%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E7%AF%87/" target="_blank" rel="noopener noreferrer">180801-Spring之定时任务基本使用篇 - 一灰灰Blog</a></li>
<li><a href="https://blog.hhui.top/hexblog/2018/08/03/180803-Spring%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E9%AB%98%E7%BA%A7%E4%BD%BF%E7%94%A8%E7%AF%87/" target="_blank" rel="noopener noreferrer">180803-Spring定时任务高级使用篇 - 一灰灰Blog</a></li>
</ul>
</blockquote>
<p><strong>每日新增用户统计</strong></p>
<p>每日新增用户统计，实现方式挺多的，比如举几个简单的实现思路</p>
<ul>
<li>基于redis的计数器：一天一个key，当天有新用户时，同步的实现计数器+1</li>
<li>基于数据库，新增一个统计表，包含如日期 + 新增用户数 + 活跃用户数 等字段
<ul>
<li>有新用户注册时，对应日期的新增用户数，活跃用户数 + 1</li>
<li>老用户今日首次使用时，活跃用户数 + 1</li>
</ul>
</li>
</ul>
<p>上面两个方案都需要借助额外的库表来辅助支持，本文则采用直接统计用户表，根据注册时间来聚合统计每日的新增用户数</p>
<ul>
<li>优点：简单，无额外要求，适用于数据量小的场景（比如用户量小于百万的）</li>
<li>缺点：用户量大时，数据库压力大</li>
</ul>
<p>关于如何使用mysql进行统计每日新增用户，不熟悉的小伙伴，推荐参考博主之前的分享文章</p>
<ul>
<li>
<ul>
<li><a href="https://blog.hhui.top/hexblog/2022/07/07/220707-MySql%E6%8C%89%E6%97%B6%E3%80%81%E5%A4%A9%E3%80%81%E5%91%A8%E3%80%81%E6%9C%88%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1/" target="_blank" rel="noopener noreferrer">220707-MySql按时、天、周、月进行数据统计 - 一灰灰Blog</a></li>
</ul>
</li>
</ul>
<p><strong>报表生成&amp;推送用户</strong></p>
<p>接下来就是将上面统计的数据，生成报表然后推送给用户；首先是如何将数据生成报表？其次则是如何推送给指定用户？</p>
<p>将数据组装成报表的方式通常取决于你选择的推送方式，如飞书、钉钉之类的，有对应的开发api，可以直接推送富文本；</p>
<p>本文的实现姿势则选择的是通过邮件的方式进行发送，why?</p>
<ul>
<li>飞书、钉钉、微信之类的，需要授权，对于不使用这些作为办公软件的小伙伴没什么意义</li>
<li>短信需要钱....</li>
</ul>
<p>对于邮件，大家应该都有，无论是qq邮箱，还是工作邮箱；基本上对于想要直接跑本文的小伙伴来说，没有什么额外的门槛</p>
<p>关于java/spring如何使用邮箱，对此不太熟悉的小伙伴，可以参考博主之前的分享文章</p>
<ul>
<li>
<ul>
<li><a href="https://spring.hhui.top/spring-blog/2021/08/02/210802-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8B%E9%82%AE%E4%BB%B6%E5%8F%91%E9%80%81%E5%A7%BF%E5%8A%BF%E4%BB%8B%E7%BB%8D/" target="_blank" rel="noopener noreferrer">【中间件】SpringBoot系列之邮件发送姿势介绍 | 一灰灰Blog</a></li>
</ul>
</li>
</ul>
<blockquote>
<p>上面文章中介绍的是FreeMaker来实现模板渲染，本文则介绍另外一个知识点，借助Thymleaf来实现数据报表的生成 （一篇文章获取这么多知识点，就问你开不开心O(∩_∩)O）</p>
</blockquote>
<h2> II. 分布实现</h2>
<h3> 1. 项目搭建</h3>
<p>首选搭建一个基本的SpringBoot应用，相信这一步大家都很熟悉了；若有不懂的小伙伴，请点赞、评论加博主好友，手把手教你，不收费</p>
<p>最终的项目依赖如下</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>别看上面好像依赖了不少包，实际上各有用处</p>
<ul>
<li><code>spring-boot-starter-web</code>: 提供web服务</li>
<li><code>spring-boot-starter-mail</code>: 发邮件就靠它</li>
<li><code>mybatis-spring-boot-starter</code>: 数据库操作</li>
</ul>
<p>我们的用户存在mysql中，这里使用mybatis来实现db操作（又一个知识点来了，收好不谢）</p>
<h3> 2. 数据准备</h3>
<blockquote>
<p>文末的源码包含库表结构，初始化数据，可以直接使用</p>
</blockquote>
<p>既然模拟的是从数据库中读取每日新增用户，所以我们准备了一张表</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来准备写入一些数据；为了模拟某些天没有新增用户，贴心的一灰灰博主给大家提供基于python的数据生成脚本，源码如下 (python3+，对python不熟的小伙伴，可以到博主的站点进补一下，<a href="https://blog.hhui.top/hexblog/categories/Python/" target="_blank" rel="noopener noreferrer">超链</a>)</p>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. 全局配置</h3>
<p>数据准备完毕之后，接下来配置一下db、email相关的参数</p>
<p><code>resources/application.yml</code> 文件内容如下</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的配置分为三类</p>
<ul>
<li>数据库相关：连接信息，用户名密码， mybatis配置</li>
<li>thymleaf：模板渲染相关</li>
<li>email: 邮箱配置相关，请注意若使用博主的源码，在本地运行时，请按照前面介绍的邮箱博文中手把手的教程，获取您自己的邮箱授权信息，填在上面的username, password中</li>
</ul>
<h3> 4. 数据报表统计实现</h3>
<p>接下来就正式进入大家喜闻乐见的编码实现环节，我们直接使用mybaits来实现数据库操作，定义一个统计的接口</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接口中定义了一个PO对象，就是我们希望返回的数据，其定义就非常清晰简单了，时间 + 数量</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面定义的知识接口，具体首先，当然是放在mybatis的传统xml文件中，根据前面application.yml配置，我们的xml文件需要放在 <code>resources/mapper</code> 目录下，具体实现如下</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>重点看一下上面的sql实现，为什么会一个join逻辑？</p>
<p>那我们稍稍思考，若我们直接通过日期进行format之后，再group一下统计计数，会有什么问题？给大家3s的思考时间</p>
<ul>
<li>1s</li>
<li>2s</li>
<li>3s</li>
</ul>
<p>好的3s时间到，现在公布答案，当某一天一个新增用户都没有的时候，会发生什么事情？会出现这一天的数据空缺，即返回的列表中，少了一天，不连续了，如果前段的小伙伴基于这个列表数据进行绘图，很有可能出现异常</p>
<p>所以出于系统的健壮性考虑（即传说中的鲁棒性），我们希望若某一天没有数据，则对应的计数设置为0</p>
<p>具体的sql说明就不展开了，请查看博文获取更多： <a href="https://juejin.cn/post/7131369167961358350" target="_blank" rel="noopener noreferrer">MySql按时、天、周、月进行数据统计</a></p>
<h3> 5. 报表生成实现</h3>
<p>数据统计出来之后，接下来就是基于这些数据来生成我们报表，我们借助Thymleaf来实现，因此先写一个html模板，<code>resources/templates/report.html</code></p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>一个非常简单的table模板，需要接收三个数据，与之对应的vo对象，我们定义如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来就是拿到数据之后，将它与模板渲染得到我们希望的数据，这里主要借助的是<code>org.thymeleaf.spring5.SpringTemplateEngine</code></p>
<p>核心实现如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>模板渲染就一行<code>templateEngine.process("report", context)</code>，第一个参数为模板名，就是上面的html文件名（对于模板文件、静态资源怎么放，放在那儿，这个知识点当然也可以在一灰灰的站点获取，<a href="https://spring.hhui.top/spring-blog/2020/06/11/200611-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8BWeb%E7%AF%87%E4%B9%8B%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E9%85%8D%E7%BD%AE/" target="_blank" rel="noopener noreferrer">超链</a>）</p>
<p>第二个参数用于封装上下文，传递模板需要使用的参数</p>
<h3> 5. 邮件发送</h3>
<p>报表生成之后，就是将它推送给用户，我们这里选定的是邮箱方式，具体实现也比较简单，但是在最终部署到生产环境（如阿里云服务器时，可能会遇到坑，同样明显的知识点，博主会没有分享么？当然不会没有了，<a href="https://blog.hhui.top/hexblog/2021/10/28/211028-Email%E5%8F%91%E9%80%81%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/" target="_blank" rel="noopener noreferrer">Email生产环境发送排雷指南，你值得拥有</a>）</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的实现，直接写死了收件人邮箱，即我本人的邮箱，各位大佬在使用的时候，请记得替换一下啊</p>
<p>上面的实现除了发送邮件这个知识点之外，还有一个隐藏的获取配置参数的知识点，即<code>environment#getProperty()</code>，有兴趣的小伙伴翻博主的站点吧</p>
<h3> 6. 定时任务</h3>
<p>上面几部基本上就把我们的整个任务功能都实现了，从数据库中统计出每日新增用户，然后借助Thymleaf来渲染模板生成报告，然后借助email进行发送</p>
<p>最后的一步，就是任务的定时执行，直接借助Spring的Schedule来完成我们的目标，这里我们希望每天4:15分执行这个任务，如下配置即可</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 7. 测试</h3>
<p>最后测试演练一下，启动方法如下，除了基本的启动注解之外，还指定了mapper接口位置，开启定时任务；感兴趣的小伙伴可以试一下干掉这两个注解会怎样，评论给出你的实测结果吧</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当然我再实际测试的时候，不可能真等到早上四点多来看是否执行，大晚上还是要睡觉的；因此本地测试的时候，可以将上面定时任务改一下，换成每隔一分钟执行一次</p>
<p>接一个debug的中间图</p>
<figure><img src="/imgs/220819/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>打开的内容展示</p>
<figure><img src="/imgs/220819/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>此外，源码除了实现了定时推送之外，也提供了一个web接口，访问之后直接可以查看报表内容，方便大家调样式，实现如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 8.一灰灰的干货总结</h3>
<p>最后进入一灰灰的保留环节，这么“大”一个项目坐下来的，当然是得好好盘一盘它的知识点了，前面的各小节内容中有穿插的指出相应的知识点，接下来如雨的知识点将迎面袭来，不要眨眼</p>
<ul>
<li>Spring定时任务@Schedule
<ul>
<li>怎么用？ -&gt; <a href="https://liuyueyi.github.io/hexblog/2018/08/01/180801-Spring%E4%B9%8B%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E7%AF%87/" target="_blank" rel="noopener noreferrer">180801-Spring之定时任务基本使用篇 - 一灰灰Blog</a></li>
<li>多个任务串行并行，是否会相互影响？自定义线程池怎么整？一个异常会影响其他么？-&gt; <a href="https://blog.hhui.top/hexblog/2018/08/03/180803-Spring%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E9%AB%98%E7%BA%A7%E4%BD%BF%E7%94%A8%E7%AF%87/" target="_blank" rel="noopener noreferrer">Spring定时任务高级使用篇 - 一灰灰Blog</a></li>
</ul>
</li>
<li>数据库统计每日新增
<ul>
<li>mysql直接统计日新增，sql怎么写？ 时间不连续，如何规避？ -&gt; <a href="https://blog.hhui.top/hexblog/2022/07/07/220707-MySql%E6%8C%89%E6%97%B6%E3%80%81%E5%A4%A9%E3%80%81%E5%91%A8%E3%80%81%E6%9C%88%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1/" target="_blank" rel="noopener noreferrer">MySql按时、天、周、月进行数据统计 - 一灰灰Blog</a></li>
<li>mybatis操作db怎么玩？ -&gt; <a href="https://spring.hhui.top/spring-blog/categories/SpringBoot/DB%E7%B3%BB%E5%88%97/Mybatis/" target="_blank" rel="noopener noreferrer">Mybatis系列教程</a></li>
</ul>
</li>
<li>模板渲染
<ul>
<li>数据报表生成，直接字符串拼接？还是模板引擎的渲染？</li>
<li>更多的spring web知识点 -&gt; <a href="https://hhui.top/spring-web/" target="_blank" rel="noopener noreferrer">一灰灰的SpringWeb专栏 | 免费</a></li>
</ul>
</li>
<li>邮件发送
<ul>
<li>怎么发邮件？ -&gt; <a href="https://hhui.top/spring-middle/01.email/" target="_blank" rel="noopener noreferrer">SpringBoot无障碍使用邮箱服务</a></li>
<li>如何避免上线不采坑 -&gt; <a href="https://blog.hhui.top/hexblog/2021/10/28/211028-Email%E5%8F%91%E9%80%81%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/" target="_blank" rel="noopener noreferrer">Email生产环境发送排雷指南，你值得拥有</a></li>
</ul>
</li>
</ul>
<p>除了上面比较突出的知识点之外，当然还有其他的，如Spring如何读取配置参数，SpringMVC如何向模板中传递上下文，模板语法，静态资源怎么放等等</p>
<p>写到这我自己都惊呆了好么，一篇文章这么多知识点，还有啥好犹豫的，一键三连走起啊，我是一灰灰，这可能是我这个假期内最后一篇实战干货了，马上要开学了，老婆孩子回归之后，后续的更新就靠各位读友的崔更保持了</p>
<p>本文中所有知识点，都可以在我的个人站点获取，欢迎关注： <a href="https://hhui.top/" target="_blank" rel="noopener noreferrer">https://hhui.top/</a></p>
<h2> III. 不能错过的源码和相关知识点</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/220819/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>8. Session与Cookie</title>
      <link>https://liuyueyi.github.io/tutorial/spring/web/Web%E4%B8%89%E5%89%91%E5%AE%A2/230323-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8BSession%E4%B8%8ECookie.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/web/Web%E4%B8%89%E5%89%91%E5%AE%A2/230323-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8BSession%E4%B8%8ECookie.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">8. Session与Cookie</source>
      <description>虽然我们现在基本上已经进入了分布式session的时代了，但是在切实去看最新的oauth, sso, jwt等各种登录方案之前，我们有必要学习一下最早的cookie/session方案，看一下它们是怎么协同工作的，又有什么局限性</description>
      <category>SpringBoot</category>
      <category>WEB系列</category>
      <pubDate>Thu, 23 Mar 2023 22:03:01 GMT</pubDate>
      <content:encoded><![CDATA[<p>虽然我们现在基本上已经进入了分布式session的时代了，但是在切实去看最新的oauth, sso, jwt等各种登录方案之前，我们有必要学习一下最早的cookie/session方案，看一下它们是怎么协同工作的，又有什么局限性</p>
<!-- more -->
<h2> 项目配置</h2>
<h3> 1. 依赖</h3>
<p>首先搭建一个标准的SpringBoot项目工程，相关版本以及依赖如下</p>
<p>本项目借助<code>SpringBoot 2.2.1.RELEASE</code> + <code>maven 3.5.3</code> + <code>IDEA</code>进行开发</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 启动入口</h3>
<p>我们使用默认的配置进行测试，因此启动入口也可以使用最基础的</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> Session/Cookie使用姿势</h2>
<p>接下来我们再看一下如何在SpringBoot项目中是session/cookie</p>
<h3> 1. 登录入口，保存session</h3>
<p>首先我们设计一个登录的接口，用来模拟真实场景下的登录，注意下面的实现</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面的实现中，方法中定义了一个<code>HttpSession</code>的参数类型，具体的实现中，就是表示写入sesion的操作</p>
<p>当session写入完毕之后，在这个会话结束之前，后续的所有请求都可以直接获取到对应的session</p>
<h3> 2. session读取测试</h3>
<p>下面给出两种常见的session获取方式</p>
<ul>
<li>直接从HttpSession中获取</li>
<li>通过HttpServletRequest来获取</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来我们来模拟验证一下</p>
<figure><img src="/imgs/230323/00.gif" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>从上面的演示图中，也可以看出，在登录之后，访问上面的接口，可以直接拿到session中存储的用户名；</p>
<p>且不同用户登录（不同的浏览器），他们的session不会出现串掉的情况</p>
<h3> 3. 退出登录</h3>
<p>有登陆当然就有登出，如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4. session实现原理</h3>
<p>SpringBoot提供了一套非常简单的session机制，那么它又是怎么工作的呢？ 特别是它是怎么识别用户身份的呢？ session又是存在什么地方的呢？</p>
<p>session：再浏览器窗口打开期间，这个会话一直有效，即先访问login，然后再访问time，可以直接拿到name， 若再此过程中，再次访问了login更新了name，那么访问time获取到的也是新的name</p>
<p>当浏览器关闭之后，重新再访问 time 接口，则此时将拿不到 name</p>
<p>核心工作原理：</p>
<ul>
<li>借助cookie中的 JESSIONID 来作为用户身份标识，这个数据相同的，认为是同一个用户；然后会将session再内存中存一份，有过期时间的限制，通常每次访问一次，过期时间重新刷新</li>
<li>当浏览器不支持cookie时，借助url重写，将 sessionId 写道url的地址中，参数名 = jsessionid</li>
</ul>
<figure><img src="/imgs/230323/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>从上面的描述中，就可以看出几个关键点：</p>
<ul>
<li>session主要是存在内存中，根据用户请求的cookie来识别用户身份，且有一个过期时间 （那么问题来了，内存有大小限制么？会出现oom么？）</li>
<li>对于用户而言，每次关闭浏览器再重新打开，会重新生成 JESSIONID 的cookies值，由于这个值的更改，导致后端无法记录之前访问的是谁</li>
</ul>
<h2> 不能错过的源码和相关知识点</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/224-web-session" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/224-web-session</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/230323/00.gif" type="image/gif"/>
    </item>
    <item>
      <title>6.基于JWT的用户鉴权实战</title>
      <link>https://liuyueyi.github.io/tutorial/spring/web/%E5%85%B6%E4%BB%96/230816-SpringBoot%E7%B3%BB%E5%88%97WEB%E4%B9%8B%E5%9F%BA%E4%BA%8EJWT%E7%9A%84%E7%94%A8%E6%88%B7%E9%89%B4%E6%9D%83.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/web/%E5%85%B6%E4%BB%96/230816-SpringBoot%E7%B3%BB%E5%88%97WEB%E4%B9%8B%E5%9F%BA%E4%BA%8EJWT%E7%9A%84%E7%94%A8%E6%88%B7%E9%89%B4%E6%9D%83.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">6.基于JWT的用户鉴权实战</source>
      <description>再传统的基于session的用户身份认证方式之中，用户相关信息存储与后端，通常基于cookie来携带用户的会话id，然后后端在基于会话id查到对应的用户身份信息；区别于session的身份认证方式，jwt作为一个基于RFC 7519的开发标准，提供了一种通过JSON形式的web令牌，用于在各系统之间的安全可信的数据传输、身份标识 本文将主要介绍jwt的相关知识点，以及如何基于jwt来实现一个简单的用户鉴权方案 I. JWT知识点 jwt，全称 json web token, JSON Web 令牌是一种开放的行业标准 RFC 7519 方法，用于在两方之间安全地表示声明。</description>
      <category>SpringBoot</category>
      <category>WEB系列</category>
      <category>JWT</category>
      <pubDate>Wed, 16 Aug 2023 14:36:37 GMT</pubDate>
      <content:encoded><![CDATA[<p>再传统的基于session的用户身份认证方式之中，用户相关信息存储与后端，通常基于cookie来携带用户的会话id，然后后端在基于会话id查到对应的用户身份信息；区别于session的身份认证方式，jwt作为一个基于RFC 7519的开发标准，提供了一种通过JSON形式的web令牌，用于在各系统之间的安全可信的数据传输、身份标识</p>
<p>本文将主要介绍jwt的相关知识点，以及如何基于jwt来实现一个简单的用户鉴权方案</p>
<!-- more  -->
<h2> I. JWT知识点</h2>
<p>jwt，全称 json web token, JSON Web 令牌是一种开放的行业标准 RFC 7519 方法，用于在两方之间安全地表示声明。</p>
<blockquote>
<p>详情可以参考： <a href="https://jwt.io/introduction" target="_blank" rel="noopener noreferrer">hhttps://jwt.io/introduction</a></p>
</blockquote>
<h3> 1. 数据结构</h3>
<p>JSON Web Token由三部分组成，它们之间用圆点<code>.</code>进行分割， 一个标准的JWT形如 <code>xxx.yyy.zzz</code></p>
<ul>
<li>Header</li>
<li>Payload</li>
<li>Signature</li>
</ul>
<h4> 1.1 header</h4>
<p>即第一部分，由两部分组成：token的类型（<code>JWT</code>）和算法名称（比如：<code>HMAC</code> <code>SHA256</code>或者<code>RSA</code>等等）。</p>
<p>一个具体实例如</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后，用Base64对这个JSON编码就得到JWT的第一部分</p>
<h4> 1.2 Payload</h4>
<p>第二部分具体的实体，可以写入自定义的数据信息，有三种类型</p>
<ul>
<li><code>Registered claims</code> : 这里有一组预定义的声明，它们不是强制的，但是推荐。比如：iss (issuer 签发者), exp (expiration time 有效期), sub (subject), aud (audience)等。</li>
<li><code>Public claims</code> : 可以随意定义。</li>
<li><code>Private claims</code> : 用于在同意使用它们的各方之间共享信息，并且不是注册的或公开的声明</li>
</ul>
<p>如一个具体实例</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对payload进行Base64编码就得到JWT的第二部分</p>
<h4> 1.3 Signature</h4>
<p>为了得到签名部分，你必须有编码过的header、编码过的payload、一个秘钥，签名算法是header中指定的那个，然对它们签名即可。</p>
<p>如 <code>HMACSHA256(base64UrlEncode(header) + "." + base64UrlEncode(payload), secret)</code></p>
<p>签名是用于验证消息在传递过程中有没有被更改，并且，对于使用私钥签名的token，它还可以验证JWT的发送方是否为它所称的发送方。</p>
<h4> 1.4 具体实例</h4>
<p>下面给出一个基于 <code>java-jwt</code> 生成的具体实例</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/230816/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> II. 使用实例</h2>
<p>接下来我们基于jwt方案实现一个用户鉴权的示例demo</p>
<h3> 1. 项目搭建</h3>
<p>首先搭建一个标准的SpringBoot项目工程，相关版本以及依赖如下</p>
<p>本项目借助<code>SpringBoot 2.2.1.RELEASE</code> + <code>maven 3.5.3</code> + <code>IDEA</code>进行开发</p>
<p>添加web支持，用于配置刷新演示</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们采用thymeleaf来进行前端页面的渲染，添加一些相关的配置 <code>application.yml</code></p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. JWT鉴权流程</h3>
<p>一个简单的基于jwt的身份验证方案如下图</p>
<figure><img src="/imgs/230816/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>基本流程分三步：</p>
<ol>
<li>
<p>用户登录成功之后，后端将生成的jwt返回给前端，然后前端将其保存在本地缓存；</p>
</li>
<li>
<p>之后前端与后端的交互时，都将jwt放在请求头中，我们这里借助Http的身份认证的请求头<code>Authorization</code></p>
</li>
<li>
<p>后端接收到用户的请求，从请求头中获取jwt，然后进行校验，通过之后，才响应相关的接口；否则表示未登录</p>
</li>
</ol>
<h3> 3. 实现方案</h3>
<p>基于上面的流程，我们可以实现一个非常简单的登录认证演示工程</p>
<p>首先在内存中，维护几个简单用户名/密码信息，用于模拟用户名+密码的校验</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后提供登录接口</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的接口实现，接收两个请求参数: 用户名 + 密码</p>
<p>当用户身份校验通过之后，将生成一个jwt，这里直接使用开源项目<code>java-jwt</code>来生成(当然有兴趣的小伙伴也可以自己来实现)</p>
<p>需要注意的一点是，我们在上面的实现中，除了直接返回jwt之外，也将这个jwt写在cookie中，这种将jwt写入cookie的方案，主要的好处就是前端不需要针对jwt进行特殊处理
当然对应的缺点也和直接使用session的鉴权方式一样，存在csrf风险，以及对于跨资源共享时的资源共享问题(CORS)</p>
<blockquote>
<p>本项目的实际演示中，采用前端存储返回的jwt，然后通过请求头方式来传递jwt</p>
</blockquote>
<p>上面登录完成之后，再提供一个简单的要求登录之后才能查看的查询接口</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>最后再写一个前端页面来完成整个测试</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对应的前端页面如下:</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4. 实例演示</h3>
<p>基于上面的实现，接下来我们看一下具体表现情况</p>
<figure><img src="/imgs/230816/02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<figure><img src="/imgs/230816/03.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>从上面的两张图也可以看出，登录成功之后，jwt写入到本地的session storage中，再后续的请求中，若请求头<code>Authroization</code>中携带了jwt信息，则后端可以进行正常校验</p>
<p>有兴趣的小伙伴可以尝试修改一下本地存储中的jwt值，看一下非法或者过期的jwt会怎么表现</p>
<h3> 5. 小结</h3>
<p>本文主要介绍了jwt的基本知识点，并给出了一个基于jwt的使用实例，下面针对jwt和session做一个简单的对比</p>
<table>
<thead>
<tr>
<th>jwt</th>
<th>session</th>
</tr>
</thead>
<tbody>
<tr>
<td>前端存储，通用的校验规则，后端再获取jwt时校验是否有效</td>
<td>前端存索引，后端判断session是否有效</td>
</tr>
<tr>
<td>验签，不可篡改</td>
<td>无签名保障，安全性由后端保障</td>
</tr>
<tr>
<td>可存储非敏感信息，如用户名，头像等</td>
<td>一般不存储业务信息</td>
</tr>
<tr>
<td>jwt生成时，指定了有效期，本身不支持续期以及提前失效</td>
<td>后端控制有效期，可提前失效或者自动续期</td>
</tr>
<tr>
<td>通常以请求头方式传递</td>
<td>通常以cookie方式传递</td>
</tr>
<tr>
<td>可预发csrf攻击</td>
<td>session-cookie方式存在csrf风险</td>
</tr>
</tbody>
</table>
<p>关于上面的两个风险，给一个简单的扩展说明</p>
<p><strong>csrf攻击</strong></p>
<p>如再我自己的网站页面上，添加下面内容</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>然后当你访问我的网站时，结果发现你在技术派上的登录用户被注销了!!!</p>
<p>使用jwt预防csrf攻击的主要原理就是jwt是通过请求头，由js主动塞进去传递给后端的，而非cookie的方式，从而避免csrf漏洞攻击</p>
<h2> III. 不能错过的源码和相关知识点</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/225-web-jwt" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/230816/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>9. 实战之基于WebListener实现实时在线人数统计</title>
      <link>https://liuyueyi.github.io/tutorial/spring/web/%E5%AE%9E%E4%BE%8B/230325-SpringBoot%E5%AE%9E%E6%88%98%E4%B9%8B%E5%9F%BA%E4%BA%8EWebListener%E5%AE%9E%E7%8E%B0%E5%AE%9E%E6%97%B6%E5%9C%A8%E7%BA%BF%E4%BA%BA%E6%95%B0%E7%BB%9F%E8%AE%A1.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/web/%E5%AE%9E%E4%BE%8B/230325-SpringBoot%E5%AE%9E%E6%88%98%E4%B9%8B%E5%9F%BA%E4%BA%8EWebListener%E5%AE%9E%E7%8E%B0%E5%AE%9E%E6%97%B6%E5%9C%A8%E7%BA%BF%E4%BA%BA%E6%95%B0%E7%BB%9F%E8%AE%A1.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">9. 实战之基于WebListener实现实时在线人数统计</source>
      <description>很多pc网站都有一个实时在线人数的统计功能，那么一般这种是采用什么方式来实现的呢？ 这里我们介绍一个最基础的是实现方式，基于Session结合WebListener来实现在线人数统计</description>
      <category>SpringBoot</category>
      <category>WEB系列</category>
      <category>应用篇</category>
      <pubDate>Sat, 25 Mar 2023 20:33:47 GMT</pubDate>
      <content:encoded><![CDATA[<p>很多pc网站都有一个实时在线人数的统计功能，那么一般这种是采用什么方式来实现的呢？ 这里我们介绍一个最基础的是实现方式，基于Session结合WebListener来实现在线人数统计</p>
<!-- more -->
<h2> 项目配置</h2>
<h3> 1. 依赖</h3>
<p>首先搭建一个标准的SpringBoot项目工程，相关版本以及依赖如下</p>
<p>本项目借助<code>SpringBoot 2.2.1.RELEASE</code> + <code>maven 3.5.3</code> + <code>IDEA</code>进行开发</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 启动入口</h3>
<p>我们使用默认的配置进行测试，因此启动入口也可以使用最基础的</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. web配置</h3>
<p>我们主要根据用户的session来创建与销毁来判断是否有新的用户访问站点、以及长时间没有访问之后认为已经离线，为了简化这个注销的模拟过程，我们将session的生命周期设置短一点</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 在线人数统计实现</h2>
<p>接下来我们看一下具体的实现思路：</p>
<ul>
<li>借助Servelt的Listener机制，主要监听Session的创建与销毁</li>
<li>当session创建时，认为新来一个用户，计数+1</li>
<li>当session销毁时，认为用户已经离开，或者长时间没有访问，计数-1</li>
</ul>
<h3> 1. 计数服务</h3>
<p>一个简单基础的计数服务，借助 <code>AtomicInteger</code> 来实现计数统计（为啥不直接是int ?)</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. Session监听器</h3>
<p>自定义一个Session的监听器，监听HttpSession的相关操作</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. 登录登出接口</h3>
<p>最后再设计一个登录、登出、查询实时在线人数的统计接口</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来验证一下，实时在线人数统计情况</p>
<figure><img src="/imgs/230325/00.gif" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 4. 小结</h3>
<p>上面虽然是实现了实时在线人数统计，但是存在一个非常明显的短板问题，那就是只适用于单机的场景，如果后台有多个服务部署，那应该怎么处理呢？</p>
<p>基于此，自然而然想到的就是分布式session 结合 redis 计数来实现，但是这个思路可行么？ 分布式session失效会抛出一个事件么？或许通过监听redis的key失效能处理，但是整体来看，还是有些麻烦，有没有更简单实用的场景呢</p>
<p>且待下文详解</p>
<h2> 不能错过的源码和相关知识点</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-case/206-web-loginuser-count" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-case/206-web-loginuser-count</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/230325/00.gif" type="image/gif"/>
    </item>
    <item>
      <title>MongoDB之Collection导入导出</title>
      <link>https://liuyueyi.github.io/tutorial/db/mongodb/basic/01.MongoDB%E4%B9%8BCollection%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA.html</link>
      <guid>https://liuyueyi.github.io/tutorial/db/mongodb/basic/01.MongoDB%E4%B9%8BCollection%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">MongoDB之Collection导入导出</source>
      <description>mongodb中集合的导入导出，在robot3t工具中没有找到对应的方法，记录下控制台的操作流程 主要利用： mongoexport 与 mongoimport</description>
      <category>DB</category>
      <category>Mongo</category>
      <pubDate>Sat, 16 Feb 2019 10:25:19 GMT</pubDate>
      <content:encoded><![CDATA[<p>mongodb中集合的导入导出，在robot3t工具中没有找到对应的方法，记录下控制台的操作流程</p>
<p>主要利用： <code>mongoexport</code> 与 <code>mongoimport</code></p>
<!-- more -->
<h3> 1. 集合导出</h3>
<p>直接使用 <code>mognoexport</code> 即可，通过<code>mongoexport --help</code>查看对应的使用说明</p>
<p>将库<code>database</code>中的集合<code>collection</code>导出到json文件<code>out.json</code></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 2. 集合导入</h3>
<p>使用 <code>mongoimport</code> 实现导入，同样可以输入<code>--help</code>查看使用说明</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>零：环境安装与初始化</title>
      <link>https://liuyueyi.github.io/tutorial/db/mongodb/basic/02.MongoDb%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E9%9B%B6-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96.html</link>
      <guid>https://liuyueyi.github.io/tutorial/db/mongodb/basic/02.MongoDb%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E9%9B%B6-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">零：环境安装与初始化</source>
      <description>MongoDB 是一个基于分布式文件存储的数据库。由 C++ 语言编写。旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。 MongoDB 是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。 本篇为mongodb系列教程第一篇，环境安装与连接设置</description>
      <category>DB</category>
      <category>Mongo</category>
      <pubDate>Thu, 19 Mar 2020 20:13:29 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>MongoDB 是一个基于分布式文件存储的数据库。由 C++ 语言编写。旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。</p>
</blockquote>
<p>MongoDB 是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。</p>
<p>本篇为mongodb系列教程第一篇，环境安装与连接设置</p>
<!-- more -->
<h3> 1. docker安装</h3>
<p>首先介绍最简单的安装方式，docker安装，请先保证docker环境存在（没有安装的推荐查看: <a href="https://blog.hhui.top/2019/12/06/191206-Centos%E5%AE%89%E8%A3%85docker%E4%B8%8E%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/" target="_blank" rel="noopener noreferrer">Centos安装docker与使用说明</a>）</p>
<p>安装命令如下:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. centos安装</h3>
<p>直接借助yum进行安装，命令如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. 用户配置</h3>
<p>直接通过mongodb提供的终端命令进行设置，</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4. 终端控制台</h3>
<p>mongodb集成了终端控制台，通过<code>mongo</code>进入；</p>
<p>但是当我们设置了登录认证时，有下面两种使用姿势</p>
<p><strong>case1</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/200319/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p><strong>case2</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/200319/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 5. 可视化操作工具</h3>
<p>终端虽好，使用起来终究不太顺手，可视化工具推荐使用<code>ROBO 3T</code>操作mongodb，官网下载地址: <a href="https://robomongo.org/" target="_blank" rel="noopener noreferrer">https://robomongo.org/</a></p>
<p>然后配置mongodb连接信息（支持ssh验证方式哦），下面是一个简单的配置</p>
<figure><img src="/imgs/200319/02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>然后就可以通过它来操作mongodb了</p>
<figure><img src="/imgs/200319/03.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/200319/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>一：基本概念</title>
      <link>https://liuyueyi.github.io/tutorial/db/mongodb/basic/03.MongoDb%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B8%80-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5.html</link>
      <guid>https://liuyueyi.github.io/tutorial/db/mongodb/basic/03.MongoDb%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B8%80-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">一：基本概念</source>
      <description>mongodb和我们通常使用的关系型数据库如mysql，在一些基本概念上有相同之处，但也有一些区别，在进行mongodb的语言介绍之前，有必要先了解一些基础概念 本文将对比sql对一些基础概念进行解释说明</description>
      <category>DB</category>
      <category>Mongo</category>
      <pubDate>Sat, 21 Mar 2020 19:40:22 GMT</pubDate>
      <content:encoded><![CDATA[<p>mongodb和我们通常使用的关系型数据库如mysql，在一些基本概念上有相同之处，但也有一些区别，在进行mongodb的语言介绍之前，有必要先了解一些基础概念</p>
<p>本文将对比sql对一些基础概念进行解释说明</p>
<!-- more -->
<h2> I. 基本概念</h2>
<blockquote>
<p><a href="https://www.runoob.com/mongodb/mongodb-databases-documents-collections.html" target="_blank" rel="noopener noreferrer">MongoDB 概念解析</a></p>
</blockquote>
<p>在sql中，会区分database, table, row, column, index, primaryId；在mongodb中也有对应的概念</p>
<table>
<thead>
<tr>
<th>sql</th>
<th>mongodb</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>database</td>
<td>db</td>
<td>数据库</td>
</tr>
<tr>
<td>table</td>
<td>collection</td>
<td>表/集合</td>
</tr>
<tr>
<td>row</td>
<td>document</td>
<td>行/文档</td>
</tr>
<tr>
<td>column</td>
<td>field</td>
<td>字段</td>
</tr>
<tr>
<td>index</td>
<td>index</td>
<td>索引</td>
</tr>
<tr>
<td>primaryId</td>
<td>_id</td>
<td>主键</td>
</tr>
<tr>
<td>lock</td>
<td>lock</td>
<td>锁</td>
</tr>
</tbody>
</table>
<p>下面对以上基本概念进行简单说明，详情的后续博文会补上</p>
<h3> 1. 数据库</h3>
<p>数据库可以理解为collection的聚集体，每个mongodb实例可以有多个database，每个database可以有多个collection</p>
<p>常见的几个命令如下：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 集合</h3>
<p>document的集合，与table最大的区别是它的结构不是固定的，不需要事先定义字段、类型</p>
<p>首次新增document时，集合被创建；</p>
<h3> 3. document</h3>
<p>文档，也就是具体的数据；bson结构，kv方式</p>
<p>最大的特点是不要求所有的document的结构一致，相同的field的数据类型可以不一致</p>
<h3> 4. index</h3>
<p>索引，同样是用来提高查询效率，避免全盘扫描</p>
<h3> 5. lock</h3>
<p>支持读写锁，document加读锁时，其他读操作ok，写操作禁止；加写锁时，其他读写操作禁止</p>
<h3> 6. 事务</h3>
<blockquote>
<p><a href="https://yq.aliyun.com/articles/610159" target="_blank" rel="noopener noreferrer">MongoDB 4.0 事务实现解析</a></p>
</blockquote>
<p>版本<code>&gt;= 4.0</code>，支持事务，支持多文档ACID，后续详细说明</p>
]]></content:encoded>
    </item>
    <item>
      <title>二：连接</title>
      <link>https://liuyueyi.github.io/tutorial/db/mongodb/basic/04.MongoDb%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%BA%8C-%E8%BF%9E%E6%8E%A5.html</link>
      <guid>https://liuyueyi.github.io/tutorial/db/mongodb/basic/04.MongoDb%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%BA%8C-%E8%BF%9E%E6%8E%A5.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">二：连接</source>
      <description>后续的所有文章的基础，都是需要先连上mongodb，然后才能执行各种命令操作； 本文将介绍一下如何连接一个已经启动的mongodb服务器</description>
      <category>DB</category>
      <category>Mongo</category>
      <pubDate>Sun, 22 Mar 2020 22:11:09 GMT</pubDate>
      <content:encoded><![CDATA[<p>后续的所有文章的基础，都是需要先连上mongodb，然后才能执行各种命令操作；</p>
<p>本文将介绍一下如何连接一个已经启动的mongodb服务器</p>
<!-- more -->
<h3> 1. 连接语法</h3>
<p>标准URI连接语法：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul>
<li><code>mongodb://</code> 固定前缀</li>
<li><code>username:password@</code>: 如果开启了用户登录验证，需要指定用户名密码</li>
<li><code>host1:port1</code>: mongodb服务器的ip/域名 + 端口(不填时，默认为27017)</li>
<li><code>database</code>: 如果指定<code>username:password@</code>，连接并验证登陆指定数据库。若不指定，默认打开 test 数据库</li>
<li><code>?options</code>: 是连接选项。如果不使用/database，则前面需要加上</li>
</ul>
<h3> 2. 实例</h3>
<p>直接连接方式如下，注意这种方式会保留用户名和密码，会有一定的安全风险</p>
<p><strong>连接目标服务器</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>连接多台服务器</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>连接 replica set 三台服务器, 写入操作应用在主服务器 并且分布查询到从服务器</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>三：基本工具介绍</title>
      <link>https://liuyueyi.github.io/tutorial/db/mongodb/basic/05.MongoDb%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B8%89-%E5%9F%BA%E6%9C%AC%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D.html</link>
      <guid>https://liuyueyi.github.io/tutorial/db/mongodb/basic/05.MongoDb%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B8%89-%E5%9F%BA%E6%9C%AC%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">三：基本工具介绍</source>
      <description>mongodb服务器安装完毕之后，提供了一些配套的操作工具，接下来我们有必要认识一下它们，并了解基本用法</description>
      <category>DB</category>
      <category>Mongo</category>
      <pubDate>Wed, 25 Mar 2020 21:32:39 GMT</pubDate>
      <content:encoded><![CDATA[<p>mongodb服务器安装完毕之后，提供了一些配套的操作工具，接下来我们有必要认识一下它们，并了解基本用法</p>
<!-- more -->
<h3> 0. mongod</h3>
<p>启动mongodb实例的主要命令，常见的使用姿势如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 1. mongo 命令行使用</h3>
<p>mongodb安装完毕之后，会自带一个终端命令行工具，通过它可以连接mongodb，并执行相关命令</p>
<h4> a. 连接</h4>
<p>介绍三种连接mongodb的姿势</p>
<p><strong>case1</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>case2</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>case3</strong></p>
<p>上面两种姿势虽然简单，但是用户名密码有暴露的风险，推荐使用下面这种方式</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> b. 操作</h4>
<p>连接上mongodb服务器之后，就可以执行mongo命令，查看数据库，管理文档，比如下面给几个常见的操作</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/200325/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 2. mongoimport/mongoexport</h3>
<p>用于导入导出数据，如</p>
<p>将库<code>database</code>中的集合<code>collection</code>导出到json文件<code>out.json</code></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>从json文件导入到目标集合<code>new_collection</code></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 3. mongodump/mongorestore</h3>
<p>使用mongodump命令来备份MongoDB数据, 将数据库<code>basic</code>的所有集合备份到目录 <code>/tmp/outDir</code>下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>使用mongorestore恢复，如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4. mongostate</h3>
<p>mongostat是mongodb自带的状态检测工具，在命令行下使用。它会间隔固定时间获取mongodb的当前运行状态，并输出。如果你发现数据库突然变慢或者有其他问题的话，你第一手的操作就考虑采用mongostat来查看mongo的状态。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="/imgs/200325/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 5. mongotop</h3>
<p>mongotop提供每个集合的水平的统计数据，默认每s输出一次</p>
<figure><img src="/imgs/200325/02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/200325/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>四：数据库 Database</title>
      <link>https://liuyueyi.github.io/tutorial/db/mongodb/basic/06.MongoDb%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E5%9B%9B-%E6%95%B0%E6%8D%AE%E5%BA%93-Database.html</link>
      <guid>https://liuyueyi.github.io/tutorial/db/mongodb/basic/06.MongoDb%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E5%9B%9B-%E6%95%B0%E6%8D%AE%E5%BA%93-Database.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">四：数据库 Database</source>
      <description>我们通常把mongodb叫文档型数据库，mysql叫关系型数据库，influxdb叫时序数据库，如果熟悉这三个的话，会发现他们都有一个database，它是collection/table/measurement的上一级，可以简单的把它理解为更高层级的集合，方便统一管理/权限划分/业务拆分 下面简单介绍一下database的基础操作</description>
      <category>DB</category>
      <category>Mongo</category>
      <pubDate>Thu, 26 Mar 2020 16:49:32 GMT</pubDate>
      <content:encoded><![CDATA[<p>我们通常把mongodb叫文档型数据库，mysql叫关系型数据库，influxdb叫时序数据库，如果熟悉这三个的话，会发现他们都有一个<code>database</code>，它是<code>collection/table/measurement</code>的上一级，可以简单的把它理解为更高层级的集合，方便统一管理/权限划分/业务拆分</p>
<p>下面简单介绍一下database的基础操作</p>
<!-- more -->
<h3> 1. 创建数据库</h3>
<p>当数据库不存在时，通过<code>use + 数据库</code>命令可以用来创建数据库；当数据库存在时，表示选中</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 2. 查看数据库</h3>
<p>通过 <code>db</code>查看当前的数据库</p>
<p>通过 <code>show dbs</code> 查看当前的数据库列表</p>
<p>请注意，新创建一个数据库时，直接使用<code>show dbs</code>命令，并不会显示出来，如下</p>
<figure><img src="/imgs/200326/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>为了显示这个数据库，需要插入一个文档</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="/imgs/200326/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 3. 删除数据库</h3>
<p>对于数据库而言，任何删除命令都需要慎重处理，一不小心就得跑路了。。。</p>
<p>命令如下: <code>db.dropDatabase()</code></p>
<p>实例说明：</p>
<p>一般来说我们需要删除时，两步走</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/200326/02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 4. 潜规则</h3>
<p>需要注意，有三个数据库属于预留的，有特殊的作用，不能新建同名的数据</p>
<ul>
<li>admin: 将一个用户添加到这个数据库，这个用户自动继承所有数据库的权限; 一些特定的服务器端命令也只能从这个数据库运行，比如列出所有的数据库或者关闭服务器。</li>
<li>local: 这个数据永远不会被复制，可以用来存储限于本地单台服务器的任意集合</li>
<li>config: 当Mongo用于分片设置时，config数据库在内部使用，用于保存分片的相关信息。</li>
</ul>
<p>命名规则：</p>
<ul>
<li>不能是空字符串</li>
<li>不能含有特殊字符（如<code> </code>，<code>.</code>，<code>$</code>, <code>\</code>, <code>/</code>, <code>\0</code></li>
<li>小写</li>
<li>最多64字节</li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/200326/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>五：集合 Collection</title>
      <link>https://liuyueyi.github.io/tutorial/db/mongodb/basic/07.MongoDb%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%BA%94-%E9%9B%86%E5%90%88-Collection.html</link>
      <guid>https://liuyueyi.github.io/tutorial/db/mongodb/basic/07.MongoDb%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%BA%94-%E9%9B%86%E5%90%88-Collection.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">五：集合 Collection</source>
      <description>集合，相当于关系型数据库中的table，在mongodb中，集合的概念非常贴切，属于文档(Document)的集合 其最大的特点是： 没有固定的结构</description>
      <category>DB</category>
      <category>Mongo</category>
      <pubDate>Thu, 26 Mar 2020 16:52:20 GMT</pubDate>
      <content:encoded><![CDATA[<p>集合，相当于关系型数据库中的table，在mongodb中，集合的概念非常贴切，属于文档(Document)的集合</p>
<p>其最大的特点是：</p>
<ul>
<li>没有固定的结构</li>
</ul>
<!-- more -->
<h3> 1. 创建集合</h3>
<p>创建命令如: <code>db.createCollection(name, options)</code></p>
<p>重点看一下参数<code>options</code>的可选项</p>
<ul>
<li>capped: true，表示创建固定大小的集合，需要指定size；超过数量之后，覆盖最早的文档</li>
<li>size: 固定集合时配套使用，KB为单位</li>
<li>autoIndexId: 自动为<code>_id</code>添加索引，默认true</li>
<li>max: 固定集合时，文档的最大数量</li>
</ul>
<p>一个简单的实例</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>除此之外，新插入一个文档时，集合若不存在，也会创建对应的集合，如</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 查看集合</h3>
<p>通过 <code>show collections</code> 查看数据库下的集合列表</p>
<figure><img src="/imgs/200326/03.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 3. 删除集合</h3>
<p>通过命令 <code>db.col.drop()</code>来删除</p>
<figure><img src="/imgs/200326/04.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 4. 命名规则</h3>
<ul>
<li>不能全是空白字符</li>
<li>不应包含特殊字符</li>
<li>不要以<code>system.</code>开头</li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/200326/03.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>六：文档 Document 插入姿势</title>
      <link>https://liuyueyi.github.io/tutorial/db/mongodb/basic/08.MongoDb%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E5%85%AD-%E6%96%87%E6%A1%A3-Document-%E6%8F%92%E5%85%A5%E5%A7%BF%E5%8A%BF.html</link>
      <guid>https://liuyueyi.github.io/tutorial/db/mongodb/basic/08.MongoDb%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E5%85%AD-%E6%96%87%E6%A1%A3-Document-%E6%8F%92%E5%85%A5%E5%A7%BF%E5%8A%BF.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">六：文档 Document 插入姿势</source>
      <description>文档相当于关系数据库中数据行，也是我们最关心的数据本身；以BSON格式存储（和json区别不大） 我们通常所说业务开发者的CURD四大技能，在mongodb中，就是针对Document而言，接下来我们先看一下文档的新增使用姿势</description>
      <category>DB</category>
      <category>Mongo</category>
      <pubDate>Thu, 26 Mar 2020 17:04:06 GMT</pubDate>
      <content:encoded><![CDATA[<p>文档相当于关系数据库中数据行，也是我们最关心的数据本身；以BSON格式存储（和json区别不大）</p>
<p>我们通常所说业务开发者的CURD四大技能，在mongodb中，就是针对Document而言，接下来我们先看一下文档的新增使用姿势</p>
<!-- more -->
<h3> 1. 基本语法</h3>
<p>插入语法： <code>db.collection.insert()</code></p>
<p>因为集合不要求定义数据结构，所以插入的文档格式理论上可以完全不一样，可以拥有完全不同的数据结构，相同的字段拥有不同的数据类型</p>
<h3> 2. 实例演示</h3>
<p>下面给出几个实例进行说明</p>
<p><strong>基本数据类型插入</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>数组类型插入</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>Object类型插入</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="/imgs/200326/05.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 3. 数据类型</h3>
<p>mongodb支持的基本数据类型，除了我们常见的string,int,float,boolean之外，还有一些其他的;</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>String</td>
<td>字符串， UTF8编码</td>
</tr>
<tr>
<td>Integer</td>
<td>整型，32/64位</td>
</tr>
<tr>
<td>Boolean</td>
<td>布尔</td>
</tr>
<tr>
<td>Double</td>
<td>浮点</td>
</tr>
<tr>
<td>Min/Max keys</td>
<td>将一个值与 BSON（二进制的 JSON）元素的最低值和最高值相对比</td>
</tr>
<tr>
<td>Array</td>
<td>数组</td>
</tr>
<tr>
<td>Timestamp</td>
<td>时间戳，记录文档修改或添加的具体时间</td>
</tr>
<tr>
<td>Object</td>
<td>内嵌文档</td>
</tr>
<tr>
<td>Null</td>
<td>创建空值</td>
</tr>
<tr>
<td>Symbol</td>
<td>符号。该数据类型基本上等同于字符串类型，但不同的是，它一般用于采用特殊符号类型的语言。</td>
</tr>
<tr>
<td>Date</td>
<td>日期，用 UNIX 时间格式来存储当前日期或时间。你可以指定自己的日期时间：创建 Date 对象，传入年月日信息。</td>
</tr>
<tr>
<td>ObjectID</td>
<td>对象ID</td>
</tr>
<tr>
<td>Binary Data</td>
<td>二进制</td>
</tr>
<tr>
<td>code</td>
<td>代码类型。用于在文档中存储 JavaScript 代码。</td>
</tr>
<tr>
<td>Regular expression</td>
<td>正则表达式类型。用于存储正则表达式。</td>
</tr>
</tbody>
</table>
<p><strong>ObjectId 类似唯一主键</strong>，可以很快的去生成和排序，包含 12 bytes，含义是：</p>
<ul>
<li>前 4 个字节表示创建 unix 时间戳,格林尼治时间 UTC 时间，比北京时间晚了 8 个小时</li>
<li>接下来的 3 个字节是机器标识码</li>
<li>紧接的两个字节由进程 id 组成 PID</li>
<li>最后三个字节是随机数</li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/200326/05.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>七：文档 Document 删除姿势</title>
      <link>https://liuyueyi.github.io/tutorial/db/mongodb/basic/09.MongoDb%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B8%83-%E6%96%87%E6%A1%A3-Document-%E5%88%A0%E9%99%A4%E5%A7%BF%E5%8A%BF.html</link>
      <guid>https://liuyueyi.github.io/tutorial/db/mongodb/basic/09.MongoDb%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B8%83-%E6%96%87%E6%A1%A3-Document-%E5%88%A0%E9%99%A4%E5%A7%BF%E5%8A%BF.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">七：文档 Document 删除姿势</source>
      <description>前面一篇介绍了插入文档的使用姿势，这一篇则主要介绍删除的使用case</description>
      <category>DB</category>
      <category>Mongo</category>
      <pubDate>Thu, 26 Mar 2020 18:02:03 GMT</pubDate>
      <content:encoded><![CDATA[<p>前面一篇介绍了插入文档的使用姿势，这一篇则主要介绍删除的使用case</p>
<!-- more -->
<h3> 1. 基本语法</h3>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>第一个为需要删除的匹配条件；第二个表示是否只删除一个，默认是false，删除所有满足条件的文档</p>
<p><strong>注意</strong></p>
<ul>
<li>当query为空时，表示删除所有文档，高危操作，谨慎执行</li>
</ul>
<h3> 2. 实例演示</h3>
<p>借用给我们上一篇插入的文档来进行演示，当前存在的文档为</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>根据id进行删除</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>根据name删除第一个满足条件的记录</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>再次查看剩下的内容如下：</p>
<figure><img src="/imgs/200326/06.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/200326/06.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>八：文档 Document 更新姿势</title>
      <link>https://liuyueyi.github.io/tutorial/db/mongodb/basic/10.MongoDb%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E5%85%AB-%E6%96%87%E6%A1%A3-Document-%E6%9B%B4%E6%96%B0%E5%A7%BF%E5%8A%BF.html</link>
      <guid>https://liuyueyi.github.io/tutorial/db/mongodb/basic/10.MongoDb%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E5%85%AB-%E6%96%87%E6%A1%A3-Document-%E6%9B%B4%E6%96%B0%E5%A7%BF%E5%8A%BF.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">八：文档 Document 更新姿势</source>
      <description>本篇介绍update/save两种方法提供的更新姿势</description>
      <category>DB</category>
      <category>Mongo</category>
      <pubDate>Fri, 27 Mar 2020 11:04:36 GMT</pubDate>
      <content:encoded><![CDATA[<p>本篇介绍update/save两种方法提供的更新姿势</p>
<!-- more -->
<h3> 1. update</h3>
<p>用于更新已经存在的文档，语法如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>query: 查询条件</li>
<li>update: 更新语句</li>
<li>upsert: （可选）true, 不存在update的记录时插入；默认是false，不插入</li>
<li>multi: (可选) true，表示更新所有满足条件的记录；默认false，只更新第一条</li>
<li>writeConcern: (可选)，抛出异常的级别</li>
</ul>
<p>插入两条用于测试的数据</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>下面给出几个更新的实例</p>
<p><strong>更新age</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/200327/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p><strong>更新所有age为20的文档，新增一个tag成员</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="/imgs/200327/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p><strong>更新一个不存在的文档</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="/imgs/200327/02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 2. save</h3>
<p>save最大的特点是覆盖，用新的文档完全覆盖旧的文档；而update，则是更新指定的field</p>
<p>语法如下：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>举例如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="/imgs/200327/03.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>那么问题来了，<strong>怎样判定是新增一条记录，还是覆盖已经存在的记录呢？</strong></p>
<ul>
<li>有唯一键来判定</li>
<li>即：如果save的文档中，某个field有唯一性要求，那么当数据库中存在这个field文档文档时，执行覆盖操作；否则执行插入</li>
</ul>
<p>举例如下, 指定ObjectId</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="/imgs/200327/04.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/200327/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>九：文档 Document 查询基础篇</title>
      <link>https://liuyueyi.github.io/tutorial/db/mongodb/basic/11.MongoDb%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B9%9D-%E6%96%87%E6%A1%A3-Document-%E6%9F%A5%E8%AF%A2%E5%9F%BA%E7%A1%80%E7%AF%87.html</link>
      <guid>https://liuyueyi.github.io/tutorial/db/mongodb/basic/11.MongoDb%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B9%9D-%E6%96%87%E6%A1%A3-Document-%E6%9F%A5%E8%AF%A2%E5%9F%BA%E7%A1%80%E7%AF%87.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">九：文档 Document 查询基础篇</source>
      <description>MongoDb文档查询，主要借助find方法来完成，在实际的业务开发中，为了满足各种复杂的业务场景，查询的姿势也是各种各样，本篇则主要介绍基本的使用姿势，不涉及到聚合、排序、分页相关内容</description>
      <category>DB</category>
      <category>Mongo</category>
      <pubDate>Sat, 28 Mar 2020 19:27:12 GMT</pubDate>
      <content:encoded><![CDATA[<p>MongoDb文档查询，主要借助find方法来完成，在实际的业务开发中，为了满足各种复杂的业务场景，查询的姿势也是各种各样，本篇则主要介绍基本的使用姿势，不涉及到聚合、排序、分页相关内容</p>
<!-- more -->
<h3> 1. 查询语法</h3>
<p>查询语法定义比较简单，复杂的是查询条件的组合；语法定义如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul>
<li>query: 查询条件，如果不填，则表示查询所有文档</li>
<li>projection: 查询需要返回的field，如果不填则返回所有的数据</li>
</ul>
<p>此外为了mongo-cli的返回结果更加友好，可以在最后添加<code>.pretty()</code>，使输出更友好</p>
<h3> 2. 查询所有</h3>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="/imgs/200328/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 3. 根据条件精准查询</h3>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="/imgs/200328/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 4. 数字比较查询</h3>
<p>对于数字类型的field，可以借助符号<code>$gt</code>(&gt;), <code>$get</code>(&gt;=), <code>$lt</code>(&lt;), <code>$lte</code>(&lt;=), <code>$ne</code>(!=) 来表示具体的操作</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/200328/02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 5. 模糊查询</h3>
<p>在mysql中有一个like用于模糊查询，在mongodb中，同样支持基于正则的模糊查询</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/200328/03.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 6. and条件</h3>
<p>多个查询条件需要满足时，并不需要什么特殊的操作，只需要在查询bson中，加上多个条件即可</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/200328/04.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 7. or条件</h3>
<p>和and不需要额外的操作不同，or条件需要借助 <code>$or</code> 来实现，语法如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>实例如下：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/200328/05.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 8. 限制返回成员</h3>
<p>有些时候我们只需要获取文档中的部分成员，可以在第二个参数中进行指定，规则如下</p>
<ul>
<li><code>成员名: 1</code>： 表示这个成员需要返回</li>
<li><code>成员名: 0</code>： 表示这个成员不返回</li>
</ul>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/200328/06.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>请注意，一般在使用了 <code>成员名: 1</code> 来指定返回field时，会自动返回<code>_id</code>，如果不需要，请显示加上 <code>_id: 0</code></p>
<h3> 9. field类型查询</h3>
<p>根据field的成员类型来作为查询条件，一般有两种方式，这里只介绍更优雅的，语法如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>举例说明</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="/imgs/200328/07.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 10. 存在查询</h3>
<p>mongodb的一个特点就是集合的结构不固定，所以某个成员可能存在也可能不存在，所以当我们的查询条件中需要加一个是否存在的判断时，可以如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/200328/08.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/200328/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>十：文档 Document 查询高级篇</title>
      <link>https://liuyueyi.github.io/tutorial/db/mongodb/basic/12.MongoDb%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E5%8D%81-%E6%96%87%E6%A1%A3-Document-%E6%9F%A5%E8%AF%A2%E9%AB%98%E7%BA%A7%E7%AF%87.html</link>
      <guid>https://liuyueyi.github.io/tutorial/db/mongodb/basic/12.MongoDb%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E5%8D%81-%E6%96%87%E6%A1%A3-Document-%E6%9F%A5%E8%AF%A2%E9%AB%98%E7%BA%A7%E7%AF%87.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">十：文档 Document 查询高级篇</source>
      <description>上一篇的mongodb查询，主要介绍的是一些基本操作，当然有基本就高阶操作； 本文将带来更多的查询姿势 排序 分页 聚合</description>
      <category>DB</category>
      <category>Mongo</category>
      <pubDate>Tue, 31 Mar 2020 21:50:13 GMT</pubDate>
      <content:encoded><![CDATA[<p>上一篇的mongodb查询，主要介绍的是一些基本操作，当然有基本就高阶操作；</p>
<p>本文将带来更多的查询姿势</p>
<ul>
<li>排序</li>
<li>分页</li>
<li>聚合</li>
</ul>
<!-- more -->
<h3> 1. 排序</h3>
<p>在mongodb中，使用sort方法进行排序，语法如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>请注意，sort内部是一个对象，key为field，value为1或者-1，其中1表示升序，-1表示降序</p>
<p>实例说明，根据age进行排序</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>输出如下:</p>
<figure><img src="/imgs/200331/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>上面的演示属于常规的操作，但是针对mongodb的特点，自然会有一些疑问</p>
<p><strong>q1: 如果某个文档没有包含这个field，排序是怎样的？</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="/imgs/200331/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>从输出来看，升序时，不包含这个field的文档，在最前面；降序时，不包含这个field的文档，在最后面</p>
<p><strong>q2: 支持多个field排序吗？</strong></p>
<p>原则上一般不建议多个field的排序（比较影响性能），但对于数据库而言，你得支持吧</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/200331/02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>请注意上的输出，在涉及到多个field排序时，优先根据第一个进行排序，当文档的field相同时，再根据后面的进行排序</p>
<h3> 2. 分页</h3>
<p>当文档很多时，我们不可能把所有的文档一次返回，所以就有了常见的分页，在sql中我们一般使用<code>limit</code> <code>offset</code>来实现分页，在mongodb中也差不多</p>
<p><strong>limit()</strong></p>
<p>限制返回的文档数</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="/imgs/200331/03.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p><strong>skip()</strong></p>
<p>使用limit进行返回条数限制，使用skip进行分页，表示跳过前面的n条数据</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/200331/04.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 3. 聚合</h3>
<p>使用<code>aggregate()</code>来实现聚合，用于处理求和、平均值，最大值，分组等</p>
<p>数据准备:</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>分组查询</strong></p>
<p>根据name进行分组统计</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/200331/05.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>请注意，分组的条件中</p>
<ul>
<li><code>_id</code>: 表示根据哪个字段进行分组</li>
<li><code>size: {}</code>: 表示聚合条件指定，将结果输出到名为size的field中</li>
<li><code>filed</code>名前加<code>$</code>进行指定</li>
</ul>
<p>当前mongodb支持的聚合表达式包括:</p>
<table>
<thead>
<tr>
<th>表达式</th>
<th>说明</th>
<th>举例说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>sum</td>
<td>求和</td>
<td><code>db.doc_demo.aggregate([{$group: {_id: "$name", size: {$sum: '$age'}}}])</code></td>
</tr>
<tr>
<td>avg</td>
<td>平均值</td>
<td><code>db.doc_demo.aggregate([{$group: {_id: "$name", size: {$avg: '$age'}}}])</code></td>
</tr>
<tr>
<td>min</td>
<td>取最小</td>
<td><code>db.doc_demo.aggregate([{$group: {_id: "$name", age: {$min: '$age'}}}])</code></td>
</tr>
<tr>
<td>max</td>
<td>取最大</td>
<td><code>db.doc_demo.aggregate([{$group: {_id: "$name", age: {$max: '$age'}}}])</code></td>
</tr>
<tr>
<td>push</td>
<td>结果插入到一个数组中</td>
<td><code>db.doc_demo.aggregate([{$group: {_id: "$name", age: {$push: '$age'}}}])</code></td>
</tr>
<tr>
<td>addToSet</td>
<td>结果插入集合，过滤重复</td>
<td><code>db.doc_demo.aggregate([{$group: {_id: "$name", age: {$addToSet: '$age'}}}])</code></td>
</tr>
<tr>
<td>first</td>
<td>第一个</td>
<td><code>db.doc_demo.aggregate([{$group: {_id: "$name", age: {$first: '$age'}}}])</code></td>
</tr>
<tr>
<td>last</td>
<td>最后一个</td>
<td><code>db.doc_demo.aggregate([{$group: {_id: "$name", age: {$last: '$age'}}}])</code></td>
</tr>
</tbody>
</table>
<figure><img src="/imgs/200331/06.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>上面虽然介绍了分组支持的一些表达式，但是没有查询条件，难道只能针对所有的文档进行分组统计么？</p>
<p><strong>分组过滤</strong></p>
<p>借助<code>$match</code>来实现过滤统计，如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/200331/07.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>请注意，$match的语法规则和find的查询条件一样，会将满足条件的数据传递给后面的分组计算</p>
<p>这种方式和liux中的管道特别相似，aggregate方法的参数数组中，前面的执行完毕之后，将结果传递给后面的继续执行，除了<code>$match</code>和<code>$group</code>之外，还有一些其他的操作</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>$project</td>
<td>修改输入文档的结构。可以用来重命名、增加或删除域，也可以用于创建计算结果以及嵌套文档。</td>
</tr>
<tr>
<td>$match</td>
<td>用于过滤数据，只输出符合条件的文档。$match使用MongoDB的标准查询操作。</td>
</tr>
<tr>
<td>$limit</td>
<td>用来限制MongoDB聚合管道返回的文档数。</td>
</tr>
<tr>
<td>$skip</td>
<td>在聚合管道中跳过指定数量的文档，并返回余下的文档。</td>
</tr>
<tr>
<td>$unwind</td>
<td>将文档中的某一个数组类型字段拆分成多条，每条包含数组中的一个值。</td>
</tr>
<tr>
<td>$group</td>
<td>将集合中的文档分组，可用于统计结果。</td>
</tr>
<tr>
<td>$sort</td>
<td>将输入文档排序后输出。</td>
</tr>
<tr>
<td>$geoNear</td>
<td>输出接近某一地理位置的有序文档。</td>
</tr>
</tbody>
</table>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/200331/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>十一：文档 Document 查询非典型篇</title>
      <link>https://liuyueyi.github.io/tutorial/db/mongodb/basic/13.MongoDb%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E5%8D%81%E4%B8%80-%E6%96%87%E6%A1%A3-Document-%E6%9F%A5%E8%AF%A2%E9%9D%9E%E5%85%B8%E5%9E%8B%E7%AF%87.html</link>
      <guid>https://liuyueyi.github.io/tutorial/db/mongodb/basic/13.MongoDb%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E5%8D%81%E4%B8%80-%E6%96%87%E6%A1%A3-Document-%E6%9F%A5%E8%AF%A2%E9%9D%9E%E5%85%B8%E5%9E%8B%E7%AF%87.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">十一：文档 Document 查询非典型篇</source>
      <description>前面介绍的查询可以说是常见的典型case，但是mongodb中有两个比价特殊的数据类型，数组 + 对象，自然的也会有一些非典型的查询case，下面主要针对这两种数据类型的查询姿势，给出实例讲解</description>
      <category>DB</category>
      <category>Mongo</category>
      <pubDate>Wed, 08 Apr 2020 21:12:29 GMT</pubDate>
      <content:encoded><![CDATA[<p>前面介绍的查询可以说是常见的典型case，但是mongodb中有两个比价特殊的数据类型，数组 + 对象，自然的也会有一些非典型的查询case，下面主要针对这两种数据类型的查询姿势，给出实例讲解</p>
<!-- more -->
<h3> 1. 数组</h3>
<p>首先准备一些供数组操作的文档如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>长度查询</strong></p>
<p>根据数组长度进行查询，借助<code>$size</code>来统计数组长度</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>长度范围查询</strong></p>
<p>请注意，不支持长度的比较查询，如下，会报语法错误</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="/imgs/200408/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>要实现范围查询，可以借助<code>$where</code>来实现(<code>$where</code>比较强大，后面单独说明)</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/200408/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p><strong>数组内容查询</strong></p>
<p>根据数组内容进行查询，常见的有两种方式，一个是直接根据数组定位比较如</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这种实用性可能并不大，另外一个常见的case就是查询数组中包含某个元素的文档，这时可以借助<code>$elemMatch</code>来实现</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/200408/02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>说明，当数组的元素是Object类型时，还可以用右边这种姿势：<code>db.doc_demo.find({'skill': {$elemMatch: {'subField': 'xxx'}}})</code></p>
<h3> 2. Object</h3>
<p>因为mongodb支持内嵌文档，所以根据内嵌文档进行查询的场景也是不少的</p>
<p>首先准备三个用于后续查询测试的文档</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>根据内嵌文档字段查询</strong></p>
<p>查询姿势和field查询相似，只是需要注意一下key的语法为: <code>field.subField</code>, 实例如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="/imgs/200408/03.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p><strong>存在性查询</strong></p>
<p>查询嵌入文档包含某个field的case，和普通的查询姿势也一样</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>排序</strong></p>
<p>根据Object的成员进行排序，操作姿势也基本一样</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="/imgs/200408/04.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/200408/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>十二：文档更新删除之非典型篇</title>
      <link>https://liuyueyi.github.io/tutorial/db/mongodb/basic/14.MongoDB%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E5%8D%81%E4%BA%8C-%E6%96%87%E6%A1%A3%E6%9B%B4%E6%96%B0%E5%88%A0%E9%99%A4%E4%B9%8B%E9%9D%9E%E5%85%B8%E5%9E%8B%E7%AF%87.html</link>
      <guid>https://liuyueyi.github.io/tutorial/db/mongodb/basic/14.MongoDB%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E5%8D%81%E4%BA%8C-%E6%96%87%E6%A1%A3%E6%9B%B4%E6%96%B0%E5%88%A0%E9%99%A4%E4%B9%8B%E9%9D%9E%E5%85%B8%E5%9E%8B%E7%AF%87.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">十二：文档更新删除之非典型篇</source>
      <description>前面介绍document的新增、删除、更新都处于相对常见和基础的说明，但是考虑到mongodb非结构化的特点，它的一些特性是我们的mysql不会遇到的，本文将针对这些特殊场景给出示例说明 在现有文档中，增加一个field 删除文档中的某个field 重命名文档的field 在文档的数组orObject中，添加/删除/更新数据</description>
      <category>DB</category>
      <category>Mongo</category>
      <pubDate>Fri, 10 Apr 2020 09:13:52 GMT</pubDate>
      <content:encoded><![CDATA[<p>前面介绍document的新增、删除、更新都处于相对常见和基础的说明，但是考虑到mongodb非结构化的特点，它的一些特性是我们的mysql不会遇到的，本文将针对这些特殊场景给出示例说明</p>
<ul>
<li>在现有文档中，增加一个field</li>
<li>删除文档中的某个field</li>
<li>重命名文档的field</li>
<li>在文档的数组orObject中，添加/删除/更新数据</li>
</ul>
<!-- more -->
<h3> 1. 增加field</h3>
<p>我们知道修改文档的命令格式如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当我们更新一个文档中，不存在的field，会怎样</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/200410/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 2. 重命名field</h3>
<p>同样是借助update方法，但是我们用到的关键字为 <code>$rename</code></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="/imgs/200410/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p><strong>请注意，当文档中不存在这个field，则不会有任何影响</strong></p>
<h3> 3. 删除field</h3>
<p>既然<code>$set</code>可以新增一个不存在的field，那么是不是就可以用<code>$unset</code>来删除一个已存在的field呢</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="/imgs/200410/02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 4. 数组元素修改</h3>
<blockquote>
<p>数组元素的修改删除增加，可以参考官方教程: <a href="https://www.mongodb.org.cn/manual/update-array/" target="_blank" rel="noopener noreferrer">MongoDB update-array Method</a></p>
</blockquote>
<p>如果我们希望直接修改数组中的某个元素，可以借助之前查询的case</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/200410/03.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p><strong>请注意，使用<code>$</code>占位符的前途是，前面的查询条件可以限定数组元素</strong></p>
<h3> 5. 数组元素新增</h3>
<p>元素添加支持两种方式，一是<code>addToSet</code>，一是<code>push</code></p>
<p><strong><code>$addToSet</code></strong></p>
<ul>
<li>确保没有重复的项添加到数组集合，对于已经存在的重复元素不受影响；</li>
<li>不能保证添加时元素的顺序</li>
<li>如果值是数组，则作为一个元素添加进去</li>
<li>可以通过 <code>$each</code> 实现添加多个元素到数组中</li>
</ul>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/200410/04.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p><strong><code>$push</code></strong></p>
<ul>
<li>如果被更新的文档该数组不存在，那么$push将添加数组字段和值</li>
<li>如果字段不是数组，失败</li>
<li>如果值是数组，那么整个数组作为一个单个元素添加到数组</li>
</ul>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/200410/05.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 6. 数组元素删除</h3>
<p><strong><code>$pop</code></strong> 删除第一个or最后一个</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/200410/06.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p><strong><code>$pull</code></strong> 删除满足条件的数组元素</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/200410/07.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>注意，<code>$pull</code>后面跟上的可以理解为限定条件，查询教程篇的一些操作也是支持的（如比较查询等）</p>
<h3> 7. 内嵌文档操作</h3>
<p>对于内嵌文档的操作，实际上普通的field的操作姿势没有什么区别，只是对于key加了一个<code>xx.xx</code>的限定而已</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/200410/08.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/200410/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>十三：索引</title>
      <link>https://liuyueyi.github.io/tutorial/db/mongodb/basic/15.MongoDb%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E5%8D%81%E4%B8%89-%E7%B4%A2%E5%BC%95.html</link>
      <guid>https://liuyueyi.github.io/tutorial/db/mongodb/basic/15.MongoDb%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E5%8D%81%E4%B8%89-%E7%B4%A2%E5%BC%95.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">十三：索引</source>
      <description>索引一般用来提高查询效率，避免全集合搜索，那么在mongodb中，支持索引么？如果支持，如何定义索引，如何使用索引，如何确定一个sql是否走索引？</description>
      <category>DB</category>
      <category>Mongo</category>
      <pubDate>Sat, 18 Apr 2020 08:55:17 GMT</pubDate>
      <content:encoded><![CDATA[<p>索引一般用来提高查询效率，避免全集合搜索，那么在mongodb中，支持索引么？如果支持，如何定义索引，如何使用索引，如何确定一个sql是否走索引？</p>
<!-- more -->
<h3> 1. 创建索引</h3>
<p><strong>语法定义:</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>请注意，在3.0之前的版本中，也可以使用<code>ensureIndex</code>来创建索引</p>
<p><strong>参数说明:</strong></p>
<ul>
<li>keys：kv结构，key为fieldName, value为1 表示升序创建索引；-1 表示降序创建索引；支持多字段索引</li>
<li>options：可选参数</li>
</ul>
<p>常见参数说明如下表:</p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>background</code></td>
<td>true，则后台方式创建索引，不阻塞其他操作；默认为false</td>
</tr>
<tr>
<td><code>unique</code></td>
<td>true，则表示唯一约束索引，比如<code>_id</code>就有唯一约束；默认为false</td>
</tr>
<tr>
<td><code>name</code></td>
<td>索引名，不指定时，根据field + 方向生成索引名</td>
</tr>
<tr>
<td><code>sparse</code></td>
<td>true, 则不包含这个字段的不创建索引，且索引查询时查不到不包含这个字段的文档；默认false</td>
</tr>
<tr>
<td><code>expireAfterSeconds</code></td>
<td>设置文档在集合的生存时间，s为单位</td>
</tr>
<tr>
<td><code>v</code></td>
<td>版本号</td>
</tr>
<tr>
<td><code>weight</code></td>
<td>索引权重值，数值在 1 到 99,999 之间，表示该索引相对于其他索引字段的得分权重</td>
</tr>
<tr>
<td><code>default_language</code></td>
<td>对于文本索引，该参数决定了停用词及词干和词器的规则的列表。 默认为英语</td>
</tr>
<tr>
<td><code>language_override</code></td>
<td>对于文本索引，该参数指定了包含在文档中的字段名，语言覆盖默认的language，默认值为 language</td>
</tr>
</tbody>
</table>
<p>实例如下：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 2. 索引查询</h3>
<p>查看一个集合定义了哪些索引，借助<code>getIndexes()</code>方法即可，如</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="/imgs/200418/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 3. 索引分析</h3>
<p>虽然我们创建了索引，但是我们的查询语句却并不一定会走索引，在mysql中我们知道有一个<code>explain</code>语句来分析索引情况，在mongodb中也存在类似的方法</p>
<p>集合数据如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当前集合上除了默认的<code>_id</code>索引之外，针对<code>name</code>也创建了升序索引</p>
<p>如需要判断一个查询语句的情况，可以在后面加上<code>explain()</code>方法，如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>输出如下</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>关于是否走索引，主要看stage，通常会有以下几种状态</p>
<table>
<thead>
<tr>
<th>stage</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>COLLSCAN</td>
<td>全表扫描</td>
</tr>
<tr>
<td>IXSCAN</td>
<td>扫描索引</td>
</tr>
<tr>
<td>FETCH</td>
<td>根据索引去检索指定document</td>
</tr>
<tr>
<td>SHARD_MERGE</td>
<td>将各个分片返回数据进行merge</td>
</tr>
<tr>
<td>SORT</td>
<td>表明在内存中进行了排序</td>
</tr>
<tr>
<td>LIMIT</td>
<td>使用limit限制返回数</td>
</tr>
<tr>
<td>SKIP</td>
<td>使用skip进行跳过</td>
</tr>
<tr>
<td>IDHACK</td>
<td>针对_id进行查询</td>
</tr>
<tr>
<td>SHARDING_FILTER</td>
<td>通过mongos对分片数据进行查询</td>
</tr>
<tr>
<td>COUNT</td>
<td>利用db.coll.explain().count()之类进行count运算</td>
</tr>
<tr>
<td>COUNTSCAN</td>
<td>count不使用Index进行count时的stage返回</td>
</tr>
<tr>
<td>COUNT_SCAN</td>
<td>count使用了Index进行count时的stage返回</td>
</tr>
<tr>
<td>SUBPLA</td>
<td>未使用到索引的$or查询的stage返回</td>
</tr>
<tr>
<td>TEXT</td>
<td>使用全文索引进行查询时候的stage返回</td>
</tr>
<tr>
<td>PROJECTION</td>
<td>限定返回字段时候stage的返回</td>
</tr>
</tbody>
</table>
<p>上面的具体查询，对应的stage组合是<code>Fetch+ixscan</code>，也就是说会根据索引查询</p>
<p>虽然mongodb会根据查询来选择索引，但并不能保证都能选到最优的索引；这种时候我们可以通过<code>hint</code>来强制指定索引，举例如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 4. 删除索引</h3>
<p>一般有下面两种删除方式，全量删除和指定索引删除</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>请注意，指定索引名删除时，如果不确定索引名是啥，可以通过<code>getIndexes()</code>来查看</p>
<h3> 5. 文档自动删除</h3>
<p>在创建索引的时候，其中有一个参数比较有意思，有必要单独拿出来说明一下，<code>expireAfterSeconds</code> 设置文档的生存时间</p>
<p>使用它有几个潜规则：</p>
<ul>
<li>索引字段为Date类型</li>
<li>单字段索引，不支持混合索引</li>
<li>非立即执行</li>
</ul>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后过一段时间（并不一定10:55分的时候会删除）再去查询，会发现插入的文档被删除了</p>
<p>利用这种特性，在mongodb中存一些需要定时删除的数据，相比较我们常用的mysql而言，还是有很大优势的</p>
<h3> 6. 覆盖索引</h3>
<p>覆盖索引的概念有些类似mysql中的不回表查询的case，直接查询索引，就可以返回所需要的字段了</p>
<p>比如在前面的case中，我只查询name字段，可以走覆盖索引；但是返回除了name，还有<code>_id</code>，那么就不能了</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>注意：所有索引字段是一个数组时，不能使用覆盖索引</strong></p>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/200418/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>MongoDB基础教程</title>
      <link>https://liuyueyi.github.io/tutorial/db/mongodb/basic/</link>
      <guid>https://liuyueyi.github.io/tutorial/db/mongodb/basic/</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">MongoDB基础教程</source>
      <description>文档数据库MongoDB的基本使用姿势教程，手把手教你学会MongoDB的CURD</description>
      <pubDate>Fri, 24 Feb 2023 08:19:09 GMT</pubDate>
      <content:encoded><![CDATA[<p>文档数据库MongoDB的基本使用姿势教程，手把手教你学会MongoDB的CURD</p>
]]></content:encoded>
    </item>
    <item>
      <title>SpringBoot整合MongoDB</title>
      <link>https://liuyueyi.github.io/tutorial/db/mongodb/spring/</link>
      <guid>https://liuyueyi.github.io/tutorial/db/mongodb/spring/</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">SpringBoot整合MongoDB</source>
      <description>SpringBoot 整合 MongoDB SpringBoot + MongoDB SpringBoot生态下，掌握MongoDB的CURD</description>
      <pubDate>Fri, 24 Feb 2023 08:19:09 GMT</pubDate>
      <content:encoded><![CDATA[<p><a href="/tutorial/spring/db/MongoDB/" target="blank">SpringBoot 整合 MongoDB</a></p>
<div class="hint-container info">
<p class="hint-container-title">SpringBoot + MongoDB</p>
<p>SpringBoot生态下，掌握MongoDB的CURD</p>
</div>
]]></content:encoded>
    </item>
    <item>
      <title>数据库</title>
      <link>https://liuyueyi.github.io/tutorial/db/</link>
      <guid>https://liuyueyi.github.io/tutorial/db/</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">数据库</source>
      <description>数据库 ❤️ MySql 📝 MongoDB ⌛ InfluxDB 🪧 ClickHouse 🫶 Redis 🔍 ES</description>
      <pubDate>Fri, 24 Feb 2023 02:18:35 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 数据库</h1>
<h2> ❤️ MySql</h2>
<h2> 📝 MongoDB</h2>
<h2> ⌛ InfluxDB</h2>
<h2> 🪧 ClickHouse</h2>
<h2> 🫶 Redis</h2>
<h2> 🔍 ES</h2>
]]></content:encoded>
    </item>
    <item>
      <title>ClickHouse系列教程</title>
      <link>https://liuyueyi.github.io/tutorial/db/clickhouse/</link>
      <guid>https://liuyueyi.github.io/tutorial/db/clickhouse/</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">ClickHouse系列教程</source>
      <description>列式数据库ClickHouse</description>
      <pubDate>Fri, 24 Feb 2023 02:18:35 GMT</pubDate>
      <content:encoded><![CDATA[<p>列式数据库ClickHouse</p>
]]></content:encoded>
    </item>
    <item>
      <title>ES系列教程</title>
      <link>https://liuyueyi.github.io/tutorial/db/es/</link>
      <guid>https://liuyueyi.github.io/tutorial/db/es/</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">ES系列教程</source>
      <description>近实时搜索引擎ElasticSearch</description>
      <pubDate>Fri, 24 Feb 2023 02:18:35 GMT</pubDate>
      <content:encoded><![CDATA[<p>近实时搜索引擎ElasticSearch</p>
]]></content:encoded>
    </item>
    <item>
      <title>InfluxDB系列教程</title>
      <link>https://liuyueyi.github.io/tutorial/db/influxdb/</link>
      <guid>https://liuyueyi.github.io/tutorial/db/influxdb/</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">InfluxDB系列教程</source>
      <description>时序数据库Influxdb</description>
      <pubDate>Fri, 24 Feb 2023 02:18:35 GMT</pubDate>
      <content:encoded><![CDATA[<p>时序数据库Influxdb</p>
]]></content:encoded>
    </item>
    <item>
      <title>MongoDB系列教程</title>
      <link>https://liuyueyi.github.io/tutorial/db/mongodb/</link>
      <guid>https://liuyueyi.github.io/tutorial/db/mongodb/</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">MongoDB系列教程</source>
      <description>专栏说明 文档数据库MongoDB的基本使用姿势教程，手把手教你学会MongoDB的CURD MongoDB 0基础入门 mongodb 基础知识 原生的mongodb知识点，如基础概念，CURD等</description>
      <pubDate>Fri, 24 Feb 2023 02:18:35 GMT</pubDate>
      <content:encoded><![CDATA[<div class="hint-container tip">
<p class="hint-container-title">专栏说明</p>
<p>文档数据库MongoDB的基本使用姿势教程，手把手教你学会MongoDB的CURD</p>
</div>
<ul>
<li><a href="./basic">MongoDB 0基础入门</a></li>
</ul>
<div class="hint-container info">
<p class="hint-container-title">mongodb 基础知识</p>
<p>原生的mongodb知识点，如基础概念，CURD等</p>
</div>
<ul>
<li><a href="/tutorial/spring/db/MongoDB/" target="blank">SpringBoot 整合 MongoDB</a></li>
</ul>
<div class="hint-container info">
<p class="hint-container-title">SpringBoot + MongoDB</p>
<p>SpringBoot生态下，掌握MongoDB的CURD</p>
</div>
]]></content:encoded>
    </item>
    <item>
      <title>mongodb零基础入门</title>
      <link>https://liuyueyi.github.io/tutorial/db/mongodb/merge.html</link>
      <guid>https://liuyueyi.github.io/tutorial/db/mongodb/merge.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">mongodb零基础入门</source>
      <description>MongoDB零基础入门 MongoDB 是一个基于分布式文件存储的数据库，本片文档主要面向0基础的小伙伴，如何迅速的学会MongoDB的基本知识点以及掌握基础的CURD，实现业务支撑 第一卷：MongoDB原生知识点 环境安装与初始化 MongoDB 是一个基于分布式文件存储的数据库。由 C++ 语言编写。旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。 MongoDB 是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。 本篇为mongodb系列教程第一篇，环境安装与连接设置</description>
      <pubDate>Fri, 24 Feb 2023 02:18:35 GMT</pubDate>
      <content:encoded><![CDATA[<figure><img src="http://cdn.hhui.top/column/mongo_cover.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> MongoDB零基础入门</h2>
<p>MongoDB 是一个基于分布式文件存储的数据库，本片文档主要面向0基础的小伙伴，如何迅速的学会MongoDB的基本知识点以及掌握基础的CURD，实现业务支撑</p>
<h1> 第一卷：MongoDB原生知识点</h1>
<h2> 环境安装与初始化</h2>
<blockquote>
<p>MongoDB 是一个基于分布式文件存储的数据库。由 C++ 语言编写。旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。</p>
</blockquote>
<p>MongoDB 是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。</p>
<p>本篇为mongodb系列教程第一篇，环境安装与连接设置</p>
<!-- more -->
<h3> 1. docker安装</h3>
<p>首先介绍最简单的安装方式，docker安装，请先保证docker环境存在（没有安装的推荐查看: <a href="https://blog.hhui.top/2019/12/06/191206-Centos%E5%AE%89%E8%A3%85docker%E4%B8%8E%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/" target="_blank" rel="noopener noreferrer">Centos安装docker与使用说明</a>）</p>
<p>安装命令如下:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. centos安装</h3>
<p>直接借助yum进行安装，命令如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. 用户配置</h3>
<p>直接通过mongodb提供的终端命令进行设置，</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4. 终端控制台</h3>
<p>mongodb集成了终端控制台，通过<code>mongo</code>进入；</p>
<p>但是当我们设置了登录认证时，有下面两种使用姿势</p>
<p><strong>case1</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://hhui.top/imgs/200319/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p><strong>case2</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://hhui.top/imgs/200319/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 5. 可视化操作工具</h3>
<p>终端虽好，使用起来终究不太顺手，可视化工具推荐使用<code>ROBO 3T</code>操作mongodb，官网下载地址: <a href="https://robomongo.org/" target="_blank" rel="noopener noreferrer">https://robomongo.org/</a></p>
<p>然后配置mongodb连接信息（支持ssh验证方式哦），下面是一个简单的配置</p>
<figure><img src="https://hhui.top/imgs/200319/02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>然后就可以通过它来操作mongodb了</p>
<figure><img src="https://hhui.top/imgs/200319/03.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> 基本概念</h2>
<p>mongodb和我们通常使用的关系型数据库如mysql，在一些基本概念上有相同之处，但也有一些区别，在进行mongodb的语言介绍之前，有必要先了解一些基础概念</p>
<p>本文将对比sql对一些基础概念进行解释说明</p>
<!-- more -->
<blockquote>
<p><a href="https://www.runoob.com/mongodb/mongodb-databases-documents-collections.html" target="_blank" rel="noopener noreferrer">MongoDB 概念解析</a></p>
</blockquote>
<p>在sql中，会区分database, table, row, column, index, primaryId；在mongodb中也有对应的概念</p>
<table>
<thead>
<tr>
<th>sql</th>
<th>mongodb</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>database</td>
<td>db</td>
<td>数据库</td>
</tr>
<tr>
<td>table</td>
<td>collection</td>
<td>表/集合</td>
</tr>
<tr>
<td>row</td>
<td>document</td>
<td>行/文档</td>
</tr>
<tr>
<td>column</td>
<td>field</td>
<td>字段</td>
</tr>
<tr>
<td>index</td>
<td>index</td>
<td>索引</td>
</tr>
<tr>
<td>primaryId</td>
<td>_id</td>
<td>主键</td>
</tr>
<tr>
<td>lock</td>
<td>lock</td>
<td>锁</td>
</tr>
</tbody>
</table>
<p>下面对以上基本概念进行简单说明，详情的后续博文会补上</p>
<h3> 1. 数据库</h3>
<p>数据库可以理解为collection的聚集体，每个mongodb实例可以有多个database，每个database可以有多个collection</p>
<p>常见的几个命令如下：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 集合</h3>
<p>document的集合，与table最大的区别是它的结构不是固定的，不需要事先定义字段、类型</p>
<p>首次新增document时，集合被创建；</p>
<h3> 3. document</h3>
<p>文档，也就是具体的数据；bson结构，kv方式</p>
<p>最大的特点是不要求所有的document的结构一致，相同的field的数据类型可以不一致</p>
<h3> 4. index</h3>
<p>索引，同样是用来提高查询效率，避免全盘扫描</p>
<h3> 5. lock</h3>
<p>支持读写锁，document加读锁时，其他读操作ok，写操作禁止；加写锁时，其他读写操作禁止</p>
<h3> 6. 事务</h3>
<blockquote>
<p><a href="https://yq.aliyun.com/articles/610159" target="_blank" rel="noopener noreferrer">MongoDB 4.0 事务实现解析</a></p>
</blockquote>
<p>版本<code>&gt;= 4.0</code>，支持事务，支持多文档ACID，后续详细说明</p>
<hr>
<p>微信搜 <strong>楼仔</strong> 或扫描下方二维码关注楼仔的原创公众号，回复 <strong>110</strong> 即可免费领取 10 本面试必刷八股文。
<img src="https://files.mdnice.com/user/13837/4b47ac79-8256-47cf-ac1a-036729635246.png" alt="" loading="lazy"></p>
<hr>
<h2> 连接</h2>
<p>后续的所有文章的基础，都是需要先连上mongodb，然后才能执行各种命令操作；</p>
<p>本文将介绍一下如何连接一个已经启动的mongodb服务器</p>
<!-- more -->
<h3> 1. 连接语法</h3>
<p>标准URI连接语法：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul>
<li><code>mongodb://</code> 固定前缀</li>
<li><code>username:password@</code>: 如果开启了用户登录验证，需要指定用户名密码</li>
<li><code>host1:port1</code>: mongodb服务器的ip/域名 + 端口(不填时，默认为27017)</li>
<li><code>database</code>: 如果指定<code>username:password@</code>，连接并验证登陆指定数据库。若不指定，默认打开 test 数据库</li>
<li><code>?options</code>: 是连接选项。如果不使用/database，则前面需要加上</li>
</ul>
<h3> 2. 实例</h3>
<p>直接连接方式如下，注意这种方式会保留用户名和密码，会有一定的安全风险</p>
<p><strong>连接目标服务器</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>连接多台服务器</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>连接 replica set 三台服务器, 写入操作应用在主服务器 并且分布查询到从服务器</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2> 基本工具介绍</h2>
<p>mongodb服务器安装完毕之后，提供了一些配套的操作工具，接下来我们有必要认识一下它们，并了解基本用法</p>
<!-- more -->
<h3> 0. mongod</h3>
<p>启动mongodb实例的主要命令，常见的使用姿势如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 1. mongo 命令行使用</h3>
<p>mongodb安装完毕之后，会自带一个终端命令行工具，通过它可以连接mongodb，并执行相关命令</p>
<h4> a. 连接</h4>
<p>介绍三种连接mongodb的姿势</p>
<p><strong>case1</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>case2</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>case3</strong></p>
<p>上面两种姿势虽然简单，但是用户名密码有暴露的风险，推荐使用下面这种方式</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> b. 操作</h4>
<p>连接上mongodb服务器之后，就可以执行mongo命令，查看数据库，管理文档，比如下面给几个常见的操作</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://hhui.top/imgs/200325/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 2. mongoimport/mongoexport</h3>
<p>用于导入导出数据，如</p>
<p>将库<code>database</code>中的集合<code>collection</code>导出到json文件<code>out.json</code></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>从json文件导入到目标集合<code>new_collection</code></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 3. mongodump/mongorestore</h3>
<p>使用mongodump命令来备份MongoDB数据, 将数据库<code>basic</code>的所有集合备份到目录 <code>/tmp/outDir</code>下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>使用mongorestore恢复，如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4. mongostate</h3>
<p>mongostat是mongodb自带的状态检测工具，在命令行下使用。它会间隔固定时间获取mongodb的当前运行状态，并输出。如果你发现数据库突然变慢或者有其他问题的话，你第一手的操作就考虑采用mongostat来查看mongo的状态。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="https://hhui.top/imgs/200325/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 5. mongotop</h3>
<p>mongotop提供每个集合的水平的统计数据，默认每s输出一次</p>
<figure><img src="https://hhui.top/imgs/200325/02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> 数据库 Database</h2>
<p>我们通常把mongodb叫文档型数据库，mysql叫关系型数据库，influxdb叫时序数据库，如果熟悉这三个的话，会发现他们都有一个<code>database</code>，它是<code>collection/table/measurement</code>的上一级，可以简单的把它理解为更高层级的集合，方便统一管理/权限划分/业务拆分</p>
<p>下面简单介绍一下database的基础操作</p>
<!-- more -->
<h3> 1. 创建数据库</h3>
<p>当数据库不存在时，通过<code>use + 数据库</code>命令可以用来创建数据库；当数据库存在时，表示选中</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 2. 查看数据库</h3>
<p>通过 <code>db</code>查看当前的数据库</p>
<p>通过 <code>show dbs</code> 查看当前的数据库列表</p>
<p>请注意，新创建一个数据库时，直接使用<code>show dbs</code>命令，并不会显示出来，如下</p>
<figure><img src="https://hhui.top/imgs/200326/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>为了显示这个数据库，需要插入一个文档</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="https://hhui.top/imgs/200326/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 3. 删除数据库</h3>
<p>对于数据库而言，任何删除命令都需要慎重处理，一不小心就得跑路了。。。</p>
<p>命令如下: <code>db.dropDatabase()</code></p>
<p>实例说明：</p>
<p>一般来说我们需要删除时，两步走</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://hhui.top/imgs/200326/02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 4. 潜规则</h3>
<p>需要注意，有三个数据库属于预留的，有特殊的作用，不能新建同名的数据</p>
<ul>
<li>admin: 将一个用户添加到这个数据库，这个用户自动继承所有数据库的权限; 一些特定的服务器端命令也只能从这个数据库运行，比如列出所有的数据库或者关闭服务器。</li>
<li>local: 这个数据永远不会被复制，可以用来存储限于本地单台服务器的任意集合</li>
<li>config: 当Mongo用于分片设置时，config数据库在内部使用，用于保存分片的相关信息。</li>
</ul>
<p>命名规则：</p>
<ul>
<li>不能是空字符串</li>
<li>不能含有特殊字符（如<code> </code>，<code>.</code>，<code>$</code>, <code>\</code>, <code>/</code>, <code>\0</code></li>
<li>小写</li>
<li>最多64字节</li>
</ul>
<h2> 集合 Collection</h2>
<p>集合，相当于关系型数据库中的table，在mongodb中，集合的概念非常贴切，属于文档(Document)的集合</p>
<p>其最大的特点是：</p>
<ul>
<li>没有固定的结构</li>
</ul>
<!-- more -->
<h3> 1. 创建集合</h3>
<p>创建命令如: <code>db.createCollection(name, options)</code></p>
<p>重点看一下参数<code>options</code>的可选项</p>
<ul>
<li>capped: true，表示创建固定大小的集合，需要指定size；超过数量之后，覆盖最早的文档</li>
<li>size: 固定集合时配套使用，KB为单位</li>
<li>autoIndexId: 自动为<code>_id</code>添加索引，默认true</li>
<li>max: 固定集合时，文档的最大数量</li>
</ul>
<p>一个简单的实例</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>除此之外，新插入一个文档时，集合若不存在，也会创建对应的集合，如</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 查看集合</h3>
<p>通过 <code>show collections</code> 查看数据库下的集合列表</p>
<figure><img src="https://hhui.top/imgs/200326/03.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 3. 删除集合</h3>
<p>通过命令 <code>db.col.drop()</code>来删除</p>
<figure><img src="https://hhui.top/imgs/200326/04.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 4. 命名规则</h3>
<ul>
<li>不能全是空白字符</li>
<li>不应包含特殊字符</li>
<li>不要以<code>system.</code>开头</li>
</ul>
<hr>
<p>微信搜 <strong>楼仔</strong> 或扫描下方二维码关注楼仔的原创公众号，回复 <strong>110</strong> 即可免费领取 10 本面试必刷八股文。 <img src="https://files.mdnice.com/user/13837/4b47ac79-8256-47cf-ac1a-036729635246.png" alt="" loading="lazy"></p>
<hr>
<h2> 文档 Document 插入姿势</h2>
<p>文档相当于关系数据库中数据行，也是我们最关心的数据本身；以BSON格式存储（和json区别不大）</p>
<p>我们通常所说业务开发者的CURD四大技能，在mongodb中，就是针对Document而言，接下来我们先看一下文档的新增使用姿势</p>
<!-- more -->
<h3> 1. 基本语法</h3>
<p>插入语法： <code>db.collection.insert()</code></p>
<p>因为集合不要求定义数据结构，所以插入的文档格式理论上可以完全不一样，可以拥有完全不同的数据结构，相同的字段拥有不同的数据类型</p>
<h3> 2. 实例演示</h3>
<p>下面给出几个实例进行说明</p>
<p><strong>基本数据类型插入</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>数组类型插入</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>Object类型插入</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="https://hhui.top/imgs/200326/05.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 3. 数据类型</h3>
<p>mongodb支持的基本数据类型，除了我们常见的string,int,float,boolean之外，还有一些其他的;</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>String</td>
<td>字符串， UTF8编码</td>
</tr>
<tr>
<td>Integer</td>
<td>整型，32/64位</td>
</tr>
<tr>
<td>Boolean</td>
<td>布尔</td>
</tr>
<tr>
<td>Double</td>
<td>浮点</td>
</tr>
<tr>
<td>Min/Max keys</td>
<td>将一个值与 BSON（二进制的 JSON）元素的最低值和最高值相对比</td>
</tr>
<tr>
<td>Array</td>
<td>数组</td>
</tr>
<tr>
<td>Timestamp</td>
<td>时间戳，记录文档修改或添加的具体时间</td>
</tr>
<tr>
<td>Object</td>
<td>内嵌文档</td>
</tr>
<tr>
<td>Null</td>
<td>创建空值</td>
</tr>
<tr>
<td>Symbol</td>
<td>符号。该数据类型基本上等同于字符串类型，但不同的是，它一般用于采用特殊符号类型的语言。</td>
</tr>
<tr>
<td>Date</td>
<td>日期，用 UNIX 时间格式来存储当前日期或时间。你可以指定自己的日期时间：创建 Date 对象，传入年月日信息。</td>
</tr>
<tr>
<td>ObjectID</td>
<td>对象ID</td>
</tr>
<tr>
<td>Binary Data</td>
<td>二进制</td>
</tr>
<tr>
<td>code</td>
<td>代码类型。用于在文档中存储 JavaScript 代码。</td>
</tr>
<tr>
<td>Regular expression</td>
<td>正则表达式类型。用于存储正则表达式。</td>
</tr>
</tbody>
</table>
<p><strong>ObjectId 类似唯一主键</strong>，可以很快的去生成和排序，包含 12 bytes，含义是：</p>
<ul>
<li>前 4 个字节表示创建 unix 时间戳,格林尼治时间 UTC 时间，比北京时间晚了 8 个小时</li>
<li>接下来的 3 个字节是机器标识码</li>
<li>紧接的两个字节由进程 id 组成 PID</li>
<li>最后三个字节是随机数</li>
</ul>
<h2> 文档 Document 删除姿势</h2>
<p>前面一篇介绍了插入文档的使用姿势，这一篇则主要介绍删除的使用case</p>
<!-- more -->
<h3> 1. 基本语法</h3>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>第一个为需要删除的匹配条件；第二个表示是否只删除一个，默认是false，删除所有满足条件的文档</p>
<p><strong>注意</strong></p>
<ul>
<li>当query为空时，表示删除所有文档，高危操作，谨慎执行</li>
</ul>
<h3> 2. 实例演示</h3>
<p>借用给我们上一篇插入的文档来进行演示，当前存在的文档为</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>根据id进行删除</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>根据name删除第一个满足条件的记录</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>再次查看剩下的内容如下：</p>
<figure><img src="https://hhui.top/imgs/200326/06.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> 文档 Document 更新姿势</h2>
<p>本篇介绍update/save两种方法提供的更新姿势</p>
<!-- more -->
<h3> 1. update</h3>
<p>用于更新已经存在的文档，语法如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>query: 查询条件</li>
<li>update: 更新语句</li>
<li>upsert: （可选）true, 不存在update的记录时插入；默认是false，不插入</li>
<li>multi: (可选) true，表示更新所有满足条件的记录；默认false，只更新第一条</li>
<li>writeConcern: (可选)，抛出异常的级别</li>
</ul>
<p>插入两条用于测试的数据</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>下面给出几个更新的实例</p>
<p><strong>更新age</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://hhui.top/imgs/200327/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p><strong>更新所有age为20的文档，新增一个tag成员</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="https://hhui.top/imgs/200327/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p><strong>更新一个不存在的文档</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="https://hhui.top/imgs/200327/02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 2. save</h3>
<p>save最大的特点是覆盖，用新的文档完全覆盖旧的文档；而update，则是更新指定的field</p>
<p>语法如下：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>举例如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="https://hhui.top/imgs/200327/03.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>那么问题来了，<strong>怎样判定是新增一条记录，还是覆盖已经存在的记录呢？</strong></p>
<ul>
<li>有唯一键来判定</li>
<li>即：如果save的文档中，某个field有唯一性要求，那么当数据库中存在这个field文档文档时，执行覆盖操作；否则执行插入</li>
</ul>
<p>举例如下, 指定ObjectId</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="https://hhui.top/imgs/200327/04.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<hr>
<p>微信搜 <strong>楼仔</strong> 或扫描下方二维码关注楼仔的原创公众号，回复 <strong>110</strong> 即可免费领取 10 本面试必刷八股文。 <img src="https://files.mdnice.com/user/13837/4b47ac79-8256-47cf-ac1a-036729635246.png" alt="" loading="lazy"></p>
<hr>
<h2> 文档 Document 查询基础篇</h2>
<p>MongoDb文档查询，主要借助find方法来完成，在实际的业务开发中，为了满足各种复杂的业务场景，查询的姿势也是各种各样，本篇则主要介绍基本的使用姿势，不涉及到聚合、排序、分页相关内容</p>
<!-- more -->
<h3> 1. 查询语法</h3>
<p>查询语法定义比较简单，复杂的是查询条件的组合；语法定义如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul>
<li>query: 查询条件，如果不填，则表示查询所有文档</li>
<li>projection: 查询需要返回的field，如果不填则返回所有的数据</li>
</ul>
<p>此外为了mongo-cli的返回结果更加友好，可以在最后添加<code>.pretty()</code>，使输出更友好</p>
<h3> 2. 查询所有</h3>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="https://hhui.top/imgs/200328/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 3. 根据条件精准查询</h3>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="https://hhui.top/imgs/200328/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 4. 数字比较查询</h3>
<p>对于数字类型的field，可以借助符号<code>$gt</code>(&gt;), <code>$get</code>(&gt;=), <code>$lt</code>(&lt;), <code>$lte</code>(&lt;=), <code>$ne</code>(!=) 来表示具体的操作</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://hhui.top/imgs/200328/02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 5. 模糊查询</h3>
<p>在mysql中有一个like用于模糊查询，在mongodb中，同样支持基于正则的模糊查询</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://hhui.top/imgs/200328/03.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 6. and条件</h3>
<p>多个查询条件需要满足时，并不需要什么特殊的操作，只需要在查询bson中，加上多个条件即可</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://hhui.top/imgs/200328/04.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 7. or条件</h3>
<p>和and不需要额外的操作不同，or条件需要借助 <code>$or</code> 来实现，语法如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>实例如下：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://hhui.top/imgs/200328/05.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 8. 限制返回成员</h3>
<p>有些时候我们只需要获取文档中的部分成员，可以在第二个参数中进行指定，规则如下</p>
<ul>
<li><code>成员名: 1</code>： 表示这个成员需要返回</li>
<li><code>成员名: 0</code>： 表示这个成员不返回</li>
</ul>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://hhui.top/imgs/200328/06.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>请注意，一般在使用了 <code>成员名: 1</code> 来指定返回field时，会自动返回<code>_id</code>，如果不需要，请显示加上 <code>_id: 0</code></p>
<h3> 9. field类型查询</h3>
<p>根据field的成员类型来作为查询条件，一般有两种方式，这里只介绍更优雅的，语法如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>举例说明</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="https://hhui.top/imgs/200328/07.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 10. 存在查询</h3>
<p>mongodb的一个特点就是集合的结构不固定，所以某个成员可能存在也可能不存在，所以当我们的查询条件中需要加一个是否存在的判断时，可以如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://hhui.top/imgs/200328/08.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> 文档 Document 查询高级篇</h2>
<p>上一篇的mongodb查询，主要介绍的是一些基本操作，当然有基本就高阶操作；</p>
<p>本文将带来更多的查询姿势</p>
<ul>
<li>排序</li>
<li>分页</li>
<li>聚合</li>
</ul>
<!-- more -->
<h3> 1. 排序</h3>
<p>在mongodb中，使用sort方法进行排序，语法如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>请注意，sort内部是一个对象，key为field，value为1或者-1，其中1表示升序，-1表示降序</p>
<p>实例说明，根据age进行排序</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>输出如下:</p>
<figure><img src="https://hhui.top/imgs/200331/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>上面的演示属于常规的操作，但是针对mongodb的特点，自然会有一些疑问</p>
<p><strong>q1: 如果某个文档没有包含这个field，排序是怎样的？</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="https://hhui.top/imgs/200331/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>从输出来看，升序时，不包含这个field的文档，在最前面；降序时，不包含这个field的文档，在最后面</p>
<p><strong>q2: 支持多个field排序吗？</strong></p>
<p>原则上一般不建议多个field的排序（比较影响性能），但对于数据库而言，你得支持吧</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://hhui.top/imgs/200331/02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>请注意上的输出，在涉及到多个field排序时，优先根据第一个进行排序，当文档的field相同时，再根据后面的进行排序</p>
<h3> 2. 分页</h3>
<p>当文档很多时，我们不可能把所有的文档一次返回，所以就有了常见的分页，在sql中我们一般使用<code>limit</code> <code>offset</code>来实现分页，在mongodb中也差不多</p>
<p><strong>limit()</strong></p>
<p>限制返回的文档数</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="https://hhui.top/imgs/200331/03.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p><strong>skip()</strong></p>
<p>使用limit进行返回条数限制，使用skip进行分页，表示跳过前面的n条数据</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://hhui.top/imgs/200331/04.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 3. 聚合</h3>
<p>使用<code>aggregate()</code>来实现聚合，用于处理求和、平均值，最大值，分组等</p>
<p>数据准备:</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>分组查询</strong></p>
<p>根据name进行分组统计</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://hhui.top/imgs/200331/05.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>请注意，分组的条件中</p>
<ul>
<li><code>_id</code>: 表示根据哪个字段进行分组</li>
<li><code>size: {}</code>: 表示聚合条件指定，将结果输出到名为size的field中</li>
<li><code>filed</code>名前加<code>$</code>进行指定</li>
</ul>
<p>当前mongodb支持的聚合表达式包括:</p>
<table>
<thead>
<tr>
<th>表达式</th>
<th>说明</th>
<th>举例说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>sum</td>
<td>求和</td>
<td><code>db.doc_demo.aggregate([{$group: {_id: "$name", size: {$sum: '$age'}}}])</code></td>
</tr>
<tr>
<td>avg</td>
<td>平均值</td>
<td><code>db.doc_demo.aggregate([{$group: {_id: "$name", size: {$avg: '$age'}}}])</code></td>
</tr>
<tr>
<td>min</td>
<td>取最小</td>
<td><code>db.doc_demo.aggregate([{$group: {_id: "$name", age: {$min: '$age'}}}])</code></td>
</tr>
<tr>
<td>max</td>
<td>取最大</td>
<td><code>db.doc_demo.aggregate([{$group: {_id: "$name", age: {$max: '$age'}}}])</code></td>
</tr>
<tr>
<td>push</td>
<td>结果插入到一个数组中</td>
<td><code>db.doc_demo.aggregate([{$group: {_id: "$name", age: {$push: '$age'}}}])</code></td>
</tr>
<tr>
<td>addToSet</td>
<td>结果插入集合，过滤重复</td>
<td><code>db.doc_demo.aggregate([{$group: {_id: "$name", age: {$addToSet: '$age'}}}])</code></td>
</tr>
<tr>
<td>first</td>
<td>第一个</td>
<td><code>db.doc_demo.aggregate([{$group: {_id: "$name", age: {$first: '$age'}}}])</code></td>
</tr>
<tr>
<td>last</td>
<td>最后一个</td>
<td><code>db.doc_demo.aggregate([{$group: {_id: "$name", age: {$last: '$age'}}}])</code></td>
</tr>
</tbody>
</table>
<figure><img src="https://hhui.top/imgs/200331/06.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>上面虽然介绍了分组支持的一些表达式，但是没有查询条件，难道只能针对所有的文档进行分组统计么？</p>
<p><strong>分组过滤</strong></p>
<p>借助<code>$match</code>来实现过滤统计，如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://hhui.top/imgs/200331/07.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>请注意，$match的语法规则和find的查询条件一样，会将满足条件的数据传递给后面的分组计算</p>
<p>这种方式和liux中的管道特别相似，aggregate方法的参数数组中，前面的执行完毕之后，将结果传递给后面的继续执行，除了<code>$match</code>和<code>$group</code>之外，还有一些其他的操作</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>$project</td>
<td>修改输入文档的结构。可以用来重命名、增加或删除域，也可以用于创建计算结果以及嵌套文档。</td>
</tr>
<tr>
<td>$match</td>
<td>用于过滤数据，只输出符合条件的文档。$match使用MongoDB的标准查询操作。</td>
</tr>
<tr>
<td>$limit</td>
<td>用来限制MongoDB聚合管道返回的文档数。</td>
</tr>
<tr>
<td>$skip</td>
<td>在聚合管道中跳过指定数量的文档，并返回余下的文档。</td>
</tr>
<tr>
<td>$unwind</td>
<td>将文档中的某一个数组类型字段拆分成多条，每条包含数组中的一个值。</td>
</tr>
<tr>
<td>$group</td>
<td>将集合中的文档分组，可用于统计结果。</td>
</tr>
<tr>
<td>$sort</td>
<td>将输入文档排序后输出。</td>
</tr>
<tr>
<td>$geoNear</td>
<td>输出接近某一地理位置的有序文档。</td>
</tr>
</tbody>
</table>
<h2> 文档 Document 查询非典型篇</h2>
<p>前面介绍的查询可以说是常见的典型case，但是mongodb中有两个比价特殊的数据类型，数组 + 对象，自然的也会有一些非典型的查询case，下面主要针对这两种数据类型的查询姿势，给出实例讲解</p>
<!-- more -->
<h3> 1. 数组</h3>
<p>首先准备一些供数组操作的文档如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>长度查询</strong></p>
<p>根据数组长度进行查询，借助<code>$size</code>来统计数组长度</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>长度范围查询</strong></p>
<p>请注意，不支持长度的比较查询，如下，会报语法错误</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="https://hhui.top/imgs/200408/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>要实现范围查询，可以借助<code>$where</code>来实现(<code>$where</code>比较强大，后面单独说明)</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://hhui.top/imgs/200408/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p><strong>数组内容查询</strong></p>
<p>根据数组内容进行查询，常见的有两种方式，一个是直接根据数组定位比较如</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这种实用性可能并不大，另外一个常见的case就是查询数组中包含某个元素的文档，这时可以借助<code>$elemMatch</code>来实现</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://hhui.top/imgs/200408/02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>说明，当数组的元素是Object类型时，还可以用右边这种姿势：<code>db.doc_demo.find({'skill': {$elemMatch: {'subField': 'xxx'}}})</code></p>
<h3> 2. Object</h3>
<p>因为mongodb支持内嵌文档，所以根据内嵌文档进行查询的场景也是不少的</p>
<p>首先准备三个用于后续查询测试的文档</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>根据内嵌文档字段查询</strong></p>
<p>查询姿势和field查询相似，只是需要注意一下key的语法为: <code>field.subField</code>, 实例如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="https://hhui.top/imgs/200408/03.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p><strong>存在性查询</strong></p>
<p>查询嵌入文档包含某个field的case，和普通的查询姿势也一样</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>排序</strong></p>
<p>根据Object的成员进行排序，操作姿势也基本一样</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="https://hhui.top/imgs/200408/04.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> 文档更新删除之非典型篇</h2>
<p>前面介绍document的新增、删除、更新都处于相对常见和基础的说明，但是考虑到mongodb非结构化的特点，它的一些特性是我们的mysql不会遇到的，本文将针对这些特殊场景给出示例说明</p>
<ul>
<li>在现有文档中，增加一个field</li>
<li>删除文档中的某个field</li>
<li>重命名文档的field</li>
<li>在文档的数组orObject中，添加/删除/更新数据</li>
</ul>
<!-- more -->
<h3> 1. 增加field</h3>
<p>我们知道修改文档的命令格式如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当我们更新一个文档中，不存在的field，会怎样</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://hhui.top/imgs/200410/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 2. 重命名field</h3>
<p>同样是借助update方法，但是我们用到的关键字为 <code>$rename</code></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="https://hhui.top/imgs/200410/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p><strong>请注意，当文档中不存在这个field，则不会有任何影响</strong></p>
<h3> 3. 删除field</h3>
<p>既然<code>$set</code>可以新增一个不存在的field，那么是不是就可以用<code>$unset</code>来删除一个已存在的field呢</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="https://hhui.top/imgs/200410/02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 4. 数组元素修改</h3>
<blockquote>
<p>数组元素的修改删除增加，可以参考官方教程: <a href="https://www.mongodb.org.cn/manual/update-array/" target="_blank" rel="noopener noreferrer">MongoDB update-array Method</a></p>
</blockquote>
<p>如果我们希望直接修改数组中的某个元素，可以借助之前查询的case</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://hhui.top/imgs/200410/03.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p><strong>请注意，使用<code>$</code>占位符的前途是，前面的查询条件可以限定数组元素</strong></p>
<h3> 5. 数组元素新增</h3>
<p>元素添加支持两种方式，一是<code>addToSet</code>，一是<code>push</code></p>
<p><strong><code>$addToSet</code></strong></p>
<ul>
<li>确保没有重复的项添加到数组集合，对于已经存在的重复元素不受影响；</li>
<li>不能保证添加时元素的顺序</li>
<li>如果值是数组，则作为一个元素添加进去</li>
<li>可以通过 <code>$each</code> 实现添加多个元素到数组中</li>
</ul>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://hhui.top/imgs/200410/04.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p><strong><code>$push</code></strong></p>
<ul>
<li>如果被更新的文档该数组不存在，那么$push将添加数组字段和值</li>
<li>如果字段不是数组，失败</li>
<li>如果值是数组，那么整个数组作为一个单个元素添加到数组</li>
</ul>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://hhui.top/imgs/200410/05.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 6. 数组元素删除</h3>
<p><strong><code>$pop</code></strong> 删除第一个or最后一个</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://hhui.top/imgs/200410/06.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p><strong><code>$pull</code></strong> 删除满足条件的数组元素</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://hhui.top/imgs/200410/07.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>注意，<code>$pull</code>后面跟上的可以理解为限定条件，查询教程篇的一些操作也是支持的（如比较查询等）</p>
<h3> 7. 内嵌文档操作</h3>
<p>对于内嵌文档的操作，实际上普通的field的操作姿势没有什么区别，只是对于key加了一个<code>xx.xx</code>的限定而已</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://hhui.top/imgs/200410/08.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> 索引</h2>
<p>索引一般用来提高查询效率，避免全集合搜索，那么在mongodb中，支持索引么？如果支持，如何定义索引，如何使用索引，如何确定一个sql是否走索引？</p>
<!-- more -->
<h3> 1. 创建索引</h3>
<p><strong>语法定义:</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>请注意，在3.0之前的版本中，也可以使用<code>ensureIndex</code>来创建索引</p>
<p><strong>参数说明:</strong></p>
<ul>
<li>keys：kv结构，key为fieldName, value为1 表示升序创建索引；-1 表示降序创建索引；支持多字段索引</li>
<li>options：可选参数</li>
</ul>
<p>常见参数说明如下表:</p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>background</code></td>
<td>true，则后台方式创建索引，不阻塞其他操作；默认为false</td>
</tr>
<tr>
<td><code>unique</code></td>
<td>true，则表示唯一约束索引，比如<code>_id</code>就有唯一约束；默认为false</td>
</tr>
<tr>
<td><code>name</code></td>
<td>索引名，不指定时，根据field + 方向生成索引名</td>
</tr>
<tr>
<td><code>sparse</code></td>
<td>true, 则不包含这个字段的不创建索引，且索引查询时查不到不包含这个字段的文档；默认false</td>
</tr>
<tr>
<td><code>expireAfterSeconds</code></td>
<td>设置文档在集合的生存时间，s为单位</td>
</tr>
<tr>
<td><code>v</code></td>
<td>版本号</td>
</tr>
<tr>
<td><code>weight</code></td>
<td>索引权重值，数值在 1 到 99,999 之间，表示该索引相对于其他索引字段的得分权重</td>
</tr>
<tr>
<td><code>default_language</code></td>
<td>对于文本索引，该参数决定了停用词及词干和词器的规则的列表。 默认为英语</td>
</tr>
<tr>
<td><code>language_override</code></td>
<td>对于文本索引，该参数指定了包含在文档中的字段名，语言覆盖默认的language，默认值为 language</td>
</tr>
</tbody>
</table>
<p>实例如下：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 2. 索引查询</h3>
<p>查看一个集合定义了哪些索引，借助<code>getIndexes()</code>方法即可，如</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="https://hhui.top/imgs/200418/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 3. 索引分析</h3>
<p>虽然我们创建了索引，但是我们的查询语句却并不一定会走索引，在mysql中我们知道有一个<code>explain</code>语句来分析索引情况，在mongodb中也存在类似的方法</p>
<p>集合数据如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当前集合上除了默认的<code>_id</code>索引之外，针对<code>name</code>也创建了升序索引</p>
<p>如需要判断一个查询语句的情况，可以在后面加上<code>explain()</code>方法，如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>输出如下</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>关于是否走索引，主要看stage，通常会有以下几种状态</p>
<table>
<thead>
<tr>
<th>stage</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>COLLSCAN</td>
<td>全表扫描</td>
</tr>
<tr>
<td>IXSCAN</td>
<td>扫描索引</td>
</tr>
<tr>
<td>FETCH</td>
<td>根据索引去检索指定document</td>
</tr>
<tr>
<td>SHARD_MERGE</td>
<td>将各个分片返回数据进行merge</td>
</tr>
<tr>
<td>SORT</td>
<td>表明在内存中进行了排序</td>
</tr>
<tr>
<td>LIMIT</td>
<td>使用limit限制返回数</td>
</tr>
<tr>
<td>SKIP</td>
<td>使用skip进行跳过</td>
</tr>
<tr>
<td>IDHACK</td>
<td>针对_id进行查询</td>
</tr>
<tr>
<td>SHARDING_FILTER</td>
<td>通过mongos对分片数据进行查询</td>
</tr>
<tr>
<td>COUNT</td>
<td>利用db.coll.explain().count()之类进行count运算</td>
</tr>
<tr>
<td>COUNTSCAN</td>
<td>count不使用Index进行count时的stage返回</td>
</tr>
<tr>
<td>COUNT_SCAN</td>
<td>count使用了Index进行count时的stage返回</td>
</tr>
<tr>
<td>SUBPLA</td>
<td>未使用到索引的$or查询的stage返回</td>
</tr>
<tr>
<td>TEXT</td>
<td>使用全文索引进行查询时候的stage返回</td>
</tr>
<tr>
<td>PROJECTION</td>
<td>限定返回字段时候stage的返回</td>
</tr>
</tbody>
</table>
<p>上面的具体查询，对应的stage组合是<code>Fetch+ixscan</code>，也就是说会根据索引查询</p>
<p>虽然mongodb会根据查询来选择索引，但并不能保证都能选到最优的索引；这种时候我们可以通过<code>hint</code>来强制指定索引，举例如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 4. 删除索引</h3>
<p>一般有下面两种删除方式，全量删除和指定索引删除</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>请注意，指定索引名删除时，如果不确定索引名是啥，可以通过<code>getIndexes()</code>来查看</p>
<h3> 5. 文档自动删除</h3>
<p>在创建索引的时候，其中有一个参数比较有意思，有必要单独拿出来说明一下，<code>expireAfterSeconds</code> 设置文档的生存时间</p>
<p>使用它有几个潜规则：</p>
<ul>
<li>索引字段为Date类型</li>
<li>单字段索引，不支持混合索引</li>
<li>非立即执行</li>
</ul>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后过一段时间（并不一定10:55分的时候会删除）再去查询，会发现插入的文档被删除了</p>
<p>利用这种特性，在mongodb中存一些需要定时删除的数据，相比较我们常用的mysql而言，还是有很大优势的</p>
<h3> 6. 覆盖索引</h3>
<p>覆盖索引的概念有些类似mysql中的不回表查询的case，直接查询索引，就可以返回所需要的字段了</p>
<p>比如在前面的case中，我只查询name字段，可以走覆盖索引；但是返回除了name，还有<code>_id</code>，那么就不能了</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>注意：所有索引字段是一个数组时，不能使用覆盖索引</strong></p>
<hr>
<p>微信搜 <strong>楼仔</strong> 或扫描下方二维码关注楼仔的原创公众号，回复 <strong>110</strong> 即可免费领取 10 本面试必刷八股文。 <img src="https://files.mdnice.com/user/13837/4b47ac79-8256-47cf-ac1a-036729635246.png" alt="" loading="lazy"></p>
<hr>
<h1> 第二卷：Spring整合MongoDB</h1>
<p>文档数据库SpringBoot的系列教程，彻底扫平阻碍我们CURD的路障，适用于对Mongodb不了解或了解不够的小伙伴</p>
<h2> 基本环境搭建与使用</h2>
<p>SpringBoot结合mongodb进行业务开发，也属于比较基本的需求了，本文为mongo系列的基本篇，主要就是环境搭建、工程的配置设置相关</p>
<!-- more -->
<h3> 1. 环境搭建</h3>
<p>正式开始之前，第一步就是需要安装Mongo的环境了，因为环境的安装和我们spring的主题没有太大的关系，因此我们选择最简单的使用姿势：直接用docker来安装mongo来使用</p>
<p>下面的安装过程都是mac环境，其他操作系统可以直接安装mongodb，移步相关教程</p>
<h4> 1.1 docker 安装</h4>
<p>可以直接到官网进行下载安装，但是对系统版本有要求，所以需要使用<code>Docker ToolBox</code>，实际试过之后，感觉不太好用，实际上是将docker安装到虚拟机中了，下面直接使用<code>brew</code>命令进行安装</p>
<p><strong>安装命令</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>执行完毕之后，会多一个应用名为 <code>docker</code>， 双击运行，输入密码等即可</p>
<h4> 1.2 mongo 安装使用</h4>
<p>直接使用官方的mongo镜像即可，然后绑定端口映射，就可以在宿主机中使用mongo</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面完毕之后，可以在宿主机进行连接测试，判断是否安装成功</p>
<h3> 2. SpringBoot工程配置</h3>
<h4> 2.1 pom依赖</h4>
<p>整个框架选择的是spring-boot，所有spring这一套相关的pom配置少不了，我们主要需要注意的包就是<code>spring-boot-starter-data-mongodb</code></p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 2.2 配置文件</h4>
<p>配置文件如下，主要就是连接mongo的url</p>
<div class="language-properties line-numbers-mode" data-ext="properties"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>通过上面的实例，也知道格式如下:</p>
<p><code>mongodb://用户名:密码@host:port/dbNmae?参数</code></p>
<ul>
<li>当没有用户名和密码时，可以省略掉中间的 <code>root:root@</code>；</li>
<li>当需要认证时，请格外注意
<ul>
<li>mongodb新版的验证方式改成了<code>SCRAM-SHA-1</code>，所以参数中一定一定一定得加上
<ul>
<li><code>?authSource=admin&amp;authMechanism=SCRAM-SHA-1</code></li>
</ul>
</li>
<li>如果将mongodb的验证方式改成了<code>MONGODB-CR</code>, 则上面的可以不需要</li>
</ul>
</li>
</ul>
<h4> 2.3 测试使用</h4>
<p>写一个简单的测试类，看下mongodb是否连接成功，是否可以正常操作</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面提供了两个方法，新增和查询，简单的使用姿势如</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后开始执行，查看输出，结果演示如下</p>
<figure><img src="https://hhui.top/imgs/181213/00.gif" alt="gif.gif" tabindex="0" loading="lazy"><figcaption>gif.gif</figcaption></figure>
<h4> 2.4 说明</h4>
<p>最后针对认证的问题，需要额外提一句，开始测试的时候，使用的配置如下</p>
<div class="language-properties line-numbers-mode" data-ext="properties"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然而因为mongo采用的是SHA-1加密方式，所以始终验证不通过；然后查了一下，各种让改mongo的验证版本，改回去用CR的方式；但明显这种并不是一种好的解决方式，既然新的版本选择了新的加密方式，总有他的理由，所以应该改的还是spring的使用姿势；目前还没找到匹配上面这种配置方式的解决方案；</p>
<p>本文选择的是用url的方式指定加密方式来解决这个问题，当然研究下后面这种方式内部实现，应该就能知道前面的可以怎么解决，这点记下来，后续再开坑填</p>
<h3> 3. 其他</h3>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">spring-boot-demo</a></li>
<li>module: <a href="https://github.com/liuyueyi/spring-boot-demo/blob/master/spring-boot/110-mongo-basic/README.md" target="_blank" rel="noopener noreferrer">110-mongo-basic</a></li>
</ul>
<hr>
<p>微信搜 <strong>楼仔</strong> 或扫描下方二维码关注楼仔的原创公众号，回复 <strong>110</strong> 即可免费领取 10 本面试必刷八股文。 <img src="https://files.mdnice.com/user/13837/4b47ac79-8256-47cf-ac1a-036729635246.png" alt="" loading="lazy"></p>
<hr>
<h2> 查询基本使用姿势</h2>
<p>学习一个新的数据库，一般怎么下手呢？基本的CURD没跑了，当可以熟练的增、删、改、查一个数据库时，可以说对这个数据库算是入门了，如果需要更进一步的话，就需要了解下数据库的特性，比如索引、事物、锁、分布式支持等</p>
<p>本篇博文为mongodb的入门篇，将介绍一下基本的查询操作，在Spring中可以怎么玩</p>
<!-- more -->
<h3> 1. 基本使用</h3>
<h4> 1.0. 环境准备</h4>
<p>在正式开始之前，先准备好环境，搭建好工程，对于这一步的详细信息，可以参考博文: <a href="http://spring.hhui.top/spring-blog/2018/12/13/181213-SpringBoot%E9%AB%98%E7%BA%A7%E7%AF%87MongoDB%E4%B9%8B%E5%9F%BA%E6%9C%AC%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8/" target="_blank" rel="noopener noreferrer">181213-SpringBoot高级篇MongoDB之基本环境搭建与使用</a></p>
<p>接下来，在一个集合中，准备一下数据如下，我们的基本查询范围就是这些数据</p>
<figure><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy9kWVY5Y0FXNjVrYTJnZHpOWjZKaWFpYmljOHhaNGliRHJVS1V1N3oxc1FoaWFKeHBieTRwMk1uSmtpY2ljVDIyOVVpYXNMZWlid3FmaWJTZHlKTnprWVdhUE1iTmtvQkEvNjQwP3d4X2ZtdD1qcGVn?x-oss-process=image/format,png" alt="data" tabindex="0" loading="lazy"><figcaption>data</figcaption></figure>
<h4> 1.1. 根据字段进行查询</h4>
<p>最常见的查询场景，比如我们根据查询<code>user=一灰灰blog</code>的数据，这里主要会使用<code>Query</code> + <code>Criteria</code> 来完成</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面是一个实际的case，从中可以知道一般的查询方式为:</p>
<ul>
<li><code>Criteria.where(xxx).is(xxx)</code>来指定具体的查询条件</li>
<li>封装Query对象 <code>new Query(criteria)</code></li>
<li>借助<code>mongoTemplate</code>执行查询 <code>mongoTemplate.findOne(query, resultType, collectionName)</code></li>
</ul>
<p>其中findOne表示只获取一条满足条件的数据；find则会将所有满足条件的返回；上面执行之后，输出结果如</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h4> 1.2. and多条件查询</h4>
<p>前面是只有一个条件满足，现在如果是要求同时满足多个条件，则利用<code>org.springframework.data.mongodb.core.query.Criteria#and</code>来斜街多个查询条件</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4> 1.3. or或查询</h4>
<p>and对应的就是or，多个条件中只要一个满足即可，这个与and的使用有些区别, 借助<code>org.springframework.data.mongodb.core.query.Criteria#orOperator</code>来实现，传参为多个<code>Criteria</code>对象，其中每一个表示一种查询条件</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>执行后输出结果为</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h4> 1.4. in查询</h4>
<p>标准的in查询case</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4> 1.5. 数值比较</h4>
<p>数值的比较大小，主要使用的是 <code>get</code>, <code>gt</code>, <code>lt</code>, <code>let</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 1.6. 正则查询</h4>
<p>牛逼高大上的功能</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4> 1.7. 查询总数</h4>
<p>统计常用，这个主要利用的是<code>mongoTemplate.count</code>方法</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4> 1.8. 分组查询</h4>
<p>这个对应的是mysql中的group查询，但是在mongodb中，更多的是通过聚合查询，可以完成很多类似的操作，下面借助聚合，来看一下分组计算总数怎么玩</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意下，这里用<code>Aggregation</code>而不是前面的<code>Query</code>和<code>Criteria</code>，输出如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4> 1.9. 排序</h4>
<p>sort，比较常见的了，在mongodb中有个有意思的地方在于某个字段，document中并不一定存在，这是会怎样呢？</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果如下，对于没有这个字段的document也被查出来了</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4> 1.10. 分页</h4>
<p>数据量多的时候，分页查询比较常见，用得多就是limit和skip了</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果表明，limit用来限制查询多少条数据，skip则表示跳过前面多少条数据</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h4> 1.11. 小结</h4>
<p>上面给出的一些常见的查询姿势，当然并不全面，比如我们如果需要查询document中的部分字段怎么办？比如document内部结果比较复杂，有内嵌的对象或者数组时，嵌套查询可以怎么玩？索引什么的又可以怎么利用起来，从而优化查询效率？如何通过传说中自动生成的<code>_id</code>来获取文档创建的时间戳？</p>
<p>先留着这些疑问，后面再补上</p>
<h3> 2. 其他</h3>
<h3> 2.0. 项目</h3>
<ul>
<li>
<p>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">spring-boot-demo</a></p>
</li>
<li>
<p>module: <a href="https://github.com/liuyueyi/spring-boot-demo/blob/master/spring-boot/111-mongo-template" target="_blank" rel="noopener noreferrer">mongo-template</a></p>
</li>
<li>
<p>相关博文: <a href="http://spring.hhui.top/spring-blog/2018/12/13/181213-SpringBoot%E9%AB%98%E7%BA%A7%E7%AF%87MongoDB%E4%B9%8B%E5%9F%BA%E6%9C%AC%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8/" target="_blank" rel="noopener noreferrer">181213-SpringBoot高级篇MongoDB之基本环境搭建与使用</a></p>
</li>
</ul>
<h2> 新增文档使用姿势</h2>
<p>本篇博文为mongodb的curd中一篇，前面介绍简单的查询使用，这一篇重点则放在插入数据;</p>
<!-- more -->
<h3> 1. 基本使用</h3>
<p>首先是准备好基本环境，可以参考博文</p>
<ul>
<li><a href="http://spring.hhui.top/spring-blog/2018/12/13/181213-SpringBoot%E9%AB%98%E7%BA%A7%E7%AF%87MongoDB%E4%B9%8B%E5%9F%BA%E6%9C%AC%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8/" target="_blank" rel="noopener noreferrer">181213-SpringBoot高级篇MongoDB之基本环境搭建与使用</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2019/01/13/190113-SpringBoot%E9%AB%98%E7%BA%A7%E7%AF%87MongoDB%E4%B9%8B%E6%9F%A5%E8%AF%A2%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF/" target="_blank" rel="noopener noreferrer">190113-SpringBoot高级篇MongoDB之查询基本使用姿势</a></li>
</ul>
<h4> 1.1. 新增一条数据</h4>
<p>MongoDB一个基本数据称为document，和mysql不一样，没有强制约束哪些字段，可以随意的插入，下面是一个简单的插入演示</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用的关键地方为一行: <code>mongoTemplate.insert(object, COLLECTION_NAME);</code></p>
<ul>
<li>第一个参数为待插入的document</li>
<li>第二个参数为collection name （相当于mysql的table)</li>
</ul>
<p>执行后输出结果为如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4> 1.2. 批量插入</h4>
<p>一次插入多条记录，传集合进去即可</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>返回结果如下:</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4> 1.3. upsert，不存在才插入</h4>
<p>我们希望在插入之前，判断数据是否存在，如果不存在则插入；如果存在则更新；此时就可以采用upsert来使用，一般三个参数</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>第一个为查询条件，第二个为需要更新的字段，最后一个指定对应的collection，一个简单的实例如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果如下:</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 1.4. upsert，存在则更新</h4>
<p>前面的demo是演示不存在，那么存在数据呢?</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果如下，注意下面的输出数据的 <code>_id</code>，正视前面插入的那条数据，两个数据唯一的不同，就是age被修改了</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h4> 1.5. upsert，多条满足时</h4>
<p>如果query条件命中多条数据，怎么办？会修改几条数据呢？</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>根据实际输出进行查看，发现只有一条数据被修改；另外一条保持不变，结果如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 其他</h3>
<h4> 2.0. 项目</h4>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">spring-boot-demo</a></li>
<li>module: <a href="https://github.com/liuyueyi/spring-boot-demo/blob/master/spring-boot/111-mongo-template" target="_blank" rel="noopener noreferrer">mongo-template</a></li>
</ul>
<p><strong>相关博文</strong></p>
<ul>
<li><a href="http://spring.hhui.top/spring-blog/2018/12/13/181213-SpringBoot%E9%AB%98%E7%BA%A7%E7%AF%87MongoDB%E4%B9%8B%E5%9F%BA%E6%9C%AC%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8/" target="_blank" rel="noopener noreferrer">181213-SpringBoot高级篇MongoDB之基本环境搭建与使用</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2019/01/13/190113-SpringBoot%E9%AB%98%E7%BA%A7%E7%AF%87MongoDB%E4%B9%8B%E6%9F%A5%E8%AF%A2%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF/" target="_blank" rel="noopener noreferrer">190113-SpringBoot高级篇MongoDB之查询基本使用姿势</a></li>
</ul>
<hr>
<p>微信搜 <strong>楼仔</strong> 或扫描下方二维码关注楼仔的原创公众号，回复 <strong>110</strong> 即可免费领取 10 本面试必刷八股文。 <img src="https://files.mdnice.com/user/13837/4b47ac79-8256-47cf-ac1a-036729635246.png" alt="" loading="lazy"></p>
<hr>
<h2> 修改基本使用姿势</h2>
<p>本篇依然是MongoDB curd中的一篇，主要介绍document的更新，主要内容如下</p>
<ul>
<li>常见类型成员的修改</li>
<li>数组类型成员的增删改</li>
<li>document类型成员的增删改</li>
</ul>
<!-- more -->
<h3> 1. 基本使用</h3>
<p>首先是准备好基本环境，可以参考博文</p>
<ul>
<li><a href="http://spring.hhui.top/spring-blog/2018/12/13/181213-SpringBoot%E9%AB%98%E7%BA%A7%E7%AF%87MongoDB%E4%B9%8B%E5%9F%BA%E6%9C%AC%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8/" target="_blank" rel="noopener noreferrer">181213-SpringBoot高级篇MongoDB之基本环境搭建与使用</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2019/01/13/190113-SpringBoot%E9%AB%98%E7%BA%A7%E7%AF%87MongoDB%E4%B9%8B%E6%9F%A5%E8%AF%A2%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF/" target="_blank" rel="noopener noreferrer">190113-SpringBoot高级篇MongoDB之查询基本使用姿势</a></li>
</ul>
<p>在开始之前，先封装一个输出方法，用于打印修改后的record对象</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 1.1. 基本类型修改</h4>
<p>mongodb支持我们常见的各种基本类型，而MongoTemplate也封装了不少对应的修改方法，最基础的修改，主要是借助<code>Update</code>来实现</p>
<p>常见的使用姿势如:</p>
<h5> a. 基本使用姿势</h5>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果为：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5> b. 数字增加/减少</h5>
<p>数字类型修改，使用 <code>org.springframework.data.mongodb.core.query.Update#inc</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果为:</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5> c. 数字比较修改</h5>
<p>数字简单比较之后修改，如<code>org.springframework.data.mongodb.core.query.Update#max</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5> d. 乘法</h5>
<p>乘法运算, 主要使用 <code>org.springframework.data.mongodb.core.query.Update#multiply</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5> e. 日期修改</h5>
<p>日期修改, 如 <code>org.springframework.data.mongodb.core.query.Update#currentDate</code></p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 1.2. field修改</h4>
<p>不同于mysql的列表是固定的,mongodb的field可以增加、删除和重命名，下面分别看下三种case如何使用</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5> a. 重命名</h5>
<p>利用<code>org.springframework.data.mongodb.core.query.Update#rename</code>来实现重命名，需要注意的是，当修改的docuemnt没有这个成员时，相当于没有任务操作</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果如下，后面一个语句相当于没有执行</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5> b. 新增成员</h5>
<p>新增也是直接利用的<code>Update#set</code>方法，当存在时，修改；不存在时，添加</p>
<ul>
<li>另外提一下<code>setOnInsert</code>, 如果要更新的文档存在那么$setOnInsert操作符不做任何处理；</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果如下：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5> c. 删除成员</h5>
<p>删除document中的某个成员，借助<code>org.springframework.data.mongodb.core.query.Update#unset</code>， 正好与添加对上</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 1.3. 数组操作</h4>
<p>在MongoDB的document中，有两个有意思的类型，一个是数组，一个是document（即可以嵌套），这里则主要介绍下如何操作数组中的成员</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5> a. 添加到数组中</h5>
<p>在数组中新增一个数据，提供了两种方式，一个是<code>org.springframework.data.mongodb.core.query.Update#addToSet(java.lang.String, java.lang.Object)</code>，一个是<code>org.springframework.data.mongodb.core.query.Update#push(java.lang.String, java.lang.Object)</code>；两个的区别在于前者不能插入重复数据，后者可以</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5> b. 批量添加</h5>
<p>一次添加多个，借助<code>addToSet</code>的<code>each</code>来实现</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果:</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5> c. 删除</h5>
<p>借助pull来精确删除某个值</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出如下，注意对比，<code>2</code>没有了</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5> d. 修改</h5>
<p>修改，首先的问题是要定位，确定删除数组中某个下标的元素，这里借助了一个有意思的站位</p>
<ul>
<li>定位删除的数组元素方法： <code>arrayKey.index</code>
<ul>
<li><code>arrayKey</code> 是数组在docment中的名</li>
<li><code>index</code> 表示要删除的索引</li>
</ul>
</li>
</ul>
<p>一个实例如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果，注意后面的，如果数组个数小于待更新的索引位置，则前面补null</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 1.4. document操作</h4>
<p>内嵌文档，可以所是MongoDB的一个特色了，我们则来看下如何进行操作</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5> a. 添加</h5>
<p>借助前面的站位思想，就很好实现了，定位元素的方式采用</p>
<ul>
<li>docName.fieldName
<ul>
<li>docName 为内嵌文档在docunent中的fieldName</li>
<li>fieldName 为内嵌文档内部需要修改的fieldName</li>
</ul>
</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5> c. 修改</h5>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5> d. 删除</h5>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 其他</h3>
<h4> 2.0. 项目</h4>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">spring-boot-demo</a></li>
<li>子module：<a href="https://github.com/liuyueyi/spring-boot-demo/blob/master/spring-boot/111-mongo-template/README.md" target="_blank" rel="noopener noreferrer">111-mongo-template</a></li>
</ul>
<hr>
<p>微信搜 <strong>楼仔</strong> 或扫描下方二维码关注楼仔的原创公众号，回复 <strong>110</strong> 即可免费领取 10 本面试必刷八股文。 <img src="https://files.mdnice.com/user/13837/4b47ac79-8256-47cf-ac1a-036729635246.png" alt="" loading="lazy"></p>
<hr>
]]></content:encoded>
      <enclosure url="http://cdn.hhui.top/column/mongo_cover.png" type="image/png"/>
    </item>
    <item>
      <title>MySql系列教程</title>
      <link>https://liuyueyi.github.io/tutorial/db/mysql/</link>
      <guid>https://liuyueyi.github.io/tutorial/db/mysql/</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">MySql系列教程</source>
      <description>关系数据库MySql系列教程</description>
      <pubDate>Fri, 24 Feb 2023 02:18:35 GMT</pubDate>
      <content:encoded><![CDATA[<p>关系数据库MySql系列教程</p>
]]></content:encoded>
    </item>
    <item>
      <title>redis系列教程</title>
      <link>https://liuyueyi.github.io/tutorial/db/redis/</link>
      <guid>https://liuyueyi.github.io/tutorial/db/redis/</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">redis系列教程</source>
      <description>KV数据库Redis系列教程</description>
      <pubDate>Fri, 24 Feb 2023 02:18:35 GMT</pubDate>
      <content:encoded><![CDATA[<p>KV数据库Redis系列教程</p>
]]></content:encoded>
    </item>
    <item>
      <title>Java实战系列</title>
      <link>https://liuyueyi.github.io/tutorial/java/skill/Java%E5%AE%9E%E6%88%9836%E8%AE%B2.html</link>
      <guid>https://liuyueyi.github.io/tutorial/java/skill/Java%E5%AE%9E%E6%88%9836%E8%AE%B2.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">Java实战系列</source>
      <description>Java实战演练 实战小技巧，可用于实际编码过程中的 code snippets 带你再日常得编码中写得更加顺畅 本专栏中所有内容来自于笔者（一灰灰blog）的日常收集与分享，其中每一个主题都是针对真实的应用场景，通过提供切实可用与项目中的代码片段或者工具类，来给给位小伙伴提供帮助 实战1：字符串占位替换 字符串占位替换，相信没有小伙伴是陌生的，这东西可以说是伴随着我们所有的项目工程，编码过程；别不相信，如 String.format sql参数拼接的占位 log日志输出 接下来我们看一下在我们的日常工作生涯中，经常涉及到的几种占位替换方式</description>
      <pubDate>Fri, 24 Feb 2023 02:18:35 GMT</pubDate>
      <content:encoded><![CDATA[<figure><img src="http://cdn.hhui.top/column/java_cover.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h1> Java实战演练</h1>
<blockquote>
<p>实战小技巧，可用于实际编码过程中的 <code>code snippets</code> 带你再日常得编码中写得更加顺畅</p>
</blockquote>
<p>本专栏中所有内容来自于笔者（一灰灰blog）的日常收集与分享，其中每一个主题都是针对真实的应用场景，通过提供切实可用与项目中的代码片段或者工具类，来给给位小伙伴提供帮助</p>
<hr>
<h1> 实战1：字符串占位替换</h1>
<p>字符串占位替换，相信没有小伙伴是陌生的，这东西可以说是伴随着我们所有的项目工程，编码过程；别不相信，如</p>
<ul>
<li>String.format</li>
<li>sql参数拼接的占位</li>
<li>log日志输出</li>
</ul>
<p>接下来我们看一下在我们的日常工作生涯中，经常涉及到的几种占位替换方式</p>
<!-- more -->
<h2> 1. String.format</h2>
<p>这种可以说是最原始最基础的方式了，基本上在最开始学习java这门语言的时候就会涉及到，语法也比较简单</p>
<p>举例如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>使用<code>%</code>来表示占位，后面跟上不同的标识符，用于限定这个占位处的参数类型</p>
<p>这种使用姿势，由jdk原生提供支持，下表为不同的转换符对应的说明</p>
<table>
<thead>
<tr>
<th>转换符</th>
<th>说明</th>
<th>参数实例</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>%s</code></td>
<td>字符串替换</td>
<td>"一灰灰"</td>
</tr>
<tr>
<td><code>%c</code></td>
<td>字符类型</td>
<td>'a'</td>
</tr>
<tr>
<td><code>%b</code></td>
<td>布尔类型</td>
<td>true/false</td>
</tr>
<tr>
<td><code>%d</code></td>
<td>整数，十进制</td>
<td>10</td>
</tr>
<tr>
<td><code>%x</code></td>
<td>整数，十六进制</td>
<td>0x12</td>
</tr>
<tr>
<td><code>%o</code></td>
<td>整数，八进制</td>
<td>012</td>
</tr>
<tr>
<td><code>%f</code></td>
<td>浮点</td>
<td>0.12f</td>
</tr>
<tr>
<td><code>%e</code></td>
<td>指数</td>
<td>2e2</td>
</tr>
<tr>
<td><code>%g</code></td>
<td>通用浮点型</td>
<td></td>
</tr>
<tr>
<td><code>%h</code></td>
<td>散列</td>
<td></td>
</tr>
<tr>
<td><code>%%</code></td>
<td>百分比</td>
<td></td>
</tr>
<tr>
<td><code>%n</code></td>
<td>换行</td>
<td></td>
</tr>
<tr>
<td><code>%tx</code></td>
<td>日期与时间类型（x代表不同的日期与时间转换符</td>
<td></td>
</tr>
</tbody>
</table>
<p>虽然上面表中列出了很多，但实际使用时，<code>%s</code>, <code>%d</code>, <code>%f</code> 这三个就足以应付绝大部分的场景了；使用姿势和上面的实例参不多，第一个参数为字符串模板，后面的可变参数为待替换的值</p>
<p>下面是在实际使用过程中的注意事项</p>
<h3> 1.1 类型不匹配</h3>
<p>上面的表中介绍了不同的转换符，要求的参数类型，如果没有对应上，会怎样</p>
<p><strong><code>%s</code>，传入非字符串类型</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>也就是说，<code>%s</code>的占位标记，传参如果不是String类型，那么实际替换的是 <code>arg.toString()</code> (所以数组输出的是地址，而list输出了内容)</p>
<p><strong><code>%d</code>，传入非整数</strong></p>
<p>与字符串的不一样的是，如果我们定义要求替换的参数类型为整数，那么传参不是整数，就会抛异常</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这两个，一个传入的参数为浮点，一个传入的是字符串，在实际替换的时候，可不会调用<code>Integer.valufOf(String.valueOf(xxx))</code>来强转，而是采用更直接的方式，抛异常</p>
<p>关键的提示信息如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>因此在实际使用这种方式进行替换时，推荐选择 <code>%s</code>，毕竟兼容性更好</p>
<h3> 1.2 参数个数不匹配</h3>
<p>我们会注意到,<code>String.format</code>接收的参数是不定长的，那么就可能存在字符串模板中预留的占位与实际传入的参数个数不匹配的场景，那么出现这种场景时，会怎样</p>
<p><strong>参数缺少</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面的例子中，模板要求两个，实际只传入一个参数，会直接抛异常<code>MissingFormatArgumentException</code></p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>参数过多</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>执行正常，多余的参数不会被替换</p>
<p>因此，我们在使用<code>String.format</code>进行字符串替换时，请确保传参不要少于实际定义的参数个数；多了还好，少了就会抛异常</p>
<h2> 2. MessageFormat</h2>
<p>上面介绍的String.format虽说简单好用，但我们用多之后，自然会遇到，一个参数，需要替换模板中多个占位的场景，针对这种场景，更友好的方式是<code>MessageFormat</code>，这个也是jdk原生提供的</p>
<p>我们来简单看一下它的使用姿势</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>使用<code>{数字}</code>来表示占位，其中数字对应的是传参的下标，因此当一个参数需要复用时，使用MessageFormat就可以比较简单的实现了，上面就是一个实例，替换之后的字符串为</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>接下来说一下它使用时的注意事项</p>
<h3> 2.1 {}成对出现</h3>
<p>如果字符串中，只出现一个<code>{</code>，而没有配套的<code>}</code>，会抛异常</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>注意上面两种case，上面一个是有<code>}</code>而缺少<code>{</code>，这样是没有问题的；而下面那个则会抛异常</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>如果字符串中却是希望输出<code>{</code>，可以使用单引号来处理</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 2.2 单引号</h3>
<p>上面提到需要转移时，可以用单引号进行处理，在字符串模板的定义中，如果有单引号，需要各位注意</p>
<p><strong>只有一个单引号，会导致后面所有占位都不生效</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面这个输出结果可能和我们实际希望的不一致</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>要解决上面这个，就是使用两个单引号</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这样输出的就是我们预期的</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 2.3 序号省略</h3>
<p>上面的定义中，已经明确要求我们在<code>{}</code>中指定参数的序号，如果模板中没有指定会怎样?</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>直接抛异常</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2> 3. 小结</h2>
<p>本文介绍的实战小技巧属于是jdk原生提供的两种实现字符串占位替换的方式，除了这两个之外，我们日常开发中还会遇到其他的占位替换方式</p>
<p>比如sql的<code>?</code>替换，mybatis中sql参数组装使用<code>${paramName}</code>，或者logback日志输出中的<code>{}</code>来表示占位，spring的@Value注解声明的配置注入方式<code>${name:defaultValue}</code>，这些也都属于占位替换的范畴，那么它们又是怎么实现的呢？</p>
<p>微信搜 <strong>楼仔</strong> 或扫描下方二维码关注楼仔的原创公众号，回复 <strong>110</strong> 即可免费领取 10 本面试必刷八股文。
<img src="https://files.mdnice.com/user/13837/4b47ac79-8256-47cf-ac1a-036729635246.png" alt="" loading="lazy"></p>
<hr>
<h1> 实战2：数组与list互转</h1>
<p>这个考题比较常见，也比较简单，难道就这也有什么可以说到的门路不成？</p>
<p>接下来本文好好的说一说它的几种实现姿势，总有一款你喜欢的</p>
<h2> 1.数组转List</h2>
<h3> 1.1. Array.asList</h3>
<p>这个考题太简单了，直接使用<code>Array.asList</code>不就完事了么，比如</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>数组转list，so easy!!!</p>
<p>真的就这么简单么？？？</p>
<p>且看下面这一段代码</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>直接抛出了异常<code>java.lang.UnsupportedOperationException</code></p>
<p>有兴趣的小伙伴可以看一下源码实现方式，通过<code>Arrays.asList</code>创建的List，虽说也命名是<code>ArrayList</code>，但是它的全路径为 <code>java.util.Arrays.ArrayList</code>， 不支持<code>add</code>, <code>remove</code>等操作（所以下次再有面试官问ArrayList的知识点时，就可以反问一句，老哥你指的是哪个ArrayList😝，逼格是不是立马拉起来）</p>
<p><strong>知识点</strong></p>
<ul>
<li>通过<code>Arrays.asList</code>创建的列表，不允许新增，删除元素；但是可以更新列表中元素的值</li>
</ul>
<h3> 1.2. new ArrayList</h3>
<p>上面的数组转list方式虽然是最简单的，但不一定是合适的，特别是当我们可能对转换后的list进行操作时，可能埋坑（而且这种坑还非常隐晦，代码层面上很难发现）</p>
<p>为了减少在代码里面下毒的可能性，不妨使用下面这种方式<code>new ArrayList&lt;&gt;(Arrays.asList(ary))</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过上面这种方式创建的List，就是我们熟知的<code>ArrayList</code>了</p>
<p><strong>避雷预警</strong></p>
<p>看到上面这个使用姿势，就很容易想到一个常见的踩雷点，比如我们的应用中，有一个全局共享的配置列表，张三需要拿id为奇数的配置，李四拿id为偶数的配置，然后他们都是这么做的</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>然后跑了一次之后发现这个全局的列表清空了，这就是典型的没有做好资源隔离的case了，针对这种场景，要么是限制使用方，直接针对全局的资源进行修改，要么就是使用方拿到的是一个隔离的备份</p>
<p><strong>禁止修改：</strong></p>
<ul>
<li>使用不可变的容器，如前面提到的<code>java.util.Arrays.ArrayList</code> ()</li>
<li>使用<code>Collections.unmodifiableList</code>创建</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>列表拷贝</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>（上面这种属于深拷贝的实现，具体可以看一下jdk的源码实现）</p>
<h3> 1.3. Collections.addAll</h3>
<p>第三种方式借助jdk提供的容器工具类<code>Collections</code>来实现</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>原则上是比较推荐这种方式来实现的，至于为啥？看下源码实现</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码的实现是不是非常眼熟，如果让我们自己来写，也差不多会写成这样吧，简单直观高效，完美</p>
<h2> 2. 列表转数组</h2>
<p>不同于数组转列表的几种玩法，列表转数组就简单多了，直接调用<code>List.toArray</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 3. 小结</h2>
<p>今天的博文主题是数组与列表的互转，虽说题目简单，但是实现方式也是多种，需要搞清楚它们之间的本质区别，一不小心就可能采坑，而最简单的地方掉坑里，往往是最难发现和爬出来的</p>
<p>核心知识点小结如下</p>
<p><strong>数组转list：</strong></p>
<ul>
<li><code>Arrays.asList(xxx)</code>：创建的是不可变列表，不能删除和新增元素</li>
<li><code>new ArrayList&lt;&gt;(Arrays.asList(xxx)</code>: 相当于用列表创建列表，属于深拷贝的一种表现，获取到的列表支持新增、删除</li>
<li>推荐写法 <code>Collections.addAll()</code></li>
</ul>
<p><strong>列表转数组</strong></p>
<ul>
<li><code>list.toArray</code>: 如果需要指定数组类型，则传参指定</li>
</ul>
<hr>
<p>微信搜 <strong>楼仔</strong> 或扫描下方二维码关注楼仔的原创公众号，回复 <strong>110</strong> 即可免费领取 10 本面试必刷八股文。
<img src="https://files.mdnice.com/user/13837/4b47ac79-8256-47cf-ac1a-036729635246.png" alt="" loading="lazy"></p>
<hr>
<h1> 实战3：字符串与Collection的互转</h1>
<p>将字符串转换为List，这种业务场景可以说非常非常常见了，实现方式也比较简单</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>那么除了上面这种实现方式之外，还有其他的么？</p>
<!-- more -->
<h2> 1. 字符串转列表</h2>
<p>上面的实现姿势相当于字符串先转数组，然后在通过数组转列表，所以可以沿用前一篇字数组转list的几种方式</p>
<h3> 1.1. jdk支持方式</h3>
<p>借助<code>Collections.addAll</code>来实现</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这种方式适用于输出String的列表，如果我希望转成int列表呢？可以采用下面的方式</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>直接将数组转换为流，然后基于jdk8的特性，来实现转换为int列表</p>
<h3> 1.2. guava方式</h3>
<p>引入依赖</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>除了使用jdk原生的方式之外，借助guava也是非常常见的的case了，主要通过Splitter来实现，写法看起来非常秀</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>简单直接的一行代码搞定，如果我们希望是对输出的列表类型进行指定，也可以如下操作</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1.3. apache-commons</h3>
<p>引入依赖</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面流的方式就很赞了，但是注意它是有jdk版本限制的，虽说现在基本上都是1.8以上的环境进行开发，但也不排除有上古的代码，比如我现在手上的项目，spring还是3...</p>
<p>如果我们不能使用流的方式，那么有什么简单的方式来实现字符串转换为指定类型的列表么？</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这个实现也没有多优雅，不过这里有个编程小技巧可以学习，<code>new Transformer(){}</code>的传参方式，这种实现方式有点像回调的写法，虽然他们有本质的区别，此外就是jdk8之后的函数方法，就充分的体现这种设计思路，比如上面的换成jdk8的写法，直接简化为</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 2. 列表转字符串</h2>
<h3> 2.1. StringBuilder</h3>
<p>最容易想到的，直接使用StringBuilder来实现拼接</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意两点：</p>
<ul>
<li>使用StringBuilder而不是StringBuffer (why?)</li>
<li>注意最后一个拼接符号不要</li>
</ul>
<h3> 2.2. String.join</h3>
<p>一个更简单的实现方式如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当然上面这个的缺点就是列表必须是字符串列表，如果换成int列表，则不行</p>
<h3> 2.3. gauva</h3>
<p>guava也提供了列表转String的方式，同样很简单，而且还没有列表类型的限制</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 3. 小结</h2>
<p>本文的考题也非常常见，列表与字符串的互转，这里介绍了多种实现方式，有jdk原生的case（如果没有什么限制，推荐使用它， <code>String.split</code>除外，原因后面再说），如果有更高级的定制场景，如非String类型类表，则可以考虑guava的Splitter/Joinner来实现</p>
<p>在上面的实现中，也提供了几种有意思的编程方式</p>
<ul>
<li>Stream: 流，jdk8之后非常常见了</li>
<li>函数方法，回调写法case</li>
</ul>
<hr>
<p>微信搜 <strong>楼仔</strong> 或扫描下方二维码关注楼仔的原创公众号，回复 <strong>110</strong> 即可免费领取 10 本面试必刷八股文。
<img src="https://files.mdnice.com/user/13837/4b47ac79-8256-47cf-ac1a-036729635246.png" alt="" loading="lazy"></p>
<hr>
<h1> 实战4：字符串拼接</h1>
<p>相信没有小伙伴没有写过这样的代码，比如说现在让我们来实现一个字符串拼接的场景，怎样的实现才算是优雅的呢？</p>
<!-- more -->
<p>以将int数组转为英文逗号分隔的字符串为例进行演示</p>
<h2> 1. 实现</h2>
<h3> 1.1. 普通写法</h3>
<p>直接使用StringBuilder来拼接</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这种写法相信比较常见，相对来说不太顺眼的地方就是最后的toString，需要将最后的一个英文逗号给干掉</p>
<p>当然也可以用下面这种事前判断方式，避免最终的字符串截取</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1.2. StringJoiner</h3>
<p>上面实现中，干掉最后的一个分隔符实在不是很优雅，那么有更好一点的用法么，接下来看一下使用<code>StringJoiner</code>的方式</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>StringJoiner由jdk1.8提供，除了上面的基础玩法之外，结合jdk1.8带来的流操作方式，可以更简洁的实现</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>怎么样，上面这个实现比起前面的代码是不是要简洁多了，一行代码完事</p>
<h3> 1.3. guava joiner</h3>
<p>如果使用的jdk还不是1.8版本，不能使用上面的StringJoiner，没关系，还有guava的Joiner也可以实现</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>注意</strong></p>
<ul>
<li>接收的参数类型为: 数组/Iterable/Iterator/可变参数, 基本上可以覆盖我们日常的业务场景</li>
</ul>
<h2> 2. 小结</h2>
<p>本篇文章的主题是一个非常非常常见的字符串拼接，一般来讲，我们在做字符串拼接时，最麻烦的事情就是分隔符的处理，要么就是分隔符前置添加，每次循环都需要判断是否为开头；要么就是后置，最后取字符串时，干掉最后一个分隔符</p>
<p>本文提供了一个非常使用的方式<code>StringJoiner</code>，完全解决了上面的分隔符问题，它的使用有两种场景</p>
<ul>
<li>简单的容器转String：直接借助Stream的<code>Collectors.joining</code>来实现</li>
<li>for循环 （这种场景一般是for循环内的逻辑不仅仅包括字符串拼接，还包括其他的业务逻辑）： 循环内直接执行<code>stringJoiner.add()</code>添加</li>
</ul>
<p>对于jdk1.8及以上的版本，优先推荐使用上面说的StringJoiner来实现字符串拼接；至于jdk1.8之下，那么Guava就是一个不错的选择了，使用姿势也很很简单</p>
<hr>
<p>微信搜 <strong>楼仔</strong> 或扫描下方二维码关注楼仔的原创公众号，回复 <strong>110</strong> 即可免费领取 10 本面试必刷八股文。
<img src="https://files.mdnice.com/user/13837/4b47ac79-8256-47cf-ac1a-036729635246.png" alt="" loading="lazy"></p>
<hr>
<h1> 实战5：驼峰与下划线划转</h1>
<p>这个考题非常实用，特别是对于我们这些号称只需要CURD的后端开发来说，驼峰与下划线互转，这不是属于日常任务么；一般来讲db中的列名，要求是下划线格式（why? 阿里的数据库规范是这么定义的，就我感觉驼峰也没毛病），而java实体命名则是驼峰格式，所以它们之间的互转，就必然存在一个驼峰与下划线的互转</p>
<p>今天我们就来看一下，这两个的互转支持方式</p>
<!-- more -->
<h2> 1.实现</h2>
<h3> 1.1. Gauva</h3>
<p>一般来讲遇到这种普适性的问题，大部分都是有现成的工具类可以来直接使用的；在java生态中，说到好用的工具百宝箱，guava可以说是排列靠前的</p>
<p>接下来我们看一下如何使用Gauva来实现我们的目的</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这里主要使用的是<code>CaseFormat</code>来实现互转，guava的CaseFormat还提供了其他几种方式</p>
<p>上面这个虽然可以实现互转，但是如果我们有一个字符串为 <code>helloWorld_Case</code></p>
<p>将其他转换输出结果如下:</p>
<ul>
<li>下划线：<code>hello_world__case</code></li>
<li>驼峰：<code>helloworldCase</code></li>
</ul>
<p>这种输出，和标准的驼峰/下划线不太一样了（当然原因是由于输入也不标准）</p>
<h3> 1.2. Hutool</h3>
<p>除了上面的guava，hutool的使用也非常广，其中包含很多工具类，其<code>StrUtil</code>也提供了下划线与驼峰的互转支持</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>同样的我们再来看一下特殊的case</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果如下</p>
<ul>
<li>驼峰：<code>helloworldCase</code></li>
<li>下划线: <code>hello_world_case</code></li>
</ul>
<p>相比较上面的guava的场景，下划线这个貌似还行</p>
<h3> 1.3. 自定义实现</h3>
<p>接下来为了满足我们希望转换为标砖的驼峰/下划线输出方式的需求，我们自己来手撸一个</p>
<p><strong>下划线转驼峰:</strong></p>
<ul>
<li>关键点就是找到下划线，然后去掉它，下一个字符转大写续上（如果下一个还是下划线，那继续找下一个）</li>
</ul>
<p>根据上面这个思路来实现，如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>驼峰转下划线</strong></p>
<ul>
<li>关键点：大写的，则前位补一个下划线，当前字符转小写（如果前面已经是一个下划线了，那前面不补，直接转小写即可）</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>再次测试<code>helloWorld_Case</code>，输出如下</p>
<ul>
<li>驼峰：<code>helloWorldCase</code></li>
<li>下划线: <code>hello_world_case</code></li>
</ul>
<hr>
<p>微信搜 <strong>楼仔</strong> 或扫描下方二维码关注楼仔的原创公众号，回复 <strong>110</strong> 即可免费领取 10 本面试必刷八股文。
<img src="https://files.mdnice.com/user/13837/4b47ac79-8256-47cf-ac1a-036729635246.png" alt="" loading="lazy"></p>
<hr>
<h1> 实战6：枚举的特殊用法</h1>
<p>难道我们日常使用的枚举还有什么特殊的玩法不成？没错，还真有，本文主要介绍枚举的两种不那么常见的使用姿势</p>
<ul>
<li>利用枚举来实现单例模式</li>
<li>利用枚举来实现策略模式</li>
</ul>
<!-- more -->
<h2> 1. 使用场景</h2>
<h3> 1.1. 单例模式</h3>
<p>单例模式可以说是每个java开发者必须掌握的一个设计模式了，通常我们说它的实现，有饱汉式和饿汉式，也有经常说的双重判断，今天我们介绍另外一种方式，借助枚举来实现</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用枚举来实现单例模式非常非常简单，将类声明为枚举，内部只定义一个值即可</p>
<p>为什么可以这样做？</p>
<ul>
<li>枚举类不能<code>new</code>，因此保证单例</li>
<li>枚举类不能被继承</li>
<li>类不加载时，不会实例化</li>
</ul>
<p>使用枚举类创建的单例有一个好处，就是即使用反射，也无法打破它的单例性质，这是相比较于其他的实现方式的一个优点</p>
<p>那么，为啥在实际的项目中，不太常见这种写法？</p>
<ul>
<li>就我个人的一点认知（不保证准确）：这个与我们对枚举的认知有一定关系，在 《Effect in java》一书中，推荐我们使用这种方式来实现单例，但是在实际的项目开发中，我们更多的将枚举作为常量来使用，很少在枚举类中，添加复杂的业务逻辑</li>
</ul>
<h3> 1.2. 策略模式</h3>
<p>枚举除了很容易就实现上面的单例模式之外，还可以非常简单的实现策略模式</p>
<p>举一个简单的例子，我现在有一个接口，通过接受的参数，来决定最终的数据存在什么地方</p>
<p>如果按照正常的写法，可能就是很多的if/else</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这种写法虽说简单直观，但是当type类型一多了之后，这个if/else的代码行数就会很多很多了，而且看起来也不美观</p>
<p>接下来我们介绍一种利用枚举，基于策略模式的思想来解决上面的if/else问题</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的实现，主要利用的是<code>抽象类 + 枚举</code>来完成不同的策略具体实现</p>
<p>这种实现方式，相比较与前面的单例模式，还是更常见一点，虽然整体看下来没有什么难度，但是仔细看一看，会发现几个知识点</p>
<ul>
<li>抽象方法的使用 （在模板设计模式中，更能体会抽象方法的使用妙处）</li>
<li>利用枚举原生提供的<code>values()</code>，来实现遍历，找到目标</li>
</ul>
<h2> 2. 小结</h2>
<p>枚举虽然说是jdk原生提供的一个基础数据类型，但是它的使用姿势除了我们熟知的常量之外，还可以有效的运用在设计模式中，让我们的代码实现更优雅</p>
<p>比如使用枚举来实现单例模式，就不用再面对让人烦躁的双重判断/内部类的方式了</p>
<p>使用枚举的策略模式，也可以有效解决我们类中大量的if/else</p>
<hr>
<p>微信搜 <strong>楼仔</strong> 或扫描下方二维码关注楼仔的原创公众号，回复 <strong>110</strong> 即可免费领取 10 本面试必刷八股文。
<img src="https://files.mdnice.com/user/13837/4b47ac79-8256-47cf-ac1a-036729635246.png" alt="" loading="lazy"></p>
<hr>
<h1> 实战7：排序比较要慎重</h1>
<p>今天介绍的又是一个非常非常基本的基本知识点，为啥要单独拎出来？还是因为这个东西虽然非常简单，但是很容易掉坑，我已经遇到几次不严谨的写法了</p>
<!-- more -->
<h2> 1.排序</h2>
<h3> 1.1. Comparator 与 Comparable</h3>
<p>输掉排序，这两个接口好像不太容易绕过去，我们简单介绍下它们的区别</p>
<ul>
<li>如果你有一个类，希望支持同类型的自定义比较策略，可以实现接口<code>Compareable</code></li>
<li>如果某个类，没有实现<code>Compareable</code>接口，但是又希望对它进行比较，则可以自自定义一个<code>Comparator</code>，来定义这个类的比较规则</li>
</ul>
<p>通过一个简单的实例进行演示说明</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的实现中，重点关注 Demo类，实现了<code>Comparable</code>接口，因此可以直接调用<code>list.sort(null)</code>来进行比较；</p>
<p>但是如果我们现在需求改变了，希望实现针对demo类的age字段，进行升序排列，那么就可以利用<code>Comparator</code>来实现了</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1.2. 踩坑预告</h3>
<p>再上面的compare方法实现中，我们可以发现里面的实现有点不太美观，我们最终的目的是什么？</p>
<ul>
<li>如果左边的小于右边的，返回 -1</li>
<li>如果左边的大于右边的，返回 0</li>
<li>如果左边的等于右边的，返回 1</li>
</ul>
<p>基于此，经常可以看到的实现如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这个实现虽然简洁了，但是有一个致命的问题，可能溢出!!!</p>
<p>所以请注意，千万千万不要用上面这种写法</p>
<p>那么有没有更优雅的方式呢？</p>
<ul>
<li>有，使用基础类的<code>compare</code>方法</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这一段代码，再jdk1.8中，可以简化为下面一句</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>再扩展一下，如果希望倒排呢？</p>
<ul>
<li>第一种实现方式，调换位置</li>
<li>Jdk1.8方式，使用负数</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 2. 小结</h2>
<p>今天主要介绍的知识点是排序，再我们日常使用中，如果一个类希望支持排序，最好的方式就是让它实现<code>Comparable</code>接口，然后自定义排序方式</p>
<p>这样再容器中，如果需要排序，直接调用 <code>list.sort(null)</code> 或者 <code>CollectionUtils.sort(list)</code></p>
<p>如果目标类没有实现排序接口，或者希望使用另外一种排序方式，则通过自定义的<code>Comparator</code>来实现</p>
<p>最后关于<code>compare</code>方法的实现，设计到两个类的比较，这种最终的落脚地，多半是基础类型的比较</p>
<ul>
<li>o1 与 o2 比较，返回负数，则最终的结果中o1再前面（即升序排列）</li>
<li>不要直接使用 <code>o1-o2</code>会溢出，推荐使用 <code>Integer.compare(o1, o2);</code></li>
</ul>
<hr>
<p>微信搜 <strong>楼仔</strong> 或扫描下方二维码关注楼仔的原创公众号，回复 <strong>110</strong> 即可免费领取 10 本面试必刷八股文。
<img src="https://files.mdnice.com/user/13837/4b47ac79-8256-47cf-ac1a-036729635246.png" alt="" loading="lazy"></p>
<hr>
<h1> 实战8：容器的初始化大小指定</h1>
<p>容器可以说是我们日常开发中，除了基本对象之外，使用最多的类了，那么平时在使用的时候，是否有主意到良好编程习惯的大佬，在创建容器的时候，一般会设置size；那么他们为什么要这么干呢？是出于什么进行考量的呢？</p>
<p>今天我们将针对最常见的List/Map/Set三种容器类型的初始化值选择，进行说明</p>
<!-- more -->
<h2> 1. 容器初始化</h2>
<h3> 1.1. List</h3>
<p>列表，在我们日常使用过程中，会接触到下面几个</p>
<ul>
<li>ArrayList: 最常见的数组列表</li>
<li>LinkedList: 基于链表的列表</li>
<li>CopyOnWriteArrayList: 线程安全的数组列表</li>
</ul>
<p>接下来逐一进行说明</p>
<h4> 1.1.1 ArrayList</h4>
<p>现在以ArrayList为例，进行源码分析，当我们不指定列表大小，直接创建时</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面是内部实现，其中<code>elementData</code>就是列表中存数据的数组，初始化为默认数组</p>
<p>当我们第一次添加一个元素时，发现数组为默认值，会触发一次数组扩容，新的数组大小为10 （详情看源码）</p>
<p>其次就是数组的库容机制，通过源码/网上分享知识点可以知道，这个扩容的实现如下</p>
<ul>
<li>当新添加的元素，数组放不下时，实现扩容</li>
<li><code>扩容后的大小</code> = <code>扩容前大小</code> + max(<code>添加元素个数</code>, 1/2 * <code>扩容前大小</code>)</li>
</ul>
<p>基于上面的知识点，大致可以得出指定列表长度的好处</p>
<ul>
<li>节省空间（用多少申请多少，避免浪费）</li>
<li>减少扩容带来的拷贝（扩容一次就会带来一次数组拷贝，如果已知列表很大，结果还使用默认的10，这会产生很多可避免的扩容开销）</li>
</ul>
<h4> 1.1.2 LinkedList</h4>
<p>基于链表的列表，不同于上面的数组列表，它没有提供指定大小的构造方法，why?</p>
<p>因为链表本身的数据结构的特点，它就像糖葫芦一样，一个串一个，有数据，才有接上的可能，因此不需要指定大小</p>
<h4> 1.1.3 CopyOnWriteArrayList</h4>
<p>这个又非常有意思，它同样不能指定大小，但是原因与前面不同，主要在于它保证线程安全的实现方式</p>
<ul>
<li>每次新增/修改(加锁，保证单线程访问)，都是在拷贝的数组操作；完成之后，用新的替换旧的</li>
</ul>
<p>所以说，每次变更，都会存在数组拷贝，因此就没有必要提前指定数组大小</p>
<p>那么它的初始化每次都使用默认的么?</p>
<p>并不是这样的，当我们已知这个列表中的值时，推荐使用下面这种方式</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>将初始化值，放在一个普通的列表中，然后利用普通列表来初始化<code>CopyOnWriteArrayList</code></li>
</ul>
<h3> 1.2.Map</h3>
<p>常见的map容器使用，大多是下面几个</p>
<ul>
<li><code>HashMap</code></li>
<li><code>LinkedHashMap</code>: 有序的hashmap</li>
<li><code>TreeMap</code>: 有序的hashmap</li>
<li><code>ConcurrentHashMap</code>: 线程安全的map</li>
</ul>
<h4> 1.2.1 HashMap</h4>
<p>HashMap的底层数据结构是 <code>数组 + 链表/红黑树</code>，关于这个就不细说了</p>
<p>我们在初始化时，若不指定size，则数组的默认长度为8（请注意，Map的数组长度是2的倍数）</p>
<p>与ArrayList的扩容时机不一样的是，默认情况下，Map容量没满就会触发一次扩容</p>
<p>默认是数量达到 <code>size * 0.75</code>(0.75为扩容因子，可以在创建时修改)，就会触发一次扩容</p>
<p>why?</p>
<ul>
<li>主要是为了减少hash冲突</li>
</ul>
<p>同样的为了减少冲突，在初始化时，我们需要指定一个合适大小</p>
<p>比如我们</p>
<ul>
<li>已知map的数量为2，这个时候Map的大小选择因该是4</li>
<li>map数量为6，这个时候Map的大小选择是16</li>
</ul>
<p>有时候让我们自己来计算这个值，就有些麻烦了，这个时候，可以直接使用Guava的工具类来完成这个目的</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4> 1.2.2 LinkedHashMap</h4>
<p>初始化方式同上，略</p>
<h4> 1.2.3 ConcurrentHashMap</h4>
<p>初始化方式同上，略</p>
<h4> 1.2.4 TreeMap</h4>
<p>不同于上面几个的是treeMap，没有提供指定容器大小的构造方法</p>
<p>原因和前面说到的LinkedList有些类似，TreeMap的底层数据结构为Tree，所以新增数据是挂在树的一个节点下面，无需指定容量大小</p>
<h3> 1.3. Set</h3>
<p>集合用的最多应该就是<code>HashSet</code>了，底层结构模型复用，所以初始化大小指定与HashMap一致，也不需要多说</p>
<h2> 2. 小结</h2>
<p>今天这篇博文主要介绍的是三种常见的容器，在创建时，如何指定容量大小</p>
<p>首先明确一点，指定容量大小是为了</p>
<ul>
<li>减少扩容带来的额外开销</li>
<li>指定容量代销，可以减少无效的内存开销</li>
</ul>
<p>初始化值设置的关键点:</p>
<ul>
<li>ArrayList: 数据有多少个，初始化值就是多少</li>
<li>HashMap: 考虑到扩容因子，初始化大小 = <code>(size / 0.75 + 1)</code></li>
</ul>
<hr>
<p>微信搜 <strong>楼仔</strong> 或扫描下方二维码关注楼仔的原创公众号，回复 <strong>110</strong> 即可免费领取 10 本面试必刷八股文。
<img src="https://files.mdnice.com/user/13837/4b47ac79-8256-47cf-ac1a-036729635246.png" alt="" loading="lazy"></p>
<hr>
<h1> 实战9：List.subList使用不当StackOverflowError</h1>
<p>相信每个小伙伴都使用过<code>List.subList</code>来获取子列表，日常使用可能没啥问题，但是，请注意，它的使用，很可能一不小心就可能导致oom</p>
<!-- more -->
<h2> 1.实例说明</h2>
<h3> 1.1. subList</h3>
<p>场景复现，如基于list实现一个小顶堆</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这个执行完毕之后，居然出现栈溢出</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从实现来看，感觉也没啥问题啊， 我们稍微改一下上面的返回</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>再次执行，却没有异常；所以关键点就在与</p>
<ul>
<li>list.subList的使用上</li>
</ul>
<h3> 1.2. StackOverflowError分析</h3>
<p>接下来我们主要看一下<code>list.subList</code>的实现</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面返回的子列表是ArrayList的一个内部类<code>SubList</code>，它拥有一个指向父列表的成员<code>parrent</code></p>
<p>也就是说，从源头的ArryList开始，后面每次调用<code>subList</code>，这个指代关系就深一层</p>
<p>然后它的add方法也很有意思</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>重点看 <code>parent.add(parentOffset + index, e);</code>，添加的数据实际上是加在最源头的ArrayList上的，也就是说，虽然你现在拿到的SubList，只有几个元素，但是它对应的数组，可能超乎你的想象</p>
<p>当然上面这个异常主要是以为调用栈溢出（一直往上找parent）</p>
<p>这里反应的另外一个重要问题则是内存泄漏，就不继续说了</p>
<p>如果需要解决上面这个问题，改造方法如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 2. 小结</h2>
<p>jdk提供的原生方法虽然非常好用，但是在使用的时候，也需要多家注意，一不小心就可能掉进坑里；这也告诉我们多看源码是有必要的</p>
<p>最后一句关键知识点小结：</p>
<ul>
<li><code>ArrayList.subList</code> 返回的是内部类，与原ArrayList公用一个数组，只是限定了这个数组的起始下标和结束下标而已</li>
<li>在使用<code>subList</code>，请注意是否会存在内存泄露和栈溢出的问题</li>
</ul>
<hr>
<p>微信搜 <strong>楼仔</strong> 或扫描下方二维码关注楼仔的原创公众号，回复 <strong>110</strong> 即可免费领取 10 本面试必刷八股文。
<img src="https://files.mdnice.com/user/13837/4b47ac79-8256-47cf-ac1a-036729635246.png" alt="" loading="lazy"></p>
<hr>
<h1> 实战10：不可变容器</h1>
<p>不可变容器，看着好像在实际的业务中不怎么会用到，但实则不然，相信每个小伙伴都用过，或者看到过下面的代码</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>今天我们来介绍一下如何使用不可变容器，以及使用时的注意事项</p>
<!-- more -->
<h2> 1. 不可变容器</h2>
<h3> 1.1. JDK不可变容器</h3>
<p>java原生提供了一些不可变容器，它们最大的特点就是不支持添加、删除、修改容器内的值</p>
<p><code>Collections.emptyXxx</code>空容器</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面三个是最常用的几个了，通常当我们一个方法的返回结果定义为容器类型时，可能为了避免npe，在返回空容器时，会如此使用</p>
<p>除了上面这几个空的不可变容器之外，还有</p>
<ul>
<li><code>UnmodifiableList</code></li>
<li><code>UnmodifiableMap</code></li>
<li><code>UnmodifiableSet</code></li>
</ul>
<p>它们的使用姿势，通常是借助<code>Collections</code>来实现</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>如上面创建的List，就不支持set/remove等修改操作</p>
<p>使用不可变容容器，最大的好处就是基于它的不可修改特性，来实现公用，且不会被污染</p>
<ul>
<li>所以一个自然而然能想到的应用场景就是 <code>全局共享的配置</code></li>
</ul>
<h3> 1.2. Guava不可变容器</h3>
<p>上面是jdk提供的不可变容器，相比较与它们，在实际的项目中，使用Gauva的不可变容器的可能更多</p>
<ul>
<li><code>ImmutableXxx</code>；不可变容器</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面是最常见的三个容器对应的不可变型</p>
<p>从使用角度来看，初始化非常方便（相比较与jdk版而言）</p>
<h2> 2. 注意事项</h2>
<p>不可变容器虽好，但是使用不当也是很坑的；就我个人的一个观点</p>
<ul>
<li>如果是应用内的接口方法，容器传参，返回容器时，尽量不要使用不可变容器；因为你没办法保证别人拿到你的返回容器之后，会对它进行什么操作</li>
<li>如果是对外提供返回结果，特别是null的场景，使用不可变的空容器优于返回null</li>
<li>不可变容器，用于全局公用资源，共享配置参数；多线程的数据传递时，属于比较合适的场景</li>
</ul>
<hr>
<p>微信搜 <strong>楼仔</strong> 或扫描下方二维码关注楼仔的原创公众号，回复 <strong>110</strong> 即可免费领取 10 本面试必刷八股文。
<img src="https://files.mdnice.com/user/13837/4b47ac79-8256-47cf-ac1a-036729635246.png" alt="" loading="lazy"></p>
<hr>
<h1> 实战11：Map转换Map的几种方式</h1>
<p>在日常开发过程中，从一个Map转换为另外一个Map属于基本操作了，那么我们一般怎么去实现这种场景呢？有什么更简洁省事的方法么？</p>
<!-- more -->
<h2> 1.Map互转</h2>
<h3> 1.1 实例场景</h3>
<p>现在我们给一个简单的实例</p>
<p>希望将一个<code>Map&lt;String, Integer&gt;</code> 转换成 <code>Map&lt;String, String&gt;</code>，接下来看一下有哪些实现方式，以及各自的优缺点</p>
<p>首先提供一个创建Map的公共方法</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 1.1.1 基本的for循环转换</h4>
<p>这种方式是最容易想到和实现的，直接for循环来转换即可</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这种方式的优点很明显，实现容易，业务直观；</p>
<p>缺点就是可复用性较差，代码量多（相比于下面的case）</p>
<h4> 1.1.2 容器的流式使用</h4>
<p>在jdk1.8提供了流式操作，同样也可以采用这种方式来实现转换</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用stream的方式，优点就是链式，代码量少；缺点是相较于上面的阅读体验会差一些（当然这个取决于个人，有些小伙伴就更习惯看这种链式的代码）</p>
<h4> 1.1.3 Guava的trasform方式</h4>
<p>从代码层面来看，上面两个都不够直观，如果对guava熟悉的小伙伴对下面的代码可能就很熟悉了</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>核心逻辑就一行 <code>Maps.transformValues(map, String::valueOf)</code>，实现了我们的Map转换的诉求</p>
<p>很明显，这种方式的优点就是间接、直观；当然缺点就是需要引入guava，并且熟悉guava</p>
<h3> 1.2 最后一问，这篇文章目的是啥？</h3>
<p>既然我们的标题是实战小技巧，本文除了给大家介绍可以使用guava的<code>Maps.transformValues</code>来实现map转换之外，更主要的一个目的是如果让我们自己来实现一个工具类，来支持这个场景，应该怎么做？</p>
<p>直接提供一个转换方法？</p>
<p><strong>第一步：一个泛型的转换接口</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>定义上面这个接口之后，自然而然想到的缺点就是差一个value的转换实现</p>
<p><strong>第二步：value转换的定义</strong></p>
<p>这里采用Function接口思想来定义转换类</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>当然到这里我们就需要注意jdk1.8以下是不支持函数编程的，那么我们可以怎么来实现呢？</p>
<p>这个时候再对照一下guava的实现，然后再手撸一个，知识点就到手了</p>
<hr>
<p>微信搜 <strong>楼仔</strong> 或扫描下方二维码关注楼仔的原创公众号，回复 <strong>110</strong> 即可免费领取 10 本面试必刷八股文。
<img src="https://files.mdnice.com/user/13837/4b47ac79-8256-47cf-ac1a-036729635246.png" alt="" loading="lazy"></p>
<hr>
<h1> 实战12：巧用函数方法实现二维数组遍历</h1>
<p>对于数组遍历，基本上每个开发者都写过，遍历本身没什么好说的，但是当我们在遍历的过程中，有一些复杂的业务逻辑时，将会发现代码的层级会逐渐加深</p>
<!-- more -->
<p>如一个简单的case，将一个二维数组中的偶数找出来，保存到一个列表中</p>
<p>二维数组遍历，每个元素判断下是否为偶数，很容易就可以写出来，如</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这个实现没啥问题，但是这个代码的深度很容易就有三层了；当上面这个if中如果再有其他的判定条件，那么这个代码层级很容易增加了；二维数组还好，如果是三维数组，一个遍历就是三层；再加点逻辑，四层、五层不也是分分钟的事情么</p>
<p>那么问题来了，代码层级变多之后会有什么问题呢？</p>
<blockquote>
<p>只要代码能跑，又能有什么问题呢？！</p>
</blockquote>
<h2> 1. 函数方法消减代码层级</h2>
<p>由于多维数组的遍历层级天然就很深，那么有办法进行消减么？</p>
<p>要解决这个问题，关键是要抓住重点，遍历的重点是什么？获取每个元素的坐标！那么我们可以怎么办？</p>
<blockquote>
<p>定义一个函数方法，输入的就是函数坐标，在这个函数体中执行我们的遍历逻辑即可</p>
</blockquote>
<p>基于上面这个思路，相信我们可以很容易写一个二维的数组遍历通用方法</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>主要上面的实现，函数方法直接使用了JDK默认提供的BiConsumer，两个传参，都是int 数组下表；无返回值</p>
<p>那么上面这个怎么用呢？</p>
<p>同样是上面的例子，改一下之后，如</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>相比于前面的，貌似也就少了一层而已，好像也没什么了不起的</p>
<p>但是，当数组变为三维、四维、无维时，这个改动的写法层级都不会变哦</p>
<h2> 2. 遍历中return支持</h2>
<p>前面的实现对于正常的遍历没啥问题；但是当我们在遍历过程中，遇到某个条件直接返回，能支持么？</p>
<p>如一个遍历二维数组，我们希望判断其中是否有偶数，那么可以怎么整？</p>
<p>仔细琢磨一下我们的scan方法，希望可以支持return，主要的问题点就是这个函数方法执行之后，我该怎么知道是继续循环还是直接return呢?</p>
<p>很容易想到的就是执行逻辑中，添加一个额外的返回值，用于标记是否中断循环直接返回</p>
<p>基于此思路，我们可以实现一个简单的demo版本</p>
<p>定义一个函数方法，接受循环的下标 + 返回值</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>循环通用方法就可以相应的改成</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>基于上面这种思路，我们的实际使用姿势如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这个实现可满足我们的需求，唯一有个别扭的地方就是返回，总有点不太优雅；那么除了这种方式之外，还有其他的方式么？</p>
<p>既然考虑了返回值，那么再考虑一下传参呢？通过一个定义的参数来装在是否中断以及返回结果，是否可行呢？</p>
<p>基于这个思路，我们可以先定义一个参数包装类</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们希望通过Ans这个类来记录循环结果，其中tag=true，则表示不用继续循环了，直接返回ans结果吧</p>
<p>与之对应的方法改造及实例如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样看起来就比前面的要好一点了</p>
<p>实际跑一下，看下输出是否和我们预期的一致；</p>
<figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/546a699ae4334df4b6525332da4e5770~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure>
<p>微信搜 <strong>楼仔</strong> 或扫描下方二维码关注楼仔的原创公众号，回复 <strong>110</strong> 即可免费领取 10 本面试必刷八股文。
<img src="https://files.mdnice.com/user/13837/4b47ac79-8256-47cf-ac1a-036729635246.png" alt="" loading="lazy"></p>
<hr>
<h1> 实战13：List转Map List的几种姿势</h1>
<p>今天介绍一个实用的小知识点，如何将List转为<code>Map&lt;Object, List&lt;Object&gt;&gt;</code></p>
<!-- more -->
<h2> 1. 转换方式</h2>
<h3> 1.1. 基本写法</h3>
<p>最开始介绍的当然是最常见、最直观的写法，当然也是任何限制的写法</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对于jdk8+，上面for循环中的内容可以利用<code>Map.computeIfAbsent</code>来替换，具体写法如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当然既然已经是jdk1.8了，借助Stream的流处理，可以将上面的更一步进行简化，如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 1.2. 通用方法</h3>
<p>上面是针对特定的列表，针对业务进行开发转换，那么我们接下来尝试构建一个通用的工具类</p>
<p>这里我们主要借助的知识点就是泛型，一个重要的点就是如何获取Map中的key</p>
<p>对于jdk &lt; 1.8的写法，通过接口来定义实现key的获取姿势</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用demo如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来再看一下jdk1.8之后的写法，结合stream + 函数方法来实现</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其对应的使用方式则如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1.3. 工具类</h3>
<p>上一节介绍了基于泛型 + jdk8 Stream + 函数方法来实现通用转换工具类的实现姿势，接下来我们小结一下，输出一个适用于1.8之后的工具类</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1.4.guava HashMultimap扩展知识点</h3>
<p>最后再介绍一个扩展知识点，Gauva工具包中提供了一个<code>HashMultimap</code>的工具类，他的使用姿势和我们平常的Map并无差别，但是需要在注意的是，它的value是个集合</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>实际输出如下，验证了value实际上是个集合（on只有一个，如果是我们上面的工具类，会输出两个）</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><hr>
<p>微信搜 <strong>楼仔</strong> 或扫描下方二维码关注楼仔的原创公众号，回复 <strong>110</strong> 即可免费领取 10 本面试必刷八股文。
<img src="https://files.mdnice.com/user/13837/4b47ac79-8256-47cf-ac1a-036729635246.png" alt="" loading="lazy"></p>
<hr>
<h1> 实战14：分页遍历得两种实现策略</h1>
<p>在日常开发中，分页遍历迭代的场景可以说非常普遍了，比如扫表，每次捞100条数据，然后遍历这100条数据，依次执行某个业务逻辑；这100条执行完毕之后，再加载下一百条数据，直到扫描完毕</p>
<p>那么要实现上面这种分页迭代遍历的场景，我们可以怎么做呢</p>
<p>本文将介绍两种使用姿势</p>
<ul>
<li>常规的使用方法</li>
<li>借助Iterator的使用姿势</li>
</ul>
<!-- more -->
<h2> 1. 实现方式</h2>
<h3> 1.1. 数据查询模拟</h3>
<p>首先mock一个分页获取数据的逻辑，直接随机生成数据，并且控制最多返回三页</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1.2. 基本实现方式</h3>
<p>针对这种场景，最常见也是最简单直观的实现方式</p>
<ul>
<li>while死循环</li>
<li>内部遍历</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1.3. 迭代器实现方式</h3>
<p>接下来介绍一种更有意思的方式，借助迭代器的遍历特性来实现，首先自定义一个通用分页迭代器</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来借助上面的迭代器可以比较简单的实现我们的需求了</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>那么问题来了，上面这种使用方式比前面的优势体现再哪儿呢？</p>
<ul>
<li>双层循环改为单层循环</li>
</ul>
<p>接下来接入重点了，在jdk1.8引入了函数方法 + lambda之后，又提供了一个更简洁的使用姿势</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在jdk1.8及之后的使用姿势，一行代码即可</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这次对比效果是不是非常显眼了，从此以后分页迭代遍历再也不用冗长的双重迭代了</p>
<hr>
<p>微信搜 <strong>楼仔</strong> 或扫描下方二维码关注楼仔的原创公众号，回复 <strong>110</strong> 即可免费领取 10 本面试必刷八股文。
<img src="https://files.mdnice.com/user/13837/4b47ac79-8256-47cf-ac1a-036729635246.png" alt="" loading="lazy"></p>
<hr>
<h1> 实战15：数组拷贝</h1>
<p>说实话，在实际的业务开发中，基本上很少很少很少...会遇到数组拷贝的场景，甚至是我们一般都不怎么用数组，List它不香嘛，为啥要用数组</p>
<p>现在问题来了，要实现数组拷贝，怎么整？</p>
<!-- more -->
<h2> 1. 实现方式</h2>
<h3> 1.1. 基础写法</h3>
<p>最简单直接的写法，那就是新建一个数组，一个一个拷贝进去，不就完事了么</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1.2. 借用容器中转</h3>
<p>数组用起来有点麻烦，还是用容器舒爽，借助List来实现数组的拷贝，也就几行代码</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1.3. Array.copy</h3>
<p>上面这个有点绕得远了， 直接使用Array.copy</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1.4. System.arraycopy</h3>
<p>除了上面的，还可以使用更基础的用法</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果有看过jdk源码的小伙伴，上面这个用法应该不会陌生，特别是在容器类，这种数组拷贝的方式比比可见</p>
<p>参数说明:</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>src : 原数组</li>
<li>srcPos: 原数组用于拷贝的起始下标</li>
<li>dest: 拷贝后的数组</li>
<li>destPos: 目标数组的小标</li>
<li>length: 原数组中拷贝过去的数组长度</li>
</ul>
<p>从上面的描述也能看出来，这个方法不仅能实现数组拷贝，还可以实现数组内指定片段的拷贝</p>
<hr>
<p>微信搜 <strong>楼仔</strong> 或扫描下方二维码关注楼仔的原创公众号，回复 <strong>110</strong> 即可免费领取 10 本面试必刷八股文。
<img src="https://files.mdnice.com/user/13837/4b47ac79-8256-47cf-ac1a-036729635246.png" alt="" loading="lazy"></p>
<hr>
<h1> 实战16：判断类为基础类型or基础类型的包装类</h1>
<p>判断一个类是否为基础类型属于常规操作了，一般我们遇到这种case，要怎么处理呢？</p>
<p>一个一个的if/else判断? 还是其他的操作姿势？</p>
<!-- more -->
<h2> 1. 基础类型判断</h2>
<p>基础类型可以借助class类的<code>isPrimitive</code>方法来实现判定，使用姿势也简单</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>如果返回true，那么这个对象就是基本类型</p>
<ul>
<li>boolean</li>
<li>char</li>
<li>byte</li>
<li>short</li>
<li>int</li>
<li>long</li>
<li>float</li>
<li>double</li>
<li>void</li>
</ul>
<p>但是请注意，对于封装类型，比如Long，访问isPrimitive返回的是false</p>
<h2> 2. 封装类型判断</h2>
<p>那么封装类型可以怎么判断呢？难道一个一个的判定不成？</p>
<p>首先我们注意到<code>Class#isPrimitive</code>的方法签名，如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的注释中，提到了Boolean#Type之类的静态成员，也就是说包装类型，都有一个TYPE的静态成员</p>
<p>比如boolean的是这个</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>所以我们可以通过这个TYPE来判定，当前对象是否为封装对象</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果Class对象没有TYPE字段，那么就不是封装类，直接抛异常，返回false；当然这种通过异常的方式来判定，并不优雅；但是写法上比我们一个一个的if/else进行对比，要好得多了</p>
<hr>
<p>微信搜 <strong>楼仔</strong> 或扫描下方二维码关注楼仔的原创公众号，回复 <strong>110</strong> 即可免费领取 10 本面试必刷八股文。
<img src="https://files.mdnice.com/user/13837/4b47ac79-8256-47cf-ac1a-036729635246.png" alt="" loading="lazy"></p>
<hr>
<h1> 实战17：Java对象内存地址输出</h1>
<h2> 输出对象地址</h2>
<p>当一个对象没有重写<code>hascode</code>方法时，它返回的内存地址，当覆盖之后，我们有什么办法获取对象的内存地址么?</p>
<ul>
<li>使用 <code>System.identityHashCode()</code> 输出内存地址</li>
</ul>
<!-- more -->
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果如:</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这个有啥用？</p>
<ul>
<li>判断两个对象是否为同一个对象时，可以借用（我是在验证Mybatis的一级缓存的，判断返回的Entity是否确实是同一个的时候以此来判定的）</li>
</ul>
<hr>
<p>微信搜 <strong>楼仔</strong> 或扫描下方二维码关注楼仔的原创公众号，回复 <strong>110</strong> 即可免费领取 10 本面试必刷八股文。
<img src="https://files.mdnice.com/user/13837/4b47ac79-8256-47cf-ac1a-036729635246.png" alt="" loading="lazy"></p>
<hr>
<h1> 实战18：随机数生成怎么选</h1>
<p>随机数生成，java中有一个专门的Random类来实现，除此之外，使用<code>Math.random</code>的也比较多，接下来我们简单学习下，随机数的使用姿势</p>
<!-- more -->
<h2> 1.随机数生成</h2>
<h3> 1.1. Math.random</h3>
<p>jdk提供的基础工具类Math中封装一些常用的基础方法，比如我们今天的主题，生成随机数，使用姿势如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>使用起来比较简单，生成的是[0,1)之间的浮点数，但是不要以为它就真的只能生成0-1之间的随机数，举例如下</p>
<p>如果想利用它，生成一个 <code>[120, 500]</code> 这个区间的随机数，怎么整？</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>为啥上面的可行？</p>
<p>将上面的代码翻译一下，取值区间如</p>
<p><code>Math.random() * 381 + 120</code> 取值范围如下</p>
<ul>
<li>[0, 1) * 381 + 120</li>
<li>[0, 381) + 120</li>
<li>[120, 501)</li>
</ul>
<p>借助<code>Math.ceil</code>只取浮点数中的整数部分，这样我们的取值范围就是 [120, 500]了，和我们的预期一致</p>
<p>最后简单来看下，<code>Math.random()</code>是怎么实现随机数的</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>请注意上面的实现，原来底层依然使用的是<code>Random</code>类来生成随机数，而且上面这种写法属于非常经典的单例模式写法（不同于我们常见的双重判定方式，这种属于内部类的玩法，后面再说为啥可以这么用）</p>
<h3> 1.2. Random</h3>
<p>除了使用上面的Math.random来获取随机数之外，直接使用Random类也是很常见的case；接下来先简单看一下Random的使用姿势</p>
<p><strong>创建Random对象</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>生成随机数</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>伪随机高斯分布双精度数</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>随机类的nextGaussian()方法返回下一个伪随机数，即与随机数生成器序列的平均值为0.0，标准差为1.0的高斯(正态)分布双精度值</p>
<p>这种使用场景可能用在更专业的场景，至少我接触过的业务开发中，没有用过这个😂</p>
<h3> 1.3. Math.random 与 Random如何选</h3>
<p>上面两个都可以用来生成随机数，那么在实际使用的时候，怎么选择呢？</p>
<p>从前面的描述也可以知道，它们两没啥本质区别，底层都是用的Random类，在实际的运用过程中，如果我们希望可以场景复现，比如测试中奖概率的场景下，选择Random类，指定随机种子可能更友好；如果只是简单的随机数生成使用，那么选择<code>Math.random</code>即可，至少使用起来一行代码即可</p>
<hr>
<p>微信搜 <strong>楼仔</strong> 或扫描下方二维码关注楼仔的原创公众号，回复 <strong>110</strong> 即可免费领取 10 本面试必刷八股文。
<img src="https://files.mdnice.com/user/13837/4b47ac79-8256-47cf-ac1a-036729635246.png" alt="" loading="lazy"></p>
<hr>
<h1> 实战19：数字格式化</h1>
<p>数字的格式化场景，更多的是在日志输出、金额计算相关的领域中会用到，平常我们可能更多使用<code>String.format</code>来格式化，但是请注意，数字格式化是有一个<code>DecimalFormat</code>，专门来针对数字进行格式化</p>
<p>今天我们的知识点就是DecimalFormat来实现数字格式化</p>
<!-- more -->
<h2> 1. 格式化</h2>
<h3> 1.1. DecimalFormat使用说明</h3>
<p>对于DecimalFormat的使用比较简单，主要是借助两个占位<code>0</code>与<code>#</code>，区别在于当格式化的占位数，多余实际数的时候，占位<code>0</code>的场景下，会用前缀0来补齐；而<code>#</code>则不需要补齐</p>
<p>上面这个可能不太好理解，举例说明如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面两个都是只输出整数，但是输出结果不同，如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>简单来说，就是<code>0</code>，主要用于定长的输出，对于不足的，前缀补0</p>
<p><strong>整数#小数</strong></p>
<p>除了上面的基本姿势之外，更常见的是设置整数、小数的位数</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>百分比</strong></p>
<p>百分比的输出也属于常见的case，使用DecimalFormat就很简单</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>输出如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>科学计数</strong></p>
<p>非专业场景下，科学技术的可能性比较小</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>金钱样式输出</strong></p>
<p>金融相关的钱输出时，非常有意思的是每三位加一个逗号分隔，如果想实现这个效果，也可以很简单完成</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>嵌入模板输出</strong></p>
<p>格式化模板，除了基础的<code>000, ###</code>之外，还可以直接放在一个字符串中，实现类似<code>String.format</code>的效果</p>
<p>比如显示余额</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><hr>
<p>微信搜 <strong>楼仔</strong> 或扫描下方二维码关注楼仔的原创公众号，回复 <strong>110</strong> 即可免费领取 10 本面试必刷八股文。
<img src="https://files.mdnice.com/user/13837/4b47ac79-8256-47cf-ac1a-036729635246.png" alt="" loading="lazy"></p>
<hr>
<h1> 实战20：进制转换很简单</h1>
<p>进制转换，属于基本技能了，在java中要实现进制转换很简单，可以非常简单的实现，接下来我们来看下它的使用姿势</p>
<!-- more -->
<h2> 1. 进制转换</h2>
<h3> 1.1. toString实现进制转换</h3>
<p>Integer/Long#toString(int i, int radix) 可以将任一进制的整数，转换为其他任意进制的整数</p>
<ul>
<li>第一个参数：待转换的数字</li>
<li>第二个参数：转换后的进制位</li>
</ul>
<p><strong>十六进制转十进制</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>八进制转是十进制</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>八进制转二进制</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 1.2. 十进制转二进制</h3>
<p>除了使用上面的姿势之外，可以直接使用<code>toBinaryString</code>来实现转二进制</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1.3. 十进制转八进制</h3>
<p><code>Integer/Long#toOctalString</code>: 转八进制</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 1.4. 十进制转十六进制</h3>
<p><code>Integer/Long#toHexString</code>: 转十六进制</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><hr>
<p>微信搜 <strong>楼仔</strong> 或扫描下方二维码关注楼仔的原创公众号，回复 <strong>110</strong> 即可免费领取 10 本面试必刷八股文。
<img src="https://files.mdnice.com/user/13837/4b47ac79-8256-47cf-ac1a-036729635246.png" alt="" loading="lazy"></p>
<hr>
<h1> 实战21：Properties配置文件</h1>
<p>properties配置文件，相信各位小伙伴都不会太陌生，常用Spring的可能会经常看到它，虽说现在更推荐的是使用Yaml配置文件，但是properties配置文件的使用频率也不低</p>
<p>在jdk中有一个直接关连的类Properties，接下来我们来看一下它的用法</p>
<!-- more -->
<h2> 1. Properties配置类</h2>
<h3> 1.1. 配置文件</h3>
<p>properties文件的格式比较简单</p>
<ul>
<li><code>key = value</code>: 等号左边的为配置key，右边的为配置value（value值会去除前后的空格）</li>
<li><code>#</code>：以<code>#</code>来区分注释</li>
</ul>
<p>一个基础的配置文件如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1.2. 配置文件加载</h3>
<p>对于Properties配置文件，我们可以非常简单的借助<code>Properties</code>类，来实现配置的加载</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>直接使用<code>Properties#config</code>就可以读取配置文件内容，并赋值到java对象</p>
<p><strong>重点注意：</strong></p>
<p>重点看一下Properties类的继承关系，它的父类是Hashtable, 也就是说它的本质是Map对象</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1.3. Properties对象使用</h3>
<p>因为<code>Properties</code>是继承自Hashtable，而Hashtable是线程安全的Map容器，因此Properties也是线程安全的，同样的，在多线程并发获取配置的时候，它的性能表现也就不咋地了，why?</p>
<p>首先看一下配置获取</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面两个方法的使用频率很高，从签名上也很容易知道使用姿势；接下来需要看一下的为啥说并发效率很低</p>
<p>关键点就在第一个方法的<code>super.get()</code>，它对应的源码正是</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>方法签名上有<code>synchronized</code>，所以为啥说并发环境下的性能表现不会特别好也就知道原因了</p>
<p>除了获取配置之外，另外一个常用的就是更新配置</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 2. 小结</h2>
<p>本文介绍的知识点主要是properties配置文件的处理，使用同名的java类来操作；需要重点注意的是Properties类属于Hashtable的子类，同样属于容器的范畴</p>
<p>最后提一个扩展的问题，在SpringBoot的配置自动装载中，可以将配置内容自动装载到配置类中，简单来讲就是支持配置到java bean的映射，如果现在让我们来实现这个，可以怎么整？</p>
<hr>
<p>微信搜 <strong>楼仔</strong> 或扫描下方二维码关注楼仔的原创公众号，回复 <strong>110</strong> 即可免费领取 10 本面试必刷八股文。
<img src="https://files.mdnice.com/user/13837/4b47ac79-8256-47cf-ac1a-036729635246.png" alt="" loading="lazy"></p>
<hr>
<h1> 实战22：Properties配置文件自动装载JavaBean</h1>
<p>SpringBoot的配置自动装载，使用起来还是很舒爽的，可以非常简单的将properties配置文件的内容，填充到Java bean对象中，如果我们现在是一个脱离于Springboot框架的项目，想实现上面这个功能，可以怎么来做呢？</p>
<!-- more -->
<h2> 1.配置封装</h2>
<h3> 1.1. 配置文件自动装载</h3>
<p>前面介绍了Properties文件的读取以及基本使用姿势，通过上篇博文已知Properties类的本质是一个Map，所以我们需要干的就是将Map容器的值，赋值到JavaBean的成员属性中</p>
<p>要实现这个功能，自然而然会想到的就是利用反射（考虑到我们赋值的通常为标准的java bean，使用内省是个更好的选择）</p>
<p>接下来我们需要实现的也比较清晰了，第一步获取成员属性，两种方式</p>
<ul>
<li>内省: <code>BeanInfo bean = Introspector.getBeanInfo(clz); PropertyDescriptor[] propertyDescriptors = bean.getPropertyDescriptors();</code></li>
<li>反射: <code>Field[] fields = clz.getDeclaredFields();</code></li>
</ul>
<p>第二步遍历成员属性，进行赋值</p>
<ul>
<li>内省：借助前面获取的<code>PropertyDescriptor</code>对象，拿到set方法，进行赋值
<ul>
<li><code>descriptor.getWriteMethod().invoke(obj, value)</code></li>
</ul>
</li>
<li>反射：适应<code>Field.set</code>来赋值
<ul>
<li><code>field.set(obj, value);</code></li>
</ul>
</li>
</ul>
<p><strong>注意</strong></p>
<ul>
<li>上面的两种赋值方式，都要求我们传入的value对象类型与定义类型一直，否则会抛类型转换异常</li>
</ul>
<p>为了避免复杂的类型转换与判定，我们这里介绍下apache的<code>commons-beanutils</code>来实现属性拷贝</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来核心的实现逻辑如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意上面的实现，首先通过内省的方式获取所有的成员，然后进行遍历，借助<code>BeanUtils.setProperty</code>来实现属性值设置</p>
<p>这里面有两个知识点</p>
<ul>
<li><code>BeanUtil</code> 还是 <code>PropertyUtil</code>
<ul>
<li>它们两都有个设置属性的方法，但是BeanUtil支持简单类型的自动转换；而后者不行，要求类型完全一致</li>
</ul>
</li>
<li>非简单类型
<ul>
<li>对于非简单类型，上面采用了递归的调用方式来处理；请注意，这里并不完善，比如BigDecimal, Date, List, Map这些相对基础的类型，是不太适用的哦</li>
</ul>
</li>
</ul>
<h3> 1.2. 功能测试</h3>
<p>最后针对上面的实现功能，简单的测试一下，是否可行</p>
<p>配置文件<code>mail.properties</code></p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>两个Java Bean</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>转换测试类</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果如下：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><hr>
<p>微信搜 <strong>楼仔</strong> 或扫描下方二维码关注楼仔的原创公众号，回复 <strong>110</strong> 即可免费领取 10 本面试必刷八股文。
<img src="https://files.mdnice.com/user/13837/4b47ac79-8256-47cf-ac1a-036729635246.png" alt="" loading="lazy"></p>
<hr>
<h1> 实战23：基于引入包选择具体实现类</h1>
<p>最近遇到一个需求场景，开源的工具包，新增了一个高级特性，会依赖json序列化工具，来做一些特殊操作；但是，这个辅助功能并不是必须的，也就是说对于使用这个工具包的业务方而言，正常使用完全不需要json相关的功能；如果我强引用某个json工具，一是对于不适用高级特性的用户而言没有必要；二则是我引入的json工具极有可能与使用者的不一致，会增加使用者的成本</p>
<p>因此我希望这个工具包对外提供时，并不会引入具体的json工具依赖；也就是说maven依赖中的<code>&lt;scope&gt;</code>设置为<code>provided</code>；具体的json序列化的实现，则取决于调用方自身引入了什么json工具包</p>
<p>那么可以怎么实现上面这个方式呢？</p>
<!-- more -->
<h2> 1.实现方式</h2>
<h3> 1.1. 任务说明</h3>
<p>上面的简单的说了一下我们需要做的事情，接下来我们重点盘一下，我们到底是要干什么</p>
<p>核心诉求相对清晰</p>
<ol>
<li>不强引入某个json工具</li>
<li>若需要使用高级特性，则直接使用当前环境中已集成的json序列化工具；若没有提供，则抛异常，不支持</li>
</ol>
<p>对于上面这个场景，常年使用Spring的我们估计不会陌生，Spring集成了很多的第三方开源组件，根据具体的依赖来选择最终的实现，比如日志，可以是logback，也可以是log4j；比如redis操作，可以是jedis，也可以是lettuce</p>
<p>那么Spring是怎么实现的呢？</p>
<h3> 1.2.具体实现</h3>
<p>在Spring中有个注解名为<code>ConditionalOnClass</code>，表示当某个类存在时，才会干某些事情（如初始化bean对象）</p>
<p>它是怎么是实现的呢？（感兴趣的小伙伴可以搜索一下，或者重点关注下 <code>SpringBootCondition</code> 的实现）</p>
<p>这里且抛开Spring的实现姿势，我们采用传统的实现方式，直接判断是否有加载对应的类，来判断有没有引入相应的工具包</p>
<p>如需要判断是否引入了gson包，则判断ClassLoader是否有加载<code>com.google.gson.Gson</code>类</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这种实现方式就可以达到我们的效果了；接下来我们参考下Spring的ClassUtils实现，做一个简单的封装，以判断是否存在某个类</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>工具类存在之后，我们实现一个简单的json工具类，根据已有的json包来选择具体的实现</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的实现中，根据已有的json序列化工具，选择具体的实现类，我们定义了一个JsonApi接口，然后分别gson,jackson,fastjson给出默认的实现类</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>最后的问题来了，如果调用方并没有使用上面三个序列化工具，而是使用其他的呢，可以支持么？</p>
<p>既然我们定义了一个JsonApi，那么是不是可以由用户自己来实现接口，然后自动选择它呢？</p>
<p>现在的问题就是如何找到用户自定义的接口实现了</p>
<h3> 1.3. 扩展机制</h3>
<p>对于SPI机制比较熟悉的小伙伴可能非常清楚，可以通过在配置目录<code>META-INF/services/</code>下新增接口文件，内容为实现类的全路径名称，然后通过 <code>ServiceLoader.load(JsonApi.class)</code> 的方式来获取所有实现类</p>
<p>除了SPI的实现方式之外，另外一个策略则是上面提到的Spring的实现原理，借助字节码来处理（详情原理后面专文说明）</p>
<p>当然也有更容易想到的策略，扫描包路径下的class文件，遍历判断是否为实现类(额外注意jar包内的实现类场景)</p>
<p>接下来以SPI的方式来介绍下扩展实现方式，首先初始化JsonApi的方式改一下，优先使用用户自定义实现</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对于使用者而言，首先是实现接口</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接着就是实现定义, <code>resources/META-INF/services/</code> 目录下，新建文件名为 <code>com.github.hui.quick.plugin.qrcode.util.json.JsonApi</code></p>
<p>内容如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>然后完工~</p>
<h2> 2. 小结</h2>
<p>主要介绍一个小的知识点，如何根据应用已有的jar包来选择具体的实现类的方式；本文介绍的方案是通过ClassLoader来尝试加载对应的类，若能正常加载，则认为有；否则认为没有；这种实现方式虽然非常简单，但是请注意，它是有缺陷的，至于缺陷是啥...</p>
<p>除此之外，也可以考虑通过字节码的方式来判断是否有某个类，或者获取某个接口的实现；文中最后抛出了一个问题，如何获取接口的所有实现类</p>
<p>常见的方式有下面三类（具体介绍了SPI的实现姿势，其他的两种感兴趣的可以搜索一下）</p>
<ul>
<li>SPI定义方式</li>
<li>扫描包路径</li>
<li>字节码方式(如Spring，如Tomcat的<code>@HandlesTypes</code>)</li>
</ul>
<hr>
<p>微信搜 <strong>楼仔</strong> 或扫描下方二维码关注楼仔的原创公众号，回复 <strong>110</strong> 即可免费领取 10 本面试必刷八股文。
<img src="https://files.mdnice.com/user/13837/4b47ac79-8256-47cf-ac1a-036729635246.png" alt="" loading="lazy"></p>
<hr>
<h1> 实战24： 基于JDK的LRU算法实现</h1>
<h2> 1. LRU算法</h2>
<p>缓存淘汰算法--LRU算法LRU（Least recently used，最近最少使用）算法</p>
<p>根据数据的历史访问记录来进行淘汰数据，其核心思想是"如果数据最近被访问过，那么将来被访问的几率也更高"</p>
<p>再Java中可以非常简单的实现LRU算法，主要利用的是LinkedHashMap容器</p>
<h3> 1.1 LRU算法实现</h3>
<p>inkedHashMap底层就是用的HashMap加双链表实现的，而且本身已经实现了按照访问顺序的存储。此外，LinkedHashMap中本身就实现了一个方法removeEldestEntry用于判断是否需要移除最不常读取的数，方法默认是直接返回false，不会移除元素</p>
<p>因此我们只需要重写这个方法，可以实现当缓存满之后，就移除最不常用的数据</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意上面的访问，当i == 6 时，主动访问了一下 <code>一灰灰blog_2</code>，主要就是不希望淘汰掉它，再看下对应的输出</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>实际输出与我们预期一致</p>
<h3> 1.2 小结</h3>
<p>jdk中蕴含了大量的财富，就看我们能不能识别出来了；通常我非常推荐&lt;3年的小伙伴，有事没事多盘一下jdk的经典实现，比如各种容器的底层结构，并发类的设计思想等</p>
<hr>
<p>微信搜 <strong>楼仔</strong> 或扫描下方二维码关注楼仔的原创公众号，回复 <strong>110</strong> 即可免费领取 10 本面试必刷八股文。
<img src="https://files.mdnice.com/user/13837/4b47ac79-8256-47cf-ac1a-036729635246.png" alt="" loading="lazy"></p>
<hr>
<h1> 实战25： 数字型字面量中的下划线</h1>
<p>不知道有没有小伙伴看过下面这种写法，不用质疑，它没有语法错误；再很多开源的框架中可以看到类似的写法；这种再字面量中添加下划线的方式，是一种小却使用的编程小技巧，推荐给CURD开发者</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><!-- more -->
<h2> 1. Java7新特性之数字中使用下划线</h2>
<p>为了直观性而言，在大数之间，加上下划线用于肉眼区分，下面实例小结下用法</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>简单来说，就是在数中间，插上下划线，用于划分段落</p>
<h2> 2. 小结</h2>
<p>再字面量中添加下划线，主要用于分割大数，方便阅读，重点注意：</p>
<ul>
<li>不能在小数点正前后添加</li>
<li>不要在L/D/F等数据类型标识的正前方添加</li>
<li>不能作为数字开头，也不能作为结尾</li>
<li>不要往进制修饰符中间或后面添加</li>
</ul>
<hr>
<p>微信搜 <strong>楼仔</strong> 或扫描下方二维码关注楼仔的原创公众号，回复 <strong>110</strong> 即可免费领取 10 本面试必刷八股文。
<img src="https://files.mdnice.com/user/13837/4b47ac79-8256-47cf-ac1a-036729635246.png" alt="" loading="lazy"></p>
<hr>
<h1> 实战26：列表遍历删除使用实例</h1>
<p>在实际的业务开发中，容器的遍历可以说是非常非常常见的场景了，遍历删除呢，用的机会也不会少，但你真的会用么？</p>
<!-- more -->
<h2> 1. List遍历删除</h2>
<p>对于列表，这里以ArrayList进行举例说明，下面给出几种经常会遇到的写法</p>
<p>首先初始化一个list数组</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1.1. foreach</h3>
<p>这个属于我们最常见的foreach循环，在循环内部判断满足条件的直接删除</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这种写法导致的问题，很容易可以发现，因为上面代码跑完之后，堆栈就出来了</p>
<figure><img src="https://blog.hhui.top/hexblog/imgs/190521/00.jpg" alt="IMAGE" tabindex="0" loading="lazy"><figcaption>IMAGE</figcaption></figure>
<p>很典型的并发修改错误，在foreach循环中不允许删除,新增</p>
<h3> 1.2. 普通for循环</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这种写法呢？我们希望把列表中，第0，5，10，15位置的元素干掉，正常执行，倒是不会报错，然而输出的结果却和我们的预期不一致</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>for循环中，另外一种写法可能更加常见，为了避免每次都访问 <code>list.size()</code> 方法，我可能提前用一个变量保存数组大小</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这个问题就很明显了，数组越界</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1.3. 迭代方式</h3>
<p>下面这种可以说是标准的迭代删除的写法了，基本上大多都是这么玩</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1.4. jdk8+ 流方式</h3>
<p>jdk8+ 推荐下面这种写法，简洁明了</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2> 2. 小结</h2>
<p>注意不要在for/foreach遍历过程中删除元素，如果有移除元素的需求，使用迭代器；或者使用jdk8的流式写法也行</p>
<hr>
<p>微信搜 <strong>楼仔</strong> 或扫描下方二维码关注楼仔的原创公众号，回复 <strong>110</strong> 即可免费领取 10 本面试必刷八股文。
<img src="https://files.mdnice.com/user/13837/4b47ac79-8256-47cf-ac1a-036729635246.png" alt="" loading="lazy"></p>
<hr>
<h1> 实战27：HashMap遍历删除使用实例</h1>
<p>map的迭代删除，和我们常见的list，set不太一样，不能直接获取Iteraotr对象，提供的删除方法也是单个的，根据key进行删除，如果我们有个需求，将map中满足某些条件的元素删除掉，要怎么做呢？</p>
<!-- more -->
<h2> 1. Map 迭代删除</h2>
<p>迭代删除，在不考虑并发安全的前提下，我们看下可以怎么支持</p>
<h3> 1.1. 非常不优雅版本</h3>
<p>我们知道map并不是继承自Collection接口的，HashMap 也没有提供迭代支持，既然没法直接迭代，那我就老老实的low b版好了</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的实现怎么样？并没有什么毛病</p>
<p>(为啥不直接在遍历中删除？）</p>
<h3> 1.2. 正确姿势版</h3>
<p>虽然Map没有迭代，但是它的entrySet有啊，所以我们可以通过它来实现遍历删除</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这个可能是我们经常使用的操作姿势了，利用迭代器来操作元素</p>
<h3> 1.3. 简洁版</h3>
<p>到jdk8之后，针对容器提供了很多简洁的操作方式，迭代删除这方面可以说更加简单了</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 2. 小结</h2>
<p>和列表删除元素一样，不要在for/foreach迭代过程中删除数据，如有需要，迭代器才是正解；jdk8之后更推荐流式写法</p>
<hr>
<p>微信搜 <strong>楼仔</strong> 或扫描下方二维码关注楼仔的原创公众号，回复 <strong>110</strong> 即可免费领取 10 本面试必刷八股文。
<img src="https://files.mdnice.com/user/13837/4b47ac79-8256-47cf-ac1a-036729635246.png" alt="" loading="lazy"></p>
<hr>
<h1> 实战28：优雅的实现代码耗时统计</h1>
<p>在我们的实际开发中，多多少少会遇到统计一段代码片段的耗时的情况，我们一般的写法如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的写法没有什么毛病，但是看起来就不太美观了，那么有没有什么更优雅的写法呢？</p>
<!-- more -->
<h2> 1. 代理方式</h2>
<p>了解Spring AOP的同学可能立马会想到一个解决方法，如果想要统计某个方法耗时，使用切面可以无侵入的实现，如</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Spring AOP的底层支持原理为代理模式，为目标对象提供增强功能；在Spring的生态体系下，使用aop的方式来统计方法耗时，可以说少侵入且实现简单，但是有以下几个问题</p>
<ul>
<li>统计粒度为方法级别</li>
<li>类内部方法调用无法生效（详情可以参考博文：<a href="http://spring.hhui.top/spring-blog/2019/03/02/190302-SpringBoot%E5%9F%BA%E7%A1%80%E7%AF%87AOP%E4%B9%8B%E9%AB%98%E7%BA%A7%E4%BD%BF%E7%94%A8%E6%8A%80%E8%83%BD/" target="_blank" rel="noopener noreferrer">【SpringBoot 基础系列教程】AOP之高级使用技能</a>）</li>
</ul>
<h2> 2. AutoCloseable</h2>
<p>在JDK1.7引入了一个新的接口<code>AutoCloseable</code>, 通常它的实现类配合<code>try{}</code>使用，可在IO流的使用上，经常可以看到下面这种写法</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意上面的写法中，最值得关注一点是，不需要再主动的写<code>stream.close</code>了，主要原因就是在<code>try(){}</code>执行完毕之后，会调用方法<code>AutoCloseable#close</code>方法；</p>
<p>基于此，我们就会有一个大单的想法，下一个<code>Cost</code>类实现<code>AutoCloseable</code>接口，创建时记录一个时间，close方法中记录一个时间，并输出时间差值；将需要统计耗时的逻辑放入<code>try(){}</code>代码块</p>
<p>下面是一个具体的实现：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>执行后输出如下:</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果代码块抛异常，也会正常输出耗时么？</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>再次输出如下，并没有问题</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 3. 小结</h2>
<p>除了上面介绍的两种方式，还有一种在业务开发中不太常见，但是在中间件、偏基础服务的功能组件中可以看到，利用Java Agent探针技术来实现，比如阿里的arthas就是在JavaAgent的基础上做了各种上天的功能，后续介绍java探针技术时会专门介绍</p>
<p>下面小结一下三种统计耗时的方式</p>
<p><strong>基本写法</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>优点是简单，适用范围广泛；缺点是侵入性强，大量的重复代码</p>
<p><strong>Spring AOP</strong></p>
<p>在Spring生态下，可以借助AOP来拦截目标方法，统计耗时</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>优点：无侵入，适合统一管理（比如测试环境输出统计耗时，生产环境不输出）；缺点是适用范围小，且粒度为方法级别，并受限于AOP的使用范围</p>
<p><strong>AutoCloseable</strong></p>
<p>这种方式可以看做是第一种写法的进阶版</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>优点是：简单，适用范围广泛，且适合统一管理；缺点是依然有代码侵入</p>
<p><strong>说明</strong></p>
<p>上面第二种方法看着属于最优雅的方式，但是限制性强；如果有更灵活的需求，建议考虑第三种写法，在代码的简洁性和统一管理上都要优雅很多，相比较第一种可以减少大量冗余代码</p>
<hr>
<p>微信搜 <strong>楼仔</strong> 或扫描下方二维码关注楼仔的原创公众号，回复 <strong>110</strong> 即可免费领取 10 本面试必刷八股文。
<img src="https://files.mdnice.com/user/13837/4b47ac79-8256-47cf-ac1a-036729635246.png" alt="" loading="lazy"></p>
<hr>
<h1> 实战29：获取类路径的常见方式</h1>
<h2> 1. 资源路径查询</h2>
<p>在Java环境中，如何获取当前类的路径，如何获取项目根路径，可以说是比较常见的需求场景了，下面简单的记录一下</p>
<!-- more -->
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出如下:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 2. 小结</h2>
<ol>
<li><code>new File(this.getClass().getResource("/").getPath())</code>
<ul>
<li>获取类加载的根路径</li>
</ul>
</li>
<li><code>new File(this.getClass().getResource("").getPath())</code>
<ul>
<li>获取当前类的所在工程路径; 如果不加“/”  获取当前类的加载目录</li>
</ul>
</li>
<li><code>new File("").getCanonicalPath()</code>
<ul>
<li>获取项目路径</li>
</ul>
</li>
<li><code>this.getClass().getClassLoader().getResource("")</code></li>
<li><code>System.getProperty("user.dir")</code></li>
<li><code>System.getProperty("java.class.path")</code>
<ul>
<li>获取所有的类路径 包括jar包的路径</li>
</ul>
</li>
</ol>
<hr>
<p>微信搜 <strong>楼仔</strong> 或扫描下方二维码关注楼仔的原创公众号，回复 <strong>110</strong> 即可免费领取 10 本面试必刷八股文。
<img src="https://files.mdnice.com/user/13837/4b47ac79-8256-47cf-ac1a-036729635246.png" alt="" loading="lazy"></p>
<hr>
<h1> 实战30：JDK压缩与解压工具类</h1>
<p>在实际的应用场景中，特别是对外传输数据时，将原始数据压缩之后丢出去，可以说是非常常见的一个case了，平常倒是没有直接使用JDK原生的压缩工具类，使用Protosutff和Kryo的机会较多,正好在实际的工作场景中遇到了，现在简单的看下使用姿势</p>
<!-- more -->
<h2> 1. 压缩与解压工具类</h2>
<h3> 1.1. 基本实现</h3>
<p>主要借助的就是Deflater, Inflater两个工具类，其使用姿势如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>一个简单的测试</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1.2. 注意事项</h3>
<p>上面这个运作的还挺好，但在接入使用时，总是提示<code>java.util.zip.DataFormatException: incorrect header check</code>, 因为接受的是第三方传递过来的压缩数据，比较坑爹的是对方就写了个Deflater压缩，然后什么都没有了，那么这个是啥原因呢？</p>
<p>其实看下Deflater的构造方法，发现还可以传一个boolean值(nowrap), 官方说明是</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>简单来说，就是压缩时，如果nowrap为true，那么解压时也要为true；否则对不上时，就会抛异常</p>
<p>接下来简单对比下两种不同传参的情况，首先更新下工具类</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>测试如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果如下，从大小来看，前者小那么一点点</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 2. 小结</h2>
<p>一般来说，jdk自带的压缩与解压，除了方便之外，可能优势并不是那么的大，这里盗一张网上的对比表格</p>
<p>以下来自: <a href="https://www.cnblogs.com/lonelywolfmoutain/p/5563985.html" target="_blank" rel="noopener noreferrer">[java]序列化框架性能对比（kryo、hessian、java、protostuff）</a></p>
<table>
<thead>
<tr>
<th></th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>kryo</td>
<td>速度快，序列化后体积小</td>
<td>跨语言支持较复杂</td>
</tr>
<tr>
<td>hessian</td>
<td>默认支持跨语言</td>
<td>较慢</td>
</tr>
<tr>
<td>protostuff</td>
<td>速度快，基于protobuf</td>
<td>需静态编译</td>
</tr>
<tr>
<td>Protostuff-Runtime</td>
<td>无需静态编译，但序列化前需预先传入schema</td>
<td>不支持无默认构造函数的类，反序列化时需用户自己初始化序列化后的对象，其只负责将该对象进行赋值</td>
</tr>
<tr>
<td>jdk</td>
<td>使用方便，可序列化所有类</td>
<td>速度慢，占空间</td>
</tr>
</tbody>
</table>
<p>其次，在使用java的压缩与解压时，需要注意下，nowrap这个参数，需要保持一致，否则会报错</p>
<hr>
<p>微信搜 <strong>楼仔</strong> 或扫描下方二维码关注楼仔的原创公众号，回复 <strong>110</strong> 即可免费领取 10 本面试必刷八股文。
<img src="https://files.mdnice.com/user/13837/4b47ac79-8256-47cf-ac1a-036729635246.png" alt="" loading="lazy"></p>
<hr>
<h1> 实战31：深拷贝浅拷贝及对象拷贝的两种方式</h1>
<h2> 1. Java之Clone</h2>
<h3> 1.1 背景</h3>
<p>对象拷贝，是一个非常基础的内容了，为什么会单独的把这个领出来讲解，主要是先前遇到了一个非常有意思的场景</p>
<p>有一个任务，需要解析类xml标记语言，然后生成document对象，之后将会有一系列针对document对象的操作</p>
<p>通过实际的测试，发现生成Document对象是比较耗时的一个操作，再加上这个任务场景中，需要解析的xml文档是固定的几个，那么一个可以优化的思路就是能不能缓存住创建后的Document对象，在实际使用的时候clone一份出来</p>
<!-- more  -->
<h3> 1.2 内容说明</h3>
<p>看到了上面的应用背景，自然而言的就会想到深拷贝了，本篇博文则主要内容如下</p>
<ul>
<li>介绍下两种拷贝方式的区别</li>
<li>深拷贝的辅助工具类</li>
<li>如何自定义实现对象拷贝</li>
</ul>
<h2> 2. 深拷贝和浅拷贝</h2>
<h3> 2.1 定义说明</h3>
<p><strong>深拷贝</strong></p>
<p>相当于创建了一个新的对象，只是这个对象的所有内容，都和被拷贝的对象一模一样而已，即两者的修改是隔离的，相互之间没有影响</p>
<p><strong>浅拷贝</strong></p>
<p>也是创建了一个对象，但是这个对象的某些内容（比如A）依然是被拷贝对象的，即通过这两个对象中任意一个修改A，两个对象的A都会受到影响</p>
<p>看到上面两个简单的说明，那么问题来了</p>
<ul>
<li>浅拷贝中，是所有的内容公用呢？还是某些内容公用？</li>
<li>从隔离来将，都不希望出现浅拷贝这种方式了，太容易出错了，那么两种拷贝方式的应用场景是怎样的？</li>
</ul>
<h3> 2.2 浅拷贝</h3>
<p>一般来说，浅拷贝方式需要实现<code>Cloneable</code>接口，下面结合一个实例，来看下浅拷贝中哪些是独立的，哪些是公用的</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>结果分析：</p>
<ul>
<li>拷贝后获取的是一个独立的对象，和原对象拥有不同的内存地址</li>
<li>基本元素类型，两者是隔离的（虽然上面只给出了int，String）
<ul>
<li>基本元素类型包括:</li>
<li>int, Integer, long, Long, char, Charset, byte,Byte, boolean, Boolean, float,Float, double, Double, String</li>
</ul>
</li>
<li>非基本数据类型（如基本容器，其他对象等），只是拷贝了一份引用出去了，实际指向的依然是同一份</li>
</ul>
<p>其实，浅拷贝有个非常简单的理解方式：</p>
<p><strong>浅拷贝的整个过程就是，创建一个新的对象，然后新对象的每个值都是由原对象的值，通过 <code>=</code> 进行赋值</strong></p>
<p>这个怎么理解呢？</p>
<p>上面的流程拆解就是：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>那么=赋值有什么特点呢？</p>
<p>基本数据类型是值赋值；非基本的就是引用赋值</p>
<h3> 2.3 深拷贝</h3>
<p>深拷贝，就是要创建一个全新的对象，新的对象内部所有的成员也都是全新的，只是初始化的值已经由被拷贝的对象确定了而已</p>
<p>那么上面的实例改成深拷贝应该是怎样的呢？</p>
<p>可以加上这么一个方法</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果为：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>结果分析：</p>
<ul>
<li>深拷贝独立的对象</li>
<li>拷贝后对象的内容，与原对象的内容完全没关系，都是独立的</li>
</ul>
<p>简单来说，深拷贝是需要自己来实现的，对于基本类型可以直接赋值，而对于对象、容器、数组来讲，需要创建一个新的出来，然后重新赋值</p>
<h3> 2.4 应用场景区分</h3>
<p>深拷贝的用途我们很容易可以想见，某个复杂对象创建比较消耗资源的时候，就可以缓存一个蓝本，后续的操作都是针对深clone后的对象，这样就不会出现混乱的情况了</p>
<p>那么浅拷贝呢？感觉留着是一个坑，一个人修改了这个对象的值，结果发现对另一个人造成了影响，真不是坑爹么？</p>
<p>假设又这么一个通知对象长下面这样</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们现在随机挑选了一千个人，同时发送通知消息，所以需要创建一千个上面的对象，这些对象中呢，除了notifyUser不同，其他的都一样</p>
<p>在发送之前，突然发现要临时新增一条通知信息，如果是浅拷贝的话，只用在任意一个通知对象的notifyRules中添加一调消息，那么这一千个对象的通知消息都会变成最新的了；而如果你是用深拷贝，那么苦逼的得遍历这一千个对象，每个都加一条消息了</p>
<hr>
<h2> 3. 对象拷贝工具</h2>
<p>上面说到，浅拷贝，需要实现Clonebale接口，深拷贝一般需要自己来实现，那么我现在拿到一个对象A，它自己没有提供深拷贝接口，我们除了主动一条一条的帮它实现之外，有什么辅助工具可用么？</p>
<p>对象拷贝区别与clone，它可以支持两个不同对象之间实现内容拷贝</p>
<p><strong>Apache的两个版本：（反射机制）</strong></p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>Spring版本：（反射机制）</strong></p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>cglib版本：（使用动态代理，效率高）</strong></p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>从上面的几个有名的工具类来看，提供了两种使用者姿势，一个是反射，一个是动态代理，下面分别来看两种思路</p>
<h3> 3.1 借助反射实现对象拷贝</h3>
<p>通过反射的方式实现对象拷贝的思路还是比较清晰的，先通过反射获取对象的所有属性，然后修改可访问级别，然后赋值；再获取继承的父类的属性，同样利用反射进行赋值</p>
<p>上面的几个开源工具，内部实现封装得比较好，所以直接贴源码可能不太容易一眼就能看出反射方式的原理，所以简单的实现了一个, 仅提供思路</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的实现步骤还是非常清晰的，首先是找同名的属性，然后利用反射获取对应的值</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果找不到，则找getXXX, isXXX来获取</p>
<h3> 3.2 代理的方式实现对象拷贝</h3>
<p>Cglib的BeanCopier就是通过代理的方式实现拷贝，性能优于反射的方式，特别是在大量的数据拷贝时，比较明显</p>
<p>代理，我们知道可以区分为静态代理和动态代理，简单来讲就是你要操作对象A，但是你不直接去操作A，而是找一个中转porxyA, 让它来帮你操作对象A</p>
<p>那么这种技术是如何使用在对象拷贝的呢？</p>
<p>我们知道，效率最高的对象拷贝方式就是Getter/Setter方法了，前面说的代理的含义指我们不直接操作，而是找个中间商来赚差价，那么方案就出来了</p>
<p>将原SourceA拷贝到目标DestB</p>
<ul>
<li>创建一个代理 copyProxy</li>
<li>在代理中，依次调用 SourceA的get方法获取属性值，然后调用DestB的set方法进行赋值</li>
</ul>
<p>实际上BeanCopier的思路大致如上，具体的方案当然就不太一样了, 简单看了一下实现逻辑，挺有意思的一块，先留个坑，后面单独开个博文补上</p>
<p><strong>说明</strong></p>
<p>从实现原理和通过简单的测试，发现BeanCopier是扫描原对象的getXXX方法，然后赋值给同名的 setXXX 方法，也就是说，如果这个对象中某个属性没有get/set方法，那么就无法赋值成功了</p>
<hr>
<h2> 3. 小结</h2>
<h3> 3.1 深拷贝和浅拷贝</h3>
<p><strong>深拷贝</strong></p>
<blockquote>
<p>相当于创建了一个新的对象，只是这个对象的所有内容，都和被拷贝的对象一模一样而已，即两者的修改是隔离的，相互之间没有影响</p>
</blockquote>
<ul>
<li>完全独立</li>
</ul>
<p><strong>浅拷贝</strong></p>
<blockquote>
<p>也是创建了一个对象，但是这个对象的某些内容（比如A）依然是被拷贝对象的，即通过这两个对象中任意一个修改A，两个对象的A都会受到影响</p>
</blockquote>
<ul>
<li>等同与新创建一个对象，然后使用=，将原对象的属性赋值给新对象的属性</li>
<li>需要实现Cloneable接口</li>
</ul>
<h3> 3.2 对象拷贝的两种方法</h3>
<p><strong>通过反射方式实现对象拷贝</strong></p>
<p>主要原理就是通过反射获取所有的属性，然后反射更改属性的内容</p>
<p><strong>通过代理实现对象拷贝</strong></p>
<p>将原SourceA拷贝到目标DestB</p>
<p>创建一个代理 copyProxy
在代理中，依次调用 SourceA的get方法获取属性值，然后调用DestB的set方法进行赋值</p>
<hr>
<p>微信搜 <strong>楼仔</strong> 或扫描下方二维码关注楼仔的原创公众号，回复 <strong>110</strong> 即可免费领取 10 本面试必刷八股文。
<img src="https://files.mdnice.com/user/13837/4b47ac79-8256-47cf-ac1a-036729635246.png" alt="" loading="lazy"></p>
<hr>
<h1> 实战32：Java可以如何实现文件变动的监听</h1>
<p>应用中使用logback作为日志输出组件的话，大部分会去配置 <code>logback.xml</code> 这个文件，而且生产环境下，直接去修改logback.xml文件中的日志级别，不用重启应用就可以生效</p>
<p>那么，这个功能是怎么实现的呢？</p>
<!-- more -->
<h2> 1. 问题描述及分析</h2>
<p>针对上面的这个问题，首先抛出一个实际的case，在我的个人网站 * <a href="https://tool.hhui.top/" target="_blank" rel="noopener noreferrer">神奇工具箱 - 小工具集合</a> 中，所有的小工具都是通过配置文件来动态新增和隐藏的，因为只有一台服务器，所以配置文件就简化的直接放在了服务器的某个目录下</p>
<p>现在的问题时，我需要在这个文件的内容发生变动时，应用可以感知这种变动，并重新加载文件内容，更新应用内部缓存</p>
<p>一个最容易想到的方法，就是轮询，判断文件是否发生修改，如果修改了，则重新加载，并刷新内存，所以主要需要关心的问题如下：</p>
<ul>
<li>如何轮询？</li>
<li>如何判断文件是否修改？</li>
<li>配置异常，会不会导致服务不可用？（即容错，这个与本次主题关联不大，但又比较重要...）</li>
</ul>
<h2> 2. 设计与实现</h2>
<p>问题抽象出来之后，对应的解决方案就比较清晰了</p>
<ul>
<li>如何轮询 ？ --》 定时器 Timer, ScheduledExecutorService 都可以实现</li>
<li>如何判断文件修改？ --》根据 <code>java.io.File#lastModified</code> 获取文件的上次修改时间，比对即可</li>
</ul>
<p>那么一个很简单的实现就比较容易了:</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这个属于一个非常简单，非常基础的实现了，基本上也可以满足我们的需求，那么这个实现有什么问题呢？</p>
<p><strong>定时任务的执行中，如果出现了异常会怎样？</strong></p>
<p>对上面的代码稍作修改</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>实际测试，发现只有首次修改的时候，触发了上面的代码，但是再次修改则没有效果了，即当抛出异常之后，定时任务将不再继续执行了，这个问题的主要原因是因为 <code>ScheduledExecutorService</code> 的原因了</p>
<p>直接查看ScheduledExecutorService的源码注释说明</p>
<blockquote>
<p>If any execution of the task encounters an exception, subsequent executions are suppressed.Otherwise, the task will only terminate via cancellation or termination of the executor.
即如果定时任务执行过程中遇到发生异常，则后面的任务将不再执行。</p>
</blockquote>
<p><strong>所以，使用这种姿势的时候，得确保自己的任务不会抛出异常，否则后面就没法玩了</strong></p>
<p>对应的解决方法也比较简单，整个catch一下就好</p>
<h2> 3. 进阶版</h2>
<p>前面是一个基础的实现版本了，当然在java圈，基本上很多常见的需求，都是可以找到对应的开源工具来使用的，当然这个也不例外，而且应该还是大家比较属性的apache系列</p>
<h3> 3.1 apache版</h3>
<p>首先maven依赖</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>主要是借助这个工具中的 <code>FileAlterationObserver</code>, <code>FileAlterationListener</code>, <code>FileAlterationMonitor</code> 三个类来实现相关的需求场景了，当然使用也算是很简单了，以至于都不太清楚可以再怎么去说明了，直接看下面从我的一个开源项目quick-alarm中拷贝出来的代码</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>针对上面的实现，简单说明几点：</p>
<ul>
<li>这个文件监听，是以目录为根源，然后可以设置过滤器，来实现对应文件变动的监听</li>
<li>如上面<code>registerConfChangeListener</code>方法，传入的file是具体的配置文件，因此构建参数的时候，捞出了目录，捞出了文件名作为过滤</li>
<li>第二参数是jdk8语法，其中为具体的读取配置文件内容，并映射为对应的实体对象</li>
</ul>
<p>一个问题，如果 func方法执行时，也抛出了异常，会怎样？</p>
<p>实际测试表现结果和上面一样，抛出异常之后，依然跪，所以依然得注意，不要跑异常</p>
<p>那么简单来看一下上面的实现逻辑，直接扣出核心模块</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从上面基本上一目了然，整个的实现逻辑了，和我们的第一种定时任务的方法不太一样，这儿直接使用线程，死循环，内部采用sleep的方式来来暂停，因此出现异常时，相当于直接抛出去了，这个线程就跪了</p>
<h3> 3.2 JDK版本</h3>
<p>jdk1.7，提供了一个<code>WatchService</code>，也可以用来实现文件变动的监听，之前也没有接触过，看到说明，然后搜了一下使用相关，发现也挺简单的，同样给出一个简单的示例demo</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 4. 小结</h2>
<p>使用Java来实现配置文件变动的监听，主要涉及到的就是两个点</p>
<ul>
<li>如何轮询：  定时器（Timer, ScheduledExecutorService）, 线程死循环+sleep</li>
<li>文件修改： File#lastModified</li>
</ul>
<p>整体来说，这个实现还是比较简单的，无论是自定义实现，还是依赖 commos-io来做，都没太大的技术成本，但是需要注意的一点是：</p>
<ul>
<li>千万不要在定时任务 or 文件变动的回调方法中抛出异常！！！</li>
</ul>
<p>为了避免上面这个情况，一个可以做的实现是借助EventBus的异步消息通知来实现，当文件变动之后，发送一个消息即可，然后在具体的重新加载文件内容的方法上，添加一个 <code>@Subscribe</code>注解即可，这样既实现了解耦，也避免了异常导致的服务异常 （如果对这个实现有兴趣的可以评论说明）</p>
<hr>
<p>微信搜 <strong>楼仔</strong> 或扫描下方二维码关注楼仔的原创公众号，回复 <strong>110</strong> 即可免费领取 10 本面试必刷八股文。
<img src="https://files.mdnice.com/user/13837/4b47ac79-8256-47cf-ac1a-036729635246.png" alt="" loading="lazy"></p>
<hr>
<h1> 实战33：实用的Map初始化工具类</h1>
<p>虽说java作为编译语言，但是它本身也提供了很多运行时能力，今天介绍一个非常基础的知识点，可变参数传递</p>
<!-- more -->
<p>在日常的开发过程中，创建Map对象还是比较常见的，现在我希望写一个工具类，可以非常简单创建并初始化Map对象</p>
<p>因此我们可以实现一个MapUtil工具类，来支持这个场景</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意一下上面的实现，kv这个参数就是我们要说的可变参数，在方法内部，kv可以看成是一个数组对象（而且是安全的对象，当不传递时，它的取值也不是null）</p>
<p>在使用可变参数时，下面是一些需要注意的点</p>
<p><strong>可变参数注意与数组参数的冲突</strong></p>
<p>注意下面的两个方法，不能同时出现，直接出现编译错误</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>重载的选择</strong></p>
<p>如果只有一个可变参数的方法，<code>newMap("key", "value")</code>不会报错，会直接访问下面这个方法，kv参数为空数组</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>当出现重载时，即如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>上面两个方法的调用，如果传参只有两个时，会调用哪个？</p>
<ul>
<li><code>newMap("key", "value")</code> 调用的下面的方法</li>
<li>`newMap("key", "value", "k", "v") 调用的上面的方法</li>
</ul>
<p><strong>可变参数传数组会怎样</strong></p>
<p>虽说我们在使用的时候，将可变参数当做数组来使用，但是传递时，若传数组，是否可行呢？</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>实际输出如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>从实际测试来看，传数组并没有问题</p>
<hr>
<p>微信搜 <strong>楼仔</strong> 或扫描下方二维码关注楼仔的原创公众号，回复 <strong>110</strong> 即可免费领取 10 本面试必刷八股文。
<img src="https://files.mdnice.com/user/13837/4b47ac79-8256-47cf-ac1a-036729635246.png" alt="" loading="lazy"></p>
<hr>
<h1> 实战34：通用的根据路径获取文件资源的工具类</h1>
<p>通常我们最多的场景是从本地资源中读取文件，这个时候我们经常需要注意的是相对路径、绝对路径问题；</p>
<p>除了从本地获取文件之外，从网络中获取文件资源（如图片）也属于相对常见的场景，接下来我们封装一个工具类，可以支持以上各种类型的数据读取</p>
<!-- more -->
<h2> 1. 工具实现类</h2>
<p>首先定义一个公共方法如下，内部支持四种方式的数据获取</p>
<ul>
<li>相对路径</li>
<li>绝对路径</li>
<li>用户根目录</li>
<li>网络</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>请注意上面的实现，绝对路径与相对路径比较好理解，用户目录，这个处理又是怎样的呢？</p>
<p>关键点在于，用户目录转绝对路径</p>
<ul>
<li>借助<code>System.getProperties</code>系统属性来处理</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来再看如何判断一个路径是否为绝对路径呢？</p>
<p>这里需要格外注意不同操作系统的差异性，比如win，区分C盘，D盘，但是mac/linux则不分这个，上面判断的核心逻辑如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>除了上面的三种本地资源获取之外，还有一个就是网络资源的读取，上面介绍的实现姿势主要是基于JDK原生的URL，在实际使用时，这个并不稳定，不能确定能获取到完整的数据，原则上不推荐使用；如果可以，使用http-client/okhttp都是不错的选择</p>
<p>最后给一个简单的测试</p>
<p>最后一个简单下载图片的case</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0542b4ae409b4336a431fac44c1cef5f~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure>
<hr>
<p>微信搜 <strong>楼仔</strong> 或扫描下方二维码关注楼仔的原创公众号，回复 <strong>110</strong> 即可免费领取 10 本面试必刷八股文。
<img src="https://files.mdnice.com/user/13837/4b47ac79-8256-47cf-ac1a-036729635246.png" alt="" loading="lazy"></p>
<hr>
<h1> 实战35：调用本地程序的几种姿势</h1>
<p>作为一个后端同学，经常被安全的小伙伴盯上，找一找安全漏洞；除了常说的注入之外，还有比较吓人的执行远程命令，唤醒本地应用程序等；然后有意思的问题就来了，写了这么多年的代码，好像还真没有尝试过用java来唤醒本地应用程序的</p>
<p>比如说一个最简单的，打开本地的计算器，应该怎么搞？</p>
<p>接下来本文将介绍一下如何使用java打开本地应用，以及打开mac系统中特殊一点的处理方式（直白来说就是不同操作系统，使用姿势不一样）</p>
<!-- more -->
<h2> 1. Runtime使用方式</h2>
<p>主要是基于<code>Runtime.getRuntime().exec()</code>来执行shell命令，来打开应用</p>
<ul>
<li>传参就是需要打开的应用名</li>
</ul>
<p>比如上面说到的打开计算器</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从上面的传参也可以看出两者的区别，为什么mac会整一个 <code>open -n</code>， 这个其实可以理解为在终端执行命令，打开计算器</p>
<p><strong>注意事项</strong></p>
<p>对于mac系统而言，除了上面这种打开方式之外，还有下面这种姿势</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>在exec中指定计算器的路径，有个很容易采的坑，直接写成下面这种</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面这个直接执行之后会提示<code>权限错误</code>，其主要原因是mac系统的应用和win中的exe作为启动方式不太一样，对于mac而言，可以理解<code>xxx.app</code>为一个目录，真正执行文件是内部的<code>xxx/Contents/MacOS/xxx</code></p>
<h2> 2. ProcessBuilder使用方式</h2>
<p>除了Runtime唤起之外，使用ProcessBuilder也属于非常常见的case</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用上面这种姿势，特别需要注意的是内部传参不能是<code>open -n</code></p>
<h2> 3. 小结</h2>
<p>从上面介绍的方式来看，其实打开应用程序的思路主要就是利用java来执行脚本命令；内容比较简单，隐患却是比较大的；在自己的项目中，最好不要出现这种调用方式</p>
<p>微信搜 <strong>楼仔</strong> 或扫描下方二维码关注楼仔的原创公众号，回复 <strong>110</strong> 即可免费领取 10 本面试必刷八股文。
<img src="https://files.mdnice.com/user/13837/4b47ac79-8256-47cf-ac1a-036729635246.png" alt="" loading="lazy"></p>
<hr>
<h1> 实战36：技术派开源项目</h1>
<p>大家好，足足搞了半年，我们的第一个项目——技术派，终于上线啦！</p>
<p>之前就有很多粉丝催，久等了各位！心急的小伙伴，可以到文末直接看网站域名。</p>
<p>在此之前，我先来介绍（吹一吹）网站。</p>
<h2> 网站内容有什么？</h2>
<p>技术派致力于打造一个完整的社区平台，采用现阶段最流行的技术实现。</p>
<p>网站的内容丰富，又不失整洁，整体以橘色为主色调，颜值很高。</p>
<figure><img src="https://files.mdnice.com/user/13837/180e1ba7-7074-43b7-9250-ac6bc158b1a9.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>什么，卡片的颜色不喜欢？我们还有其它的，<strong>这些色系是根据图片自动识别</strong>，满满的黑科技。</p>
<figure><img src="https://files.mdnice.com/user/13837/0d4b3010-58a1-4279-9268-574981ca81e9.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>再看看文章详情页，整个阅读体验非常不错。</p>
<figure><img src="https://files.mdnice.com/user/13837/9d52c137-5b44-4ffe-a6a8-98df2d40f739.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>除了文章，我们还有配套的教程，目前的教程，都是楼仔的原创系列文章，让你刷得飞起，嘎嘎。。。</p>
<figure><img src="https://files.mdnice.com/user/13837/4492a683-f131-4320-b8fe-e3d5e78a567e.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>下面是个人中心，还是我喜欢的配色，如果你也喜欢写文，欢迎入驻哈，没事一起侃侃大山。</p>
<figure><img src="https://files.mdnice.com/user/13837/5b9617c7-b728-4824-9331-b538933b7e3a.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>那如何登录呢？当然是微信扫码呗，来来，一起扫一扫，公众号内输入验证码，即可登录成功，是不是很方便？</p>
<figure><img src="https://files.mdnice.com/user/13837/8d8b4592-0e64-49e7-8caf-a8386f60cb08.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>告诉你一个秘密，<strong>登录后，还会有惊喜哦</strong>，一般人我不告诉他，嘿嘿。。。</p>
<p>除了前端，我们也有自己的运营后台，文末有登录方式。</p>
<figure><img src="https://files.mdnice.com/user/13837/fbacda81-41a9-4f88-8eac-d3826828df47.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> 技术派能给你提供什么帮助呢？</h2>
<p>可能有粉丝会问 “市面上的技术网站已经很多，你们为啥还要做一个呢？”</p>
<p>其实我们做这个网站的目的，<strong>主要是为了教大家如何从 0 到 1 去构建一个商业化的社区平台</strong>，特别是对于那些缺乏项目经验，或者需要深入学习 Java 的同学。</p>
<p>下面我就给大家讲讲，技术派用到哪些牛逼的框架的技术。</p>
<p>技术派包括前台社区系统和后台管理系统，基于 SpringBoot + MyBatis Plus 实现，采用 Docker 容器化部署。</p>
<p><strong>前台社区系统</strong>包括首页门户、文章浏览、文章编辑、文章搜索、系列教程、登录鉴权、用户评论、点赞收藏、个人中心、消息通知、广告运营、粉丝管理等模块。</p>
<p><strong>后台管理系统</strong>包括数据统计、运营配置、分类管理、标签管理、文章管理、教程配置、教程文章、权限管理等模块。</p>
<p>是不是讲的太泛？给你来一张系统架构图，所有的模块和技术，都能一目了然。</p>
<figure><img src="https://files.mdnice.com/user/13837/6cfb2a84-78cd-45b6-80b3-15ab422997c4.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>再来一张业务架构图，让你对前后台模块更清晰。</p>
<figure><img src="https://files.mdnice.com/user/13837/7720af6c-2ae4-47ea-aad4-593d74347d81.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>有同学会说，楼哥，我想要更详细的模块介绍，好好学学，好嘞，下面就给安排上。</p>
<figure><img src="https://files.mdnice.com/user/13837/ac8f2050-5d19-447e-be3b-19776c11e32a.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>这个是我们的开发进度，核心功能都已完成，后面也会持续迭代。</p>
<figure><img src="https://files.mdnice.com/user/13837/86ee6878-33cf-4bc8-a746-a8648ac5256c.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>最后就是大家最关心的地方，我们的项目源码能下载么，那必须的，我们的项目完全开源！</p>
<p>对，你没有听错，文末有 GitHub 地址，大家可以自行下载。</p>
<p>同时，我们后续也会出配套的项目教程，无论你是小白，还是有一定工作经验的同学，这套教程都会帮你进阶，让你大厂 Offer 拿到手软。</p>
<p>这套教程直接对标大厂，下面是教程目录。</p>
<figure><img src="https://files.mdnice.com/user/13837/f84b0111-4cf3-41e1-a8bd-ada028071b04.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>由于出教程比较花时间，所以前期的教程，会在楼仔的公众号中连载，请大家持续关注哈。</p>
<p>最后告诉大家一个秘密，后面我们也会开通<strong>技术派的知识星球</strong>，更好去帮助大家学习这个项目，有没有亿点小期待呢？</p>
<h2> 网站地址</h2>
<p>好了，楼仔不啰嗦了，大家自己去体验下网站吧。</p>
<ul>
<li>
<p><strong>前台地址</strong>：<a href="https://paicoding.com" target="_blank" rel="noopener noreferrer">https://paicoding.com</a></p>
</li>
<li>
<p><strong>后台地址</strong>：<a href="https://paicoding.com/admin-view" target="_blank" rel="noopener noreferrer">https://paicoding.com/admin-view</a></p>
</li>
</ul>
<p>前台可以直接访问，后台需要扫描/长按下方的二维码关注「楼仔」的公众号后，<strong>回复 “001” 即可获取登录账号和密码。</strong></p>
<figure><img src="https://files.mdnice.com/user/13837/e670d6d3-b4d8-4c17-80c0-fa2dd68000e4.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>大家在体验的过程中，如果发现任何问题，都可以直接在 Github 上提交 PR，我们会定期 fix。</p>
<ul>
<li>
<p>前台社区系统 GitHub：<a href="https://github.com/itwanger/paicoding" target="_blank" rel="noopener noreferrer">https://github.com/itwanger/paicoding</a></p>
</li>
<li>
<p>后台管理系统 GitHub：<a href="https://github.com/itwanger/paicoding-admin" target="_blank" rel="noopener noreferrer">https://github.com/itwanger/paicoding-admin</a></p>
</li>
</ul>
<p>欢迎大家奔走相告，将技术派网站分享给你们的朋友，他们一定很感激你告诉他这么牛逼的学习资源。</p>
<blockquote>
<p>我从清晨走过，也拥抱夜晚的星辰，人生没有捷径，你我皆平凡，你好，陌生人，一起共勉。</p>
</blockquote>
]]></content:encoded>
      <enclosure url="http://cdn.hhui.top/column/java_cover.png" type="image/png"/>
    </item>
    <item>
      <title>关于我</title>
      <link>https://liuyueyi.github.io/tutorial/me/</link>
      <guid>https://liuyueyi.github.io/tutorial/me/</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">关于我</source>
      <description>关于我</description>
      <pubDate>Fri, 17 Feb 2023 14:22:08 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 关于我</h2>
]]></content:encoded>
    </item>
    <item>
      <title>关于我</title>
      <link>https://liuyueyi.github.io/tutorial/me/about-me.html</link>
      <guid>https://liuyueyi.github.io/tutorial/me/about-me.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">关于我</source>
      <description>1. 自我介绍 不习惯分享私人相关的，简单说几个关键点 常用名：一灰，一灰灰，一灰灰blog 性别：男 工作：8+ 履历：一线大厂、千人规模、创业团队、国企都待过 2. 有啥成就 比较惭愧，没有太大的成就，业内也不算出名，甚至是小透明 个人网站： www.hhui.top GitHub： https://github.com/liuyueyi 上架的app： https://play.google.com/store/apps/details?id=com.yhh.zhongdian 活跃网站： https://juejin.cn/user/377887729916126</description>
      <pubDate>Fri, 17 Feb 2023 14:22:08 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 1. 自我介绍</h2>
<p>不习惯分享私人相关的，简单说几个关键点</p>
<ul>
<li>常用名：一灰，一灰灰，一灰灰blog</li>
<li>性别：男</li>
<li>工作：8+</li>
<li>履历：一线大厂、千人规模、创业团队、国企都待过</li>
</ul>
<h2> 2. 有啥成就</h2>
<p>比较惭愧，没有太大的成就，业内也不算出名，甚至是小透明</p>
<ul>
<li>个人网站： <a href="www.hhui.top">www.hhui.top</a></li>
<li>GitHub： <a href="https://github.com/liuyueyi" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi</a></li>
<li>上架的app： <a href="https://play.google.com/store/apps/details?id=com.yhh.zhongdian" target="_blank" rel="noopener noreferrer">https://play.google.com/store/apps/details?id=com.yhh.zhongdian</a></li>
<li>活跃网站： <a href="https://juejin.cn/user/377887729916126" target="_blank" rel="noopener noreferrer">https://juejin.cn/user/377887729916126</a></li>
</ul>
<h2> 3. 什么时候开始的分享</h2>
<p>最早是在16、17年的时候开始在开源中国上分享一些自己的笔记，然后就一直坚持了下来，至今所有的文章加起来应该也有五六百篇了，当然其中有很多比较水；但也有不少文章是注入了心血的</p>
<p>有到我站点逛的小伙伴可能也看到了，有几个分站</p>
<ul>
<li><a href="https://blog.hhui.top" target="_blank" rel="noopener noreferrer">https://blog.hhui.top</a> ： 最早搭建的博客站点，记录的内容多，且零散，检索阅读并不友好，虽然东西很多，但是很多时候我自己都找不到，更何况其他的小伙伴呢</li>
<li><a href="https://spring.hhui.top" target="_blank" rel="noopener noreferrer">https://spring.hhui.tpp</a>： 这个站点相比于上面一个更垂直一点，全是spring相关的博文，每一篇文章都搭配有对应的项目源码，目前也在持续更新迭代中</li>
<li><a href="https://hhui.top" target="_blank" rel="noopener noreferrer">https://hhui.top</a>：主站点，为了解决上面说到的知识点分散的问题，近期我也在做知识汇总，形成一个一个专栏性质的小册，后续也会逐渐整理为pdf，供有离线学习诉求的小伙伴查阅</li>
</ul>
<h2> 4. 最近在干什么</h2>
<p>在22年中开始，和楼仔（强烈推荐关注他的公众号“楼仔”，分享的都是技术干活）凑一起搞事情，目前项目已上线，一个开源的博客论坛系统，将会围绕这个项目，出一版相关的教程，希望能基于此为各位有志于从事编程事业的小伙伴，提供一个极佳的练手项目、学习平台</p>
<ul>
<li>源码地址：<a href="https://github.com/itwanger/paicoding" target="_blank" rel="noopener noreferrer">https://github.com/itwanger/paicoding</a></li>
<li>论坛地址：<a href="https://paicoding.com/" target="_blank" rel="noopener noreferrer">https://paicoding.com/</a></li>
</ul>
<h2> 5. 有公众号么</h2>
<p>我的公众号是："一灰灰blog"， 有兴趣的小伙伴可以关注一波</p>
<figure><img src="https://spring.hhui.top/spring-blog/imgs/info/info.png" alt="一灰灰的公众号" tabindex="0" loading="lazy"><figcaption>一灰灰的公众号</figcaption></figure>
<p>我的小伙伴楼仔的公众号： "楼仔" 同时也推荐各位</p>
<figure><img src="https://files.mdnice.com/user/13837/4b47ac79-8256-47cf-ac1a-036729635246.png" alt="楼仔的公众号" tabindex="0" loading="lazy"><figcaption>楼仔的公众号</figcaption></figure>
<h2> 6. 有什么学习的资料么</h2>
<p>找楼仔，他有很多pdf</p>
<h2> 7. 有什么学习的建议么</h2>
<p>我一般做不来指路明灯，或者导师的角色；一个建议就是跟着大佬后面走</p>
<h2> 8. 怎么联系我</h2>
<ul>
<li>QQ : 3302797840</li>
<li>微信 : liuyueyi25</li>
<li>邮箱 : <a href="mailto:bangzewu@126.com">bangzewu@126.com</a></li>
<li>微博 : 一灰灰blog (基本上不活跃)</li>
</ul>
]]></content:encoded>
      <enclosure url="https://spring.hhui.top/spring-blog/imgs/info/info.png" type="image/png"/>
    </item>
    <item>
      <title>1.字符串占位替换</title>
      <link>https://liuyueyi.github.io/tutorial/java/skill/01.%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8D%A0%E4%BD%8D%E6%9B%BF%E6%8D%A2.html</link>
      <guid>https://liuyueyi.github.io/tutorial/java/skill/01.%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8D%A0%E4%BD%8D%E6%9B%BF%E6%8D%A2.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">1.字符串占位替换</source>
      <description>实战1：字符串占位替换 字符串占位替换，相信没有小伙伴是陌生的，这东西可以说是伴随着我们所有的项目工程，编码过程；别不相信，如 String.format sql参数拼接的占位 log日志输出 接下来我们看一下在我们的日常工作生涯中，经常涉及到的几种占位替换方式</description>
      <category>Java</category>
      <category>编程技巧</category>
      <pubDate>Mon, 09 Aug 2021 08:53:46 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 实战1：字符串占位替换</h1>
<p>字符串占位替换，相信没有小伙伴是陌生的，这东西可以说是伴随着我们所有的项目工程，编码过程；别不相信，如</p>
<ul>
<li>String.format</li>
<li>sql参数拼接的占位</li>
<li>log日志输出</li>
</ul>
<p>接下来我们看一下在我们的日常工作生涯中，经常涉及到的几种占位替换方式</p>
<!-- more -->
<h2> 1. String.format</h2>
<p>这种可以说是最原始最基础的方式了，基本上在最开始学习java这门语言的时候就会涉及到，语法也比较简单</p>
<p>举例如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>使用<code>%</code>来表示占位，后面跟上不同的标识符，用于限定这个占位处的参数类型</p>
<p>这种使用姿势，由jdk原生提供支持，下表为不同的转换符对应的说明</p>
<table>
<thead>
<tr>
<th>转换符</th>
<th>说明</th>
<th>参数实例</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>%s</code></td>
<td>字符串替换</td>
<td>"一灰灰"</td>
</tr>
<tr>
<td><code>%c</code></td>
<td>字符类型</td>
<td>'a'</td>
</tr>
<tr>
<td><code>%b</code></td>
<td>布尔类型</td>
<td>true/false</td>
</tr>
<tr>
<td><code>%d</code></td>
<td>整数，十进制</td>
<td>10</td>
</tr>
<tr>
<td><code>%x</code></td>
<td>整数，十六进制</td>
<td>0x12</td>
</tr>
<tr>
<td><code>%o</code></td>
<td>整数，八进制</td>
<td>012</td>
</tr>
<tr>
<td><code>%f</code></td>
<td>浮点</td>
<td>0.12f</td>
</tr>
<tr>
<td><code>%e</code></td>
<td>指数</td>
<td>2e2</td>
</tr>
<tr>
<td><code>%g</code></td>
<td>通用浮点型</td>
<td></td>
</tr>
<tr>
<td><code>%h</code></td>
<td>散列</td>
<td></td>
</tr>
<tr>
<td><code>%%</code></td>
<td>百分比</td>
<td></td>
</tr>
<tr>
<td><code>%n</code></td>
<td>换行</td>
<td></td>
</tr>
<tr>
<td><code>%tx</code></td>
<td>日期与时间类型（x代表不同的日期与时间转换符</td>
<td></td>
</tr>
</tbody>
</table>
<p>虽然上面表中列出了很多，但实际使用时，<code>%s</code>, <code>%d</code>, <code>%f</code> 这三个就足以应付绝大部分的场景了；使用姿势和上面的实例参不多，第一个参数为字符串模板，后面的可变参数为待替换的值</p>
<p>下面是在实际使用过程中的注意事项</p>
<h3> 1.1 类型不匹配</h3>
<p>上面的表中介绍了不同的转换符，要求的参数类型，如果没有对应上，会怎样</p>
<p><strong><code>%s</code>，传入非字符串类型</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>也就是说，<code>%s</code>的占位标记，传参如果不是String类型，那么实际替换的是 <code>arg.toString()</code> (所以数组输出的是地址，而list输出了内容)</p>
<p><strong><code>%d</code>，传入非整数</strong></p>
<p>与字符串的不一样的是，如果我们定义要求替换的参数类型为整数，那么传参不是整数，就会抛异常</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这两个，一个传入的参数为浮点，一个传入的是字符串，在实际替换的时候，可不会调用<code>Integer.valufOf(String.valueOf(xxx))</code>来强转，而是采用更直接的方式，抛异常</p>
<p>关键的提示信息如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>因此在实际使用这种方式进行替换时，推荐选择 <code>%s</code>，毕竟兼容性更好</p>
<h3> 1.2 参数个数不匹配</h3>
<p>我们会注意到,<code>String.format</code>接收的参数是不定长的，那么就可能存在字符串模板中预留的占位与实际传入的参数个数不匹配的场景，那么出现这种场景时，会怎样</p>
<p><strong>参数缺少</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面的例子中，模板要求两个，实际只传入一个参数，会直接抛异常<code>MissingFormatArgumentException</code></p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>参数过多</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>执行正常，多余的参数不会被替换</p>
<p>因此，我们在使用<code>String.format</code>进行字符串替换时，请确保传参不要少于实际定义的参数个数；多了还好，少了就会抛异常</p>
<h2> 2. MessageFormat</h2>
<p>上面介绍的String.format虽说简单好用，但我们用多之后，自然会遇到，一个参数，需要替换模板中多个占位的场景，针对这种场景，更友好的方式是<code>MessageFormat</code>，这个也是jdk原生提供的</p>
<p>我们来简单看一下它的使用姿势</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>使用<code>{数字}</code>来表示占位，其中数字对应的是传参的下标，因此当一个参数需要复用时，使用MessageFormat就可以比较简单的实现了，上面就是一个实例，替换之后的字符串为</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>接下来说一下它使用时的注意事项</p>
<h3> 2.1 {}成对出现</h3>
<p>如果字符串中，只出现一个<code>{</code>，而没有配套的<code>}</code>，会抛异常</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>注意上面两种case，上面一个是有<code>}</code>而缺少<code>{</code>，这样是没有问题的；而下面那个则会抛异常</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>如果字符串中却是希望输出<code>{</code>，可以使用单引号来处理</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 2.2 单引号</h3>
<p>上面提到需要转移时，可以用单引号进行处理，在字符串模板的定义中，如果有单引号，需要各位注意</p>
<p><strong>只有一个单引号，会导致后面所有占位都不生效</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面这个输出结果可能和我们实际希望的不一致</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>要解决上面这个，就是使用两个单引号</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这样输出的就是我们预期的</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 2.3 序号省略</h3>
<p>上面的定义中，已经明确要求我们在<code>{}</code>中指定参数的序号，如果模板中没有指定会怎样?</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>直接抛异常</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2> 3. 小结</h2>
<p>本文介绍的实战小技巧属于是jdk原生提供的两种实现字符串占位替换的方式，除了这两个之外，我们日常开发中还会遇到其他的占位替换方式</p>
<p>比如sql的<code>?</code>替换，mybatis中sql参数组装使用<code>${paramName}</code>，或者logback日志输出中的<code>{}</code>来表示占位，spring的@Value注解声明的配置注入方式<code>${name:defaultValue}</code>，这些也都属于占位替换的范畴，那么它们又是怎么实现的呢？</p>
]]></content:encoded>
    </item>
    <item>
      <title>2. 数组与list互转</title>
      <link>https://liuyueyi.github.io/tutorial/java/skill/02.%E6%95%B0%E7%BB%84%E4%B8%8Elist%E4%BA%92%E8%BD%AC.html</link>
      <guid>https://liuyueyi.github.io/tutorial/java/skill/02.%E6%95%B0%E7%BB%84%E4%B8%8Elist%E4%BA%92%E8%BD%AC.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">2. 数组与list互转</source>
      <description>实战2：数组与list互转 这个考题比较常见，也比较简单，难道就这也有什么可以说到的门路不成？ 接下来本文好好的说一说它的几种实现姿势，总有一款你喜欢的 1.数组转List 1.1. Array.asList 这个考题太简单了，直接使用Array.asList不就完事了么，比如 @Test public void ary2list() { String[] ary = new String[]{ &amp;quot;1&amp;quot;, &amp;quot;a&amp;quot;}; List&amp;lt;String&amp;gt; list = Arrays.asList((ary); System.out.println(list); }</description>
      <category>Java</category>
      <category>编程技巧</category>
      <pubDate>Tue, 10 Aug 2021 08:42:44 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 实战2：数组与list互转</h1>
<p>这个考题比较常见，也比较简单，难道就这也有什么可以说到的门路不成？</p>
<p>接下来本文好好的说一说它的几种实现姿势，总有一款你喜欢的</p>
<h2> 1.数组转List</h2>
<h3> 1.1. Array.asList</h3>
<p>这个考题太简单了，直接使用<code>Array.asList</code>不就完事了么，比如</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>数组转list，so easy!!!</p>
<p>真的就这么简单么？？？</p>
<p>且看下面这一段代码</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>直接抛出了异常<code>java.lang.UnsupportedOperationException</code></p>
<p>有兴趣的小伙伴可以看一下源码实现方式，通过<code>Arrays.asList</code>创建的List，虽说也命名是<code>ArrayList</code>，但是它的全路径为 <code>java.util.Arrays.ArrayList</code>， 不支持<code>add</code>, <code>remove</code>等操作（所以下次再有面试官问ArrayList的知识点时，就可以反问一句，老哥你指的是哪个ArrayList😝，逼格是不是立马拉起来）</p>
<p><strong>知识点</strong></p>
<ul>
<li>通过<code>Arrays.asList</code>创建的列表，不允许新增，删除元素；但是可以更新列表中元素的值</li>
</ul>
<h3> 1.2. new ArrayList</h3>
<p>上面的数组转list方式虽然是最简单的，但不一定是合适的，特别是当我们可能对转换后的list进行操作时，可能埋坑（而且这种坑还非常隐晦，代码层面上很难发现）</p>
<p>为了减少在代码里面下毒的可能性，不妨使用下面这种方式<code>new ArrayList&lt;&gt;(Arrays.asList(ary))</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过上面这种方式创建的List，就是我们熟知的<code>ArrayList</code>了</p>
<p><strong>避雷预警</strong></p>
<p>看到上面这个使用姿势，就很容易想到一个常见的踩雷点，比如我们的应用中，有一个全局共享的配置列表，张三需要拿id为奇数的配置，李四拿id为偶数的配置，然后他们都是这么做的</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>然后跑了一次之后发现这个全局的列表清空了，这就是典型的没有做好资源隔离的case了，针对这种场景，要么是限制使用方，直接针对全局的资源进行修改，要么就是使用方拿到的是一个隔离的备份</p>
<p><strong>禁止修改：</strong></p>
<ul>
<li>使用不可变的容器，如前面提到的<code>java.util.Arrays.ArrayList</code> ()</li>
<li>使用<code>Collections.unmodifiableList</code>创建</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>列表拷贝</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>（上面这种属于深拷贝的实现，具体可以看一下jdk的源码实现）</p>
<h3> 1.3. Collections.addAll</h3>
<p>第三种方式借助jdk提供的容器工具类<code>Collections</code>来实现</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>原则上是比较推荐这种方式来实现的，至于为啥？看下源码实现</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码的实现是不是非常眼熟，如果让我们自己来写，也差不多会写成这样吧，简单直观高效，完美</p>
<h2> 2. 列表转数组</h2>
<p>不同于数组转列表的几种玩法，列表转数组就简单多了，直接调用<code>List.toArray</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 3. 小结</h2>
<p>今天的博文主题是数组与列表的互转，虽说题目简单，但是实现方式也是多种，需要搞清楚它们之间的本质区别，一不小心就可能采坑，而最简单的地方掉坑里，往往是最难发现和爬出来的</p>
<p>核心知识点小结如下</p>
<p><strong>数组转list：</strong></p>
<ul>
<li><code>Arrays.asList(xxx)</code>：创建的是不可变列表，不能删除和新增元素</li>
<li><code>new ArrayList&lt;&gt;(Arrays.asList(xxx)</code>: 相当于用列表创建列表，属于深拷贝的一种表现，获取到的列表支持新增、删除</li>
<li>推荐写法 <code>Collections.addAll()</code></li>
</ul>
<p><strong>列表转数组</strong></p>
<ul>
<li><code>list.toArray</code>: 如果需要指定数组类型，则传参指定</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>3.字符串与容器互转</title>
      <link>https://liuyueyi.github.io/tutorial/java/skill/03.%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8E%E5%AE%B9%E5%99%A8%E4%BA%92%E8%BD%AC.html</link>
      <guid>https://liuyueyi.github.io/tutorial/java/skill/03.%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8E%E5%AE%B9%E5%99%A8%E4%BA%92%E8%BD%AC.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">3.字符串与容器互转</source>
      <description>实战3：字符串与Collection的互转 将字符串转换为List，这种业务场景可以说非常非常常见了，实现方式也比较简单 public List&amp;lt;String&amp;gt; str2list(String str, String split) { String[] cells = str.split(split); return Arrays.asList(cells); } 那么除了上面这种实现方式之外，还有其他的么？</description>
      <category>Java</category>
      <category>编程技巧</category>
      <pubDate>Wed, 11 Aug 2021 08:32:54 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 实战3：字符串与Collection的互转</h1>
<p>将字符串转换为List，这种业务场景可以说非常非常常见了，实现方式也比较简单</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>那么除了上面这种实现方式之外，还有其他的么？</p>
<!-- more -->
<h2> 1. 字符串转列表</h2>
<p>上面的实现姿势相当于字符串先转数组，然后在通过数组转列表，所以可以沿用前一篇字数组转list的几种方式</p>
<h3> 1.1. jdk支持方式</h3>
<p>借助<code>Collections.addAll</code>来实现</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这种方式适用于输出String的列表，如果我希望转成int列表呢？可以采用下面的方式</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>直接将数组转换为流，然后基于jdk8的特性，来实现转换为int列表</p>
<h3> 1.2. guava方式</h3>
<p>引入依赖</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>除了使用jdk原生的方式之外，借助guava也是非常常见的的case了，主要通过Splitter来实现，写法看起来非常秀</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>简单直接的一行代码搞定，如果我们希望是对输出的列表类型进行指定，也可以如下操作</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1.3. apache-commons</h3>
<p>引入依赖</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面流的方式就很赞了，但是注意它是有jdk版本限制的，虽说现在基本上都是1.8以上的环境进行开发，但也不排除有上古的代码，比如我现在手上的项目，spring还是3...</p>
<p>如果我们不能使用流的方式，那么有什么简单的方式来实现字符串转换为指定类型的列表么？</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这个实现也没有多优雅，不过这里有个编程小技巧可以学习，<code>new Transformer(){}</code>的传参方式，这种实现方式有点像回调的写法，虽然他们有本质的区别，此外就是jdk8之后的函数方法，就充分的体现这种设计思路，比如上面的换成jdk8的写法，直接简化为</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 2. 列表转字符串</h2>
<h3> 2.1. StringBuilder</h3>
<p>最容易想到的，直接使用StringBuilder来实现拼接</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意两点：</p>
<ul>
<li>使用StringBuilder而不是StringBuffer (why?)</li>
<li>注意最后一个拼接符号不要</li>
</ul>
<h3> 2.2. String.join</h3>
<p>一个更简单的实现方式如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当然上面这个的缺点就是列表必须是字符串列表，如果换成int列表，则不行</p>
<h3> 2.3. gauva</h3>
<p>guava也提供了列表转String的方式，同样很简单，而且还没有列表类型的限制</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 3. 小结</h2>
<p>本文的考题也非常常见，列表与字符串的互转，这里介绍了多种实现方式，有jdk原生的case（如果没有什么限制，推荐使用它， <code>String.split</code>除外，原因后面再说），如果有更高级的定制场景，如非String类型类表，则可以考虑guava的Splitter/Joinner来实现</p>
<p>在上面的实现中，也提供了几种有意思的编程方式</p>
<ul>
<li>Stream: 流，jdk8之后非常常见了</li>
<li>函数方法，回调写法case</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>4.优雅的实现字符串拼接</title>
      <link>https://liuyueyi.github.io/tutorial/java/skill/04.%E4%BC%98%E9%9B%85%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5.html</link>
      <guid>https://liuyueyi.github.io/tutorial/java/skill/04.%E4%BC%98%E9%9B%85%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">4.优雅的实现字符串拼接</source>
      <description>实战4：字符串拼接 相信没有小伙伴没有写过这样的代码，比如说现在让我们来实现一个字符串拼接的场景，怎样的实现才算是优雅的呢？</description>
      <category>Java</category>
      <category>编程技巧</category>
      <pubDate>Thu, 12 Aug 2021 07:39:11 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 实战4：字符串拼接</h1>
<p>相信没有小伙伴没有写过这样的代码，比如说现在让我们来实现一个字符串拼接的场景，怎样的实现才算是优雅的呢？</p>
<!-- more -->
<p>以将int数组转为英文逗号分隔的字符串为例进行演示</p>
<h2> 1. 实现</h2>
<h3> 1.1. 普通写法</h3>
<p>直接使用StringBuilder来拼接</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这种写法相信比较常见，相对来说不太顺眼的地方就是最后的toString，需要将最后的一个英文逗号给干掉</p>
<p>当然也可以用下面这种事前判断方式，避免最终的字符串截取</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1.2. StringJoiner</h3>
<p>上面实现中，干掉最后的一个分隔符实在不是很优雅，那么有更好一点的用法么，接下来看一下使用<code>StringJoiner</code>的方式</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>StringJoiner由jdk1.8提供，除了上面的基础玩法之外，结合jdk1.8带来的流操作方式，可以更简洁的实现</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>怎么样，上面这个实现比起前面的代码是不是要简洁多了，一行代码完事</p>
<h3> 1.3. guava joiner</h3>
<p>如果使用的jdk还不是1.8版本，不能使用上面的StringJoiner，没关系，还有guava的Joiner也可以实现</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>注意</strong></p>
<ul>
<li>接收的参数类型为: 数组/Iterable/Iterator/可变参数, 基本上可以覆盖我们日常的业务场景</li>
</ul>
<h2> 2. 小结</h2>
<p>本篇文章的主题是一个非常非常常见的字符串拼接，一般来讲，我们在做字符串拼接时，最麻烦的事情就是分隔符的处理，要么就是分隔符前置添加，每次循环都需要判断是否为开头；要么就是后置，最后取字符串时，干掉最后一个分隔符</p>
<p>本文提供了一个非常使用的方式<code>StringJoiner</code>，完全解决了上面的分隔符问题，它的使用有两种场景</p>
<ul>
<li>简单的容器转String：直接借助Stream的<code>Collectors.joining</code>来实现</li>
<li>for循环 （这种场景一般是for循环内的逻辑不仅仅包括字符串拼接，还包括其他的业务逻辑）： 循环内直接执行<code>stringJoiner.add()</code>添加</li>
</ul>
<p>对于jdk1.8及以上的版本，优先推荐使用上面说的StringJoiner来实现字符串拼接；至于jdk1.8之下，那么Guava就是一个不错的选择了，使用姿势也很很简单</p>
]]></content:encoded>
    </item>
    <item>
      <title>5.驼峰与下划线互转</title>
      <link>https://liuyueyi.github.io/tutorial/java/skill/05.%E9%A9%BC%E5%B3%B0%E4%B8%8E%E4%B8%8B%E5%88%92%E7%BA%BF%E4%BA%92%E8%BD%AC.html</link>
      <guid>https://liuyueyi.github.io/tutorial/java/skill/05.%E9%A9%BC%E5%B3%B0%E4%B8%8E%E4%B8%8B%E5%88%92%E7%BA%BF%E4%BA%92%E8%BD%AC.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">5.驼峰与下划线互转</source>
      <description>实战5：驼峰与下划线划转 这个考题非常实用，特别是对于我们这些号称只需要CURD的后端开发来说，驼峰与下划线互转，这不是属于日常任务么；一般来讲db中的列名，要求是下划线格式（why? 阿里的数据库规范是这么定义的，就我感觉驼峰也没毛病），而java实体命名则是驼峰格式，所以它们之间的互转，就必然存在一个驼峰与下划线的互转 今天我们就来看一下，这两个的互转支持方式</description>
      <category>Java</category>
      <category>编程技巧</category>
      <pubDate>Sat, 14 Aug 2021 11:17:19 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 实战5：驼峰与下划线划转</h1>
<p>这个考题非常实用，特别是对于我们这些号称只需要CURD的后端开发来说，驼峰与下划线互转，这不是属于日常任务么；一般来讲db中的列名，要求是下划线格式（why? 阿里的数据库规范是这么定义的，就我感觉驼峰也没毛病），而java实体命名则是驼峰格式，所以它们之间的互转，就必然存在一个驼峰与下划线的互转</p>
<p>今天我们就来看一下，这两个的互转支持方式</p>
<!-- more -->
<h2> 1.实现</h2>
<h3> 1.1. Gauva</h3>
<p>一般来讲遇到这种普适性的问题，大部分都是有现成的工具类可以来直接使用的；在java生态中，说到好用的工具百宝箱，guava可以说是排列靠前的</p>
<p>接下来我们看一下如何使用Gauva来实现我们的目的</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这里主要使用的是<code>CaseFormat</code>来实现互转，guava的CaseFormat还提供了其他几种方式</p>
<p>上面这个虽然可以实现互转，但是如果我们有一个字符串为 <code>helloWorld_Case</code></p>
<p>将其他转换输出结果如下:</p>
<ul>
<li>下划线：<code>hello_world__case</code></li>
<li>驼峰：<code>helloworldCase</code></li>
</ul>
<p>这种输出，和标准的驼峰/下划线不太一样了（当然原因是由于输入也不标准）</p>
<h3> 1.2. Hutool</h3>
<p>除了上面的guava，hutool的使用也非常广，其中包含很多工具类，其<code>StrUtil</code>也提供了下划线与驼峰的互转支持</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>同样的我们再来看一下特殊的case</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果如下</p>
<ul>
<li>驼峰：<code>helloworldCase</code></li>
<li>下划线: <code>hello_world_case</code></li>
</ul>
<p>相比较上面的guava的场景，下划线这个貌似还行</p>
<h3> 1.3. 自定义实现</h3>
<p>接下来为了满足我们希望转换为标砖的驼峰/下划线输出方式的需求，我们自己来手撸一个</p>
<p><strong>下划线转驼峰:</strong></p>
<ul>
<li>关键点就是找到下划线，然后去掉它，下一个字符转大写续上（如果下一个还是下划线，那继续找下一个）</li>
</ul>
<p>根据上面这个思路来实现，如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>驼峰转下划线</strong></p>
<ul>
<li>关键点：大写的，则前位补一个下划线，当前字符转小写（如果前面已经是一个下划线了，那前面不补，直接转小写即可）</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>再次测试<code>helloWorld_Case</code>，输出如下</p>
<ul>
<li>驼峰：<code>helloWorldCase</code></li>
<li>下划线: <code>hello_world_case</code></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>6.枚举的特殊用法</title>
      <link>https://liuyueyi.github.io/tutorial/java/skill/06.%E6%9E%9A%E4%B8%BE%E7%9A%84%E7%89%B9%E6%AE%8A%E7%94%A8%E6%B3%95.html</link>
      <guid>https://liuyueyi.github.io/tutorial/java/skill/06.%E6%9E%9A%E4%B8%BE%E7%9A%84%E7%89%B9%E6%AE%8A%E7%94%A8%E6%B3%95.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">6.枚举的特殊用法</source>
      <description>实战6：枚举的特殊用法 难道我们日常使用的枚举还有什么特殊的玩法不成？没错，还真有，本文主要介绍枚举的两种不那么常见的使用姿势 利用枚举来实现单例模式 利用枚举来实现策略模式</description>
      <category>Java</category>
      <category>编程技巧</category>
      <pubDate>Mon, 16 Aug 2021 09:54:23 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 实战6：枚举的特殊用法</h1>
<p>难道我们日常使用的枚举还有什么特殊的玩法不成？没错，还真有，本文主要介绍枚举的两种不那么常见的使用姿势</p>
<ul>
<li>利用枚举来实现单例模式</li>
<li>利用枚举来实现策略模式</li>
</ul>
<!-- more -->
<h2> 1. 使用场景</h2>
<h3> 1.1. 单例模式</h3>
<p>单例模式可以说是每个java开发者必须掌握的一个设计模式了，通常我们说它的实现，有饱汉式和饿汉式，也有经常说的双重判断，今天我们介绍另外一种方式，借助枚举来实现</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用枚举来实现单例模式非常非常简单，将类声明为枚举，内部只定义一个值即可</p>
<p>为什么可以这样做？</p>
<ul>
<li>枚举类不能<code>new</code>，因此保证单例</li>
<li>枚举类不能被继承</li>
<li>类不加载时，不会实例化</li>
</ul>
<p>使用枚举类创建的单例有一个好处，就是即使用反射，也无法打破它的单例性质，这是相比较于其他的实现方式的一个优点</p>
<p>那么，为啥在实际的项目中，不太常见这种写法？</p>
<ul>
<li>就我个人的一点认知（不保证准确）：这个与我们对枚举的认知有一定关系，在 《Effect in java》一书中，推荐我们使用这种方式来实现单例，但是在实际的项目开发中，我们更多的将枚举作为常量来使用，很少在枚举类中，添加复杂的业务逻辑</li>
</ul>
<h3> 1.2. 策略模式</h3>
<p>枚举除了很容易就实现上面的单例模式之外，还可以非常简单的实现策略模式</p>
<p>举一个简单的例子，我现在有一个接口，通过接受的参数，来决定最终的数据存在什么地方</p>
<p>如果按照正常的写法，可能就是很多的if/else</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这种写法虽说简单直观，但是当type类型一多了之后，这个if/else的代码行数就会很多很多了，而且看起来也不美观</p>
<p>接下来我们介绍一种利用枚举，基于策略模式的思想来解决上面的if/else问题</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的实现，主要利用的是<code>抽象类 + 枚举</code>来完成不同的策略具体实现</p>
<p>这种实现方式，相比较与前面的单例模式，还是更常见一点，虽然整体看下来没有什么难度，但是仔细看一看，会发现几个知识点</p>
<ul>
<li>抽象方法的使用 （在模板设计模式中，更能体会抽象方法的使用妙处）</li>
<li>利用枚举原生提供的<code>values()</code>，来实现遍历，找到目标</li>
</ul>
<h2> 2. 小结</h2>
<p>枚举虽然说是jdk原生提供的一个基础数据类型，但是它的使用姿势除了我们熟知的常量之外，还可以有效的运用在设计模式中，让我们的代码实现更优雅</p>
<p>比如使用枚举来实现单例模式，就不用再面对让人烦躁的双重判断/内部类的方式了</p>
<p>使用枚举的策略模式，也可以有效解决我们类中大量的if/else</p>
]]></content:encoded>
    </item>
    <item>
      <title>7.排序比较要慎重</title>
      <link>https://liuyueyi.github.io/tutorial/java/skill/07.%E6%8E%92%E5%BA%8F%E6%AF%94%E8%BE%83%E8%A6%81%E6%85%8E%E9%87%8D.html</link>
      <guid>https://liuyueyi.github.io/tutorial/java/skill/07.%E6%8E%92%E5%BA%8F%E6%AF%94%E8%BE%83%E8%A6%81%E6%85%8E%E9%87%8D.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">7.排序比较要慎重</source>
      <description>实战7：排序比较要慎重 今天介绍的又是一个非常非常基本的基本知识点，为啥要单独拎出来？还是因为这个东西虽然非常简单，但是很容易掉坑，我已经遇到几次不严谨的写法了</description>
      <category>Java</category>
      <category>编程技巧</category>
      <pubDate>Tue, 17 Aug 2021 14:22:52 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 实战7：排序比较要慎重</h1>
<p>今天介绍的又是一个非常非常基本的基本知识点，为啥要单独拎出来？还是因为这个东西虽然非常简单，但是很容易掉坑，我已经遇到几次不严谨的写法了</p>
<!-- more -->
<h2> 1.排序</h2>
<h3> 1.1. Comparator 与 Comparable</h3>
<p>输掉排序，这两个接口好像不太容易绕过去，我们简单介绍下它们的区别</p>
<ul>
<li>如果你有一个类，希望支持同类型的自定义比较策略，可以实现接口<code>Compareable</code></li>
<li>如果某个类，没有实现<code>Compareable</code>接口，但是又希望对它进行比较，则可以自自定义一个<code>Comparator</code>，来定义这个类的比较规则</li>
</ul>
<p>通过一个简单的实例进行演示说明</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的实现中，重点关注 Demo类，实现了<code>Comparable</code>接口，因此可以直接调用<code>list.sort(null)</code>来进行比较；</p>
<p>但是如果我们现在需求改变了，希望实现针对demo类的age字段，进行升序排列，那么就可以利用<code>Comparator</code>来实现了</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1.2. 踩坑预告</h3>
<p>再上面的compare方法实现中，我们可以发现里面的实现有点不太美观，我们最终的目的是什么？</p>
<ul>
<li>如果左边的小于右边的，返回 -1</li>
<li>如果左边的大于右边的，返回 0</li>
<li>如果左边的等于右边的，返回 1</li>
</ul>
<p>基于此，经常可以看到的实现如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这个实现虽然简洁了，但是有一个致命的问题，可能溢出!!!</p>
<p>所以请注意，千万千万不要用上面这种写法</p>
<p>那么有没有更优雅的方式呢？</p>
<ul>
<li>有，使用基础类的<code>compare</code>方法</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这一段代码，再jdk1.8中，可以简化为下面一句</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>再扩展一下，如果希望倒排呢？</p>
<ul>
<li>第一种实现方式，调换位置</li>
<li>Jdk1.8方式，使用负数</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 2. 小结</h2>
<p>今天主要介绍的知识点是排序，再我们日常使用中，如果一个类希望支持排序，最好的方式就是让它实现<code>Comparable</code>接口，然后自定义排序方式</p>
<p>这样再容器中，如果需要排序，直接调用 <code>list.sort(null)</code> 或者 <code>CollectionUtils.sort(list)</code></p>
<p>如果目标类没有实现排序接口，或者希望使用另外一种排序方式，则通过自定义的<code>Comparator</code>来实现</p>
<p>最后关于<code>compare</code>方法的实现，设计到两个类的比较，这种最终的落脚地，多半是基础类型的比较</p>
<ul>
<li>o1 与 o2 比较，返回负数，则最终的结果中o1再前面（即升序排列）</li>
<li>不要直接使用 <code>o1-o2</code>会溢出，推荐使用 <code>Integer.compare(o1, o2);</code></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>8.容器的初始化大小指定</title>
      <link>https://liuyueyi.github.io/tutorial/java/skill/08.%E5%AE%B9%E5%99%A8%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%A4%A7%E5%B0%8F%E6%8C%87%E5%AE%9A.html</link>
      <guid>https://liuyueyi.github.io/tutorial/java/skill/08.%E5%AE%B9%E5%99%A8%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%A4%A7%E5%B0%8F%E6%8C%87%E5%AE%9A.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">8.容器的初始化大小指定</source>
      <description>实战8：容器的初始化大小指定 容器可以说是我们日常开发中，除了基本对象之外，使用最多的类了，那么平时在使用的时候，是否有主意到良好编程习惯的大佬，在创建容器的时候，一般会设置size；那么他们为什么要这么干呢？是出于什么进行考量的呢？ 今天我们将针对最常见的List/Map/Set三种容器类型的初始化值选择，进行说明</description>
      <category>Java</category>
      <category>编程技巧</category>
      <pubDate>Wed, 18 Aug 2021 14:11:05 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 实战8：容器的初始化大小指定</h1>
<p>容器可以说是我们日常开发中，除了基本对象之外，使用最多的类了，那么平时在使用的时候，是否有主意到良好编程习惯的大佬，在创建容器的时候，一般会设置size；那么他们为什么要这么干呢？是出于什么进行考量的呢？</p>
<p>今天我们将针对最常见的List/Map/Set三种容器类型的初始化值选择，进行说明</p>
<!-- more -->
<h2> 1. 容器初始化</h2>
<h3> 1.1. List</h3>
<p>列表，在我们日常使用过程中，会接触到下面几个</p>
<ul>
<li>ArrayList: 最常见的数组列表</li>
<li>LinkedList: 基于链表的列表</li>
<li>CopyOnWriteArrayList: 线程安全的数组列表</li>
</ul>
<p>接下来逐一进行说明</p>
<h4> 1.1.1 ArrayList</h4>
<p>现在以ArrayList为例，进行源码分析，当我们不指定列表大小，直接创建时</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面是内部实现，其中<code>elementData</code>就是列表中存数据的数组，初始化为默认数组</p>
<p>当我们第一次添加一个元素时，发现数组为默认值，会触发一次数组扩容，新的数组大小为10 （详情看源码）</p>
<p>其次就是数组的库容机制，通过源码/网上分享知识点可以知道，这个扩容的实现如下</p>
<ul>
<li>当新添加的元素，数组放不下时，实现扩容</li>
<li><code>扩容后的大小</code> = <code>扩容前大小</code> + max(<code>添加元素个数</code>, 1/2 * <code>扩容前大小</code>)</li>
</ul>
<p>基于上面的知识点，大致可以得出指定列表长度的好处</p>
<ul>
<li>节省空间（用多少申请多少，避免浪费）</li>
<li>减少扩容带来的拷贝（扩容一次就会带来一次数组拷贝，如果已知列表很大，结果还使用默认的10，这会产生很多可避免的扩容开销）</li>
</ul>
<h4> 1.1.2 LinkedList</h4>
<p>基于链表的列表，不同于上面的数组列表，它没有提供指定大小的构造方法，why?</p>
<p>因为链表本身的数据结构的特点，它就像糖葫芦一样，一个串一个，有数据，才有接上的可能，因此不需要指定大小</p>
<h4> 1.1.3 CopyOnWriteArrayList</h4>
<p>这个又非常有意思，它同样不能指定大小，但是原因与前面不同，主要在于它保证线程安全的实现方式</p>
<ul>
<li>每次新增/修改(加锁，保证单线程访问)，都是在拷贝的数组操作；完成之后，用新的替换旧的</li>
</ul>
<p>所以说，每次变更，都会存在数组拷贝，因此就没有必要提前指定数组大小</p>
<p>那么它的初始化每次都使用默认的么?</p>
<p>并不是这样的，当我们已知这个列表中的值时，推荐使用下面这种方式</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>将初始化值，放在一个普通的列表中，然后利用普通列表来初始化<code>CopyOnWriteArrayList</code></li>
</ul>
<h3> 1.2.Map</h3>
<p>常见的map容器使用，大多是下面几个</p>
<ul>
<li><code>HashMap</code></li>
<li><code>LinkedHashMap</code>: 有序的hashmap</li>
<li><code>TreeMap</code>: 有序的hashmap</li>
<li><code>ConcurrentHashMap</code>: 线程安全的map</li>
</ul>
<h4> 1.2.1 HashMap</h4>
<p>HashMap的底层数据结构是 <code>数组 + 链表/红黑树</code>，关于这个就不细说了</p>
<p>我们在初始化时，若不指定size，则数组的默认长度为8（请注意，Map的数组长度是2的倍数）</p>
<p>与ArrayList的扩容时机不一样的是，默认情况下，Map容量没满就会触发一次扩容</p>
<p>默认是数量达到 <code>size * 0.75</code>(0.75为扩容因子，可以在创建时修改)，就会触发一次扩容</p>
<p>why?</p>
<ul>
<li>主要是为了减少hash冲突</li>
</ul>
<p>同样的为了减少冲突，在初始化时，我们需要指定一个合适大小</p>
<p>比如我们</p>
<ul>
<li>已知map的数量为2，这个时候Map的大小选择因该是4</li>
<li>map数量为6，这个时候Map的大小选择是16</li>
</ul>
<p>有时候让我们自己来计算这个值，就有些麻烦了，这个时候，可以直接使用Guava的工具类来完成这个目的</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4> 1.2.2 LinkedHashMap</h4>
<p>初始化方式同上，略</p>
<h4> 1.2.3 ConcurrentHashMap</h4>
<p>初始化方式同上，略</p>
<h4> 1.2.4 TreeMap</h4>
<p>不同于上面几个的是treeMap，没有提供指定容器大小的构造方法</p>
<p>原因和前面说到的LinkedList有些类似，TreeMap的底层数据结构为Tree，所以新增数据是挂在树的一个节点下面，无需指定容量大小</p>
<h3> 1.3. Set</h3>
<p>集合用的最多应该就是<code>HashSet</code>了，底层结构模型复用，所以初始化大小指定与HashMap一致，也不需要多说</p>
<h2> 2. 小结</h2>
<p>今天这篇博文主要介绍的是三种常见的容器，在创建时，如何指定容量大小</p>
<p>首先明确一点，指定容量大小是为了</p>
<ul>
<li>减少扩容带来的额外开销</li>
<li>指定容量代销，可以减少无效的内存开销</li>
</ul>
<p>初始化值设置的关键点:</p>
<ul>
<li>ArrayList: 数据有多少个，初始化值就是多少</li>
<li>HashMap: 考虑到扩容因子，初始化大小 = <code>(size / 0.75 + 1)</code></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>9.List.subList使用不当StackOverflowError</title>
      <link>https://liuyueyi.github.io/tutorial/java/skill/09.List-subList%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%BD%93StackOverflowError.html</link>
      <guid>https://liuyueyi.github.io/tutorial/java/skill/09.List-subList%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%BD%93StackOverflowError.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">9.List.subList使用不当StackOverflowError</source>
      <description>实战9：List.subList使用不当StackOverflowError 相信每个小伙伴都使用过List.subList来获取子列表，日常使用可能没啥问题，但是，请注意，它的使用，很可能一不小心就可能导致oom</description>
      <category>Java</category>
      <category>编程技巧</category>
      <pubDate>Thu, 19 Aug 2021 14:13:42 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 实战9：List.subList使用不当StackOverflowError</h1>
<p>相信每个小伙伴都使用过<code>List.subList</code>来获取子列表，日常使用可能没啥问题，但是，请注意，它的使用，很可能一不小心就可能导致oom</p>
<!-- more -->
<h2> 1.实例说明</h2>
<h3> 1.1. subList</h3>
<p>场景复现，如基于list实现一个小顶堆</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这个执行完毕之后，居然出现栈溢出</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从实现来看，感觉也没啥问题啊， 我们稍微改一下上面的返回</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>再次执行，却没有异常；所以关键点就在与</p>
<ul>
<li>list.subList的使用上</li>
</ul>
<h3> 1.2. StackOverflowError分析</h3>
<p>接下来我们主要看一下<code>list.subList</code>的实现</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面返回的子列表是ArrayList的一个内部类<code>SubList</code>，它拥有一个指向父列表的成员<code>parrent</code></p>
<p>也就是说，从源头的ArryList开始，后面每次调用<code>subList</code>，这个指代关系就深一层</p>
<p>然后它的add方法也很有意思</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>重点看 <code>parent.add(parentOffset + index, e);</code>，添加的数据实际上是加在最源头的ArrayList上的，也就是说，虽然你现在拿到的SubList，只有几个元素，但是它对应的数组，可能超乎你的想象</p>
<p>当然上面这个异常主要是以为调用栈溢出（一直往上找parent）</p>
<p>这里反应的另外一个重要问题则是内存泄漏，就不继续说了</p>
<p>如果需要解决上面这个问题，改造方法如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 2. 小结</h2>
<p>jdk提供的原生方法虽然非常好用，但是在使用的时候，也需要多家注意，一不小心就可能掉进坑里；这也告诉我们多看源码是有必要的</p>
<p>最后一句关键知识点小结：</p>
<ul>
<li><code>ArrayList.subList</code> 返回的是内部类，与原ArrayList公用一个数组，只是限定了这个数组的起始下标和结束下标而已</li>
<li>在使用<code>subList</code>，请注意是否会存在内存泄露和栈溢出的问题</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>10.不可变容器</title>
      <link>https://liuyueyi.github.io/tutorial/java/skill/10.%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%AE%B9%E5%99%A8.html</link>
      <guid>https://liuyueyi.github.io/tutorial/java/skill/10.%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%AE%B9%E5%99%A8.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">10.不可变容器</source>
      <description>实战10：不可变容器 不可变容器，看着好像在实际的业务中不怎么会用到，但实则不然，相信每个小伙伴都用过，或者看到过下面的代码 Collections.emptyList(); Collections.emptyMap(); 今天我们来介绍一下如何使用不可变容器，以及使用时的注意事项</description>
      <category>Java</category>
      <category>编程技巧</category>
      <pubDate>Fri, 20 Aug 2021 17:59:24 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 实战10：不可变容器</h1>
<p>不可变容器，看着好像在实际的业务中不怎么会用到，但实则不然，相信每个小伙伴都用过，或者看到过下面的代码</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>今天我们来介绍一下如何使用不可变容器，以及使用时的注意事项</p>
<!-- more -->
<h2> 1. 不可变容器</h2>
<h3> 1.1. JDK不可变容器</h3>
<p>java原生提供了一些不可变容器，它们最大的特点就是不支持添加、删除、修改容器内的值</p>
<p><code>Collections.emptyXxx</code>空容器</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面三个是最常用的几个了，通常当我们一个方法的返回结果定义为容器类型时，可能为了避免npe，在返回空容器时，会如此使用</p>
<p>除了上面这几个空的不可变容器之外，还有</p>
<ul>
<li><code>UnmodifiableList</code></li>
<li><code>UnmodifiableMap</code></li>
<li><code>UnmodifiableSet</code></li>
</ul>
<p>它们的使用姿势，通常是借助<code>Collections</code>来实现</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>如上面创建的List，就不支持set/remove等修改操作</p>
<p>使用不可变容容器，最大的好处就是基于它的不可修改特性，来实现公用，且不会被污染</p>
<ul>
<li>所以一个自然而然能想到的应用场景就是 <code>全局共享的配置</code></li>
</ul>
<h3> 1.2. Guava不可变容器</h3>
<p>上面是jdk提供的不可变容器，相比较与它们，在实际的项目中，使用Gauva的不可变容器的可能更多</p>
<ul>
<li><code>ImmutableXxx</code>；不可变容器</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面是最常见的三个容器对应的不可变型</p>
<p>从使用角度来看，初始化非常方便（相比较与jdk版而言）</p>
<h2> 2. 注意事项</h2>
<p>不可变容器虽好，但是使用不当也是很坑的；就我个人的一个观点</p>
<ul>
<li>如果是应用内的接口方法，容器传参，返回容器时，尽量不要使用不可变容器；因为你没办法保证别人拿到你的返回容器之后，会对它进行什么操作</li>
<li>如果是对外提供返回结果，特别是null的场景，使用不可变的空容器优于返回null</li>
<li>不可变容器，用于全局公用资源，共享配置参数；多线程的数据传递时，属于比较合适的场景</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>11.Map转换的几种方式</title>
      <link>https://liuyueyi.github.io/tutorial/java/skill/11.Map%E8%BD%AC%E6%8D%A2%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F.html</link>
      <guid>https://liuyueyi.github.io/tutorial/java/skill/11.Map%E8%BD%AC%E6%8D%A2%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">11.Map转换的几种方式</source>
      <description>实战11：Map转换Map的几种方式 在日常开发过程中，从一个Map转换为另外一个Map属于基本操作了，那么我们一般怎么去实现这种场景呢？有什么更简洁省事的方法么？</description>
      <category>Java</category>
      <category>编程技巧</category>
      <pubDate>Tue, 02 Nov 2021 19:43:19 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 实战11：Map转换Map的几种方式</h1>
<p>在日常开发过程中，从一个Map转换为另外一个Map属于基本操作了，那么我们一般怎么去实现这种场景呢？有什么更简洁省事的方法么？</p>
<!-- more -->
<h2> 1.Map互转</h2>
<h3> 1.1 实例场景</h3>
<p>现在我们给一个简单的实例</p>
<p>希望将一个<code>Map&lt;String, Integer&gt;</code> 转换成 <code>Map&lt;String, String&gt;</code>，接下来看一下有哪些实现方式，以及各自的优缺点</p>
<p>首先提供一个创建Map的公共方法</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 1.1.1 基本的for循环转换</h4>
<p>这种方式是最容易想到和实现的，直接for循环来转换即可</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这种方式的优点很明显，实现容易，业务直观；</p>
<p>缺点就是可复用性较差，代码量多（相比于下面的case）</p>
<h4> 1.1.2 容器的流式使用</h4>
<p>在jdk1.8提供了流式操作，同样也可以采用这种方式来实现转换</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用stream的方式，优点就是链式，代码量少；缺点是相较于上面的阅读体验会差一些（当然这个取决于个人，有些小伙伴就更习惯看这种链式的代码）</p>
<h4> 1.1.3 Guava的trasform方式</h4>
<p>从代码层面来看，上面两个都不够直观，如果对guava熟悉的小伙伴对下面的代码可能就很熟悉了</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>核心逻辑就一行 <code>Maps.transformValues(map, String::valueOf)</code>，实现了我们的Map转换的诉求</p>
<p>很明显，这种方式的优点就是间接、直观；当然缺点就是需要引入guava，并且熟悉guava</p>
<h3> 1.2 最后一问，这篇文章目的是啥？</h3>
<p>既然我们的标题是实战小技巧，本文除了给大家介绍可以使用guava的<code>Maps.transformValues</code>来实现map转换之外，更主要的一个目的是如果让我们自己来实现一个工具类，来支持这个场景，应该怎么做？</p>
<p>直接提供一个转换方法？</p>
<p><strong>第一步：一个泛型的转换接口</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>定义上面这个接口之后，自然而然想到的缺点就是差一个value的转换实现</p>
<p><strong>第二步：value转换的定义</strong></p>
<p>这里采用Function接口思想来定义转换类</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>当然到这里我们就需要注意jdk1.8以下是不支持函数编程的，那么我们可以怎么来实现呢？</p>
<p>这个时候再对照一下guava的实现，然后再手撸一个，知识点就到手了</p>
]]></content:encoded>
    </item>
    <item>
      <title>12.巧用函数方法实现二维数组遍历</title>
      <link>https://liuyueyi.github.io/tutorial/java/skill/12.%E5%B7%A7%E7%94%A8%E5%87%BD%E6%95%B0%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E9%81%8D%E5%8E%86.html</link>
      <guid>https://liuyueyi.github.io/tutorial/java/skill/12.%E5%B7%A7%E7%94%A8%E5%87%BD%E6%95%B0%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E9%81%8D%E5%8E%86.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">12.巧用函数方法实现二维数组遍历</source>
      <description>实战12：巧用函数方法实现二维数组遍历 对于数组遍历，基本上每个开发者都写过，遍历本身没什么好说的，但是当我们在遍历的过程中，有一些复杂的业务逻辑时，将会发现代码的层级会逐渐加深</description>
      <category>Java</category>
      <category>编程技巧</category>
      <pubDate>Tue, 09 Aug 2022 18:35:40 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 实战12：巧用函数方法实现二维数组遍历</h1>
<p>对于数组遍历，基本上每个开发者都写过，遍历本身没什么好说的，但是当我们在遍历的过程中，有一些复杂的业务逻辑时，将会发现代码的层级会逐渐加深</p>
<!-- more -->
<p>如一个简单的case，将一个二维数组中的偶数找出来，保存到一个列表中</p>
<p>二维数组遍历，每个元素判断下是否为偶数，很容易就可以写出来，如</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这个实现没啥问题，但是这个代码的深度很容易就有三层了；当上面这个if中如果再有其他的判定条件，那么这个代码层级很容易增加了；二维数组还好，如果是三维数组，一个遍历就是三层；再加点逻辑，四层、五层不也是分分钟的事情么</p>
<p>那么问题来了，代码层级变多之后会有什么问题呢？</p>
<blockquote>
<p>只要代码能跑，又能有什么问题呢？！</p>
</blockquote>
<h2> 1. 函数方法消减代码层级</h2>
<p>由于多维数组的遍历层级天然就很深，那么有办法进行消减么？</p>
<p>要解决这个问题，关键是要抓住重点，遍历的重点是什么？获取每个元素的坐标！那么我们可以怎么办？</p>
<blockquote>
<p>定义一个函数方法，输入的就是函数坐标，在这个函数体中执行我们的遍历逻辑即可</p>
</blockquote>
<p>基于上面这个思路，相信我们可以很容易写一个二维的数组遍历通用方法</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>主要上面的实现，函数方法直接使用了JDK默认提供的BiConsumer，两个传参，都是int 数组下表；无返回值</p>
<p>那么上面这个怎么用呢？</p>
<p>同样是上面的例子，改一下之后，如</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>相比于前面的，貌似也就少了一层而已，好像也没什么了不起的</p>
<p>但是，当数组变为三维、四维、无维时，这个改动的写法层级都不会变哦</p>
<h2> 2. 遍历中return支持</h2>
<p>前面的实现对于正常的遍历没啥问题；但是当我们在遍历过程中，遇到某个条件直接返回，能支持么？</p>
<p>如一个遍历二维数组，我们希望判断其中是否有偶数，那么可以怎么整？</p>
<p>仔细琢磨一下我们的scan方法，希望可以支持return，主要的问题点就是这个函数方法执行之后，我该怎么知道是继续循环还是直接return呢?</p>
<p>很容易想到的就是执行逻辑中，添加一个额外的返回值，用于标记是否中断循环直接返回</p>
<p>基于此思路，我们可以实现一个简单的demo版本</p>
<p>定义一个函数方法，接受循环的下标 + 返回值</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>循环通用方法就可以相应的改成</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>基于上面这种思路，我们的实际使用姿势如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这个实现可满足我们的需求，唯一有个别扭的地方就是返回，总有点不太优雅；那么除了这种方式之外，还有其他的方式么？</p>
<p>既然考虑了返回值，那么再考虑一下传参呢？通过一个定义的参数来装在是否中断以及返回结果，是否可行呢？</p>
<p>基于这个思路，我们可以先定义一个参数包装类</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们希望通过Ans这个类来记录循环结果，其中tag=true，则表示不用继续循环了，直接返回ans结果吧</p>
<p>与之对应的方法改造及实例如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样看起来就比前面的要好一点了</p>
<p>实际跑一下，看下输出是否和我们预期的一致；</p>
<figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/546a699ae4334df4b6525332da4e5770~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure>
]]></content:encoded>
      <enclosure url="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/546a699ae4334df4b6525332da4e5770~tplv-k3u1fbpfcp-watermark.image?" type="image/"/>
    </item>
    <item>
      <title>13.List转Map List的几种姿势</title>
      <link>https://liuyueyi.github.io/tutorial/java/skill/13.List%E8%BD%ACMap-List%E7%9A%84%E5%87%A0%E7%A7%8D%E5%A7%BF%E5%8A%BF.html</link>
      <guid>https://liuyueyi.github.io/tutorial/java/skill/13.List%E8%BD%ACMap-List%E7%9A%84%E5%87%A0%E7%A7%8D%E5%A7%BF%E5%8A%BF.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">13.List转Map List的几种姿势</source>
      <description>实战13：List转Map List的几种姿势 今天介绍一个实用的小知识点，如何将List转为Map&amp;lt;Object, List&amp;lt;Object&amp;gt;&amp;gt;</description>
      <category>Java</category>
      <category>编程技巧</category>
      <pubDate>Tue, 17 May 2022 19:44:20 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 实战13：List转Map List的几种姿势</h1>
<p>今天介绍一个实用的小知识点，如何将List转为<code>Map&lt;Object, List&lt;Object&gt;&gt;</code></p>
<!-- more -->
<h2> 1. 转换方式</h2>
<h3> 1.1. 基本写法</h3>
<p>最开始介绍的当然是最常见、最直观的写法，当然也是任何限制的写法</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对于jdk8+，上面for循环中的内容可以利用<code>Map.computeIfAbsent</code>来替换，具体写法如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当然既然已经是jdk1.8了，借助Stream的流处理，可以将上面的更一步进行简化，如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 1.2. 通用方法</h3>
<p>上面是针对特定的列表，针对业务进行开发转换，那么我们接下来尝试构建一个通用的工具类</p>
<p>这里我们主要借助的知识点就是泛型，一个重要的点就是如何获取Map中的key</p>
<p>对于jdk &lt; 1.8的写法，通过接口来定义实现key的获取姿势</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用demo如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来再看一下jdk1.8之后的写法，结合stream + 函数方法来实现</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其对应的使用方式则如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1.3. 工具类</h3>
<p>上一节介绍了基于泛型 + jdk8 Stream + 函数方法来实现通用转换工具类的实现姿势，接下来我们小结一下，输出一个适用于1.8之后的工具类</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1.4.guava HashMultimap扩展知识点</h3>
<p>最后再介绍一个扩展知识点，Gauva工具包中提供了一个<code>HashMultimap</code>的工具类，他的使用姿势和我们平常的Map并无差别，但是需要在注意的是，它的value是个集合</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>实际输出如下，验证了value实际上是个集合（on只有一个，如果是我们上面的工具类，会输出两个）</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>14.分页遍历的两种使用姿势</title>
      <link>https://liuyueyi.github.io/tutorial/java/skill/14.%E5%88%86%E9%A1%B5%E9%81%8D%E5%8E%86%E7%9A%84%E4%B8%A4%E7%A7%8D%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF.html</link>
      <guid>https://liuyueyi.github.io/tutorial/java/skill/14.%E5%88%86%E9%A1%B5%E9%81%8D%E5%8E%86%E7%9A%84%E4%B8%A4%E7%A7%8D%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">14.分页遍历的两种使用姿势</source>
      <description>实战14：分页遍历得两种实现策略 在日常开发中，分页遍历迭代的场景可以说非常普遍了，比如扫表，每次捞100条数据，然后遍历这100条数据，依次执行某个业务逻辑；这100条执行完毕之后，再加载下一百条数据，直到扫描完毕 那么要实现上面这种分页迭代遍历的场景，我们可以怎么做呢 本文将介绍两种使用姿势 常规的使用方法 借助Iterator的使用姿势</description>
      <category>Java</category>
      <category>JDK</category>
      <pubDate>Thu, 25 Feb 2021 08:05:07 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 实战14：分页遍历得两种实现策略</h1>
<p>在日常开发中，分页遍历迭代的场景可以说非常普遍了，比如扫表，每次捞100条数据，然后遍历这100条数据，依次执行某个业务逻辑；这100条执行完毕之后，再加载下一百条数据，直到扫描完毕</p>
<p>那么要实现上面这种分页迭代遍历的场景，我们可以怎么做呢</p>
<p>本文将介绍两种使用姿势</p>
<ul>
<li>常规的使用方法</li>
<li>借助Iterator的使用姿势</li>
</ul>
<!-- more -->
<h2> 1. 实现方式</h2>
<h3> 1.1. 数据查询模拟</h3>
<p>首先mock一个分页获取数据的逻辑，直接随机生成数据，并且控制最多返回三页</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1.2. 基本实现方式</h3>
<p>针对这种场景，最常见也是最简单直观的实现方式</p>
<ul>
<li>while死循环</li>
<li>内部遍历</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1.3. 迭代器实现方式</h3>
<p>接下来介绍一种更有意思的方式，借助迭代器的遍历特性来实现，首先自定义一个通用分页迭代器</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来借助上面的迭代器可以比较简单的实现我们的需求了</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>那么问题来了，上面这种使用方式比前面的优势体现再哪儿呢？</p>
<ul>
<li>双层循环改为单层循环</li>
</ul>
<p>接下来接入重点了，在jdk1.8引入了函数方法 + lambda之后，又提供了一个更简洁的使用姿势</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在jdk1.8及之后的使用姿势，一行代码即可</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这次对比效果是不是非常显眼了，从此以后分页迭代遍历再也不用冗长的双重迭代了</p>
]]></content:encoded>
    </item>
    <item>
      <title>15.数组拷贝</title>
      <link>https://liuyueyi.github.io/tutorial/java/skill/15.%E6%95%B0%E7%BB%84%E6%8B%B7%E8%B4%9D.html</link>
      <guid>https://liuyueyi.github.io/tutorial/java/skill/15.%E6%95%B0%E7%BB%84%E6%8B%B7%E8%B4%9D.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">15.数组拷贝</source>
      <description>实战15：数组拷贝 说实话，在实际的业务开发中，基本上很少很少很少...会遇到数组拷贝的场景，甚至是我们一般都不怎么用数组，List它不香嘛，为啥要用数组 现在问题来了，要实现数组拷贝，怎么整？</description>
      <category>Java</category>
      <category>编程技巧</category>
      <pubDate>Sat, 21 Aug 2021 06:56:34 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 实战15：数组拷贝</h1>
<p>说实话，在实际的业务开发中，基本上很少很少很少...会遇到数组拷贝的场景，甚至是我们一般都不怎么用数组，List它不香嘛，为啥要用数组</p>
<p>现在问题来了，要实现数组拷贝，怎么整？</p>
<!-- more -->
<h2> 1. 实现方式</h2>
<h3> 1.1. 基础写法</h3>
<p>最简单直接的写法，那就是新建一个数组，一个一个拷贝进去，不就完事了么</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1.2. 借用容器中转</h3>
<p>数组用起来有点麻烦，还是用容器舒爽，借助List来实现数组的拷贝，也就几行代码</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1.3. Array.copy</h3>
<p>上面这个有点绕得远了， 直接使用Array.copy</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1.4. System.arraycopy</h3>
<p>除了上面的，还可以使用更基础的用法</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果有看过jdk源码的小伙伴，上面这个用法应该不会陌生，特别是在容器类，这种数组拷贝的方式比比可见</p>
<p>参数说明:</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>src : 原数组</li>
<li>srcPos: 原数组用于拷贝的起始下标</li>
<li>dest: 拷贝后的数组</li>
<li>destPos: 目标数组的小标</li>
<li>length: 原数组中拷贝过去的数组长度</li>
</ul>
<p>从上面的描述也能看出来，这个方法不仅能实现数组拷贝，还可以实现数组内指定片段的拷贝</p>
]]></content:encoded>
    </item>
    <item>
      <title>16.如何判断类为基础类型or基础类型的包装类</title>
      <link>https://liuyueyi.github.io/tutorial/java/skill/16.%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E7%B1%BB%E4%B8%BA%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8Bor%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8C%85%E8%A3%85%E7%B1%BB.html</link>
      <guid>https://liuyueyi.github.io/tutorial/java/skill/16.%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E7%B1%BB%E4%B8%BA%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8Bor%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8C%85%E8%A3%85%E7%B1%BB.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">16.如何判断类为基础类型or基础类型的包装类</source>
      <description>实战16：判断类为基础类型or基础类型的包装类 判断一个类是否为基础类型属于常规操作了，一般我们遇到这种case，要怎么处理呢？ 一个一个的if/else判断? 还是其他的操作姿势？</description>
      <category>Java</category>
      <category>编程技巧</category>
      <pubDate>Fri, 03 Sep 2021 19:36:52 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 实战16：判断类为基础类型or基础类型的包装类</h1>
<p>判断一个类是否为基础类型属于常规操作了，一般我们遇到这种case，要怎么处理呢？</p>
<p>一个一个的if/else判断? 还是其他的操作姿势？</p>
<!-- more -->
<h2> 1. 基础类型判断</h2>
<p>基础类型可以借助class类的<code>isPrimitive</code>方法来实现判定，使用姿势也简单</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>如果返回true，那么这个对象就是基本类型</p>
<ul>
<li>boolean</li>
<li>char</li>
<li>byte</li>
<li>short</li>
<li>int</li>
<li>long</li>
<li>float</li>
<li>double</li>
<li>void</li>
</ul>
<p>但是请注意，对于封装类型，比如Long，访问isPrimitive返回的是false</p>
<h2> 2. 封装类型判断</h2>
<p>那么封装类型可以怎么判断呢？难道一个一个的判定不成？</p>
<p>首先我们注意到<code>Class#isPrimitive</code>的方法签名，如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的注释中，提到了Boolean#Type之类的静态成员，也就是说包装类型，都有一个TYPE的静态成员</p>
<p>比如boolean的是这个</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>所以我们可以通过这个TYPE来判定，当前对象是否为封装对象</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果Class对象没有TYPE字段，那么就不是封装类，直接抛异常，返回false；当然这种通过异常的方式来判定，并不优雅；但是写法上比我们一个一个的if/else进行对比，要好得多了</p>
]]></content:encoded>
    </item>
    <item>
      <title>17.Java对象内存地址输出</title>
      <link>https://liuyueyi.github.io/tutorial/java/skill/17.Java%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80%E8%BE%93%E5%87%BA.html</link>
      <guid>https://liuyueyi.github.io/tutorial/java/skill/17.Java%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80%E8%BE%93%E5%87%BA.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">17.Java对象内存地址输出</source>
      <description>实战17：Java对象内存地址输出 输出对象地址 当一个对象没有重写hascode方法时，它返回的内存地址，当覆盖之后，我们有什么办法获取对象的内存地址么? 使用 System.identityHashCode() 输出内存地址</description>
      <category>Java</category>
      <category>JDK</category>
      <pubDate>Fri, 29 Jan 2021 10:37:36 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 实战17：Java对象内存地址输出</h1>
<h2> 输出对象地址</h2>
<p>当一个对象没有重写<code>hascode</code>方法时，它返回的内存地址，当覆盖之后，我们有什么办法获取对象的内存地址么?</p>
<ul>
<li>使用 <code>System.identityHashCode()</code> 输出内存地址</li>
</ul>
<!-- more -->
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果如:</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这个有啥用？</p>
<ul>
<li>判断两个对象是否为同一个对象时，可以借用（我是在验证Mybatis的一级缓存的，判断返回的Entity是否确实是同一个的时候以此来判定的）</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>18.随机数生成怎么选</title>
      <link>https://liuyueyi.github.io/tutorial/java/skill/18.%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%94%9F%E6%88%90%E6%80%8E%E4%B9%88%E9%80%89.html</link>
      <guid>https://liuyueyi.github.io/tutorial/java/skill/18.%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%94%9F%E6%88%90%E6%80%8E%E4%B9%88%E9%80%89.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">18.随机数生成怎么选</source>
      <description>实战18：随机数生成怎么选 随机数生成，java中有一个专门的Random类来实现，除此之外，使用Math.random的也比较多，接下来我们简单学习下，随机数的使用姿势</description>
      <category>Java</category>
      <category>编程技巧</category>
      <pubDate>Fri, 03 Sep 2021 19:40:13 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 实战18：随机数生成怎么选</h1>
<p>随机数生成，java中有一个专门的Random类来实现，除此之外，使用<code>Math.random</code>的也比较多，接下来我们简单学习下，随机数的使用姿势</p>
<!-- more -->
<h2> 1.随机数生成</h2>
<h3> 1.1. Math.random</h3>
<p>jdk提供的基础工具类Math中封装一些常用的基础方法，比如我们今天的主题，生成随机数，使用姿势如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>使用起来比较简单，生成的是[0,1)之间的浮点数，但是不要以为它就真的只能生成0-1之间的随机数，举例如下</p>
<p>如果想利用它，生成一个 <code>[120, 500]</code> 这个区间的随机数，怎么整？</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>为啥上面的可行？</p>
<p>将上面的代码翻译一下，取值区间如</p>
<p><code>Math.random() * 381 + 120</code> 取值范围如下</p>
<ul>
<li>[0, 1) * 381 + 120</li>
<li>[0, 381) + 120</li>
<li>[120, 501)</li>
</ul>
<p>借助<code>Math.ceil</code>只取浮点数中的整数部分，这样我们的取值范围就是 [120, 500]了，和我们的预期一致</p>
<p>最后简单来看下，<code>Math.random()</code>是怎么实现随机数的</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>请注意上面的实现，原来底层依然使用的是<code>Random</code>类来生成随机数，而且上面这种写法属于非常经典的单例模式写法（不同于我们常见的双重判定方式，这种属于内部类的玩法，后面再说为啥可以这么用）</p>
<h3> 1.2. Random</h3>
<p>除了使用上面的Math.random来获取随机数之外，直接使用Random类也是很常见的case；接下来先简单看一下Random的使用姿势</p>
<p><strong>创建Random对象</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>生成随机数</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>伪随机高斯分布双精度数</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>随机类的nextGaussian()方法返回下一个伪随机数，即与随机数生成器序列的平均值为0.0，标准差为1.0的高斯(正态)分布双精度值</p>
<p>这种使用场景可能用在更专业的场景，至少我接触过的业务开发中，没有用过这个😂</p>
<h3> 1.3. Math.random 与 Random如何选</h3>
<p>上面两个都可以用来生成随机数，那么在实际使用的时候，怎么选择呢？</p>
<p>从前面的描述也可以知道，它们两没啥本质区别，底层都是用的Random类，在实际的运用过程中，如果我们希望可以场景复现，比如测试中奖概率的场景下，选择Random类，指定随机种子可能更友好；如果只是简单的随机数生成使用，那么选择<code>Math.random</code>即可，至少使用起来一行代码即可</p>
]]></content:encoded>
    </item>
  </channel>
</rss>