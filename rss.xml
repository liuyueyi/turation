<?xml version="1.0" encoding="utf-8"?><?xml-stylesheet type="text/xsl" href="https://liuyueyi.github.io/tutorial/rss.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <atom:link href="https://liuyueyi.github.io/tutorial/rss.xml" rel="self" type="application/rss+xml"/>
    <title>一灰灰的站点</title>
    <link>https://liuyueyi.github.io/tutorial/</link>
    <description>一灰灰的全网知识站点</description>
    <language>zh-CN</language>
    <pubDate>Thu, 01 Feb 2024 07:52:59 GMT</pubDate>
    <lastBuildDate>Thu, 01 Feb 2024 07:52:59 GMT</lastBuildDate>
    <generator>vuepress-plugin-feed2</generator>
    <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
    <copyright>Copyright by 一灰灰blog</copyright>
    <image>
      <title>一灰灰的站点</title>
      <url>https://liuyueyi.github.io/tutorial/logo.svg</url>
      <link>https://liuyueyi.github.io/tutorial/</link>
    </image>
    <category>IM</category>
    <category>技术管理</category>
    <category>SpringBoot</category>
    <category>基础系列</category>
    <category>配置</category>
    <category>DB系列</category>
    <category>WEB系列</category>
    <category>Response</category>
    <category>WebSocket</category>
    <category>Spring源码</category>
    <category>扩展点</category>
    <category>中间件</category>
    <category>Caffiene</category>
    <category>初始化</category>
    <category>Liquebase</category>
    <category>Mybatis</category>
    <category>email</category>
    <category>应用篇</category>
    <category>JWT</category>
    <category>DB</category>
    <category>Mongo</category>
    <category>Java</category>
    <category>编程技巧</category>
    <category>JDK</category>
    <category>SpringCloud</category>
    <category>Eureka系列</category>
    <category>Feign系列</category>
    <category>采坑记录</category>
    <item>
      <title>01.实时聊天应用简介</title>
      <link>https://liuyueyi.github.io/tutorial/column/im/01.%E5%AE%9E%E6%97%B6%E8%81%8A%E5%A4%A9%E5%BA%94%E7%94%A8%E7%AE%80%E4%BB%8B.html</link>
      <guid>https://liuyueyi.github.io/tutorial/column/im/01.%E5%AE%9E%E6%97%B6%E8%81%8A%E5%A4%A9%E5%BA%94%E7%94%A8%E7%AE%80%E4%BB%8B.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">01.实时聊天应用简介</source>
      <description>1. IM简介 1.1 什么是实时聊天应用？ 实时聊天应用，又称即时通讯（Instant Messaging，简称IM），是一个允许两人或多人通过网络实时聊天应用，又称即时通讯（Instant Messaging，简称IM），是一个允许两人或多人通过网络实时传递文字消息、文件、语音与视频交流的系统。这类应用软件有两种架构形式：C/S架构和B/S架构。在C/S架构中，用户需要下载并安装客户端软件才能使用，例如微信、QQ等；而在B/S架构中，用户只需通过浏览器就可以进行聊天。 实时聊天应用具有极高的&amp;quot;实时性&amp;quot;和&amp;quot;可靠性&amp;quot;，消息的传递几乎没有延迟，且不会丢失。因此，这类应用被广泛应用于各种社交互动领域，如个人通信、商务沟通、企业协作等。</description>
      <category>IM</category>
      <pubDate>Wed, 27 Dec 2023 10:06:46 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 1. IM简介</h2>
<h3> 1.1 什么是实时聊天应用？</h3>
<p>实时聊天应用，又称即时通讯（Instant Messaging，简称IM），是一个允许两人或多人通过网络实时聊天应用，又称即时通讯（Instant Messaging，简称IM），是一个允许两人或多人通过网络实时传递文字消息、文件、语音与视频交流的系统。这类应用软件有两种架构形式：C/S架构和B/S架构。在C/S架构中，用户需要下载并安装客户端软件才能使用，例如微信、QQ等；而在B/S架构中，用户只需通过浏览器就可以进行聊天。</p>
<p>实时聊天应用具有极高的"实时性"和"可靠性"，消息的传递几乎没有延迟，且不会丢失。因此，这类应用被广泛应用于各种社交互动领域，如个人通信、商务沟通、企业协作等。</p>
<h3> 1.2 实时聊天应用的应用场景</h3>
<p>实时聊天应用的应用场景非常广泛，以下是一些常见的应用场景：</p>
<ol>
<li>
<p>社交沟通：即时通信 IM 为应用于社交沟通提供能力支持，可实现单聊、群聊、弹幕等多种聊天模式，支持文字、图片、语音、短视频等多种消息类型。实时消息推送满足消息到达率的要求，并可与实时音视频 TRTC 共同实现实时音视频通话，有效提升用户粘性与活跃度。</p>
</li>
<li>
<p>在线协作和协同编辑：对于需要多用户协同工作的应用，如协同编辑文档或绘图，WebSocket 的实时性使得用户能够看到其他用户的操作。</p>
</li>
<li>
<p>视频会议和聊天：视频会议、聊天等高实时性的场景，都适合使用IM来做。</p>
</li>
<li>
<p>抽奖和互动游戏：这些需要高实时性反馈的活动，也是实时聊天应用的典型应用场景。</p>
</li>
<li>
<p>股票基金实时报价、体育实况更新：这些需要实时信息更新的场景，可以利用实时聊天应用的特性，快速准确地将信息传递给用户。</p>
</li>
<li>
<p>基于位置的应用：例如Uber、滴滴等打车软件，可以利用实时聊天应用获取司机的位置信息，提高服务的便捷性和效率。</p>
</li>
</ol>
<h2> 2. WebSocket简介</h2>
<h3> 2.1 什么是WebSocket</h3>
<p>WebSocket是一种在单个TCP连接上进行全又向通信的协议。它是建立在TCP/IP协议之上，独立于HTTP协议，可以允许客户端和服务器之间进行双向通信。这种持久化的协议能够大幅度减少网络延迟和数据传输的开销，并提高资源利用率。</p>
<p>WebSocket的工作原理是，首先，客户端和服务端需要通过握手来建立连接。在握手成功之后，就会形成一条持久的连接通道，使得数据可以双向实时传输，一旦连接建立，服务端可以在任何时候将数据主动推送到客户端。这种方式不仅减少了频繁请求导致的网络延迟，还提高了用户体验。</p>
<p>此外，WebSocket还支持跨域通信，使得不同的域名、端口或协议之间的数据交换变得更容易。并且，WebSocket协议的端口是80，这使得其能够在大多数网络环境中顺利工作。</p>
<h3> 2.2 WebSocket与HTTP的区别</h3>
<p>WebSocket和HTTP是两种完全不同的网络协议，它们在通信方式、连接方式以及应用场景上都存在显著的差异。</p>
<p>首先，两者的通信方式不同。WebSocket是一种双向通信协议，能够实现客户端与服务器间实时双向信息传输。这意味着，服务器可以在任何时候将数据“推送”到客户端。而HTTP协议则是单向的，信息传送总是从客户端发起，服务器对请求做出响应。</p>
<p>其次，两者的连接方式也有所不同。WebSocket在建立连接时，需要经历一次由服务器和客户端进行的握手过程。一旦连接建立，该连接就会持续保持，直到被明确终止。这与HTTP的无状态连接方式形成了鲜明的对比，后者的每次数据传输都需要建立新的TCP连接。</p>
<p>此外，WebSocket和HTTP在应用场景上也各有所长。WebSocket由于其双向通信和长连接的特性，常被用于如聊天应用、实时通知等需要频繁、实时交互的场景；而HTTP协议则更多地用在需要获取或提交资源（如网页、图片等）的信息交换中。</p>
<h3> 2.3 WebSocket协议</h3>
<blockquote>
<p><a href="https://datatracker.ietf.org/doc/html/rfc6455" target="_blank" rel="noopener noreferrer">RFC 6455 - The WebSocket Protocol</a></p>
</blockquote>
<h4> 2.3.1 WebSocket的工作原理</h4>
<p>WebSocket是一种在单个TCP连接上进行全双工通信的协议，它允许服务端与客户端之间进行实时数据交互，且信息传递的方式可以是服务端主动向客户端推送。这种协议是建立在TCP协议之上的，能够实现双向通讯。</p>
<p>WebSocket协议的工作流程包括以下几个步骤：</p>
<ol>
<li>
<p>握手阶段：这是建立连接时的第一个阶段。客户端向服务端发送一个HTTP请求；然后，服务器在响应头中添加一些特殊的字段，表明愿意将当前的HTTP连接升级为WebSocket连接；当客户端收到这个响应后，也会在请求头中添加类似的字段，同时，客户端还会将<code>Sec-WebSocket-Key</code>对应的值通过SHA-1算法进行编码，将编码后的值作为<code>Sec-WebSocket-Accept</code>放在请求头中；最后，服务器对<code>Sec-WebSocket-Key</code>对应的值进行同样的SHA-1编码。</p>
</li>
<li>
<p>数据传输阶段：一旦连接建立，数据就可以在客户端和服务器之间双向流动。这个阶段是全双工的，意味着数据可以同时从客户端发送到服务器，也可以从服务器发送到客户端。</p>
</li>
</ol>
<p>此外，WebSocket协议还具有以下特点：</p>
<ul>
<li>信息传输的开销较小，因为其数据帧相较于HTTP请求报文小；</li>
<li>较低的服务器资源占用。由于WebSocket的长连接特性，服务器能处理更多的并发连接。</li>
</ul>
<h4> 2.3.2 WebSocket协议的握手过程</h4>
<p>WebSocket协议的握手过程是建立WebSocket连接前的重要步骤，主要包括以下步骤：</p>
<ol>
<li>客户端通过TCP连接到服务器。</li>
<li>客户端向服务器发送HTTP/1.1协议的GET请求，这个请求通常被称为握手请求。</li>
<li>握手请求中包含了几个特定的头信息，这些信息用于指示客户端希望升级到WebSocket协议。具体来说，这些头信息包括：</li>
</ol>
<ul>
<li>Upgrade: websocket，这表示客户端希望升级到WebSocket协议。</li>
<li>Connection: Upgrade，这表示客户端希望建立持久连接。</li>
<li>Sec-WebSocket-Key: 这是一个随机的Base64编码密钥，用于安全验证。</li>
<li>Sec-WebSocket-Version: 这指示了客户端使用的WebSocket协议版本。</li>
</ul>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="4">
<li>一旦服务器接收到并验证了这些头信息，它就会返回一个响应给客户端。这个响应也是一个HTTP/1.1协议的响应，对应的HTTP状态码为101，此外还包含了一些特定的头信息，例如Upgrade和Connection头信息，指示连接已经升级到了WebSocket协议。同时，响应的正文中包含了由服务器生成的Base64编码的握手响应。</li>
</ol>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="5">
<li>一旦客户端收到服务器的响应，它就会检查响应中的头信息以及正文中的握手响应。如果一切验证无误，那么WebSocket连接就建立起来了。</li>
</ol>
<p>对应的校验机制如下：</p>
<ul>
<li>客户端应首先检查服务端返回的状态码是否为 101, 只有在 HTTP 状态码为 101 时才代表服务端同意了协议升级, 对于其它类型的状态码, 客户端应根据 HTTP 状态码的语义做相应的处理</li>
<li>客户端应检查服务端返回的响应是否包含 Upgrade 字段, 若缺失, 代表 Upgrade 未成功, 客户端应终止 WebSocket 握手</li>
<li>客户端应检查 Upgrade 字段的值是否为 websocket (该字段是大小写不敏感的, 如 websocket, WebSocket, webSocket 等都是合法的), 若不是, 客户端应终止 WebSocket 握手</li>
<li>客户端应采用如上所表述的方式校验服务端返回的 Sec-WebSocket-Accept 字段的值是否合法, 若该字段不存在或值不符合预期, 则客户端应终止 WebSocket 握手</li>
<li>若服务端返回的 Header 中包含 Sec-WebSocket-Extensions, 但其字段的值并不在客户端最初向服务端发起握手时传递的 Sec-WebSocket-Extensions 的值列表中, 则客户端应终止 WebSocket 握手</li>
<li>若服务端返回的 Header 中包含 Sec-WebSocket-Protocol, 但该字段的值并不在客户端最初向服务端发起握手时传递的 Sec-WebSocket-Protocol 的值列表中, 则客户端应终止 WebSocket 握手</li>
</ul>
<p>以上就是WebSocket协议的握手过程，这个过程确保了客户端和服务器都明确彼此将使用WebSocket协议进行通信，并且已经完成了必要的安全验证。</p>
<h4> 2.3.3 WebSocket协议的消息格式</h4>
<p>WebSocket 以 frame 为单位传输数据, frame 是客户端和服务端数据传输的最小单元, 当一条消息过长时, 通信方可以将该消息拆分成多个 frame 发送, 接收方收到以后重新拼接、解码从而还原出完整的消息, 在 WebSocket 中, frame 有多种类型, frame 的类型由 frame 头部的 Opcode 字段指示, WebSocket frame 的结构如下所示:</p>
<figure><img src="/imgs/column/im/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>Frame由两部分组成：头部和数据部分。</p>
<p>头部是一个二进制字节流，包含以下几部分内容：</p>
<ul>
<li>Fin: 这是一个1比特的标志位，用于指示当前的frame是不是消息的最后一个分段。如果一个消息被切分为多个frame进行发送，那么除了最后一个frame，其他所有frame的Fin字段都会被设置为0，而最后一个frame的Fin字段则被设置为1。当然，如果一条消息没有被切分，那么一个frame就会包含完整的消息，此时该frame的Fin字段值就为1。</li>
<li>Rsv1, Rsv2, Rsv3: 这三个标志位各占1比特，目前还没有定义具体的含义，保留给后续的应用。</li>
<li>Opcode: 这是4比特的操作码，用于指示客户端和服务器之间要执行的具体操作。比如连接建立、关闭连接、文本消息、二进制消息等。</li>
<li>Mask: 这是一个1比特的标志位，用于指示是否需要对数据进行掩码处理。如果需要掩码处理，那么在数据字段中就会出现一个4字节的掩码键。</li>
<li>Payload length: 这是16比特的长度字段，表示接下来的数据长度。因为WebSocket协议支持传输的数据长度可以是任意的，所以这个字段是必要的。</li>
<li>Masking-key: 如果Mask标志位为1，那么这个字段就会出现。它是一个4字节的字段，用于对数据进行掩码处理。</li>
</ul>
<p>数据部分就是根据Payload length字段确定的具体数据内容。</p>
<h2> 3. 实时聊天技术方案</h2>
<p>实时聊天的通讯协议主要有以下几种：</p>
<ol>
<li>
<p>XMPP（可扩展消息与存在协议）：这是一个成熟且开源的即时聊天协议，基于XMPP的开源技术有openfire(后台端)、spark(客户端)等。它的优势在于比较成熟的聊天协议，已在XMPP协议内支持单聊、群聊、加好友等功能。</p>
</li>
<li>
<p>WebSocket：它是一种在单个TCP连接上进行全双工通讯的协议，可以实现客户端与服务器之间的实时数据交互。</p>
</li>
<li>
<p>MQTT（轻量级发布/订阅消息传输协议）：它是一种轻量级的发布/订阅模式的消息传输协议，适用于低带宽、不稳定网络环境下的通信。</p>
</li>
<li>
<p>CoAP（受限应用协议）：它是一种专为受限设备设计的应用层协议，适用于物联网等场景。</p>
</li>
</ol>
<p>其中WebSocket在实时聊天应用中的优势主要体现在以下几个方面：</p>
<ol>
<li>
<p>实时性：WebSocket提供了双向通信，服务器可以主动向客户端推送数据，实现的实时性非常高，适用于实时聊天、在线协作等应用。</p>
</li>
<li>
<p>减少网络延迟：与轮询和长轮询相比，WebSocket可以显著减少网络延迟，因为不需要在每个请求之间建立和关闭连接。</p>
</li>
<li>
<p>较小的数据传输开销：WebSocket的数据帧相比于HTTP请求报文较小，减少了在每个请求中传输的开销，特别适用于需要频繁通信的应用。</p>
</li>
<li>
<p>较低的服务器资源占用：由于WebSocket的长连接特性，服务器可以处理更多的并发连接，相较于短连接有更低的资源占用。</p>
</li>
<li>
<p>跨域通信：与一些其他跨域通信方法相比，WebSocket更容易实现跨域通信。</p>
</li>
<li>
<p>效率和可扩展性：WebSocket技术提供了一种在各种应用程序中实现实时通信的强大高效手段，包括聊天应用程序、协作工具、实时通知和多人游戏。</p>
</li>
</ol>
<p>接下来我们将基于WebSocket来实现一个实时聊天应用的开发搭建</p>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/column/im/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>QuickIM聊天专栏</title>
      <link>https://liuyueyi.github.io/tutorial/column/im/</link>
      <guid>https://liuyueyi.github.io/tutorial/column/im/</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">QuickIM聊天专栏</source>
      <description>WebSocket实现实时聊天应用专栏</description>
      <pubDate>Thu, 28 Dec 2023 07:14:20 GMT</pubDate>
      <content:encoded><![CDATA[<h1> WebSocket实现实时聊天应用专栏</h1>
]]></content:encoded>
    </item>
    <item>
      <title>专栏</title>
      <link>https://liuyueyi.github.io/tutorial/column/</link>
      <guid>https://liuyueyi.github.io/tutorial/column/</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">专栏</source>
      <description>技术专栏 ❤️ 技术管理 📝 高可用专栏</description>
      <pubDate>Fri, 22 Dec 2023 03:01:10 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 技术专栏</h1>
<h2> ❤️ 技术管理</h2>
<h2> 📝 高可用专栏</h2>
]]></content:encoded>
    </item>
    <item>
      <title>00.契机</title>
      <link>https://liuyueyi.github.io/tutorial/column/techmanager/00.%E5%BA%8F%20%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%81%9A%E7%AE%A1%E7%90%86.html</link>
      <guid>https://liuyueyi.github.io/tutorial/column/techmanager/00.%E5%BA%8F%20%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%81%9A%E7%AE%A1%E7%90%86.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">00.契机</source>
      <description>在职业发展的旅程中，每位技术人员都会面临一个关键性的选择：是继续深耕技术领域，还是转向管理岗位。这一选择不仅关乎个人的职业路径，也涉及到如何最有效地发挥自身才能的问题。 我们必须承认，人的精力和时间是有限的资源。在技术领域达到高深境界的专家，其管理能力未必同样出色，反之亦然。管理与技术，虽然同为职场上的重要角色，但它们的要求和侧重点却大相径庭。技术的焦点在于解决与机器相关的具体问题，而管理的重心则在于协调人与人的关系，优化团队的整体效能。两者之间的差异，使得在两者间寻求平衡成为一项挑战。 在过去的一年里，我深刻体会到了这一难题。我面临的困境是：我应继续深化我的技术专长，还是应该转型，投身于管理岗位。</description>
      <category>技术管理</category>
      <pubDate>Wed, 31 Jan 2024 08:53:46 GMT</pubDate>
      <content:encoded><![CDATA[<p>在职业发展的旅程中，每位技术人员都会面临一个关键性的选择：是继续深耕技术领域，还是转向管理岗位。这一选择不仅关乎个人的职业路径，也涉及到如何最有效地发挥自身才能的问题。</p>
<p>我们必须承认，人的精力和时间是有限的资源。在技术领域达到高深境界的专家，其管理能力未必同样出色，反之亦然。管理与技术，虽然同为职场上的重要角色，但它们的要求和侧重点却大相径庭。技术的焦点在于解决与机器相关的具体问题，而管理的重心则在于协调人与人的关系，优化团队的整体效能。两者之间的差异，使得在两者间寻求平衡成为一项挑战。</p>
<p>在过去的一年里，我深刻体会到了这一难题。我面临的困境是：我应继续深化我的技术专长，还是应该转型，投身于管理岗位。</p>
<p>经过一年多的实践和深思，我积累了一些关于技术和管理融合的经验和反思。我希望通过分享这些经验，能够为同行们提供一些参考，特别是那些在技术和管理之间徘徊不决的同仁。</p>
<p>以下是我个人对技术与管理结合的总结与思考，希望能够对大家有所启发，也期待与各位共同探讨，以促进我们在这一复杂领域中的成长和进步。</p>
<h2> 谈一谈职业规划</h2>
<p>关于程序员的职业规划，下面有一张网图，感觉还是很有代表性分享给大家</p>
<figure><img src="/imgs/column/manager/职业发展路线图.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>从上图可以看出，当你实际干了几年之后，通常会出现一个分支，继续走技术，往专家、架构的方向走，还是往技术管理、项目经理的路线发展</p>
<p>就个人职业发展规划而言，我的性格倾向较为内向，并不擅长或特别偏好与人频繁互动。鉴于此，我的初步规划是沿着技术路线发展。</p>
<p>在技术路线上，我们可以进一步细分为两个方向：</p>
<ol>
<li>纯粹的技术方向，这一路径要求深厚的技术功底，专注于解决技术难题、构建系统架构，例如成为Redis、消息队列（MQ）等领域的技术专家。</li>
<li>业务专家方向，这要求深入理解业务领域，更侧重于实际业务问题的解决方案和架构能力，成为业务线中的核心力量。</li>
</ol>
<p>在我国的职场环境中，纯粹技术路径的机会相对有限。对于大多数程序员来说，成为业务专家可能是一个更加现实和贴切的选择。以下是我对于职业规划的一些思考，这些观点主要适用于面试环节或是与上级领导讨论职业发展规划时的情况。</p>
<h3> 如何谈自己的职业规划</h3>
<ol>
<li>技术路线
比如我个人比较喜欢搞技术，因此想在技术这一条路线上继续往下周，通常有两个方向，一个是业务架构、一个技术架构；</li>
</ol>
<p>1.1 针对业务架构方向：</p>
<p>业务架构可能更看重实际的业务解决能力，然后结合自己的实际工作经验说一下
比如：我想成为某个领域的业务专家，梳理复杂的业务模型、制定业务标准解决方案，我的规划是先希望能成为某个业务的负责人，然后再往上负责一条业务线，最后希望可以成为行业类的专家</p>
<ul>
<li>为了往这个方向发展，我做了哪些尝试，比如不仅仅局限开发的角色，会主动反推产品优化业务模型等、不断地学习相关的业务知识点，比如学习了xxxx，参加了xxx会议分享，组织了xxx业务共创会等;</li>
</ul>
<p>1.2 针对技术架构方向</p>
<p>技术架构，则可以从纯技术的角度出发，比如个人还是有很强的技术崇拜，更喜欢做一些技术上的东西，因此希望朝着主程，高级开发，系统架构的方向进行发展</p>
<ul>
<li>对于此，自己做了xxx，比如先成为团队的技术骨干，掌握日常工作的所有技术栈，时刻关心新的技术架构、技术演进，经常参加一些xxx技术会议，平时遇到问题都追本溯源，深挖原理细节，做完之后也会输出相关的复盘给别人分享； 经常思考现在工作项目的架构设计、为什么这么设计，可以怎么优化，组织技术方案评审、架构评审等等都可以谈 （当然重点突出自己做过的事情，不然一问深就露馅了）</li>
</ul>
<ol start="2">
<li>管理路线</li>
</ol>
<p>如果想做技术管理，则可以从职业的生涯规划来说，谈一下什么一个人可以走的很快，但不一定能走的很远；一个团队则可以走的更稳、更远，也希望能结合自己的技术能力 + 加上团队的力量，最大的发挥出自己的特长</p>
<p>2.1 技术管理
先简单说一下为什么想做技术管理，以及个人的忧思：比如一个人的影响范围有限，更希望能依托自己技术的优势，充分发挥一拨人的潜能，干一些有意思、有挑战、有成就感的事情</p>
<ul>
<li>基于此，平时除了做技术的事情之外，也会额外关心team leader是怎么带领团队的，然后从他身上学习xxx</li>
<li>平时也会带一些实习生、应届生，增加自己的带人能力</li>
<li>在一些日常的项目需求中，主动承担牵头人角色，积累自己项目管理的经验，比如具体的有xxx</li>
<li>经常和一些小组长、管理者聊，怎么样来调动大家的积极性，自己也经常学习一些相关视频、文章，提升自己的人际处理能力等</li>
</ul>
<p>2.2 项目经理
对技术人员而言，这条路线相当于转行了，因此要先说一下为什么想做这个：</p>
<ul>
<li>一个供参考的回答
比如说自己有很多的想法，想去充分发挥自己的才能，更喜欢做一些落地事情；或者非常擅长人际关系，资源协调。想充分体验一下不同的风景</li>
</ul>
<p>对于此，自己的努力尝试：</p>
<ul>
<li>个人性格外向，社牛，很会和被人打交道，很会维护人际关系，很会协调资源等 (优势)</li>
<li>做了xxx项目管理的学习，从一些大牛身上学到了xxx  （说明自己有在持续学习）</li>
<li>平时有提高自己的汇报、文档能力 （PM基本功）</li>
<li>在平时的项目管控中，有意思的加强自己的节奏控制能力，比如之前负责xxx项目，经过了xxx步骤，最终完美交付</li>
</ul>
<h2> 转管理的契机</h2>
<p>在我的职业生涯中，目前我正担任技术管理的职位，这已是我第二次承担此类角色。初次尝试管理职位是在一家初创公司，当时的技术负责人离职后，我便接替了他的位置。与许多人的首次管理经历相似，我缺乏管理经验，经历了一段时间的摸索和努力，最终效果却是一般。而现在，我面临着第二次管理的机会。</p>
<p>在2022年底，我转至一家新公司，这里的团队更重视管理经验而非单纯的技术能力。公司的运作模式与IT行业常见的持续迭代和维护的项目有所不同，主要是周期性项目。通常，一个项目的生命周期并不长，项目交付并回款后，主要的工作便是运维，这与外包工作的性质相似。加入公司后，我深刻感受到，在这个环境中，技术研发的地位相对较低。</p>
<p>在这样的背景下，我在入职一个月后遇到了转变的契机。公司有一个企业电商项目需要从外部合作方转回内部进行研发和运营。考虑到公司内部具备电商背景的人员较少，这个任务便落在了我的肩上。对于这个项目，我最初持怀疑态度，不太愿意接手，主要原因有两点：</p>
<ol>
<li>这是一个已在线运行的项目，每日成交额超过1亿，代码量达千万级别，除了代码外几乎没有任何有效文档，而我需要在半年内完全接手；并且在项目经理与我交谈时，团队的基本框架尚未建立。</li>
<li>当时我所在的项目组工作相对轻松，工作量小，压力不大，下班时间早，这是我从业以来经历过的最轻松的工作，我不太愿意离开。</li>
</ol>
<p>在选择的过程中，发生了一个小插曲。我个人更倾向于留在原项目组，也与原项目组的项目经理（PM）讨论其对2023年的规划以及我能发挥的作用。PM建议我若不想加入新项目组，应尽快向公司高层表达我的立场。然而，由于高层领导忙碌，我未能找到合适的机会表达我的想法。而直接负责这个新项目的负责人先行与我交谈，然后我便加入了这个新项目。</p>
<p>之前阅读《知行》一书时，作者提到“超过80%的技术管理者，都是在没有明确表达管理意愿的情况下，被公司推到管理岗位的。”，就我个人的感受而言，在IT行业，突然被推上管理岗位的情况确实比其他行业更为常见。那么，当这样的机会来临时，我们是否真的做好了准备呢？</p>
<h2> 预设目标</h2>
<p>随着新的征程的开启，设定明确的目标对于成功至关重要。在23年初，我即将踏入新项目组并面对即将到来的挑战时，为自己设定了以下目标：</p>
<ol>
<li>迅速融入新项目，建立团队成员之间的信任，并组建一个高效的团队。</li>
<li>顺利接手项目任务，确保工作的连续性和项目的顺利交付。</li>
<li>完成从技术专家到管理角色的转变，培养出一个具有强大战斗力的团队。</li>
</ol>
<p>这些目标在当时看来可能显得有些抽象，缺乏具体的衡量指标。为了在接下来的系列分享中能够对这些目标进行详细分析，我计划在最后的总结中对它们进行深入拆解。 接下来，让我们正式开始这一段项目管理的旅程。</p>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/column/manager/职业发展路线图.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>一灰灰的技术管理之路</title>
      <link>https://liuyueyi.github.io/tutorial/column/techmanager/</link>
      <guid>https://liuyueyi.github.io/tutorial/column/techmanager/</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">一灰灰的技术管理之路</source>
      <description>技术管理 目录清单： 契机 准备工作 入职新项目 招人/带人 新项目交接，团队磨合 如何做项目的持续交接 建立信任：攻坚、身先士卒 进入正轨 突发故障及应对方案：超付 任务过重，分摊压力 中间序曲：转正定级 团队建设与沟通：1to1 授人以渔-软福利的宣扬：项目推进、方案设计、代码评审 人员变动：怎么看离职 向上管理 收获与小结</description>
      <pubDate>Fri, 22 Dec 2023 03:01:10 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 技术管理</h2>
<p>目录清单：</p>
<ol>
<li>契机</li>
<li>准备工作</li>
<li>入职新项目</li>
<li>招人/带人</li>
<li>新项目交接，团队磨合</li>
<li>如何做项目的持续交接</li>
<li>建立信任：攻坚、身先士卒</li>
<li>进入正轨</li>
<li>突发故障及应对方案：超付</li>
<li>任务过重，分摊压力</li>
<li>中间序曲：转正定级</li>
<li>团队建设与沟通：1to1</li>
<li>授人以渔-软福利的宣扬：项目推进、方案设计、代码评审</li>
<li>人员变动：怎么看离职</li>
<li>向上管理</li>
<li>收获与小结</li>
</ol>
]]></content:encoded>
    </item>
    <item>
      <title>16.从零开始：SpringBoot配置动态刷新的详细解析与实践！</title>
      <link>https://liuyueyi.github.io/tutorial/spring/basic/%E9%85%8D%E7%BD%AE/231030-SpringBoot%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E5%8A%A8%E6%80%81%E9%85%8D%E7%BD%AE%E5%88%B7%E6%96%B0%E6%96%B9%E6%A1%88.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/basic/%E9%85%8D%E7%BD%AE/231030-SpringBoot%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E5%8A%A8%E6%80%81%E9%85%8D%E7%BD%AE%E5%88%B7%E6%96%B0%E6%96%B9%E6%A1%88.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">16.从零开始：SpringBoot配置动态刷新的详细解析与实践！</source>
      <description>关于SpringBoot的自定义配置源、配置刷新之前也介绍过几篇博文；最近正好在使用apollo时，排查配置未动态刷新的问题时，看了下它的具体实现发现挺有意思的； 接下来我们致敬经典，看一下如果让我们来实现配置的动态刷新，应该怎么搞？</description>
      <category>SpringBoot</category>
      <category>基础系列</category>
      <category>配置</category>
      <pubDate>Mon, 30 Oct 2023 07:46:58 GMT</pubDate>
      <content:encoded><![CDATA[<p>关于SpringBoot的自定义配置源、配置刷新之前也介绍过几篇博文；最近正好在使用apollo时，排查配置未动态刷新的问题时，看了下它的具体实现发现挺有意思的；</p>
<p>接下来我们致敬经典，看一下如果让我们来实现配置的动态刷新，应该怎么搞？</p>
<!-- more -->
<h2> I. 配置使用姿势</h2>
<p>既然要支持配置的动态刷新，那么我们就得先看一下，在SpringBoot中，常见的配置使用姿势有哪些</p>
<h3> 1. @Value注解绑定</h3>
<p>直接通过<code>@Value</code>注解，将一个对象得成员变量与Environment中的配置进行绑定，如</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意：<code>@Value</code>支持SpEL</p>
<h3> 2. @ConfigurationProperties绑定</h3>
<p>通过<code>@ConfigurationProperties</code>注解声明一个配置类，这个类中的成员变量都是从<code>Environment</code>中进行初始化</p>
<p>如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. Environment.getProperty()直接获取配置</h3>
<p>直接从上下文中获取配置，也常见于各种使用场景中，如</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2> II. 配置刷新</h2>
<p>接下来我们看一下，如何实现配置刷新后，上面的三种使用姿势都能获取到刷新后的值</p>
<h3> 1. 自定义一个属性配置源</h3>
<p>自定义一个配置源，我们直接基于内存的<code>ConcurrentHashMap</code>来进行模拟，内部提供了一个配置更新的方法，当配置刷新之后，还会对外广播一个配置变更事件</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来就需要将这个自定义的配置元，注册到 <code>environment</code> 上下文，在这里我们可以借助<code>ApplicationContextInitializer</code>来实现，在上下文初始化前，完成自定义配置注册</p>
<blockquote>
<ul>
<li><a href="https://spring.hhui.top/spring-blog/2022/09/27/220927-Spring%E6%89%A9%E5%B1%95%E4%B9%8B%E5%AE%B9%E5%99%A8%E5%88%B7%E6%96%B0%E5%89%8D%E5%9B%9E%E8%B0%83ApplicationContextInitializer/" target="_blank" rel="noopener noreferrer">【扩展点】 容器刷新前回调ApplicationContextInitializer | 一灰灰Blog</a></li>
</ul>
</blockquote>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来注册这个扩展点，直接选择在项目启动时，进行注册</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. Environment配置刷新</h3>
<p>envionment实时获取配置的方式，支持配置刷新应该相对简单，如直接吐出一个接口，支持更新我们自定义配置源的配置，不做任何变更，这个配置应该时同时更新的</p>
<p>首先提供一个Spring的工具类，用于更简单的获取Spring上下文</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>配置更新的示例</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>执行验证一下:</p>
<figure><img src="/imgs/231030/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 3. <code>@ConfigurationProperties</code> 配置刷新</h3>
<blockquote>
<p><a href="https://spring.hhui.top/spring-blog/2023/06/27/230627-SpringBoot%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7%E9%85%8D%E7%BD%AE%E7%BB%91%E5%AE%9A%E5%AE%9E%E7%8E%B0%E4%BB%8B%E7%BB%8D/" target="_blank" rel="noopener noreferrer">【基础系列】自定义属性配置绑定极简实现姿势介绍 | 一灰灰Blog</a></p>
</blockquote>
<p>之前在介绍自定义属性配置绑定时介绍过，通过<code>Binder</code>来实现绑定配置的Config对象动态刷新，我们这里同样可以实现配置变更时，主动刷新<code>@ConfigurationProperties</code>注解绑定的属性</p>
<p>具体实现如下，</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意上面的实现，分三类：</p>
<ol>
<li><code>public &lt;T&gt; void bind(Bindable&lt;T&gt; bindable)</code>: 具体实现绑定配置刷新的逻辑</li>
</ol>
<p>核心思想就是将当前对象与environment配置进行重新绑定</p>
<ol start="2">
<li><code>public void run</code>: binder初始化</li>
</ol>
<p>在应用启动之后进行回调，确保是在environment准备完毕之后回调，获取用于属性配置绑定的binder，避免出现<code>envionment</code>还没有准备好</p>
<p>也可以借助实现<code>EnvironmentPostProcessor</code>来实现</p>
<ol start="3">
<li><code>public void refreshConfig(ConfigChangeListener.ConfigChangeEvent event)</code>： 配置刷新</li>
</ol>
<p>通过<code>@EventListener</code>监听配置变更事件，找到所有的<code>ConfigurationProperties</code>修饰对象，执行重新绑定逻辑</p>
<p>接下来我们验证一下配置变更是否会生效</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>定义一个UserConfig来接收<code>config</code>前缀开始的配置，通过update接口来更新相关配置，更新完毕之后返回UserConfig的结果</p>
<figure><img src="/imgs/231030/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 4. @Value 配置刷新</h3>
<p>最后我们再来看一下@Value注解绑定的配置的刷新策略，很久很久之前我也介绍一篇博文，如何实现动态刷新，欢迎查看</p>
<blockquote>
<p><a href="https://spring.hhui.top/spring-blog/2021/08/01/210801-SpringBoot%E5%BA%94%E7%94%A8%E7%AF%87-Value%E6%B3%A8%E8%A7%A3%E6%94%AF%E6%8C%81%E9%85%8D%E7%BD%AE%E8%87%AA%E5%8A%A8%E5%88%B7%E6%96%B0%E8%83%BD%E5%8A%9B%E6%89%A9%E5%B1%95/" target="_blank" rel="noopener noreferrer">【基础系列】SpringBoot应用篇@Value注解支持配置自动刷新能力扩展 | 一灰灰Blog</a></p>
</blockquote>
<p>其核心思想就是找出所有<code>@Value</code>绑定的成员变量，当监听到配置变更之后，通过反射的方式进行刷新</p>
<p>关键的实现如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的实现，主要利用到<code>BeanPostProcessor</code>，在bean初始化之后，扫描当前bean中是否有<code>@Value</code>绑定的属性，若有，则注册到自定义的<code>SpringValueRegistry</code>中</p>
<p><strong>注意事项：</strong></p>
<ol>
<li><code>@Value</code>有两种绑定姿势，直接放在成员变量上，以及通过方法进行注入</li>
</ol>
<p>所以上面的实现策略中，有<code>Field</code>和<code>Method</code>两种不同的处理策略；</p>
<ol start="2">
<li><code>@Value</code>支持SpEL表达式，我们需要对配置key进行解析</li>
</ol>
<p>相关的源码，推荐直接在下面的项目中进行获取，demo中的实现也是来自apollo-client</p>
<p>接下来再看一下注册配置绑定的实现，核心方法比较简单，两个，一个注册，一个刷新</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>SpringValue的构建，主要就是基于反射需要使用到的一些关键信息的组成上；可以按需进行设计补充</p>
<p>到此，关于@Value注解的配置动态刷新就已经实现了，接下来写几个demo验证一下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/231030/02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 5. 小结</h3>
<p>本文主要介绍了项目中配置的动态刷新的实现方案，也可以看作是apollo配置中心的简易实现原理，其中涉及到的知识点较多，下面做一个简单的小结</p>
<ol>
<li>配置的三种使用姿势</li>
</ol>
<ul>
<li><code>@Value</code>绑定</li>
<li><code>@ConfigurationProperties</code>绑定对象</li>
<li><code>environment.getProperty()</code></li>
</ul>
<ol start="2">
<li>自定义配置源加载</li>
</ol>
<ul>
<li><code>environment.getPropertySources().addFirst(MapPropertySource)</code></li>
</ul>
<ol start="3">
<li>配置刷新</li>
</ol>
<ul>
<li>Binder实现ConfigurationProperties刷新</li>
<li>反射实现@Value注解刷新</li>
</ul>
<h2> III. 不能错过的源码和相关知识点</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/003-self-config-binder" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/003-self-config-binder</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/231030/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>6.如何利用雪花算法生成分布式ID</title>
      <link>https://liuyueyi.github.io/tutorial/spring/db/%E5%9F%BA%E7%A1%80/231026-SpringBoot%E8%87%AA%E5%AE%9A%E4%B9%89%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95%E7%94%9F%E6%88%90%E5%88%86%E5%B8%83%E5%BC%8Fid.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/db/%E5%9F%BA%E7%A1%80/231026-SpringBoot%E8%87%AA%E5%AE%9A%E4%B9%89%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95%E7%94%9F%E6%88%90%E5%88%86%E5%B8%83%E5%BC%8Fid.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">6.如何利用雪花算法生成分布式ID</source>
      <description>系统唯一ID是我们在设计一个系统的时候常常会遇见的问题，比如常见的基于数据库自增主键生成的id，随机生成的uuid，亦或者redis自增的计数器等都属于常见的解决方案；本文我们将会重点看一下业界内大名鼎鼎的雪花算法，是如何实现分布式id的</description>
      <category>SpringBoot</category>
      <category>DB系列</category>
      <category>配置</category>
      <pubDate>Thu, 26 Oct 2023 17:28:47 GMT</pubDate>
      <content:encoded><![CDATA[<p>系统唯一ID是我们在设计一个系统的时候常常会遇见的问题，比如常见的基于数据库自增主键生成的id，随机生成的uuid，亦或者redis自增的计数器等都属于常见的解决方案；本文我们将会重点看一下业界内大名鼎鼎的雪花算法，是如何实现分布式id的</p>
<!-- more -->
<h2> I. 雪花算法</h2>
<h3> 1. 全局唯一id</h3>
<p>雪花算法主要是为了解决全局唯一id，那么什么是全局唯一id呢？它应该满足什么属性呢</p>
<p>基本属性：</p>
<ul>
<li>全局唯一性：不能出现重复的 ID 号，既然是唯一标识，这是最基本的要求；</li>
<li>趋势递增：在 MySQL InnoDB 引擎中使用的是聚集索引，由于多数 RDBMS 使用 B-tree 的数据结构来存储索引数据，在主键的选择上面我们应该尽量使用有序的主键保证写入性能；</li>
<li>单调递增：保证下一个 ID 一定大于上一个 ID，例如事务版本号、IM 增量消息、排序等特殊需求；</li>
<li>信息安全：如果 ID 是连续的，恶意用户的爬取工作就非常容易做了，直接按照顺序下载指定 URL 即可；如果是订单号就更危险了，竞争对手可以直接知道我们一天的单量。所以在一些应用场景下，会需要 ID 无规则、不规则。</li>
</ul>
<h3> 2. 雪花算法</h3>
<p>雪花算法可以说是业界内生成全局唯一id的经典算法，其基本原理也比较简单</p>
<figure><img src="/imgs/231026/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>Snowflake 以 64 bit 来存储组成 ID 的4 个部分：</p>
<ol>
<li>最高位占1 bit，值固定为 0，以保证生成的 ID 为正数；</li>
<li>中位占 41 bit，值为毫秒级时间戳；</li>
<li>中下位占 10 bit，值为机器标识id，值的上限为 1024；</li>
<li>末位占 12 bit，值为当前毫秒内生成的不同的自增序列，值的上限为 4096；</li>
</ol>
<p>从上面的结构设计来看，雪花算法的实现可以说比较清晰了，我们重点看一下它的缺陷</p>
<ol>
<li>时钟回拨问题：由于id的高位依赖于系统的时间戳，因此当服务器时间错乱或者出现时钟回拨，可能导致数据重复</li>
<li>集群规模1024台机器，每1ms单机4096个id最大限制</li>
</ol>
<h3> 3. 实现与使用</h3>
<p>目前雪花算法的实现方式较多，通常也不需要我们进行额外开发，如直接Hutool的<code>Snowflake</code></p>
<p>看下它的核心实现</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>关键实现在 <code>nextId()</code> 方法内，做了两个保护性兼容</p>
<ol>
<li>记录上次生成id的时间戳，若当前时间戳小于上次产生的时间戳，则表示出现了时钟回拨，超过一定间隔，则直接抛异常</li>
</ol>
<figure><img src="/imgs/231026/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<ol start="2">
<li>当前时间戳生成的id数量超过了4096最大值限制，则等待下一秒</li>
</ol>
<figure><img src="/imgs/231026/02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>接下来看一下实际的使用</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出如下:</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>生成的id：19位</li>
<li>单调递增，同一毫秒内，序号+1</li>
</ul>
<h3> 4. 自定义雪花算法实现</h3>
<p>在某些时候我们对雪花算法的实现有一些特殊的定制化场景，比如希望生成的id能一些更具有标识性，如以商城领域的订单数据模型为例</p>
<ul>
<li>第一位：标记订单类型， 1: 普通订单  2: 换货订单  3: 退货订单  4: 退款订单</li>
<li>第二三位：标记订单所属年份，如 22xxx，表示22年的订单；23xxx，则表示23年的订单</li>
</ul>
<p>再比如对订单的长度希望做一些限制,19位太多了，我希望16、7位的长度</p>
<p>再比如我希望调整workerId 与 datacenter之间的分配比例</p>
<p>基于以上等等原因，当我们面对需要修改雪花算法逻辑时，再知晓算法原理的基础上，完全可以自己手撸</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意上面的实现，相比较于前面HuTool的实现，有几个变更</p>
<ol>
<li>时间戳从毫秒改为秒</li>
<li>生成id前五位：年 + 天</li>
<li>workcenterId : dataCenterId = 3 : 7</li>
<li>当时钟回拨时，等待时间追上，而不是直接抛异常</li>
<li>自增序列的起始值，0/1互切</li>
</ol>
<p>接下来再看下实际的使用输出</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 5. 小结</h3>
<p>雪花算法本身的实现并不复杂，但是它的设计理念非常有意思；业界内也有不少基于雪花算法的变种实现，主要是为了解决时钟不一致及时钟回拨问题，如百度<code>UIDGenerator</code>，美团的<code>Leaf-Snowflake</code>方案</p>
<p>雪花算法其实是依赖于时间的一致性的，如果时间回拨，就可能有问题，其次机器数与自增序列虽然官方推荐是10位与12位，但正如没有万能的解决方案，只有最合适的解决方案，我们完全可以根据自己的实际诉求，对64个字节，进行灵活的分配</p>
<p>再实际使用雪花算法时，有几个注意事项</p>
<ol>
<li>雪花算法生成的id，通常是长整形，对于前端使用时，对于超过16位的数字，会出现精度问题，需要转换成String的方式传递，否则就会出现各种预料之外的事情发生</li>
<li>workId如何获取？</li>
</ol>
<ul>
<li>如：借助第三方服务(db/redis/zk)，统一为每个实例分配唯一的workId</li>
<li>如：同一个局域网内的所有应用，借助ip的最后一段来定位</li>
</ul>
<h2> II. 不能错过的源码和相关知识点</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/600-snowflake-id" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/600-snowflake-id</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/231026/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>17.压缩返回结果实例演示，让你的性能更高效！</title>
      <link>https://liuyueyi.github.io/tutorial/spring/web/Response/231108-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8B%E5%8E%8B%E7%BC%A9%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C%E5%AE%9E%E4%BE%8B%E6%BC%94%E7%A4%BA.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/web/Response/231108-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8B%E5%8E%8B%E7%BC%A9%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C%E5%AE%9E%E4%BE%8B%E6%BC%94%E7%A4%BA.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">17.压缩返回结果实例演示，让你的性能更高效！</source>
      <description>本文将介绍一个SpringBoot进阶技巧：压缩返回结果实例演示，旨在提升您的网站访问性能。 当返回的数据较大时，网络开销通常不可忽视。为了解决这个问题，我们可以考虑压缩返回的结果，以减少传输的数据量，从而降低网络开销并提高性能。对于依赖Spring生态的Java开发者来说，幸运的是SpringBoot提供了非常便捷的使用方式。 接下来，我们将介绍几种不同情况下的压缩返回的使用方式： 直接返回文本：使用text/plain作为响应类型。 返回JSON数据：使用application/json作为响应类型。 返回静态资源文件：对于静态资源文件，可以使用压缩算法进行压缩后再返回。</description>
      <category>SpringBoot</category>
      <category>WEB系列</category>
      <category>Response</category>
      <pubDate>Wed, 08 Nov 2023 10:38:11 GMT</pubDate>
      <content:encoded><![CDATA[<p>本文将介绍一个SpringBoot进阶技巧：压缩返回结果实例演示，旨在提升您的网站访问性能。</p>
<p>当返回的数据较大时，网络开销通常不可忽视。为了解决这个问题，我们可以考虑压缩返回的结果，以减少传输的数据量，从而降低网络开销并提高性能。对于依赖Spring生态的Java开发者来说，幸运的是SpringBoot提供了非常便捷的使用方式。</p>
<p>接下来，我们将介绍几种不同情况下的压缩返回的使用方式：</p>
<ul>
<li>直接返回文本：使用text/plain作为响应类型。</li>
<li>返回JSON数据：使用application/json作为响应类型。</li>
<li>返回静态资源文件：对于静态资源文件，可以使用压缩算法进行压缩后再返回。</li>
</ul>
<!-- more -->
<h2> I. 项目配置</h2>
<h3> 1. 依赖</h3>
<p>首先搭建一个标准的SpringBoot项目工程，相关版本以及依赖如下</p>
<p>本项目借助<code>SpringBoot 2.2.1.RELEASE</code> + <code>maven 3.5.3</code> + <code>IDEA</code>进行开发</p>
<p>核心依赖 <code>spring-boot-starter-web</code></p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 启动入口</h3>
<p>我们使用默认的配置进行测试，因此启动入口也可以使用最基础的</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> II. 返回结果压缩</h2>
<h3> 1. 开启gzip压缩</h3>
<p>在Spring Boot中开启压缩，只需要在配置文件中添加以下配置即可自动开启：</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意上面的两个配置，其中 <code>server.compression.enabled</code> 用于控制是否开启压缩；而<code>server.compression.min-response-size</code>则根据实际返回的大小，来决定是否需要开启压缩，上面的配置表示，只有返回的长度超过128时，才开启压缩。</p>
<p>写一个简单的demo进行验证</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>下图为实际访问对比，从两次请求的返回头来看，左边的示例表示没有开启压缩处理，而右边的示例则开启了gzip压缩。</p>
<figure><img src="/imgs/231108/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 2. 返回json对象时最小返回阈值不生效问题</h3>
<p>接下来我们再看一个特殊的场景，当我们返回的是jsonObject对象时，即便返回的内容小于前面配置的128，也会开启压缩</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/231108/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>根据上述实际表现，我们注意到一个令人费解的现象：同样返回一条数据时，如前面返回String时，不需要进行压缩；然而，当数据类型为JsonObject时，即使返回的内容小于128字节，也会启用gzip压缩。</p>
<p>这一现象的主要原因则是：</p>
<p>在Spring Boot框架中，默认情况下会对所有的json对象进行压缩处理。即使返回的数据量较小，即使未达到最小返回阈值，系统也会自动对其进行压缩操作。这样做的目的是为了减少传输的数据量并提高性能。</p>
<blockquote>
<p>即当返回的是对象，即<code>Content-Type: application/json</code>时，不会设置Content-Length，服务端无法判断长度，并且是通过<code>Transfer-Encoding: chunked</code>的方式发送给客户端，因此一定会做压缩。</p>
</blockquote>
<p>若我们希望严格按照预期来执行，那么可以通过对返回结果进行包装，补齐<code>Content-Length</code>来实现</p>
<p>自定义一个过滤器，借助<code>ContentCachingResponseWrapper</code>来包装返回结果</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>再次访问验证一下，结果和我们预期的保持一致了</p>
<figure><img src="/imgs/231108/02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 3. 返回静态资源压缩</h3>
<p>对于前后端未分离的项目，后端可能还需要返回静态资源文件，如JavaScript、CSS和图像等。在Spring Boot中，这些静态资源文件也可以被压缩并返回。为了实现这一功能，主要借助了<code>EncodedResourceResolver</code>类。</p>
<p><code>EncodedResourceResolver</code>是Spring框架中的一个类，用于解析和处理静态资源文件的编码和解码。通过使用<code>EncodedResourceResolver</code>，我们可以对静态资源文件进行压缩，并将其作为响应返回给前端。</p>
<p>一个简单的使用实例如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的配置中，表示将static资源目录下的文件，作为静态资源返回，会设置缓存时间，并开启压缩支持</p>
<p>我们可以再项目的 <code>resources/static/</code> 目录下新增一个 <code>txt.txt</code> 文件，并再其中随意补充一些内容</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>然后直接访问验证一下</p>
<figure><img src="/imgs/231108/03.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>从上面的访问示例可以看出，首次访问时，压缩返回；再次访问时，因为资源未发生变更，所以直接使用本地的缓存。这是因为浏览器在第一次请求静态资源时会将其缓存起来，以便下次访问时能够更快地加载。如果资源发生了更改，浏览器将不会使用缓存的版本，而是重新发起请求以获取最新的资源。</p>
<h3> 4. 小结</h3>
<p>最后对文中介绍的内容做一个整体的总结，在Spring Boot中开启gzip压缩可以通过以下方式实现：</p>
<ol>
<li>在配置文件中添加如下配置：</li>
</ol>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2">
<li>返回json对象时最小返回阈值不生效问题：</li>
</ol>
<p>当返回的是对象时，即使返回的内容小于前面配置的128字节，也会启用gzip压缩。这是因为在Spring Boot框架中，默认会对所有的json对象进行压缩处理。如果不想压缩，可以将返回结果进行包装，实现按需压缩。</p>
<ol start="3">
<li>返回静态资源压缩：</li>
</ol>
<p>对于前后端未分离的项目，后端可能还需要返回静态资源文件，如JavaScript、CSS和图像等。在Spring Boot中，这些静态资源文件也可以被压缩并返回。为了实现这一功能，主要借助了<code>EncodedResourceResolver</code>类，通过设置静态资源的压缩方式，并再<code>WebMvcConfigurer</code>实现中进行注册，从而实现静态资源的压缩与缓存</p>
<h2> III. 不能错过的源码和相关知识点</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/207-web-res-gzip" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/207-web-res-gzip</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/231108/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>2.从零开始学习SpringBoot整合WebSocket与STOMP协议：实用案例带你轻松入门！</title>
      <link>https://liuyueyi.github.io/tutorial/spring/web/WebSocket/231115-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8BWebScoket%E6%95%B4%E5%90%88stomp%E5%8D%8F%E8%AE%AE%E5%AE%9E%E4%BE%8B.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/web/WebSocket/231115-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8BWebScoket%E6%95%B4%E5%90%88stomp%E5%8D%8F%E8%AE%AE%E5%AE%9E%E4%BE%8B.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">2.从零开始学习SpringBoot整合WebSocket与STOMP协议：实用案例带你轻松入门！</source>
      <description>在我们的日常工作中，我们可能会遇到需要实现双向通讯的场景。为了解决这个问题，常见的实现方案包括短轮询、长轮询、SSE和WebSocket等几种方式。本文将重点介绍如何通过整合WebSocket和STOMP协议来实现双向通讯的方案, 并给出一个应用实例，带你轻松掌握如何基于SpringBoot搭建一个在线聊天系统</description>
      <category>WEB系列</category>
      <category>WebSocket</category>
      <pubDate>Wed, 15 Nov 2023 15:12:39 GMT</pubDate>
      <content:encoded><![CDATA[<p>在我们的日常工作中，我们可能会遇到需要实现双向通讯的场景。为了解决这个问题，常见的实现方案包括短轮询、长轮询、SSE和WebSocket等几种方式。本文将重点介绍如何通过整合WebSocket和STOMP协议来实现双向通讯的方案, 并给出一个应用实例，带你轻松掌握如何基于SpringBoot搭建一个在线聊天系统</p>
<!-- more -->
<h2> I. 基础知识点</h2>
<h3> 1. 相关概念释疑</h3>
<p>再开始之前，简单介绍一下文中会出现的几个术语的</p>
<p><strong>WebSocket</strong>： WebSocket是一种在单个TCP连接上进行全双工通信的协议。它使得客户端和服务器之间能够实时地进行双向数据传输，而不需要频繁地建立和关闭连接。这种机制可以提高数据传输的效率和性能。</p>
<p><strong>STOMP</strong>:  Simple Text Oriented Messaging Protocol 是一种简单而灵活的消息传递协议，它是在HTTP之上实现的。STOMP协议定义了一套简单的命令和帧格式，用于在客户端和服务器之间进行消息传递。通过使用STOMP协议，我们可以实现客户端和服务器之间的双向通讯。</p>
<p>注意：stomp协议属于websocket的子协议</p>
<h3> 2. WebSocket整合STOMP</h3>
<p>WebSocket整合STOMP协议实现双向通讯的方案，主要步骤如下：</p>
<ol>
<li>
<p>建立WebSocket连接：客户端通过JavaScript的WebSocket API与服务器建立连接。</p>
</li>
<li>
<p>发送STOMP帧：在WebSocket连接建立后，客户端和服务器就可以通过发送STOMP帧来进行通信了。STOMP帧是STOMP协议的基本单位，它定义了消息的各种操作，如订阅、发布等。</p>
</li>
<li>
<p>处理STOMP帧：服务器收到STOMP帧后，会根据帧的类型进行相应的处理。例如，如果收到一个SUBSCRIBE帧，服务器就会为客户端创建一个订阅；如果收到一个SEND帧，服务器就会将消息发送给指定的目的地。</p>
</li>
<li>
<p>关闭WebSocket连接：当客户端和服务器都完成了通信后，可以通过调用WebSocket API的close方法来关闭连接。</p>
</li>
</ol>
<h3> 3. SpringBoot整合STOMP流程</h3>
<p>SpringBoot对websocket提供了非常友好的封装，对于业务开放而言，可以简单迅速的搭建一个基于STOMP协议的websocket应用工程</p>
<figure><img src="/imgs/231115/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>上图展示了STOMP的基本工作流程。</p>
<p><strong>步骤1：初始化</strong></p>
<p>服务端：</p>
<ul>
<li>定义接收建立WebSocket连接的端点EndPoint。</li>
<li>配置消息代理Broker，用于前端订阅（subscribe），后端向该Broker写入消息后，订阅了该Broker的前端都会收到相应的消息。</li>
<li>配置路由转发规则，将用户发送的信息转发给相应的处理器（类似于<code>RequestMappingHandlerMapping</code>与@<code>RequestMapping</code>注解，在WebSocket中使用的是<code>Destination</code> + <code>@MessageMapping</code>）。</li>
</ul>
<p>客户端：</p>
<ul>
<li>与EndPoint建立连接。</li>
<li>订阅Broker，注册消息回调。</li>
</ul>
<p><strong>步骤2：通讯</strong></p>
<p>服务端：</p>
<ul>
<li>主动向Broker写入消息：使用<code>simpMessagingTemplate</code>。</li>
<li>消息应答：使用<code>@SendTo</code>注解。</li>
</ul>
<p>客户端：</p>
<ul>
<li>发送消息：调用send(xxxx)方法。</li>
<li>消息应答：触发订阅的回调函数。</li>
</ul>
<h2> II. 实例演示</h2>
<h3> 1. 项目配置</h3>
<p>首先搭建一个标准的SpringBoot项目工程，相关版本以及依赖如下</p>
<p>本项目借助<code>SpringBoot 2.2.1.RELEASE</code> + <code>maven 3.5.3</code> + <code>IDEA</code>进行开发</p>
<p>核心依赖 <code>spring-boot-starter-websocket</code>， 其中模板渲染引擎<code>thymeleaf</code>主要是集成前端页面</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. WebSocket配置</h3>
<p>正如前面流程图中介绍的，后端需要先配置一下websocket的相关信息，通过实现配置类<code>WebSocketMessageBrokerConfigurer</code>来定义</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol>
<li>定义端点： <code>registerStompEndpoints()</code></li>
<li>定义客户端与服务端通讯信息: <code>configureMessageBroker()</code></li>
</ol>
<ul>
<li>配置消息代理: <code>registry.enableSimpleBroker</code></li>
<li>配置消息转发: <code>registry.setApplicationDestinationPrefixes</code>，转发前缀可以是多个</li>
</ul>
<p>上面的配置完毕之后，对于客户端而言</p>
<ul>
<li>建立连接的路径是： <code>/ws/hello</code></li>
<li>订阅消息的路径是： <code>/topic/xxx</code>
<ul>
<li>订阅的路径全程，是由 <code>@SendTo</code>的路径来确定</li>
</ul>
</li>
<li>接收前端消息的路劲是: <code>/app/xxx</code>
<ul>
<li>后面的这个xxx，是由 <code>@MessageMapping</code>中的路径来补齐</li>
</ul>
</li>
</ul>
<h3> 3. 消息接收应答</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>实现一个非常简单的消息应答，接收客户端朝 <code>/app/hello</code> 发送的消息，然后将结果写回到 <code>/topic/hello</code> 对应的Broker，那么订阅了这个broker的客户端，都会收到这个应答消息了</p>
<p>再写一个定时器，由后端定时的向<code>/topic/hello</code>这个Broker中写入消息，模拟后台主动下发消息的场景</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4. 前端示例</h3>
<p>一个简单基础的html页面</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>核心的js逻辑，实现websocket连接建立，通讯</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意上面的实现：</p>
<ol>
<li>建立连接 <code>connect()</code></li>
</ol>
<ul>
<li>与后端定义的端点建立连接: <code>new SockJS('/ws/hello');</code></li>
<li>连接建立成功之后，订阅Broker，接收消息回传: <code>stompClient.subscribe('/topic/hello', 消息应答回调)</code></li>
</ul>
<ol start="2">
<li>发送消息</li>
</ol>
<ul>
<li>`stompClient.send("/app/hello", xxx)``</li>
</ul>
<ol start="3">
<li>断开连接</li>
</ol>
<ul>
<li><code>stompClient.disconnect();</code></li>
</ul>
<h3> 5. 演示</h3>
<p>到这里，一个完整的基于SpringBoot整合WebSocket与STOMP协议的示例应用已经搭建完成；接下来我们实际启动一下看看效果</p>
<figure><img src="/imgs/231115/01.gif" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>上面的动图展示了前端建立连接后，向后端发送信息并接收后端广播的消息的过程。由于两个客户端订阅的是同一个broker，因此后端发送的消息可以被所有客户端接收到。</p>
<p>这种交互方式类似于群组聊天，当一个人发送消息后，其他人都可以收到。</p>
<p>如果我希望通过websocket实现一个消息通知的功能，其中后端发送的消息既有广播的，也有面向个人的，那么应该如何实现呢？</p>
<p>我们下篇博文将进行详细介绍</p>
<h2> III. 不能错过的源码和相关知识点</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/203-websocket" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/203-websocket</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/231115/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>3.从零开始学习SpringBoot WebSocket身份鉴权，让你的项目更上一层楼！</title>
      <link>https://liuyueyi.github.io/tutorial/spring/web/WebSocket/231204-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8BWebSocket%E8%BA%AB%E4%BB%BD%E9%89%B4%E6%9D%83.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/web/WebSocket/231204-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8BWebSocket%E8%BA%AB%E4%BB%BD%E9%89%B4%E6%9D%83.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">3.从零开始学习SpringBoot WebSocket身份鉴权，让你的项目更上一层楼！</source>
      <description>上一篇博文介绍了如何利用STOMP和SpringBoot搭建一个能够实现相互通讯的聊天系统。通过该系统，我们了解了STOMP的基本使用方法以及一些基础概念。接下来，我们将在此基础上进行一些增强。由于聊天的本质是交流，因此我们需要知道是谁在与谁进行聊天，这就需要登录功能的支持。 接下来，我们将探讨如何为WebSocket通信添加身份验证功能。</description>
      <category>WEB系列</category>
      <category>WebSocket</category>
      <pubDate>Mon, 04 Dec 2023 09:40:04 GMT</pubDate>
      <content:encoded><![CDATA[<p>上一篇博文介绍了如何利用STOMP和SpringBoot搭建一个能够实现相互通讯的聊天系统。通过该系统，我们了解了STOMP的基本使用方法以及一些基础概念。接下来，我们将在此基础上进行一些增强。由于聊天的本质是交流，因此我们需要知道是谁在与谁进行聊天，这就需要登录功能的支持。</p>
<p>接下来，我们将探讨如何为WebSocket通信添加身份验证功能。</p>
<!-- more -->
<h2> I. 实例演示</h2>
<h3> 1. 项目配置</h3>
<p>首先搭建一个标准的SpringBoot项目工程，相关版本以及依赖如下</p>
<p>本项目借助<code>SpringBoot 2.2.1.RELEASE</code> + <code>maven 3.5.3</code> + <code>IDEA</code>进行开发</p>
<p>核心依赖 <code>spring-boot-starter-websocket</code>， 其中模板渲染引擎<code>thymeleaf</code>主要是集成前端页面</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. WebSocket配置</h3>
<p>首先我们先看一下后端的配置，对于SpringBoot整合STOMP，主要通过实现配置类<code>WebSocketMessageBrokerConfigurer</code>来定义相关的信息：</p>
<ul>
<li>注册端点Endpoint</li>
<li>定义消息转发规则</li>
<li>定义拦截器（配置消息接收、返回的相关参数）</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>有兴趣的小伙伴可以对比一下上面的Endpoint配置与之前整合STOMP的示例中的配置，两者之间存在两个主要差异：</p>
<ol>
<li><code>addEndpoint("/ws/chat/{channel}")</code></li>
</ol>
<p>这个端点并不是一个固定的值，最后一个<code>{channel}</code>是一个变量。可以理解为聊天群，不同聊天群中的信息是相互隔离的，不会出现串频的情况。</p>
<ol start="2">
<li><code>addInterceptors(authHandshakeInterceptor())</code></li>
</ol>
<p>这里设置了身份鉴权拦截器，也是本文的核心内容。在WebSocket连接建立之后，如何识别当前建立连接的用户呢？</p>
<h3> 3. 身份鉴权拦截器</h3>
<p>与SpringMVC类似，WebSocket也支持拦截器。在握手之前，可以通过识别用户身份来实现辅助操作。例如，我们可以从cookie中获取用户信息，并将其写入消息的全局属性请求头。</p>
<p>实现方式主要是通过拦截器在握手过程中进行用户身份验证，并将用户信息存储在全局属性中，以便在整个WebSocket连接的生命周期内使用。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的拦截器可以通过cookie来识别用户身份。当用户登录成功后，将用户名写入请求头uname中。这样，在后续的WebSocket通信过程中，就可以通过访问请求头uname来获取当前登录的用户信息</p>
<h3> 4. 用户登录</h3>
<p>我们还是基于springmvc搭建一个用户的登录入口，直接基于内存做一个最简单的用户登录管理</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>新增一个用户登录的入口，用户登录成功之后，将session写入cookie，有效期30天</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 5. ws聊天实现</h3>
<p>接下来我们开始写登录聊天的相关业务逻辑</p>
<p><strong>后端实现</strong></p>
<p>首先提供一个消息转发的后端接口</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意上面的实现，有几个关键信息</p>
<ol>
<li><code>@MessageMapping("/hello/{channel}")</code></li>
</ol>
<p>这里的<code>{channel}</code>是一个传参形式，表示接收不同目标来源的消息；其取值通过<code>DestinationVariable("channel") String channel</code> 来获取</p>
<p>举个简单的例子：</p>
<ul>
<li>客户端往 <code>app/hello/globalChannel</code> 发送的消息，会被后端转发给 <code>/topic/chat/globalChannel</code></li>
<li>客户端往 <code>app/hello/signleChannel</code> 发送的消息，会被后端转发给 <code>/topic/chat/signleChannel</code></li>
</ul>
<ol start="2">
<li><code>headerAccessor.getSessionAttributes().get("uname")</code></li>
</ol>
<p>从请求头中获取用户身份，没错，这里的uname就是在上面的拦截器 <code>AuthHandshakeInterceptor</code> 写入的</p>
<ol start="3">
<li>消息发送</li>
</ol>
<p>写了一个简单的工具类，实现后端给客户端发送消息， <code>WsAnswerHelper</code>实现如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>最后再给出前端访问入口</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>前端实现</strong></p>
<p>前端的实现和上一篇博文的基本没有太大差别，无非是多了一个登录</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>js实现如下</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>和之前的示例相比，区别在于建立连接之前，先调用了登录接口实现自动登录</p>
<h3> 6. 示例演示</h3>
<p>接下来我们演示一下，用户登录之后，再进行聊天的表现形式</p>
<figure><img src="/imgs/231204/00.gif" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>面的示意图也可以看出，在相同channel之间的用户可以相互通信。聊天信息前面都会带上发送这个消息的用户名。这样可以方便用户识别和区分来自不同用户的聊天信息。</p>
<h3> 7. 小结</h3>
<p>本文通过实例演示了WebSocket的身份鉴权，其底层依然是借助Cookie来实现用户身份识别。与常规的Cookie鉴权不同之处在于，在WebSocket连接的生命周期内，通过HttpSessionHandshakeInterceptor拦截器来解析用户身份，并将相关信息写入到请求头中，以供其他地方进行使用。</p>
<p>本文的主要目的是为大家演示如何实现WebSocket的身份识别验证，整体的功能相对较少。以下是一些可能的应用场景和实现方式：</p>
<ul>
<li>当一个用户加入聊天室时，系统可以通过广播一个通知来告知其他用户。具体实现方式可以是，在用户加入聊天室时，服务器将该用户的身份信息发送给所有已连接的客户端，客户端收到通知后可以在界面上显示相应的提示信息。</li>
<li>当一个用户离开聊天室时，系统同样可以通过广播一个通知来告知其他用户。具体实现方式可以是，在用户离开聊天室时，服务器将该用户的身份信息发送给所有已连接的客户端，客户端收到通知后可以在界面上移除相应的提示信息。</li>
<li>如现在一个订阅对应一个websocket连接，那么是否可以一个ws连接，通过订阅不同的topic，来实现多群组聊天的功能呢？</li>
</ul>
<p>下篇博文将探讨如何实现以下功能：</p>
<ol>
<li>当一个用户加入聊天时，系统广播一个通知。</li>
<li>当用户离开聊天时，系统广播一个通知。</li>
<li>使用一个WebSocket连接，通过订阅不同的主题来实现多群组聊天的功能。</li>
</ol>
<p>敬请期待下篇博文！我是你们的好朋友一灰灰</p>
<h2> II. 不能错过的源码和相关知识点</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-case/207-websocket-chat" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-case/207-websocket-chat</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/231204/00.gif" type="image/gif"/>
    </item>
    <item>
      <title>4.SpringBoot WebSocket进阶：如何利用消息拦截器优化聊天功能？</title>
      <link>https://liuyueyi.github.io/tutorial/spring/web/WebSocket/231218-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8BWebsocket%E6%B6%88%E6%81%AF%E6%8B%A6%E6%88%AA%E5%99%A8%E5%AE%9E%E7%8E%B0%E8%81%8A%E5%A4%A9%E6%8F%90%E9%86%92.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/web/WebSocket/231218-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8BWebsocket%E6%B6%88%E6%81%AF%E6%8B%A6%E6%88%AA%E5%99%A8%E5%AE%9E%E7%8E%B0%E8%81%8A%E5%A4%A9%E6%8F%90%E9%86%92.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">4.SpringBoot WebSocket进阶：如何利用消息拦截器优化聊天功能？</source>
      <description>在上一篇文章中，我们成功地为WebSocket的聊天应用添加了身份验证功能。然而，当时遗留了一个关键问题：当一个新用户加入群聊时，我们希望向群聊内的其他成员发送一条欢迎消息，以告知他们有新朋友加入了。那么，如何实现这一需求呢？ 接下来，我们将重点介绍如何使用ChannelInterceptor来实现加入/退出群聊的通知功能。</description>
      <category>WEB系列</category>
      <category>WebSocket</category>
      <pubDate>Mon, 18 Dec 2023 14:23:43 GMT</pubDate>
      <content:encoded><![CDATA[<p>在上一篇文章中，我们成功地为WebSocket的聊天应用添加了身份验证功能。然而，当时遗留了一个关键问题：当一个新用户加入群聊时，我们希望向群聊内的其他成员发送一条欢迎消息，以告知他们有新朋友加入了。那么，如何实现这一需求呢？</p>
<p>接下来，我们将重点介绍如何使用<code>ChannelInterceptor</code>来实现加入/退出群聊的通知功能。</p>
<!-- more -->
<h2> I. 实例演示</h2>
<h3> 1. 项目搭建</h3>
<p>项目搭建过程与前文类似，请直接参考上文 或者 查看文末的项目源码</p>
<h3> 2. WebSocket配置</h3>
<p>在之前介绍的几篇博文中，我们提到了通过实现接口<code>WebSocketMessageBrokerConfigure</code>在之前介绍的几篇博文中，我们提到了通过实现接口<code>WebSocketMessageBrokerConfigurer</code> 来进行 WebSocket 的配置。</p>
<p>本文的重点正是在这个配置类中进行实现，因此我们将借此机会回顾一下之前的内容。</p>
<ul>
<li>首先，我们需要创建一个配置类，并实现 <code>WebSocketMessageBrokerConfigurer</code> 接口。然后，我们可以重写其中的方法来配置 WebSocket 的相关参数和消息代理。</li>
<li>在 <code>configureMessageBroker</code> 方法中，我们可以指定使用的消息代理（例如：SimpleBroker）以及对应的前缀（用于路由消息）。同时，我们还可以设置订阅者模式（<code>subscriptionChannel</code>）和广播模式（<code>publisherChannel</code>），以便在不同的场景下使用不同的通信方式。</li>
<li>接下来，在 <code>registerStompEndpoints</code> 方法中，我们可以注册一个或多个端点（<code>endpoint</code>），并为每个端点指定一个路径（<code>path</code>）。这样，客户端就可以通过这个路径与服务器进行 WebSocket 通信了。</li>
<li>最后，在 <code>addInterceptors</code> 方法中，我们可以添加一些拦截器（<code>interceptor</code>），用于处理 WebSocket 连接、消息发送和接收等过程中的一些逻辑。例如，我们可以添加一个身份验证拦截器，用于验证客户端的身份信息。</li>
</ul>
<p><code>WebSocketMessageBrokerConfigurer</code> 接口允许我们配置 Stomp 协议的各种属性，包括端点、拦截器、消息转换器等。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>configureMessageBroker()方法</strong></p>
<p>配置消息代理与消息转发</p>
<ul>
<li><code>registry.enableSimpleBroker("/topic")</code>: 启用简单的消息代理，即对于客户端而言，前端需要订阅的就是这个路径，如对应 index.js中的 <code>stompClient.subscribe('/topic/hello', xx)</code></li>
<li><code>registry.setApplicationDestinationPrefixes("/app")</code>: 设置了目标转发的前缀为<code>/app</code>，客户端发送给<code>/app/xxx</code>的消息，会被转发给<code>@MessageMapping</code>注解修饰的方法</li>
</ul>
<p>如我们定义的消息转发实现</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>registerStompEndpoints()方法</strong></p>
<p>注册连接端点</p>
<ul>
<li><code>registry.addEndpoint("/ws/chat/{channel}")</code>: 添加端点，对应的就是客户端建立连接的url</li>
<li><code>.addInterceptors(authHandshakeInterceptor())</code>: 上文中用于身份识别的拦截器</li>
</ul>
<p>此外对于跨域支持，也是在这里进行设置，如在上面的链式使用中，添加 <code>.setAllowedOrigins("*")</code></p>
<p><strong>configureClientInboundChannel()方法</strong></p>
<p>用于设置接收客户端消息的相关配置参数，如线程连接参数、拦截器配置</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>关于拦截器<code>SocketInChannelInterceptor</code>为我们自定义的实现，其内部实现了我们对聊天通知的核心逻辑；咱们下一节再看它</p>
<p>请注意上面配置的taskExecutor, 上面的几个配置参数和线程池的配置参数别无二致，一般建议是使用自定义的线程池来进行管理；方便监控</p>
<p><strong>configureClientOutboundChannel()方法</strong></p>
<p>与前面的使用姿势一致，唯一的区别则在于它主要设置的是服务端返回消息给客户端的相关配置，或者拦截</p>
<h3> 3. 管道拦截</h3>
<p>在完成前面的配置后，接下来我们将进入管道拦截器的重点部分。我们的目标是在用户进入或离开群聊时，向群聊的其他成员推送一条通知。</p>
<p>为了实现这一目标，一个直观的方案是监控客户端的订阅和取消订阅操作，并在此基础上进行相应的操作。因此，我们的核心实现将基于之前定义的<code>SocketInChannelInterceptor</code>。</p>
<p>首先来看一下管道拦截器的接口签名</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对于消息广播通知，我们放在<code>afterSendCompletion</code>来实现，判断客户端的命令，对于订阅/取消订阅进行处理</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的订阅实现相对简单，主要有下面几个关键知识点：</p>
<ol>
<li>封装消息头访问器： <code>StompHeaderAccessor.wrap(message)</code>， 简化请求相关信息的获取方式</li>
<li>判断交互类型： <code>headerAccessor.getCommand()</code></li>
<li>获取请求头：</li>
</ol>
<ul>
<li><code>headerAccessor.getHeader("simpDestination")</code></li>
<li><code>message.getHeaders().get("simpDestination")</code></li>
</ul>
<p>需要注意一点：直接可以从请求头中找到客户端订阅的是哪个群组(通过<code>destination</code>)，但是对于取消订阅时，则拿不到这个信息了，因此需要客户端再取消时，将这个关键信息回传给我们</p>
<h3> 4. 前端订阅/取消订阅</h3>
<p>前面说到了需要再取消订阅的时候，告诉后端退出的是哪个群组，所以我们的客户端的使用上，需要做一些小的适配调整</p>
<p>完整的前端代码可以参考项目源码中的 <code>chat.html</code>， 下面是关键的订阅/取消订阅逻辑</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>再上面的实现中，使用一个对象<code>subscribeMap</code>来存储订阅关系，并设置了订阅的ID 正好等于订阅的<code>channel</code>, 这样在订阅/取消订阅时，都会新增一个id的请求头，如下图所示，这样后端就可以根据这个id来做离开群聊的广播通知</p>
<figure><img src="/imgs/231218/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 5. 效果演示</h3>
<p>接下来我们实际演示一下，开始订阅/和结束订阅时，其他的小伙伴是否可以收到相关的提示消息</p>
<figure><img src="/imgs/231218/01.gif" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>从上图可以比较直观的看到，当一个用户加入群聊时，其他用户/自己均可以正常收到对应的系统通知消息；离开群聊时，因为取消了订阅所以也就只有其他的小伙伴能收到系统消息，而自己是收不到的</p>
<h3> 6. 小结</h3>
<p>本文主要介绍了管道拦截器，用于在接收和发送客户端消息时进行定制开发，以满足特定需求场景。</p>
<p>目前为止，我们所讨论的都是与群聊相关的内容。然而，如果后台系统希望向用户推送私人消息，例如提醒用户在线时间过长需要休息的提示消息，应该如何实现呢？</p>
<h2> III. 不能错过的源码和相关知识点</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-case/207-websocket-chat" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-case/207-websocket-chat</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/231218/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>5.一文教你如何在SpringBoot中使用WebSocket发送消息！</title>
      <link>https://liuyueyi.github.io/tutorial/spring/web/WebSocket/231220-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8BWebSocket%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81%E7%A4%BA%E4%BE%8B.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/web/WebSocket/231220-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8BWebSocket%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81%E7%A4%BA%E4%BE%8B.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">5.一文教你如何在SpringBoot中使用WebSocket发送消息！</source>
      <description>前面介绍的几篇是消息广播，所有在群组内的小伙伴都可以收到消息；那么如果后台只想给某个用户私发消息，可以怎么实现呢？ 本文将主要介绍服务端如何给客户端发送消息</description>
      <category>WEB系列</category>
      <category>WebSocket</category>
      <pubDate>Wed, 20 Dec 2023 14:54:40 GMT</pubDate>
      <content:encoded><![CDATA[<p>前面介绍的几篇是消息广播，所有在群组内的小伙伴都可以收到消息；那么如果后台只想给某个用户私发消息，可以怎么实现呢？</p>
<p>本文将主要介绍服务端如何给客户端发送消息</p>
<!-- more -->
<h2> I. 实例演示</h2>
<h3> 1. 项目搭建</h3>
<p>项目搭建过程与前文类似，请直接参考上文 或者 查看文末的项目源码</p>
<h3> 2. WebSocket配置</h3>
<p>核心的websocket配置依然与之前一致，实现<code>WebSocketMessageBrokerConfigurer</code>接口，定义端点、消息代理、认证授权拦截器</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. 消息发送</h3>
<h4> 3.1 @SendTo 返回消息</h4>
<p>对于服务器若需要将消息发送给客户端，最简单的方式就是接收消息时，直接返回，如</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这个实现，即表示接收 <code>/app/hello</code> 发送的消息，然后将结果转发给所有订阅了  <code>/topic/hello</code> 的客户端</p>
<h4> 3.2 SimpMessagingTemplate 返回消息</h4>
<p>若我们希望更灵活的返回消息，比如后台主动的返回消息，此时则可以借助Spring封装的<code>SimpMessagingTemplate</code>来实现消息回传</p>
<p>直接通过<code>@Autowired</code>的方式注入</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的工具类，主要封装了官方提供的两种返回方式</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>虽然上面提供了两种方式，但是看一下<code>convertAndSendToUser</code>的源码实现会发现，它的底层依然调用的是<code>convertAndSend</code>，向特定用户发送消息，无非就是调整 <code>destination</code> 的取值</p>
<figure><img src="/imgs/231220/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>重点看一下<code>destination</code>的取值 = <code>this.destinationPrefix + user + destination</code> = <code>"/user/" + user + destination</code></p>
<p>所以当我们希望给特定用户发送消息时；需要用户订阅 <code>/user/destination</code> 的地址， 如下</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对于客户端而言，虽然我订阅的是 <code>/user/topic/notify</code>， 但是后台返回消息的目的地，实际上则是 <code>/user/xxxx/topic/notify</code> ，其中的xxx则是用户标识</p>
<p>现在的问题就是，这个用户的标识，是怎么确定的呢?</p>
<ul>
<li>主要就是我们前面做用户身份鉴权中介绍到的<code>HandshakeHandler</code>中定义的Principal</li>
<li>在webscoket的生命周期内，通过Principal来识别用户身份，当需要向后端发送消息时，也是基于它来确定user</li>
</ul>
<h3> 4. 使用实例</h3>
<p>比如写一个定时器，给每个3s给当前登录的用户报时</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/231220/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 5. 小结</h3>
<p>本文主要介绍的是后端如何给客户端发送消息，其中重点介绍了一下当我们希望给用户私发消息时，可以借助<code>simpMessagingTemplate.convertAndSendToUser</code>来实现，当然对应的用户也需要订阅<code>/user/xxx</code>的channel</p>
<p>到目前位置，我们的所有聊天还局限于文本的交流，如果我们希望传图，可以怎么做呢？</p>
<h2> II. 不能错过的源码和相关知识点</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-case/207-websocket-chat" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-case/207-websocket-chat</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/231220/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>7.别再为JS长整型精度丢失烦恼了！这些方法帮你轻松搞定！</title>
      <link>https://liuyueyi.github.io/tutorial/spring/web/%E5%85%B6%E4%BB%96/231027-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8B%E9%95%BF%E6%95%B4%E5%9E%8B%E7%B2%BE%E5%BA%A6%E4%B8%A2%E5%A4%B1%E9%97%AE%E9%A2%98%E4%BF%AE%E5%A4%8D%E6%96%B9%E6%A1%88.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/web/%E5%85%B6%E4%BB%96/231027-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8B%E9%95%BF%E6%95%B4%E5%9E%8B%E7%B2%BE%E5%BA%A6%E4%B8%A2%E5%A4%B1%E9%97%AE%E9%A2%98%E4%BF%AE%E5%A4%8D%E6%96%B9%E6%A1%88.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">7.别再为JS长整型精度丢失烦恼了！这些方法帮你轻松搞定！</source>
      <description>javascript以64位双精度浮点数存储所有Number类型值，即计算机最多存储64位二进制数。 但是需要注意的是Number包含了我们常说的整形、浮点型，相比较于整形而言，会有一位存储小数点的偏移位，由于存储二进制时小数点的偏移量最大为52位，计算机存储的为二进制，而能存储的二进制为62位，超出就会有舍入操作，因此 JS 中能精准表示的最大整数是 Math.pow(2, 53)，十进制即9007199254740992 大于9007199254740992的可能会丢失精度 因此对于java后端返回的一个大整数，如基于前面说到的雪花算法生成的id，前端js接收处理时，就可能出现精度问题 接下来我们以Thymeleaf模板渲染引擎，来介绍一下对于大整数的精度丢失问题的几种解决方案</description>
      <category>SpringBoot</category>
      <category>WEB系列</category>
      <category>Response</category>
      <pubDate>Fri, 27 Oct 2023 13:50:27 GMT</pubDate>
      <content:encoded><![CDATA[<p>javascript以64位双精度浮点数存储所有Number类型值，即计算机最多存储64位二进制数。 但是需要注意的是Number包含了我们常说的整形、浮点型，相比较于整形而言，会有一位存储小数点的偏移位，由于存储二进制时小数点的偏移量最大为52位，计算机存储的为二进制，而能存储的二进制为62位，超出就会有舍入操作，因此 JS 中能精准表示的最大整数是 Math.pow(2, 53)，十进制即<code>9007199254740992</code> 大于<code>9007199254740992</code>的可能会丢失精度</p>
<p>因此对于java后端返回的一个大整数，如基于前面说到的雪花算法生成的id，前端js接收处理时，就可能出现精度问题</p>
<p>接下来我们以Thymeleaf模板渲染引擎，来介绍一下对于大整数的精度丢失问题的几种解决方案</p>
<!-- more -->
<h2> I. 测试项目搭建</h2>
<h3> 1. 依赖</h3>
<p>首先搭建一个标准的SpringBoot项目工程，相关版本以及依赖如下</p>
<p>本项目借助<code>SpringBoot 2.2.1.RELEASE</code> + <code>maven 3.5.3</code> + <code>IDEA</code>进行开发</p>
<p>添加web支持，用于配置刷新演示</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 配置</h3>
<p>接下来配置一下db的相关配置 <code>application.yml</code></p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> II. 长整型适配</h2>
<p>首先我们借助Thymeleaf创建一个简单的页面，用于返回演示长整型的使用</p>
<h3> 1. 场景复现</h3>
<p>模板网页如下</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们直接借助前面实现的Snowflake来生成长整数，写一个对应的接口</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>直接访问，表现如下</p>
<figure><img src="/imgs/231027/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>从截图可以看出，再html标签中，直接使用<code>${hu}</code>获取长整型时，显示正常；</p>
<p>但是js中，获取的长整型，则出现了精度丢失问题</p>
<p>如控制台中打印的 <code>console.log("hu = ", hu);</code> 最后的几位变成了0，与实际不符</p>
<h3> 2. long转String，解决长整型问题</h3>
<p>对于长整型导致的精度问题，最容易想到也是最推荐的解决方案，即对于long类型的参数，改为String方式进行返回，让前端以String的方式进行处理，从而解决精度丢失问题</p>
<p>方案1：修改后端的返回，将长整形改String</p>
<p>如将上面的流程如下修改:</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>方案2：前端js使用String方式接收长整形</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>具体的效果就不再演示，有兴趣的小伙伴可以自己体验一下；这种方式虽然简单有效，但是对现有的项目改造还是挺大的，且很容易有遗漏；自然的，我们就会思考一下，是否有统一的处理方式来解决这种问题</p>
<h3> 3. 修改序列化方式，实现长整型转字符串</h3>
<p>作为后端，前端的使用姿势我们无法控制；为了整个程序的准确性，后端直接返回String格式通常是首选的方案；对于现下主流的前后端分离方案，后端一般是返回json格式的数据，所以要想实现统一的格式转换，自然会想到对序列化做文章</p>
<p>比如SpringBoot默认的jackson序列化框架，直接让其实现对长整型转String的转换</p>
<p>先实现一个工具类，来实现上面的诉求，支持long/bigint/bigdecimal转string</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其次就是注册一个支持长整型转String的序列化转换类<code>HttpMessageConverter</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来我们对比一下，上面注册前后，访问 '<a href="http://localhost:8080/id2" target="_blank" rel="noopener noreferrer">http://localhost:8080/id2</a>' 返回的数据格式</p>
<figure><img src="/imgs/231027/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>基于上面的输出结果，可以看到我们的目标已经实现，返回的长整型会自动转换为字符串；这样前端使用时，就不会出现精度丢失问题了（除非前端又将字符串转number）</p>
<p>上面这个是后端直接返回Json对象数据；这种解决方案适用于 <code>Thymeleaf</code> 模板渲染引擎么？</p>
<ul>
<li>直接访问一下 <code>http://localhost:8080/show</code> 看一下控制台输出</li>
<li>很遗憾的是，依然是<strong>精度丢失</strong></li>
</ul>
<p>why?</p>
<blockquote>
<p>Thymeleaf模板的参数传递，并不是通过<code>HttpMessageConverter</code>来实现的，数据转换的实现主要是靠<code>IStandardJavaScriptSerializer</code></p>
</blockquote>
<h3> 4. Thymeleaf 长整型精度丢失问题解决方案</h3>
<p>既然直接返回json数据可以通过修改序列化的转换方式来实现，那么Thymeleaf按照这个思路，应该也是可行的</p>
<p>直接通过debug，我们可以知道Thymeleaf默认使用的是<code>JacksonStandardJavaScriptSerializer</code>来对js传递的对象进行序列化</p>
<figure><img src="/imgs/231027/02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>从<code>JacksonStandardJavaScriptSerializer</code>的实现来看，比较遗憾的是它并没有支持长整型转字符串，也没有预留给我们进行注册<code>Module</code>的口子</p>
<p>因此一个粗暴的解决方案就是反射拿到它，然后进行主动注册</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面配置完毕之后，正常我们再js中获取到的长整型就会变成字符串，不会再出现精度丢失问题了；直接再次验证一下，正常输出应该如下：</p>
<figure><img src="/imgs/231027/03.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>使用反射的方式虽然可以解决我们的诉求，但是不太优雅，既然官方定义了接口，我们完全可以注册自定义实现，来解决这个问题</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后再将我们自定义的是转换类注册到<code>TemplateEngine</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 5. 小结</h3>
<p>本文的内容相对较多，但是核心的问题解决思路只有一个：</p>
<p><strong>对于长整型的精度问题，解决方案就是将长整型转换为字符串</strong></p>
<p>对应的解决方案有下面几种</p>
<ol>
<li>后端直接编码中，对于长整型的字段转换为字符串进行返回</li>
<li>前端接收时，以字符串方式接收长整形</li>
<li>后端针对json返回，通过注册自定义的<code>HttpMessageConverter</code>做统一的长整型格式化转换</li>
<li>对于Thymeleaf模板渲染引擎，通过修改<code>IStandardJavaScriptSerializer</code>支持长整型的格式转换</li>
</ol>
<p>最后再抛出一个问题，上面给出了Thymeleaf的长整形转换，但是如果我用的是Freemaker渲染引擎， 序列化工具使用的是gson, fastjson，那应该怎么处理呢？</p>
<h2> III. 不能错过的源码和相关知识点</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/600-snowflake-id" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/600-snowflake-id</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/231027/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>1.容器刷新前回调ApplicationContextInitializer</title>
      <link>https://liuyueyi.github.io/tutorial/spring/extend/220927-Spring%E6%89%A9%E5%B1%95%E4%B9%8B%E5%AE%B9%E5%99%A8%E5%88%B7%E6%96%B0%E5%89%8D%E5%9B%9E%E8%B0%83ApplicationContextInitializer.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/extend/220927-Spring%E6%89%A9%E5%B1%95%E4%B9%8B%E5%AE%B9%E5%99%A8%E5%88%B7%E6%96%B0%E5%89%8D%E5%9B%9E%E8%B0%83ApplicationContextInitializer.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">1.容器刷新前回调ApplicationContextInitializer</source>
      <description>本文将作为Spring系列教程中源码版块的第一篇，整个源码系列将分为两部分进行介绍；单纯的源码解析，大概率是个吃力没人看的事情，因此我们将结合源码解析，一个是学习下别人的优秀设计，一个是站在源码的角度看一下我们除了日常的CURD之外，还可以干些啥</description>
      <category>Spring源码</category>
      <category>扩展点</category>
      <pubDate>Tue, 27 Sep 2022 19:26:11 GMT</pubDate>
      <content:encoded><![CDATA[<p>本文将作为Spring系列教程中源码版块的第一篇，整个源码系列将分为两部分进行介绍；单纯的源码解析，大概率是个吃力没人看的事情，因此我们将结合源码解析，一个是学习下别人的优秀设计，一个是站在源码的角度看一下我们除了日常的CURD之外，还可以干些啥</p>
<!-- more -->
<p>在Spring的启动过程中，一系列的操作步骤中，提供了很多的扩展点，供我们来增强；简单来说就是提供了很多的钩子，这样当我们在某个节点执行前后，想干点其他的事情时，可以很简单的支持；本文介绍的<code>ApplicationContextInitializer</code>，spring容器在刷新之前会回调这个接口，从而实现在spring容器未初始化前，干一些用户希望做的事情</p>
<h2> I. 项目准备</h2>
<p>本文创建的实例工程采用<code>SpringBoot 2.2.1.RELEASE</code> + <code>maven 3.5.3</code> + <code>idea</code>进行开发</p>
<p>具体的SpringBoot项目工程创建就不赘述了，核心的pom文件，无需额外的依赖</p>
<p>配置文件 <code>application.yml</code>， 也没有什么特殊的配置</p>
<p>源码工程参考文末的源码</p>
<h2> II. 容器刷新前扩展点实例</h2>
<h3> 1. 自定义ApplicationContextInitializer</h3>
<p>当我们希望实现一个自定义的上下文初始化时，非常简单，实现上面这个接口就行了，如</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 扩展点注册</h3>
<p>上面自定义一个扩展点，如何使它生效呢？</p>
<p>官方提供了三种方式，如在启动时，直接进行注册: <code>springApplication.addInitializers(new ApplicationContextInitializer01());</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当我们的扩展点是放在一个jar包中对外提供时，使用上面的启动注册方式显然是不可行的，此时更推荐的做法就是通过Spring的SPI机制进行注册</p>
<p>在资源目录下的<code>META-INF/spring.factories</code>文件中进行注册</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>说明</strong></p>
<ul>
<li>上面SPI的机制非常推荐大家使用，在之前的文章中，<code>AutoConfiguration</code>的注册通常也是使用这种方式</li>
</ul>
<p>除了上面的两种注册方式之外，另外还有一个配置文件的方式，在配置文件<code>application.properties</code> 或 <code>application.yml</code>中，如下配置</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>启动测试</strong></p>
<p>上面三种注册方式，我们实现三个自定义的扩展点，然后启动之后，看一下实际输出</p>
<figure><img src="/imgs/220927/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>上面的输出，可以简单的得出一个结论，不同注册方式的优先级（为了更合理的验证下面的观点，推荐大家修改下上面三个自定义扩展点名，排除掉是因为扩展名导致的排序问题）</p>
<ul>
<li>配置文件注册 &gt; SPI注册 &gt; 启动时注册</li>
</ul>
<h3> 3. 执行顺序指定</h3>
<p>对于自定义的扩展点实现，当存在顺序关系时，我们可以通过<code>@Order</code>注解来实现， 如当上面的三个扩展点都是通过启动方式注册时</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出实例如下</p>
<figure><img src="/imgs/220927/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p><strong>接着重点来了</strong></p>
<ul>
<li>若上面的三个自定义实现，不是相同的注册方式，如将03采用配置文件方式进行注册，那么01, 02 依然是启动注册</li>
<li>则顺序是 03 &gt; 02 &gt; 01</li>
<li>即 <code>@Order</code>注解修饰的顺序，并不能打破  <strong>配置文件 &gt; SPI &gt; 启动方式注册的顺序</strong></li>
</ul>
<p>关于自定义实现类的执行顺序，规则如下</p>
<ul>
<li>配置文件 &gt; SPI &gt; 启动方式</li>
<li>相同的注册方式，可以通过 <code>@Order</code> 注解进行修饰，值越小则优先级越高</li>
</ul>
<h3> 4. 使用场景示例</h3>
<p>最后我们再来看一下，这个扩展点到底有什么用，我们再什么场景下会用到这个呢？</p>
<p>一个经常可以看到的应用场景如通过它来指定需要激活的配置文件</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但是一般也很少见到有人这么干，因为直接使用配置参数就行了，那么有场景需要这么做么？</p>
<p>答案当然是有的，比如现在广为流行的docker容器部署，当我们希望每次都是打同一个镜像，然后在实际运行的时候，根据不同的环境来决定当前镜像到底启用哪些配置文件，这时就有用了</p>
<p>比如我们通过容器的环境参数 <code>app.env</code> 来获取当前运行的环境，如果是prod，则激活<code>application-prod.yml</code>; 如果是test，则激活<code>application-test.yml</code></p>
<p>那么此时可以这么干</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 5. 小结</h3>
<p>本文作为扩展点的第一篇，通过实现<code>ApplicationContextInitializer</code>接口，从而达到在spring容器刷新之前做某些事情的目的</p>
<p>通常自定义的ApplicationContextInitializer有三种注册方式，按照优先级如下</p>
<ul>
<li>配置文件 &gt; SPI方式 &gt; 启动方式注册</li>
<li>相同的注册方式中，可以使用<code>@Order</code>注解来指定优先级，值越小优先级越高</li>
</ul>
<p>最后还给出了一个可以应用得实例场景，即如何实现一个镜像在不同的环境中启动运行</p>
<p>下一个扩展点我们将介绍如何通过<code>BeanDefinitionRegistryPostProcessor</code>来实现非Spring生态的Bean加载使用</p>
<h2> III. 不能错过的源码和相关知识点</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/220927/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>2.自定义bean注册扩展机制BeanDefinitionRegistryPostProcessor</title>
      <link>https://liuyueyi.github.io/tutorial/spring/extend/221026-Spring%E6%89%A9%E5%B1%95%E7%82%B9%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89bean%E6%B3%A8%E5%86%8C.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/extend/221026-Spring%E6%89%A9%E5%B1%95%E7%82%B9%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89bean%E6%B3%A8%E5%86%8C.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">2.自定义bean注册扩展机制BeanDefinitionRegistryPostProcessor</source>
      <description>接着上一篇容器刷新前的扩展点，我们继续往下走；接下来来到的就是bean的定义扩展处，它是在Spring容器刷新之后，应用的bean定义加载完成、实例化之前提供的切入点，主要是通过实现BeanDefinitionRegistryPostProcessor接口的两个方法，来实现自定义的bean定义，或者对已注册的bean进行修改or代理替换 本文将带来的知识点如下： BeanDefinitionRegistryPostProcessor： 基本使用姿势 postProcessBeanDefinitionRegistry 方法 优先于 postProcessBeanFactory 方法执行 实现自定义的bean注册，实现对容器的bean定义进行修改</description>
      <category>Spring源码</category>
      <category>扩展点</category>
      <pubDate>Wed, 26 Oct 2022 14:45:41 GMT</pubDate>
      <content:encoded><![CDATA[<p>接着上一篇容器刷新前的扩展点，我们继续往下走；接下来来到的就是bean的定义扩展处，它是在Spring容器刷新之后，应用的bean定义加载完成、实例化之前提供的切入点，主要是通过实现<code>BeanDefinitionRegistryPostProcessor</code>接口的两个方法，来实现自定义的bean定义，或者对已注册的bean进行修改or代理替换</p>
<p>本文将带来的知识点如下：</p>
<ul>
<li>BeanDefinitionRegistryPostProcessor： 基本使用姿势</li>
<li><code>postProcessBeanDefinitionRegistry</code> 方法 优先于  <code>postProcessBeanFactory</code> 方法执行</li>
<li>实现自定义的bean注册，实现对容器的bean定义进行修改</li>
</ul>
<!-- more -->
<h2> I. 项目准备</h2>
<p>本文创建的实例工程采用<code>SpringBoot 2.2.1.RELEASE</code> + <code>maven 3.5.3</code> + <code>idea</code>进行开发</p>
<p>具体的SpringBoot项目工程创建就不赘述了，核心的pom文件，无需额外的依赖； 配置文件 <code>application.yml</code>， 也没有什么特殊的配置</p>
<p><strong>说明</strong></p>
<ul>
<li>源码工程参考文末的源码</li>
<li>虽然本文是基于 <code>2.2.1.RELEASE</code> 版本进行实测；实际上这些基础的扩展点，在更高的版本中表现也不会有太大的变动，基本上可以无修改复现</li>
</ul>
<h2> II. 自定义bean注册</h2>
<p>有关注过博主一灰灰的朋友，应该在我之前的文章中可以翻到bean的动态注册的内容，其中其实也介绍到通过<code>BeanDefinitionRegistryPostProcessor</code>来实现bean的动态注册，有兴趣的小伙伴可以翻一下，链接如下</p>
<blockquote>
<ul>
<li><a href="https://spring.hhui.top/spring-blog/2018/10/13/181013-SpringBoot%E5%9F%BA%E7%A1%80%E7%AF%87Bean%E4%B9%8B%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8C/" target="_blank" rel="noopener noreferrer">【基础系列】Bean之动态注册 | 一灰灰Blog</a></li>
</ul>
</blockquote>
<p>接下来我们开始进入正题</p>
<h3> 1. 自定义bean注册</h3>
<p>现在我们定义一个普通的bean对象，也定义了几个常见的bean初始化之后的回调方法，顺带验证两个知识点</p>
<ul>
<li>自定义注册的bean是否表现和普通的bean一致</li>
<li>初始化后的方法执行的顺序</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>再定义一个bean，构造方法依赖其他的bean</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来我们再看一下这两个bean如何进行注册</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>bean的注册从上面的代码来看比较简单，先看DemoBean的注册</p>
<p><strong>方法： <code>postProcessBeanDefinitionRegistry</code></strong></p>
<p>在这个方法中进行简单的bean注册，除了上面这个稍显复杂的注册方式之外，也可以使用更简单的策略，如下，省略掉<code>BeanDefinitionBuilder.genericBeanDefinition</code>第二个参数</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个方法内的bean注册，更适用于简单的bean对象注册，如当其构造方法依赖其他的bean时，放在这个方法中好像没辙，此时则放在第二个方法中就更合适了</p>
<p><strong>方法： <code>postProcessBeanFactory</code></strong></p>
<p>这个方法的参数是BeanFactory，可以通过它获取其他的bean对象，因此适用于DemoBeanWrapper的注册了，当然除了上面的使用姿势之外，也可以如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2.bean注册知识点</h3>
<p>单独看上面的代码可能对知识点理解不够直观清晰，那么我们就进行知识点归纳一下</p>
<p><strong>bean注册方式</strong></p>
<p>如何生成Bean的定义 <code>BeanDefinition</code> ?</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>两个方法的选择</strong></p>
<ul>
<li><code>postProcessBeanDefinitionRegistry</code> 方法执行先于 <code>postProcessBeanFactory</code></li>
<li><code>postProcessBeanDefinitionRegistry</code> 在bean实例化之前触发，可用于注册简单的自定义bean对象</li>
<li><code>postProcessBeanFactory</code>: 若bean的定义中需要依赖其他的bean对象，则放在这个方法内实现，通过BeanFactory参数获取其他bean</li>
</ul>
<h3> 3. bean定义扩展</h3>
<p>文章开头介绍了除了自定义bean之外，还可以做一些其他的操作，如针对现有的bean定义进行修改，下面给一个基础的demo，针对一个已有的bean，设置它的init方法</p>
<p>新增一个普通的bean对象</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后我们通过修改bean注册，来指定bean加载完之后，执行init方法，在前面的<code>AutoBeanDefinitionRegistryPostProcessor</code>中进行扩展</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后我们将整个项目执行以下，看下会输出些啥</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从上面的输出也可以看出，我们的几个自定义bean都被正常的加载、注入，依赖使用也没有什么问题；而且从日志输出还可以看出bean初始化后的触发方法，也有先后顺序</p>
<ul>
<li><code>@PostConstruct</code> &gt; <code>InitializingBean#afterPropertiesSet</code> &gt;  <code>init-method</code> (这个可以理解为xml定义bean中的初始化方法, @Bean注解中的initMethod)</li>
</ul>
<h3> 4. 小结</h3>
<p>最后进入大家喜闻乐见的知识点汇总环节，本文中主要介绍的是bean定义加载之后、实例化之前的扩展点<code>BeanDefinitionRegistryPostProcessor</code></p>
<h4> 4.1 知识点一：核心方法说明</h4>
<p>通过它，我们可以实现自定义的bean注册，也可以实现对现有的bean定义进行扩展修改；有两个方法</p>
<p><strong>postProcessBeanDefinitionRegistry</strong></p>
<ul>
<li>执行顺序在下面的方法之前，通常是在bean实例化之前被触发</li>
<li>适用于通用的bean注册定义</li>
</ul>
<p><strong>postProcessBeanFactory</strong></p>
<ul>
<li>其参数为BeanFactory，因此可以通过它获取Spring容器中的其他bean对象</li>
</ul>
<h4> 4.2 知识点二：bean注册</h4>
<p><strong>bean注册方式</strong></p>
<p>如何生成Bean的定义 <code>BeanDefinition</code> ?</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 4.3 知识点三：使用场景</h4>
<p>看完本文之后，勤于思考的小伙伴可能就会想，这个东西到底有啥用，有真实的应用场景么？</p>
<p><strong>自定义bean注册实例场景</strong></p>
<p>这个应用场景就非常的典型了，用过mybatis的小伙伴都知道，我们会定义一个Mapper接口，用于与对应的xml文件进行映射，那么这些mapper接口是怎么注册到Spring容器的呢？</p>
<ul>
<li>核心实现 <code>org.mybatis.spring.mapper.MapperScannerConfigurer</code></li>
<li>借助<code>BeanDefinitionRegistryPostProcessor</code>与<code>ClassPathBeanDefinitionScanner</code>来实现扫描相关的类，并注册bean</li>
</ul>
<p><strong>bean定义修改实例场景</strong></p>
<p>对于已有的bean定义进行修改，同样也有一个应用场景，在SpringCloud中，有个<code>RefreshAutoConfiguration#RefreshScopeBeanDefinitionEnhancer</code></p>
<p>它会捞出<code>HikariDataSource</code>数据源bean对象，添加<code>RefreshScope</code>的能力增强，支持配置文件的动态加载</p>
<p>从而实现数据源配置的热加载更新（不发版，直接改数据库连接池，是不是很方便？）</p>
<h4> 4.4 知识点四：bean初始化后执行方法先后顺序</h4>
<p>我们知道在bean创建之后执行某些方法有多种策略，那么不同的方式先后顺序是怎样的呢？</p>
<p>bean创建到销毁的先后执行顺序如下</p>
<ul>
<li>构造方法</li>
<li>@PostConstruct修饰的方法</li>
<li>InitializingBean接口的实现方法</li>
<li>xml/@Bean中定义的initMethod</li>
<li>@PreDestroy bean销毁前的执行方法</li>
</ul>
<h4> 其他</h4>
<p>本文为Spring扩展点系列中的第二篇，接下来的扩展知识点同样是bean定义之后，实例化之前的<code>BeanFactoryPostProcessor</code>，那么这两个究竟又有什么区别呢？ 应用场景又有什么区别呢？我是一灰灰，欢迎关注我的Spring专栏，咱们下文见</p>
<ul>
<li><a href="https://hhui.top/spring-extention/" target="_blank" rel="noopener noreferrer">一灰灰的Spring专栏</a></li>
</ul>
<h2> III. 不能错过的源码和相关知识点</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-extention/101-bean-definition" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-extention/101-bean-definition</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>1.内存缓存Caffeine基本使用</title>
      <link>https://liuyueyi.github.io/tutorial/spring/basic/%E7%BC%93%E5%AD%98/230307-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8B%E5%86%85%E5%AD%98%E7%BC%93%E5%AD%98Caffeine%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/basic/%E7%BC%93%E5%AD%98/230307-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8B%E5%86%85%E5%AD%98%E7%BC%93%E5%AD%98Caffeine%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">1.内存缓存Caffeine基本使用</source>
      <description>Caffeine作为当下本地缓存的王者被大量的应用再实际的项目中，可以有效的提高服务吞吐率、qps，降低rt 本文将简单介绍下Caffeine的使用姿势</description>
      <category>SpringBoot</category>
      <category>中间件</category>
      <category>Caffiene</category>
      <pubDate>Mon, 06 Mar 2023 22:55:36 GMT</pubDate>
      <content:encoded><![CDATA[<p>Caffeine作为当下本地缓存的王者被大量的应用再实际的项目中，可以有效的提高服务吞吐率、qps，降低rt</p>
<p>本文将简单介绍下Caffeine的使用姿势</p>
<!-- more -->
<h2> 项目配置</h2>
<h3> 1. 依赖</h3>
<p>首先搭建一个标准的SpringBoot项目工程，相关版本以及依赖如下</p>
<p>本项目借助<code>SpringBoot 2.2.1.RELEASE</code> + <code>maven 3.5.3</code> + <code>IDEA</code>进行开发</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 使用实例</h2>
<p>引入上面的jar包之后，就可以进入caffeine的使用环节了；我们主要依照官方wiki来进行演练</p>
<blockquote>
<ul>
<li><a href="https://github.com/ben-manes/caffeine/wiki/Home-zh-CN" target="_blank" rel="noopener noreferrer">Home zh CN · ben-manes/caffeine Wiki</a></li>
</ul>
</blockquote>
<p>caffeine提供了四种缓存策略，主要是基于手动添加/自动添加，同步/异步来进行区分</p>
<p>其基本使用姿势于Guava差不多</p>
<h3> 1. 手动加载</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 1.1 三种失效策略</h4>
<p>注意参数设置，我们先看一下失效策略，共有下面几种</p>
<p><strong>权重：</strong></p>
<ul>
<li>maximumSize: 基于容量策略，当缓存内元素个数超过时，通过基于就近度和频率的算法来驱逐掉不会再被使用到的元素</li>
<li>maximumWeight: 基于权重的容量策略，主要应用于缓存中的元素存在不同的权重场景</li>
</ul>
<p><strong>时间：</strong></p>
<ul>
<li>expireAfterAccess: 基于访问时间</li>
<li>expireAfterWrite: 基于写入时间</li>
<li>expireAfter: 可以根据读更新写入来调整有效期</li>
</ul>
<p><strong>引用：</strong></p>
<ul>
<li>weakKeys: 保存的key为弱引用</li>
<li>weakValues: 保存的value会使用弱引用</li>
<li>softValues: 保存的value使用软引用</li>
</ul>
<p>弱引用：这允许在GC的过程中，当没有被任何强引用指向的时候去将缓存元素回收</p>
<p>软引用：在GC过程中被软引用的对象将会被通过LRU算法回收</p>
<h4> 1.2 缓存增删查姿势</h4>
<p>接下来我们看一下手动方式的使用</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>查询缓存&amp;添加缓存</strong></p>
<ul>
<li><code>getIfPresent(key)</code>: 不存在时，返回null</li>
<li><code>get(key, (key) -&gt; {value初始化策略})</code>: 不存在时，会根据第二个lambda表达式来写入数据，这个就表示的是手动加载缓存</li>
<li><code>asMap</code>: 获取缓存所有数据</li>
</ul>
<p><strong>添加缓存</strong></p>
<ul>
<li><code>put(key, val)</code>: 主动添加缓存</li>
</ul>
<p><strong>清空缓存</strong></p>
<ul>
<li><code>invalidate</code>: 主动移除缓存</li>
<li><code>invalidateAll</code>: 失效所有缓存</li>
</ul>
<p>执行完毕之后，输出日志:</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 自动加载</h3>
<p>在创建的时候，就指定缓存未命中时的加载规则</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>它的配置，与前面介绍的一致；主要的区别点在于build时，确定缓存值的获取方式</p>
<h4> 2.1 缓存使用姿势</h4>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>与前面的区别在于获取缓存值的方式</p>
<ul>
<li>get(key): 不用传第二个参数，直接传key获取对应的缓存值，如果没有自动加载数据</li>
<li>getAll(keys): 可以批量获取数据，若某个key不再缓存中，会自动加载；在里面的则直接使用缓存的</li>
</ul>
<p>实际输出结果如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3.异步手动加载</h3>
<p>异步，主要是值在获取换粗内容时，采用的异步策略；使用与前面没有什么太大差别</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 3.1 缓存使用姿势</h4>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>getIfPresent: 存在时返回CompletableFuture，不存在时返回null，因此注意npe的问题</li>
<li>get(key, Function&lt;&gt;): 第二个参数表示加载数据的逻辑</li>
<li>put(key, CompletableFuture&lt;&gt;): 手动加入缓存，注意这里也不是直接加一个具体的value到缓存</li>
<li>synchronous().invalidate() : 同步清除缓存</li>
<li>getAll: 一次获取多个缓存，同样的是在缓存的取缓存，不在的根据第二个传参进行加载</li>
</ul>
<p>与前面相比，使用姿势差不多，唯一注意的是，获取的并不是直接的结果，而是CompletableFuture，上面执行之后的输出如下：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4. 异步自动加载</h3>
<p>在定义缓存时，就指定了缓存不存在的加载逻辑；与第二个相比区别在于这里是异步加载数据到缓存中</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 4.1 缓存使用姿势</h4>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 不能错过的源码和相关知识点</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>2.内存Caffeine整合Cachebale注解</title>
      <link>https://liuyueyi.github.io/tutorial/spring/basic/%E7%BC%93%E5%AD%98/230308-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8B%E5%86%85%E5%AD%98%E7%BC%93%E5%AD%98Caffeine%E6%95%B4%E5%90%88Cachebale%E6%B3%A8%E8%A7%A3.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/basic/%E7%BC%93%E5%AD%98/230308-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8B%E5%86%85%E5%AD%98%E7%BC%93%E5%AD%98Caffeine%E6%95%B4%E5%90%88Cachebale%E6%B3%A8%E8%A7%A3.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">2.内存Caffeine整合Cachebale注解</source>
      <description>前面一片文章虽说介绍了Caffeine的使用方式，但是更多的是偏向于基础的Caffeine用法；接下来这边博文将给大家介绍一下Caffeine结合Spring的@Cacheable注解，来实现内部缓存的使用姿势</description>
      <category>SpringBoot</category>
      <category>中间件</category>
      <category>Caffiene</category>
      <pubDate>Wed, 08 Mar 2023 22:55:36 GMT</pubDate>
      <content:encoded><![CDATA[<p>前面一片文章虽说介绍了Caffeine的使用方式，但是更多的是偏向于基础的Caffeine用法；接下来这边博文将给大家介绍一下Caffeine结合Spring的<code>@Cacheable</code>注解，来实现内部缓存的使用姿势</p>
<!-- more -->
<h2> 项目配置</h2>
<h3> 1. 依赖</h3>
<p>首先搭建一个标准的SpringBoot项目工程，相关版本以及依赖如下</p>
<p>本项目借助<code>SpringBoot 2.2.1.RELEASE</code> + <code>maven 3.5.3</code> + <code>IDEA</code>进行开发</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 配置</h3>
<p>SpringBoot官方对Caffeine的集成，提供了非常好的支持，比如本文介绍的在使用 <code>@Cacheable</code> 注解来处理缓存时，我们无需额外操作，直接在配置文件来实现缓存的指定，以及对应的Caffeine相关配置限定</p>
<p>核心配置如下 application.yml</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的 spring.cache.type 主要用来表明缓存注解的具体缓存实现为 Caffeine，当然还可以是Guava、redis等</p>
<p>其次就是 <code>spring.cache.caffeine.spec</code>， 它指定了Caffeine的初始化容量大小，最大个数，失效时间等 （无特殊场景时，所有的缓存注解都是公用这个配置的）</p>
<h2> 使用实例</h2>
<h3> 1. 开启缓存注解支持</h3>
<p>首先在启动类上添加 <code>@EnableCaching</code> 注解，注意若不加则缓存不会生效</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 使用实例</h3>
<p>我们定义一个UserService，主要是用来操作用户相关信息，现在先定义一个<code>User</code>实体类</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后添加增删查</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面分别介绍了三个注解</p>
<ul>
<li>CachePut: 不管缓存有没有，都将方法的返回结果写入缓存中</li>
<li>Cacheable: 先从缓存查，没有则执行方法，并塞入缓存</li>
<li>CacheEvit: 失效缓存</li>
</ul>
<p>其次在类上还有一个<code>@CacheConfig</code>注解，主要定义了一个 <code>cacheNames</code> 属性，当我们使用缓存注解时，需要注意的是这个cacheNames必须得有，否则就会报错</p>
<p>当一个类中所有缓存公用一个cacheNames时，可以直接在类上添加<code>@CacheConfig</code>来避免在每个地方都添加指定</p>
<h3> 3. 写个测试demo</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们来实际看一下，第一次没有数据时，返回的是不是空；当有数据之后，缓存是否会命中</p>
<figure><img src="/imgs/230308/00.gif" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 4. 小结</h3>
<p>这篇博文主要介绍了SpringBoot如何整合Caffeine，结合Spring的缓存注解，基于可以说是很低成本的就让我们的方法实现缓存功能，但是请注意，有几个注意点</p>
<ol>
<li>当我并不希望所有数据公用一个缓存时，怎么处理？</li>
</ol>
<ul>
<li>比如我有一些关键数据，虽然访问频率可能没那么高，但是还每次实际读取的成本很高，又不怎么变动，我希望可以更长久的缓存；</li>
<li>如果公用一个缓存，则有可能导致它们被其他的热点数据给挤下线了（超过最大数量限制给删除了）</li>
</ul>
<ol start="2">
<li>在实际使用时，需要特别注意，加了缓存注解之后，返回的实际上是缓存中的对象，如上面返回的是User对象还好，如果返回的是一个容器，那么直接像这些容器中进行额外的添加、删除元素，是直接影响缓存结果的</li>
</ol>
<p>另外，查看本文推荐结合下面几篇博文一起享用，以获取更多的知识点</p>
<ul>
<li><a href="https://spring.hhui.top/spring-blog/2021/06/16/210616-SpringBoot%E7%BC%93%E5%AD%98%E6%B3%A8%E8%A7%A3-Cacheable-CacheEvit-CachePut%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF%E4%BB%8B%E7%BB%8D/" target="_blank" rel="noopener noreferrer">【DB系列】缓存注解@Cacheable @CacheEvit @CachePut使用姿势介绍 | 一灰灰Blog</a></li>
<li><a href="https://spring.hhui.top/spring-blog/2021/07/01/210701-SpringBoot%E7%BC%93%E5%AD%98%E6%B3%A8%E8%A7%A3-Cacheable%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89key%E7%AD%96%E7%95%A5%E5%8F%8A%E7%BC%93%E5%AD%98%E5%A4%B1%E6%95%88%E6%97%B6%E9%97%B4%E6%8C%87%E5%AE%9A/" target="_blank" rel="noopener noreferrer">【DB系列】SpringBoot缓存注解@Cacheable之自定义key策略及缓存失效时间指定 | 一灰灰Blog</a></li>
</ul>
<h2> 不能错过的源码和相关知识点</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/500-cache-caffeine" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/500-cache-caffeine</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/230308/00.gif" type="image/gif"/>
    </item>
    <item>
      <title>3.内存缓存Caffiene自定义CacheManager</title>
      <link>https://liuyueyi.github.io/tutorial/spring/basic/%E7%BC%93%E5%AD%98/230309-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8B%E5%86%85%E5%AD%98%E7%BC%93%E5%AD%98Caffiene%E8%87%AA%E5%AE%9A%E4%B9%89CacheBean.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/basic/%E7%BC%93%E5%AD%98/230309-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8B%E5%86%85%E5%AD%98%E7%BC%93%E5%AD%98Caffiene%E8%87%AA%E5%AE%9A%E4%B9%89CacheBean.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">3.内存缓存Caffiene自定义CacheManager</source>
      <description>上一篇介绍了Caffiene整合Spring的缓存注解@Cacheable，在这篇示例中，所有的缓存公用，但是实际的场景中，我们可能会更希望针对不同的场景，配置不同的缓存（比如我的关键数据，虽然访问频率可能没那么高，但是每次实际读取的成本很高，又不怎么变动，我希望可以更长久的缓存；不希望这些数据因为缓存的淘汰策略被其他的热点数据给淘汰掉），那么可以怎么处理呢？ 接下来我们来看一下两种不同的方式，来实现上面的诉求</description>
      <category>SpringBoot</category>
      <category>中间件</category>
      <category>Caffiene</category>
      <pubDate>Thu, 09 Mar 2023 17:55:36 GMT</pubDate>
      <content:encoded><![CDATA[<p>上一篇介绍了Caffiene整合Spring的缓存注解@Cacheable，在这篇示例中，所有的缓存公用，但是实际的场景中，我们可能会更希望针对不同的场景，配置不同的缓存（比如我的关键数据，虽然访问频率可能没那么高，但是每次实际读取的成本很高，又不怎么变动，我希望可以更长久的缓存；不希望这些数据因为缓存的淘汰策略被其他的热点数据给淘汰掉），那么可以怎么处理呢？</p>
<p>接下来我们来看一下两种不同的方式，来实现上面的诉求</p>
<!-- more -->
<h2> 项目配置</h2>
<h3> 1. 依赖</h3>
<p>首先搭建一个标准的SpringBoot项目工程，相关版本以及依赖如下</p>
<p>本项目借助<code>SpringBoot 2.2.1.RELEASE</code> + <code>maven 3.5.3</code> + <code>IDEA</code>进行开发</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>与前面不同，我们不需要在配置文件中指定缓存类型以及caffeine的相关条件参数，直接放在配置类中</p>
<h3> 2. 配置类</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意上面的 cacheList，其中传入的就是<code>Cache</code>对象，每个Cache对象就可以理解为一个缓存实例，重点注意构造参数中的第一个<code>customCache</code>，这个就是后面缓存具体使用时，注解中的<code>cacheNames</code>属性</p>
<h2> 使用实例</h2>
<h3> 1. SimpleCacheManager 使用实例</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>重点注意一下上面的<code>@CacheConfig</code>，它定义了这个类中的的缓存，都使用 <code>customCacheManager</code> 缓存管理器，且具体的缓存为定义的<code>customCache</code> （改成其他的会报错）</p>
<p>从上面的配置声明，也可以看出，当我们希望使用多个缓存时，可以直接如下面这种方式进行扩展即可</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. CaffeineCacheManager 方式</h3>
<p>除了上面这种方式之外，我们当然也可以再额外定义一个CacheManager，如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用上面这种方式，cacheName可以不需要指定，具体使用如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>方法的内部实现完全一致；重点看<code>@CacheConfig</code>中的属性值</p>
<ul>
<li>cacheNames 表示这个缓存前缀，没有约束限制</li>
</ul>
<h3> 3. 测试</h3>
<p>上面介绍了两种使用不同缓存的姿势：</p>
<ul>
<li>SimpleCacheManager: 定义多个Cache</li>
<li>多个CacheManager</li>
</ul>
<p>我们写个简单的验证上面两个CacheManager表示不同缓存的测试用例</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>操作步骤：</p>
<ul>
<li>anoCacheService 写入缓存</li>
<li>anoCacheService2 查看缓存，此时不应该能查到前面写入的缓存</li>
</ul>
<figure><img src="/imgs/230309/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> 不能错过的源码和相关知识点</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/501-cache-caffeine-special" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/501-cache-caffeine-special</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/230309/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>缓存</title>
      <link>https://liuyueyi.github.io/tutorial/spring/basic/%E7%BC%93%E5%AD%98/</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/basic/%E7%BC%93%E5%AD%98/</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">缓存</source>
      <description>SpringBoot 缓存相关知识点 guava caffeine</description>
      <pubDate>Thu, 21 Sep 2023 09:55:31 GMT</pubDate>
      <content:encoded><![CDATA[<p>SpringBoot 缓存相关知识点</p>
<ul>
<li>guava</li>
<li>caffeine</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>14. 编程式属性绑定Binder</title>
      <link>https://liuyueyi.github.io/tutorial/spring/basic/%E9%85%8D%E7%BD%AE/14.230618-SpringBoot%E4%B9%8B%E7%BC%96%E7%A8%8B%E5%BC%8F%E5%B1%9E%E6%80%A7%E7%BB%91%E5%AE%9ABinder.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/basic/%E9%85%8D%E7%BD%AE/14.230618-SpringBoot%E4%B9%8B%E7%BC%96%E7%A8%8B%E5%BC%8F%E5%B1%9E%E6%80%A7%E7%BB%91%E5%AE%9ABinder.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">14. 编程式属性绑定Binder</source>
      <description>SpringBoot中极大的简化了项目中对于属性配置的加载方式，可以简单的通过 @Value, @ConfigurationProperties 来实现属性配置与Java POJO对象、Bean的成员变量的绑定，那如果出现一个某些场景，需要我们手动的、通过编程式的方式，将属性配置与给定的pojo对象进行绑定，我们又应该怎么实现呢?</description>
      <category>SpringBoot</category>
      <category>基础系列</category>
      <category>配置</category>
      <pubDate>Sun, 18 Jun 2023 11:28:28 GMT</pubDate>
      <content:encoded><![CDATA[<p>SpringBoot中极大的简化了项目中对于属性配置的加载方式，可以简单的通过 <code>@Value</code>, <code>@ConfigurationProperties</code> 来实现属性配置与Java POJO对象、Bean的成员变量的绑定，那如果出现一个某些场景，需要我们手动的、通过编程式的方式，将属性配置与给定的pojo对象进行绑定，我们又应该怎么实现呢?</p>
<!-- more -->
<h2> I. 项目配置</h2>
<h3> 1. 依赖</h3>
<p>首先搭建一个标准的SpringBoot项目工程，相关版本以及依赖如下</p>
<p>本项目借助<code>SpringBoot 2.2.1.RELEASE</code> + <code>maven 3.5.3</code> + <code>IDEA</code>进行开发</p>
<h3> 2. 启动入口</h3>
<p>我们使用默认的配置进行测试，因此启动入口也可以使用最基础的</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> II. 实例演示</h2>
<h3> 1. 基础知识点Binder</h3>
<p>本文的目的主要是给大家介绍编程式的属性绑定，当然除了我们最熟悉的直接写代码，从<code>Environment</code>中获取配置之外，还可以使用Binder来更方便的实现属性绑定</p>
<p>因此我们首先来了解一下这个不太常出现在CURD的日常工作中的Binder类：</p>
<blockquote>
<p><a href="https://docs.spring.io/spring-boot/docs/current/api/org/springframework/boot/context/properties/bind/Binder.html" target="_blank" rel="noopener noreferrer">Binder JavaDoc</a></p>
</blockquote>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>两种常见的使用姿势：</p>
<ul>
<li>bind方法: 将属性绑定到对应的类上, 不会返回null</li>
<li>bindOrCreate: 将属性绑定到对应的类上, 返回结果可能为null</li>
</ul>
<h3> 2. 实例演示</h3>
<p>接下来我们看几个常见的使用姿势</p>
<h4> 2.1 配置绑定到POJO属性类</h4>
<p>直接将配置绑定到我们自定义的属性配置类上，也就是我们最常见的、可直接利用<code>@ConfigurationProperties</code>来实现的使用方式</p>
<p>我们在配置文件中，添加一个基础的配置</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来定义一个对应的属性配置类Mail</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后我们的使用姿势，将如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面的基础使用姿势之上，我们再加两个使用姿势</p>
<ul>
<li>配置不存在时，返回什么？</li>
<li>使用bind对于不存在时，如何表现</li>
</ul>
<p>微调一下上面的bindInfo()方法</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>执行之后，输出如下</p>
<figure><img src="/imgs/230618/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>从上面的输出可以看出，对于</p>
<ul>
<li>bindOrCreat 而言，若整个配置不存在，返回一个空对象，内部属性为null； bind 若相关的配置不存在，会抛异常 (这个不存在指的是配置前缀<code>demo.mail2</code>的都没有)</li>
<li>配置内的某个属性不存在，如 <code>demo.mail.user</code> 这个配置不存在时（配置中的是username），此时bind/bindOrCrate 返回的对象中，相关的属性是null (主意这种场景 bind 方法调用不会抛移异常，有兴趣的小伙伴可以实际验证一下)</li>
</ul>
<h4> 2.2 配置绑定到List对象</h4>
<p>在实际的应用场景中，配置为数组的可能性也很高，比如我有一个代理库，对应的相关配置如下</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>此时我们的实际使用姿势可以如下</p>
<ul>
<li>首先定义Proxy类</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对应的手动绑定方式</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4> 2.3 配置绑定到Map对象</h4>
<p>将属性配置绑定到一个Map的场景也不算少见，如之前写过的多数据源自主切换的实现方式中，就有这么个场景</p>
<ul>
<li><a href="https://spring.hhui.top/spring-blog/2021/01/10/210110-SpringBoot%E7%B3%BB%E5%88%97Mybatis%E5%9F%BA%E4%BA%8EAbstractRoutingDataSource%E4%B8%8EAOP%E5%AE%9E%E7%8E%B0%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E5%88%87%E6%8D%A2/" target="_blank" rel="noopener noreferrer">SpringBoot系列Mybatis基于AbstractRoutingDataSource与AOP实现多数据源切换/</a></li>
</ul>
<p>我们写一个简单的配置模拟上面的场景</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面的配置中，master/slave 为数据源名称，在下面的配置则为数据源配置信息，结构都一致；基于此，我们需要声明的配置类实际为</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>配置绑定的实现也很简单，与上面List的类似</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>执行之后的输出结果如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4> 2.4 配置转换处理</h4>
<p>上面介绍的姿势都是直接将配置绑定到对应的java对象上，那么我们是否会存在需要对配置属性进行特殊处理的场景呢？</p>
<p>这种场景当然也不算少见，如驼峰与下划线的互转，如密码之类的配置文件中属于加密填写，应用加载时需要解密之后使用等</p>
<p>对于这种场景，我们也给出一个简单的实例，在配置文件中，添加一个base64加密的数据</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对应的解析方式</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>执行之后，实际输出结果如下：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4> 2.5 绑定方法回调</h4>
<p>除了上面介绍到的属性绑定姿势之外，Binder还非常贴心的给大家提供了过程回调，给你提供更灵活的控制方式</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>同样是实现配置解密，如上面的方式也是可行的，对应的输出如</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. 小结</h3>
<p>本文的知识点比较简单，属于看过就会的范畴，但是它的实际应用场景可以说非常多；特别是当我们在某些场景下，直接使用SpringBoot的属性配置绑定不太好实现时，如动态数据源、配置的回调处理等，不妨考虑借助Binder来实现编程式的配置绑定加载</p>
<p>其次本文只介绍了Binder类的使用姿势，有好气的小伙伴，自然会想了解它的具体实现姿势，它是怎么实现配置属性与java实体类进行绑定的呢？ 类型转换如何支持的呢？ 如果让我们自己来实现配置绑定，可以怎么支持呢？</p>
<p>不妨再进一步，让我们实现一个自定义的配置加载、解析、绑定并注入到Spring容器的解决方案，可以怎么整？</p>
<h2> III. 不能错过的源码和相关知识点</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/230618/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>15.自定义属性配置绑定极简实现姿势介绍</title>
      <link>https://liuyueyi.github.io/tutorial/spring/basic/%E9%85%8D%E7%BD%AE/15.230627-SpringBoot%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7%E9%85%8D%E7%BD%AE%E7%BB%91%E5%AE%9A%E5%AE%9E%E7%8E%B0%E4%BB%8B%E7%BB%8D.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/basic/%E9%85%8D%E7%BD%AE/15.230627-SpringBoot%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7%E9%85%8D%E7%BD%AE%E7%BB%91%E5%AE%9A%E5%AE%9E%E7%8E%B0%E4%BB%8B%E7%BB%8D.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">15.自定义属性配置绑定极简实现姿势介绍</source>
      <description>使用过SpringBoot应用的小伙伴应该对它配套的配置文件application.yml不会陌生，通常我们将应用需要的配置信息，放在配置文件中，然后再应用中，就可以通过 @Value 或者 @ConfigurationProperties来引用 那么配置信息只能放在这些配置文件么？ 能否从db/redis中获取配置信息呢？ 又或者借助http/rpc从其他的应用中获取配置信息呢？ 答案当然是可以，比如我们熟悉的配置中心（apollo, nacos, SpringCloudConfig) 接下来我们将介绍一个不借助配置中心，也可以实现自定义配置信息加载的方式，并且支持配置的动态刷新</description>
      <category>SpringBoot</category>
      <category>基础系列</category>
      <category>配置</category>
      <pubDate>Tue, 27 Jun 2023 04:46:58 GMT</pubDate>
      <content:encoded><![CDATA[<p>使用过SpringBoot应用的小伙伴应该对它配套的配置文件application.yml不会陌生，通常我们将应用需要的配置信息，放在配置文件中，然后再应用中，就可以通过 <code>@Value</code> 或者 <code>@ConfigurationProperties</code>来引用</p>
<p>那么配置信息只能放在这些配置文件么？ 能否从db/redis中获取配置信息呢？ 又或者借助http/rpc从其他的应用中获取配置信息呢？</p>
<p>答案当然是可以，比如我们熟悉的配置中心（apollo, nacos, SpringCloudConfig)</p>
<p>接下来我们将介绍一个不借助配置中心，也可以实现自定义配置信息加载的方式，并且支持配置的动态刷新</p>
<!-- more -->
<h2> I. 项目配置</h2>
<h3> 1. 依赖</h3>
<p>首先搭建一个标准的SpringBoot项目工程，相关版本以及依赖如下</p>
<p>本项目借助<code>SpringBoot 2.2.1.RELEASE</code> + <code>maven 3.5.3</code> + <code>IDEA</code>进行开发</p>
<p>添加web支持，用于配置刷新演示</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 启动入口</h3>
<p>我们使用默认的配置进行测试，因此启动入口也可以使用最基础的</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> II. 自定义配置实现</h2>
<h3> 1. 方案设计</h3>
<p>我们的目标是实现一个自定义的配置信息加载，并支持配置与Spring bean对象的绑定，同时我们还需要支持这个配置的动态刷新</p>
<p>基于上面这个目标，要想实现则需要几个知识储备：</p>
<ul>
<li><a href="https://spring.hhui.top/spring-blog/2020/05/07/200507-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B9%8B%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E8%87%AA%E5%AE%9A%E4%B9%89%E9%85%8D%E7%BD%AE%E5%8A%A0%E8%BD%BD%E5%99%A8/" target="_blank" rel="noopener noreferrer">【基础系列】 实现一个自定义配置加载器（应用篇） | 一灰灰Blog</a></li>
<li><a href="https://spring.hhui.top/spring-blog/2021/01/17/210117-SpringBoot%E7%B3%BB%E5%88%97ConfigurationProperties%E9%85%8D%E7%BD%AE%E7%BB%91%E5%AE%9A%E4%B8%AD%E9%82%A3%E4%BA%9B%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%E4%BA%8B%E6%83%85/" target="_blank" rel="noopener noreferrer">【基础系列】 ConfigurationProperties配置绑定中那些你不知道的事情 | 一灰灰Blog</a></li>
<li><a href="https://spring.hhui.top/spring-blog/2021/08/01/210801-SpringBoot%E5%BA%94%E7%94%A8%E7%AF%87-Value%E6%B3%A8%E8%A7%A3%E6%94%AF%E6%8C%81%E9%85%8D%E7%BD%AE%E8%87%AA%E5%8A%A8%E5%88%B7%E6%96%B0%E8%83%BD%E5%8A%9B%E6%89%A9%E5%B1%95/" target="_blank" rel="noopener noreferrer">【基础系列】 SpringBoot应用篇@Value注解支持配置自动刷新能力扩展 | 一灰灰Blog</a></li>
<li><a href="https://spring.hhui.top/spring-blog/2023/06/18/230618-SpringBoot%E4%B9%8B%E7%BC%96%E7%A8%8B%E5%BC%8F%E5%B1%9E%E6%80%A7%E7%BB%91%E5%AE%9ABinder/" target="_blank" rel="noopener noreferrer">【基础系列】 编程式属性绑定Binder | 一灰灰Blog</a></li>
</ul>
<p>结合上面的知识点，我们主要需要实现的有三步：</p>
<ol>
<li>读取自定义的配置</li>
<li>扫描需要绑定自定义配置的bean</li>
<li>借助Binder来重新绑定bean中的定义的属性到envionment的配置参数（这里就包含了自定义的配置及默认的配置）</li>
</ol>
<h3> 2. 实现方式</h3>
<p>为了简化自定义的配置使用，我们这里直接使用一个内存缓存来模拟自定义的配置源</p>
<h4> 2.1 加载自定义配置源</h4>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意上面的实现，这里是自定义的配置源 propertySources 中包含了environment的配置信息；如果希望将自定义的配置信息源注入到environment，可以如下实现</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h4> 2.2 扫描需要绑定bean</h4>
<p>接下来我们自定义一个注解<code>@ConfDot</code>, 凡是带有这个注解的bean的成员变量，从上面的属性源中进行初始化</p>
<p>这个注解可以完全按照<code>@ConfigurationProperties</code>的来设计（实际上我们也可以直接使用<code>@ConfigurationProperties</code>注解，这样适用范围更广了）</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后借助Spring来扫描带有特定注解的bean，就可以很简单了</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 2.3 bean与配置的绑定</h4>
<p>上面两部完成之后，接下来就需要我们将配置与bean进行绑定，这里就主要使用Binder来实现我们的预期功能了</p>
<p>实现一个自定义的绑定工具类</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的实现虽然多，但是核心其实比较简单：</p>
<ol>
<li>初始化Binder对象 <code>this.binder = new Binder(getConfigurationPropertySources(), getPropertySourcesPlaceholdersResolver(), getConversionService(), getPropertyEditorInitializer());</code></li>
<li>提供绑定入口</li>
</ol>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 2.4 完整实现</h4>
<p>上面的三步实现，基本上已经将整个功能给实现了，其中<code>SelfConfigBinder</code>提供了完成的代码实现，接下来我们再将第一步与第三步的整合，来看一下完整的实现，并且提供一个配置刷新的支持</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. 测试验证</h3>
<p>接下来就是验证一下上面的设计，首先再配置文件中，添加几个默认的信息</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>绑定配置的bean对象</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这个MyConfig中的 user, pwd 从前面的配置文件中获取，然后type则此自定义的配置信息<code>configCache</code>中获取，应该是12，接下来我们首先一个访问与刷新的接口</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>实际执行测试如下图</p>
<figure><img src="/imgs/230627/00.gif" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> III. 不能错过的源码和相关知识点</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-case/003-self-config-binder" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-case/003-self-config-binder</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/230627/00.gif" type="image/gif"/>
    </item>
    <item>
      <title>1.数据库初始化-DataSourceInitializer方式</title>
      <link>https://liuyueyi.github.io/tutorial/spring/db/%E5%9F%BA%E7%A1%80/221221-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%9D%E5%A7%8B%E5%8C%96-DataSourceInitializer%E6%96%B9%E5%BC%8F.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/db/%E5%9F%BA%E7%A1%80/221221-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%9D%E5%A7%8B%E5%8C%96-DataSourceInitializer%E6%96%B9%E5%BC%8F.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">1.数据库初始化-DataSourceInitializer方式</source>
      <description>前面介绍的两篇基于配置方式的数据库初始化方式，使用起来非常简单，但是有一个非常明显的问题，如何实现表结构存在时不再初始化，不存在时才执行？ 如果数据库也不存在，也需要初始化时创建，可行么？ 接下来介绍一下如何使用DataSourceInitializer来实现自主可控的数据初始化</description>
      <category>SpringBoot</category>
      <category>DB系列</category>
      <category>初始化</category>
      <pubDate>Wed, 21 Dec 2022 11:52:03 GMT</pubDate>
      <content:encoded><![CDATA[<p>前面介绍的两篇基于配置方式的数据库初始化方式，使用起来非常简单，但是有一个非常明显的问题，如何实现表结构存在时不再初始化，不存在时才执行？ 如果数据库也不存在，也需要初始化时创建，可行么？</p>
<p>接下来介绍一下如何使用DataSourceInitializer来实现自主可控的数据初始化</p>
<!-- more -->
<h2> I. 项目搭建</h2>
<h3> 1. 依赖</h3>
<p>首先搭建一个标准的SpringBoot项目工程，相关版本以及依赖如下</p>
<p>本项目借助<code>SpringBoot 2.2.1.RELEASE</code> + <code>maven 3.5.3</code> + <code>IDEA</code>进行开发</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>本文使用MySql数据库, 版本8.0.31</p>
<h3> 2. 配置</h3>
<p>注意实现初始化数据库表操作的核心配置就在下面，重点关注</p>
<p>配置文件： <code>resources/application.yml</code></p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意上面的配置，我们新定义了一个数据库的配置项 <code>database.name</code>， 主要是为了检测database是否存在，若不存在时，创建对应的数据库时使用</p>
<p>接下来是初始化sql脚本</p>
<p><code>resources/init-schema.sql</code> 对应的初始化ddl</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>resources/init-data.sql</code> 对用的初始化dml</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2> II. 初始化</h2>
<h3> 1.初始化配置</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们这里主要是借助 DataSourceInitializer 来实现初始化，其核心有两个配置</p>
<ul>
<li>DatabasePopulator: 通过<code>addScripts</code>来指定对应的sql文件</li>
<li>DataSourceInitializer#setEnabled: 判断是否需要执行初始化</li>
</ul>
<p>接下来重点需要看的就是needInit方法，我们再这个方法里面，需要判断数据库是否存在，若不存在时，则创建数据库；然后再判断表是否存在，以此来决定是否需要执行初始化方法</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的数据库判断是否存在以及初始化的过程相对基础，直接使用了基础的Connection进行操作；这里借助了SpringUtil来获取配置信息，对应的类源码如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>到此整个初始化相关的配置已经完成；接下来我们验证一下</p>
<h3> 2.验证</h3>
<p>再项目启动成功之后，查看一下数据</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/221221/03.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 3. 小结</h3>
<p>本文主要介绍的是基于<code>DataSourceInitializer</code>来实现自主可控的数据初始化，其核心配置为</p>
<ul>
<li>DatabasePopulator: 通过<code>addScripts</code>来指定对应的sql文件</li>
<li>DataSourceInitializer#setEnabled: 判断是否需要执行初始化</li>
</ul>
<p>此外本文还介绍了如何判断数据库是否存在，当数据库不存在时，借助基础的Connection来建立连接，创建数据库；从初始化角度来看，这几篇文中介绍的方式已经足够，但是在项目制的场景下，我们需要记录数据库的版本迭代记录，下一篇将介绍如何使用liquibase来实现数据版本管理，解决初始化以及增量的迭代变更</p>
<h2> III. 不能错过的源码和相关知识点</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/221221/03.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>2.数据库初始化-datasource配置方式</title>
      <link>https://liuyueyi.github.io/tutorial/spring/db/%E5%9F%BA%E7%A1%80/221221-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%9D%E5%A7%8B%E5%8C%96-datasource%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/db/%E5%9F%BA%E7%A1%80/221221-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%9D%E5%A7%8B%E5%8C%96-datasource%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">2.数据库初始化-datasource配置方式</source>
      <description>在我们的日常业务开发过程中，如果有db的相关操作，通常我们是直接建立好对应的库表结构，并初始化对应的数据，即更常见的情况下是我们在已有表结构基础之下，进行开发； 但是当我们是以项目形式工作时，更常见的做法是所有的库表结构变更、数据的初始、更新等都需要持有对应的sql变更，并保存在项目工程中，这也是使用liqubase的一个重要场景； 将上面的问题进行简单的翻译一下，就是如何实现在项目启动之后执行相应的sql，实现数据库表的初始化？ 本文将作为初始化方式的第一篇：基于SpringBoot的配置方式实现的数据初始化</description>
      <category>SpringBoot</category>
      <category>DB系列</category>
      <category>初始化</category>
      <pubDate>Wed, 21 Dec 2022 09:57:22 GMT</pubDate>
      <content:encoded><![CDATA[<p>在我们的日常业务开发过程中，如果有db的相关操作，通常我们是直接建立好对应的库表结构，并初始化对应的数据，即更常见的情况下是我们在已有表结构基础之下，进行开发；
但是当我们是以项目形式工作时，更常见的做法是所有的库表结构变更、数据的初始、更新等都需要持有对应的sql变更，并保存在项目工程中，这也是使用liqubase的一个重要场景；
将上面的问题进行简单的翻译一下，就是如何实现在项目启动之后执行相应的sql，实现数据库表的初始化？</p>
<p>本文将作为初始化方式的第一篇：基于SpringBoot的配置方式实现的数据初始化</p>
<!-- more -->
<h2> I. 项目搭建</h2>
<h3> 1. 依赖</h3>
<p>首先搭建一个标准的SpringBoot项目工程，相关版本以及依赖如下</p>
<p>本项目借助<code>SpringBoot 2.2.1.RELEASE</code> + <code>maven 3.5.3</code> + <code>IDEA</code>进行开发</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>本文使用MySql数据库, 版本8.0.31</p>
<h3> 2. 配置</h3>
<p>注意实现初始化数据库表操作的核心配置就在下面，重点关注</p>
<p>配置文件： <code>resources/application.yml</code></p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的配置中，相比较于普通的数据库链接配置，多了几个配置项</p>
<ul>
<li>spring.datasource.initialization-mode: 取值为 always，改成其他的会导致sql不会被执行</li>
<li>spring.datasource.platform: mysql</li>
<li>spring.datasource.seprator: ;  这个表示sql之间的分隔符</li>
<li>spring.datasource.data: classpath:config-data.sql  取值可以是数组，这里存的是初始化数据的sql文件地址</li>
<li>spring.datasource.data-username:  上面data对应的sql文件执行用户名</li>
<li>spring.datasource.data-password:  上面data对应的sql文件执行用户密码</li>
<li>spring.datasource.schema: classpath:config-schema.sql   取值也可以是数组，这里存的是初始化表结构的sql文件地址</li>
</ul>
<h3> 3. 初始化sql</h3>
<p>上面指定了两个sql，一个是用于建表的ddl，一个是用于初始化数据的dml</p>
<p><code>resources/config-schema.sql</code> 文件对应的内容如下</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>resources/config-data.sql</code> 文件对应的内容如下</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2> II. 示例</h2>
<h3> 1. 验证demo</h3>
<p>接下来上面的工作准备完毕之后，在我们启动项目之后，正常就会执行上面的两个sql，我们写一个简单的验证demo</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/221221/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 2. 问题记录</h3>
<p>从上面的过程走下来，看起来很简单，但是在实际的使用过程中，很容易遇到不生效的问题，下面记录一下</p>
<h4> 2.1 只有初始化数据data.sql，没有schema.sql时，不生效</h4>
<p>当库表已经存在时，此时我们可能并没有上文中的<code>config-schema.sql</code>文件，此时对应的配置可能是</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如上面所示，当我们只指定了data时，会发现data对应的sql文件也不会被执行；即要求schema对应的sql文件也必须同时存在</p>
<p>针对上面这种情况，可以考虑将data.sql中的语句，卸载schema.sql中</p>
<h4> 2.2 版本问题导致配置不生效</h4>
<p>在SpringBoot2.5+版本，使用 <code>spring.sql.init</code> 代替上面的配置项</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>相关的配置参数说明如下</p>
<ul>
<li><code>spring.sql.init.enabled</code>：是否启动初始化的开关，默认是true。如果不想执行初始化脚本，设置为false即可。通过-D的命令行参数会更容易控制。</li>
<li><code>spring.sql.init.username</code>和<code>spring.sql.init.password</code>：配置执行初始化脚本的用户名与密码。这个非常有必要，因为安全管理要求，通常给业务应用分配的用户对一些建表删表等命令没有权限。这样就可以与datasource中的用户分开管理。</li>
<li><code>spring.sql.init.schema-locations</code>：配置与schema变更相关的sql脚本，可配置多个（默认用;分割）</li>
<li><code>spring.sql.init.data-locations</code>：用来配置与数据相关的sql脚本，可配置多个（默认用;分割）</li>
<li><code>spring.sql.init.encoding</code>：配置脚本文件的编码</li>
<li><code>spring.sql.init.separator</code>：配置多个sql文件的分隔符，默认是;</li>
<li><code>spring.sql.init.continue-on-error</code>：如果执行脚本过程中碰到错误是否继续，默认是false`</li>
</ul>
<h4> 2.3 mode配置不对导致不生效</h4>
<p>当配置完之后发，发现sql没有按照预期的执行，可以检查一下<code>spring.datasource.initialization-mode</code>配置是否存在，且值为<code>always</code></p>
<h4> 2.4 重复启动之后，报错</h4>
<p>同样上面的项目，在第一次启动时，会执行schema对应的sql文件，创建表结构；执行data对应的sql文件，初始化数据；但是再次执行之后就会报错了，会提示表已经存在</p>
<p>即初始化是一次性的，第一次执行完毕之后，请将<code>spring.datasource.initialization-mode</code>设置为<code>none</code></p>
<h3> 3. 小结</h3>
<p>本文主要介绍了项目启动时，数据库的初始化方式，当然除了本文中介绍的<code>spring.datasource</code>配置之外，还有<code>spring.jpa</code>的配置方式</p>
<p>对于配置方式不太友好的地方则在于不好自适应控制，若表存在则不执行；若不存在则执行；后面将介绍如何使用<code>DataSourceInitializer</code>来实现自主可控的数据初始化，以及更现代化一些的基于liquibase的数据库版本管理记录</p>
<h2> III. 不能错过的源码和相关知识点</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/161-schema-init" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/161-schema-init</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/221221/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>3.数据库初始化-jpa配置方式</title>
      <link>https://liuyueyi.github.io/tutorial/spring/db/%E5%9F%BA%E7%A1%80/221221-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%9D%E5%A7%8B%E5%8C%96-jpa%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/db/%E5%9F%BA%E7%A1%80/221221-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%9D%E5%A7%8B%E5%8C%96-jpa%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">3.数据库初始化-jpa配置方式</source>
      <description>上一篇博文介绍如何使用spring.datasource来实现项目启动之后的数据库初始化，本文作为数据库初始化的第二篇，将主要介绍一下，如何使用spring.jpa的配置方式来实现相同的效果</description>
      <category>SpringBoot</category>
      <category>DB系列</category>
      <category>初始化</category>
      <pubDate>Wed, 21 Dec 2022 10:59:32 GMT</pubDate>
      <content:encoded><![CDATA[<p>上一篇博文介绍如何使用<code>spring.datasource</code>来实现项目启动之后的数据库初始化，本文作为数据库初始化的第二篇，将主要介绍一下，如何使用<code>spring.jpa</code>的配置方式来实现相同的效果</p>
<!-- more -->
<h2> I. 项目搭建</h2>
<h3> 1. 依赖</h3>
<p>首先搭建一个标准的SpringBoot项目工程，相关版本以及依赖如下</p>
<p>本项目借助<code>SpringBoot 2.2.1.RELEASE</code> + <code>maven 3.5.3</code> + <code>IDEA</code>进行开发</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>本文使用MySql数据库, 版本8.0.31</p>
<h3> 2. 配置</h3>
<p>注意实现初始化数据库表操作的核心配置就在下面，重点关注</p>
<p>配置文件： <code>resources/application.yml</code></p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意上面jpa的一个配置，其次就是上一篇博文中介绍的 <code>spring.datasource.initialization-mode</code> 同样需要将配置设置为 <code>always</code></p>
<p>使用jpa的配置方式，将<code>ddl-auto</code>设置为<code>create</code>或者<code>create-drop</code>时，会自动搜索<code>@Entity</code>实体对象，并创建为对应的表</p>
<h2> II. 示例</h2>
<h3> 1. 验证demo</h3>
<p>接下来上面的工作准备完毕之后，我们先创建一个实体对象</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来我们的目标就是基于上面这个实体类生成对应的表结构</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>直接启动项目之后，到数据库中将可以查到已经创建了一个库<code>user3</code></p>
<figure><img src="/imgs/221221/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 2. 初始化数据</h3>
<p>上面的过程只是初始化了表结构，如果我们希望导入一些初始化数据，可以怎么办？</p>
<p>如上面的配置： <code>spring.jpa.hibernate.ddl-auto: update</code>，此时在资源目录下，新建 <code>data.sql</code> , 取值为</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>然后再次执行，既可以看到db中会新增一条数据</p>
<figure><img src="/imgs/221221/02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>若<code>spring.jpa.hibernate.ddl-auto: create</code>，则再资源目录下，新建<code>import.sql</code>文件，来实现数据初始化</p>
<h3> 3. 小结</h3>
<p>使用Jpa的配置方式，总体来说和前面的介绍的spring.datasource的配置方式差别不大，jpa方式主要是基于<code>@Entity</code>来创建对应的表结构，且不会出现再次启动之后重复建表导致异常的问题（注意如上面data.sql中的数据插入依然会重复执行，会导致主键插入冲突）</p>
<p>本文中需要重点关注的几个配置:</p>
<ul>
<li>spring.datasource.initialization-mode: always 同样需要设置为always</li>
<li>spring.jpa.generate-ddl: true 会根据@Entity注解的实体类生成对应数据表</li>
<li>spring.jpa.hibernate.ddl-auto: create/create-drop 这两个取值时，再创建表之后执行import.sql文件导入测试数据；若取值为update，则会执行data.sql</li>
</ul>
<p>本文作为数据初始化第二篇，推荐与前文对比阅读，收获更多的知识点 <a href="https://spring.hhui.top/spring-blog/2022/12/21/221221-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%9D%E5%A7%8B%E5%8C%96-datasource%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F/" target="_blank" rel="noopener noreferrer">【DB系列】 数据库初始化-datasource配置方式</a></p>
<h2> III. 不能错过的源码和相关知识点</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/161-schema-init" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/161-schema-init</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/221221/01.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>4.数据库版本管理Liquibase集成</title>
      <link>https://liuyueyi.github.io/tutorial/spring/db/%E5%9F%BA%E7%A1%80/221222-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86Liquibase%E9%9B%86%E6%88%90.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/db/%E5%9F%BA%E7%A1%80/221222-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86Liquibase%E9%9B%86%E6%88%90.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">4.数据库版本管理Liquibase集成</source>
      <description>前面几篇介绍了项目启动之后进行数据库初始化的几种方式，接下来我们看一下如何使用Liquibase来实现数据库版本管理</description>
      <category>SpringBoot</category>
      <category>DB系列</category>
      <category>Liquebase</category>
      <pubDate>Thu, 22 Dec 2022 12:52:35 GMT</pubDate>
      <content:encoded><![CDATA[<p>前面几篇介绍了项目启动之后进行数据库初始化的几种方式，接下来我们看一下如何使用Liquibase来实现数据库版本管理</p>
<!-- more -->
<p>SpringBoot内置了对Liquibase的支持，在项目中使用非常简单</p>
<h2> I. 项目搭建</h2>
<h3> 1. 依赖</h3>
<p>首先搭建一个标准的SpringBoot项目工程，相关版本以及依赖如下</p>
<p>本项目借助<code>SpringBoot 2.2.1.RELEASE</code> + <code>maven 3.5.3</code> + <code>IDEA</code>进行开发</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>本文使用MySql数据库, 版本8.0.31; Liquibase的核心依赖<code>liquibase-core</code>，版本推荐使用SpringBoot配套的版本，一般来讲无需特殊指定</p>
<h3> 2. 配置</h3>
<p>配置文件 <code>resources/application.yml</code></p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>关键配置为 <code>spring.liquibase.change-log</code> 和 <code>spring.liquibase.enabled</code></p>
<p>第一个指定的是change-log对应的xml文件，其内容如下</p>
<p>liquibase核心xml文件 <code>resources/liquibase/master.xml</code></p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的xml依赖了一个xml文件，如第一个主要定义的是初始化的表结构</p>
<p><code>resources/changelog/000_initial_schema.xml</code> 对应的内容如下</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面的配置文件中，核心点在 <code>&lt;changeSet&gt;</code> 其中id要求全局唯一，<code>sqlFile</code>表示这次变动对应的sql语句; 一个<code>&lt;changeSet&gt;</code>对应一次变更，注意每次变更完成之后，不能再修改（sql文件内容不能改），changeSet本身也不要再去修改</p>
<p>接下来再看一下对应的sql文件</p>
<p><code>resources/liquibase/data/init_schema_221209.sql</code>对应的schema相关的表结构定义如下</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>resources/liquibase/data/init_data_221209.sql</code>对应的初始化数据定义如下</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2> II. 项目演示</h2>
<h3> 1. 测试</h3>
<p>上面配置完毕之后，再主项目结构工程中无需特殊处理，我们写一个简单的启动测试一下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>直接执行之后看一下输出结果(再执行之前，请确保数据库已经创建成功了；若没有则会抛异常)</p>
<figure><img src="/imgs/221222/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 2. 增量变更</h3>
<p>上面演示的是初始化过程；再实际开发过程中，若存在增量的变更，比如现在需要新增一个测试数据，此时我们的操作流程可以如下</p>
<p>再<code>liquibase/</code>目录下新增一个<code>001_change_schema.xml</code>文件，后续的增量变更相关的<code>ChangeSet</code>都放在这个xml文件中；再master.xml文件中，添加上面xml文件的引入</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>其次就是 <code>resources/liquibase/changelog/001_change_schema.xml</code> 文件内容</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的<code>changeSet</code>中包含初始化相关的sql文件，内容如下</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>再次启动验证一下，是否增加了新的数据</p>
<figure><img src="/imgs/221222/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 3. 小结</h3>
<p>本文主要介绍的是SpringBoot如何结合Liquibase来实现数据库版本管理，核心知识点介绍得不多，再实际使用的时候，重点注意</p>
<p>每次变更，都新增一个 <code>&lt;changeSet&gt;</code>，且保证所有的id唯一；当变更完成之后，不要再修改对应sql文件内容</p>
<blockquote>
<p>liquibase本身也有一些相关的知识点，如版本回滚，标签语义等，下篇博文再专门介绍Liquibase本身的核心知识点</p>
</blockquote>
<p>如对项目启动之后数据初始话相关有兴趣的小伙伴，欢迎查看</p>
<ul>
<li><a href="https://spring.hhui.top/spring-blog/2022/12/21/221221-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%9D%E5%A7%8B%E5%8C%96-datasource%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F/" target="_blank" rel="noopener noreferrer">【DB系列】数据库初始化-datasource配置方式 | 一灰灰Blog</a></li>
<li><a href="https://spring.hhui.top/spring-blog/2022/12/21/221221-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%9D%E5%A7%8B%E5%8C%96-jpa%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F/" target="_blank" rel="noopener noreferrer">【DB系列】数据库初始化-jpa配置方式 | 一灰灰Blog</a></li>
<li><a href="https://spring.hhui.top/spring-blog/2022/12/21/221221-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%9D%E5%A7%8B%E5%8C%96-DataSourceInitializer%E6%96%B9%E5%BC%8F/" target="_blank" rel="noopener noreferrer">【DB系列】数据库初始化-DataSourceInitializer方式 | 一灰灰Blog</a></li>
</ul>
<h2> III. 不能错过的源码和相关知识点</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/162-liquibase" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/162-liquibase</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/221222/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>5.SQL执行日志打印的几种方式</title>
      <link>https://liuyueyi.github.io/tutorial/spring/db/%E5%9F%BA%E7%A1%80/230719-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8BDB%E6%89%A7%E8%A1%8C%E6%97%A5%E5%BF%97%E6%89%93%E5%8D%B0%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/db/%E5%9F%BA%E7%A1%80/230719-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8BDB%E6%89%A7%E8%A1%8C%E6%97%A5%E5%BF%97%E6%89%93%E5%8D%B0%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">5.SQL执行日志打印的几种方式</source>
      <description>sql日志打印，再我们日常排查问题时，某些时候帮助可以说是非常大的，那么一般的Spring项目中，可以怎么打印执行的sql日志呢？ 本文将介绍三种sql日志打印的方式： Druid打印sql日志 Mybatis自带的日志输出 基于拦截器实现sql日志输出</description>
      <category>SpringBoot</category>
      <category>DB系列</category>
      <category>Mybatis</category>
      <pubDate>Wed, 19 Jul 2023 08:52:04 GMT</pubDate>
      <content:encoded><![CDATA[<p>sql日志打印，再我们日常排查问题时，某些时候帮助可以说是非常大的，那么一般的Spring项目中，可以怎么打印执行的sql日志呢？</p>
<p>本文将介绍三种sql日志打印的方式：</p>
<ol>
<li>Druid打印sql日志</li>
<li>Mybatis自带的日志输出</li>
<li>基于拦截器实现sql日志输出</li>
</ol>
<!-- more -->
<h2> I. 项目配置</h2>
<h3> 1. 依赖</h3>
<p>首先搭建一个标准的SpringBoot项目工程，相关版本以及依赖如下</p>
<p>本项目借助<code>SpringBoot 2.2.1.RELEASE</code> + <code>maven 3.5.3</code> + <code>IDEA</code>进行开发</p>
<p>添加web支持，用于配置刷新演示</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 配置</h3>
<p>接下来配置一下db的相关配置 <code>application.yml</code></p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>关于上面配置的一些细节，后面进行细说</p>
<p>我们创建一个用于测试的数据库</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对应的myabtis-config.xml，配置我们自定义的sql日志输出拦截器</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> II. 实例</h2>
<h3> 1. mybatis默认配置</h3>
<p>我们先看一下mybatis的默认日志输出方案，首先写一个<code>money</code>数据库的db操作mapper</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来重点看一下，如需开启myabtis默认的sql日志输出，应该如何配置</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>重点看上面的 <code>mybatis.configuration.log-prefix</code> 与 <code>myabtis.configuration.log-impl</code> 这里制定了日志输出的方式</p>
<p>但是请注意，通常我们的日志是基于<code>logback/slf4j</code>来输出，默认的mybati的sql日志输出是debug级别，所以要看到输出的sql日志，还需要配置一下日志输出级别（本项目的实例中是直接控制台输出，因此不配置下面的也没有问题）</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后写个demo验证一下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/230719/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>从上图可以看出，myabtis将具体的sql执行，返回的行数等信息进行了返回，但是这个sql，并不是一个可以直接执行的，还需要我们自己来拼装一下，为了解决这个问题，可以通过 <a href="https://book.hhui.top/sql.html" target="_blank" rel="noopener noreferrer">https://book.hhui.top/sql.html</a> 来进行sql的自动拼接</p>
<h3> 2. Druid日志输出</h3>
<p>除了mybatis的默认日志之外，对于使用druid数据源的场景，也可以直接借助druid来打印执行日志</p>
<p>核心的配置如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>示例如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/230719/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>druid的默认输出日志中，并没有将请求参数打印出来，其效果相比较于mybatis而言，信息更少一些</p>
<h3> 3. 基于Mybatis的Interceptor实现方案</h3>
<p>默认的输出方案虽好，但是总有一些缺陷，如果有一些自定义的诉求，如日志输出的脱敏，不妨考虑下接下来的基于mybatis的拦截器的实现方案</p>
<p>如下面是一个自定义的日志输出拦截器, 相关知识点较多，有兴趣的小伙伴，推荐参考下文</p>
<blockquote>
<ul>
<li><a href="https://spring.hhui.top/spring-blog/2021/07/26/210726-SpringBoot%E7%B3%BB%E5%88%97Mybatis%E4%B9%8B%E6%8F%92%E4%BB%B6%E6%9C%BA%E5%88%B6Interceptor/" target="_blank" rel="noopener noreferrer">【DB系列】SpringBoot系列Mybatis之插件机制Interceptor | 一灰灰Blog</a></li>
</ul>
</blockquote>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后将第一种测试用例再跑一下，实际输出如下</p>
<figure><img src="/imgs/230719/02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 3. 小结</h3>
<p>本文主要介绍了三种常见的sql日志输出方案，原则上推荐通过自定义的插件方式来实现更符合业务需求的sql日志打印；但是，掌握了默认的myabtis日志输出方案之后，我们就可以借助配置中心，通过动态添加/修改 <code>logging.level.com.git.hui.boot.db.mapper.*</code> 来动态设置日志输出级别，再线上问题排查、尤其时场景可以复现的场景时，会有奇效哦</p>
<h2> III. 不能错过的源码和相关知识点</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/100-db-log" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/230719/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>MySql</title>
      <link>https://liuyueyi.github.io/tutorial/spring/db/%E5%9F%BA%E7%A1%80/</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/db/%E5%9F%BA%E7%A1%80/</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">MySql</source>
      <description>MySql数据库相关知识点</description>
      <pubDate>Thu, 21 Sep 2023 09:55:31 GMT</pubDate>
      <content:encoded><![CDATA[<p>MySql数据库相关知识点</p>
]]></content:encoded>
    </item>
    <item>
      <title>7.数据报表统计并定时推送用户的手把手教程</title>
      <link>https://liuyueyi.github.io/tutorial/spring/db/%E5%AE%9E%E4%BE%8B/21.220819-SpringBoot%E5%AE%9E%E6%88%98%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E6%8A%A5%E8%A1%A8%E7%BB%9F%E8%AE%A1%E5%B9%B6%E5%AE%9A%E6%97%B6%E6%8E%A8%E9%80%81%E7%94%A8%E6%88%B7.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/db/%E5%AE%9E%E4%BE%8B/21.220819-SpringBoot%E5%AE%9E%E6%88%98%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E6%8A%A5%E8%A1%A8%E7%BB%9F%E8%AE%A1%E5%B9%B6%E5%AE%9A%E6%97%B6%E6%8E%A8%E9%80%81%E7%94%A8%E6%88%B7.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">7.数据报表统计并定时推送用户的手把手教程</source>
      <description>本文节选自 《实战演练专题》 通过一个小的业务点出发，搭建一个可以实例使用的项目工程，将各种知识点串联起来; 实战演练专题中，每一个项目都是可以独立运行的，包含若干知识点，甚至可以不做修改直接应用于生产项目； 今天的实战项目主要解决的业务需求为：每日新增用户统计，生成报表，并邮件发送给相关人 本项目将包含以下知识点： 基于MySql的每日新增用户报表统计（如何统计每日新增用户，若日期不连续如何自动补0？） 定时执行报表统计任务 MyBatis + MySql数据操作 邮件发送 Thymeleaf引擎实现报表模板渲染</description>
      <category>SpringBoot</category>
      <category>中间件</category>
      <category>email</category>
      <category>应用篇</category>
      <pubDate>Fri, 19 Aug 2022 10:34:38 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>本文节选自 <a href="https://hhui.top/spring/" target="_blank" rel="noopener noreferrer">《实战演练专题》 </a></p>
</blockquote>
<p>通过一个小的业务点出发，搭建一个可以实例使用的项目工程，将各种知识点串联起来; 实战演练专题中，每一个项目都是可以独立运行的，包含若干知识点，甚至可以不做修改直接应用于生产项目；</p>
<p>今天的实战项目主要解决的业务需求为：<code>每日新增用户统计，生成报表，并邮件发送给相关人</code></p>
<p>本项目将包含以下知识点：</p>
<ul>
<li>基于MySql的每日新增用户报表统计（如何统计每日新增用户，若日期不连续如何自动补0？）</li>
<li>定时执行报表统计任务</li>
<li>MyBatis + MySql数据操作</li>
<li>邮件发送</li>
<li>Thymeleaf引擎实现报表模板渲染</li>
</ul>
<!-- more -->
<h2> I. 需求拆解</h2>
<p>需要相对来说属于比较明确的了，目的就是实现一个自动报表统计的任务，查询出每日的用户新增情况，然后推送给指定的用户</p>
<p>因此我们将很清晰的知道，我们需要干的事情</p>
<p><strong>定时任务</strong></p>
<p>这里重点放在如何来支持这个任务的定时执行，通常来说定时任务会区分为固定时刻执行 + 间隔时长执行两种（注意这种区分主要是为了方便理解，如每天五点执行的任务，也可以理解为每隔24h执行一次）</p>
<p>前者常见于<code>一次性任务</code>，如本文中的每天统计一次，这种就是相对典型的固定时刻执行的任务；</p>
<p>后者常见于<code>轮询式任务</code>，如常见的应用探活(每隔30s发一个ping消息，判断服务是否健在）</p>
<blockquote>
<p>定时任务的方案非常多，有兴趣的小伙伴可以关注一波“一灰灰blog”公众号，蹲守一个后续</p>
</blockquote>
<p>本文将直接采用Spring的定时任务实现需求场景，对这块不熟悉的小伙伴可以看一下我之前的分享的博文</p>
<blockquote>
<ul>
<li><a href="https://blog.hhui.top/hexblog/2018/08/01/180801-Spring%E4%B9%8B%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E7%AF%87/" target="_blank" rel="noopener noreferrer">180801-Spring之定时任务基本使用篇 - 一灰灰Blog</a></li>
<li><a href="https://blog.hhui.top/hexblog/2018/08/03/180803-Spring%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E9%AB%98%E7%BA%A7%E4%BD%BF%E7%94%A8%E7%AF%87/" target="_blank" rel="noopener noreferrer">180803-Spring定时任务高级使用篇 - 一灰灰Blog</a></li>
</ul>
</blockquote>
<p><strong>每日新增用户统计</strong></p>
<p>每日新增用户统计，实现方式挺多的，比如举几个简单的实现思路</p>
<ul>
<li>基于redis的计数器：一天一个key，当天有新用户时，同步的实现计数器+1</li>
<li>基于数据库，新增一个统计表，包含如日期 + 新增用户数 + 活跃用户数 等字段
<ul>
<li>有新用户注册时，对应日期的新增用户数，活跃用户数 + 1</li>
<li>老用户今日首次使用时，活跃用户数 + 1</li>
</ul>
</li>
</ul>
<p>上面两个方案都需要借助额外的库表来辅助支持，本文则采用直接统计用户表，根据注册时间来聚合统计每日的新增用户数</p>
<ul>
<li>优点：简单，无额外要求，适用于数据量小的场景（比如用户量小于百万的）</li>
<li>缺点：用户量大时，数据库压力大</li>
</ul>
<p>关于如何使用mysql进行统计每日新增用户，不熟悉的小伙伴，推荐参考博主之前的分享文章</p>
<ul>
<li>
<ul>
<li><a href="https://blog.hhui.top/hexblog/2022/07/07/220707-MySql%E6%8C%89%E6%97%B6%E3%80%81%E5%A4%A9%E3%80%81%E5%91%A8%E3%80%81%E6%9C%88%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1/" target="_blank" rel="noopener noreferrer">220707-MySql按时、天、周、月进行数据统计 - 一灰灰Blog</a></li>
</ul>
</li>
</ul>
<p><strong>报表生成&amp;推送用户</strong></p>
<p>接下来就是将上面统计的数据，生成报表然后推送给用户；首先是如何将数据生成报表？其次则是如何推送给指定用户？</p>
<p>将数据组装成报表的方式通常取决于你选择的推送方式，如飞书、钉钉之类的，有对应的开发api，可以直接推送富文本；</p>
<p>本文的实现姿势则选择的是通过邮件的方式进行发送，why?</p>
<ul>
<li>飞书、钉钉、微信之类的，需要授权，对于不使用这些作为办公软件的小伙伴没什么意义</li>
<li>短信需要钱....</li>
</ul>
<p>对于邮件，大家应该都有，无论是qq邮箱，还是工作邮箱；基本上对于想要直接跑本文的小伙伴来说，没有什么额外的门槛</p>
<p>关于java/spring如何使用邮箱，对此不太熟悉的小伙伴，可以参考博主之前的分享文章</p>
<ul>
<li>
<ul>
<li><a href="https://spring.hhui.top/spring-blog/2021/08/02/210802-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8B%E9%82%AE%E4%BB%B6%E5%8F%91%E9%80%81%E5%A7%BF%E5%8A%BF%E4%BB%8B%E7%BB%8D/" target="_blank" rel="noopener noreferrer">【中间件】SpringBoot系列之邮件发送姿势介绍 | 一灰灰Blog</a></li>
</ul>
</li>
</ul>
<blockquote>
<p>上面文章中介绍的是FreeMaker来实现模板渲染，本文则介绍另外一个知识点，借助Thymleaf来实现数据报表的生成 （一篇文章获取这么多知识点，就问你开不开心O(∩_∩)O）</p>
</blockquote>
<h2> II. 分布实现</h2>
<h3> 1. 项目搭建</h3>
<p>首选搭建一个基本的SpringBoot应用，相信这一步大家都很熟悉了；若有不懂的小伙伴，请点赞、评论加博主好友，手把手教你，不收费</p>
<p>最终的项目依赖如下</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>别看上面好像依赖了不少包，实际上各有用处</p>
<ul>
<li><code>spring-boot-starter-web</code>: 提供web服务</li>
<li><code>spring-boot-starter-mail</code>: 发邮件就靠它</li>
<li><code>mybatis-spring-boot-starter</code>: 数据库操作</li>
</ul>
<p>我们的用户存在mysql中，这里使用mybatis来实现db操作（又一个知识点来了，收好不谢）</p>
<h3> 2. 数据准备</h3>
<blockquote>
<p>文末的源码包含库表结构，初始化数据，可以直接使用</p>
</blockquote>
<p>既然模拟的是从数据库中读取每日新增用户，所以我们准备了一张表</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来准备写入一些数据；为了模拟某些天没有新增用户，贴心的一灰灰博主给大家提供基于python的数据生成脚本，源码如下 (python3+，对python不熟的小伙伴，可以到博主的站点进补一下，<a href="https://blog.hhui.top/hexblog/categories/Python/" target="_blank" rel="noopener noreferrer">超链</a>)</p>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. 全局配置</h3>
<p>数据准备完毕之后，接下来配置一下db、email相关的参数</p>
<p><code>resources/application.yml</code> 文件内容如下</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的配置分为三类</p>
<ul>
<li>数据库相关：连接信息，用户名密码， mybatis配置</li>
<li>thymleaf：模板渲染相关</li>
<li>email: 邮箱配置相关，请注意若使用博主的源码，在本地运行时，请按照前面介绍的邮箱博文中手把手的教程，获取您自己的邮箱授权信息，填在上面的username, password中</li>
</ul>
<h3> 4. 数据报表统计实现</h3>
<p>接下来就正式进入大家喜闻乐见的编码实现环节，我们直接使用mybaits来实现数据库操作，定义一个统计的接口</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接口中定义了一个PO对象，就是我们希望返回的数据，其定义就非常清晰简单了，时间 + 数量</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面定义的知识接口，具体首先，当然是放在mybatis的传统xml文件中，根据前面application.yml配置，我们的xml文件需要放在 <code>resources/mapper</code> 目录下，具体实现如下</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>重点看一下上面的sql实现，为什么会一个join逻辑？</p>
<p>那我们稍稍思考，若我们直接通过日期进行format之后，再group一下统计计数，会有什么问题？给大家3s的思考时间</p>
<ul>
<li>1s</li>
<li>2s</li>
<li>3s</li>
</ul>
<p>好的3s时间到，现在公布答案，当某一天一个新增用户都没有的时候，会发生什么事情？会出现这一天的数据空缺，即返回的列表中，少了一天，不连续了，如果前段的小伙伴基于这个列表数据进行绘图，很有可能出现异常</p>
<p>所以出于系统的健壮性考虑（即传说中的鲁棒性），我们希望若某一天没有数据，则对应的计数设置为0</p>
<p>具体的sql说明就不展开了，请查看博文获取更多： <a href="https://juejin.cn/post/7131369167961358350" target="_blank" rel="noopener noreferrer">MySql按时、天、周、月进行数据统计</a></p>
<h3> 5. 报表生成实现</h3>
<p>数据统计出来之后，接下来就是基于这些数据来生成我们报表，我们借助Thymleaf来实现，因此先写一个html模板，<code>resources/templates/report.html</code></p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>一个非常简单的table模板，需要接收三个数据，与之对应的vo对象，我们定义如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来就是拿到数据之后，将它与模板渲染得到我们希望的数据，这里主要借助的是<code>org.thymeleaf.spring5.SpringTemplateEngine</code></p>
<p>核心实现如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>模板渲染就一行<code>templateEngine.process("report", context)</code>，第一个参数为模板名，就是上面的html文件名（对于模板文件、静态资源怎么放，放在那儿，这个知识点当然也可以在一灰灰的站点获取，<a href="https://spring.hhui.top/spring-blog/2020/06/11/200611-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8BWeb%E7%AF%87%E4%B9%8B%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E9%85%8D%E7%BD%AE/" target="_blank" rel="noopener noreferrer">超链</a>）</p>
<p>第二个参数用于封装上下文，传递模板需要使用的参数</p>
<h3> 5. 邮件发送</h3>
<p>报表生成之后，就是将它推送给用户，我们这里选定的是邮箱方式，具体实现也比较简单，但是在最终部署到生产环境（如阿里云服务器时，可能会遇到坑，同样明显的知识点，博主会没有分享么？当然不会没有了，<a href="https://blog.hhui.top/hexblog/2021/10/28/211028-Email%E5%8F%91%E9%80%81%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/" target="_blank" rel="noopener noreferrer">Email生产环境发送排雷指南，你值得拥有</a>）</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的实现，直接写死了收件人邮箱，即我本人的邮箱，各位大佬在使用的时候，请记得替换一下啊</p>
<p>上面的实现除了发送邮件这个知识点之外，还有一个隐藏的获取配置参数的知识点，即<code>environment#getProperty()</code>，有兴趣的小伙伴翻博主的站点吧</p>
<h3> 6. 定时任务</h3>
<p>上面几部基本上就把我们的整个任务功能都实现了，从数据库中统计出每日新增用户，然后借助Thymleaf来渲染模板生成报告，然后借助email进行发送</p>
<p>最后的一步，就是任务的定时执行，直接借助Spring的Schedule来完成我们的目标，这里我们希望每天4:15分执行这个任务，如下配置即可</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 7. 测试</h3>
<p>最后测试演练一下，启动方法如下，除了基本的启动注解之外，还指定了mapper接口位置，开启定时任务；感兴趣的小伙伴可以试一下干掉这两个注解会怎样，评论给出你的实测结果吧</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当然我再实际测试的时候，不可能真等到早上四点多来看是否执行，大晚上还是要睡觉的；因此本地测试的时候，可以将上面定时任务改一下，换成每隔一分钟执行一次</p>
<p>接一个debug的中间图</p>
<figure><img src="/imgs/220819/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>打开的内容展示</p>
<figure><img src="/imgs/220819/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>此外，源码除了实现了定时推送之外，也提供了一个web接口，访问之后直接可以查看报表内容，方便大家调样式，实现如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 8.一灰灰的干货总结</h3>
<p>最后进入一灰灰的保留环节，这么“大”一个项目坐下来的，当然是得好好盘一盘它的知识点了，前面的各小节内容中有穿插的指出相应的知识点，接下来如雨的知识点将迎面袭来，不要眨眼</p>
<ul>
<li>Spring定时任务@Schedule
<ul>
<li>怎么用？ -&gt; <a href="https://liuyueyi.github.io/hexblog/2018/08/01/180801-Spring%E4%B9%8B%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E7%AF%87/" target="_blank" rel="noopener noreferrer">180801-Spring之定时任务基本使用篇 - 一灰灰Blog</a></li>
<li>多个任务串行并行，是否会相互影响？自定义线程池怎么整？一个异常会影响其他么？-&gt; <a href="https://blog.hhui.top/hexblog/2018/08/03/180803-Spring%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E9%AB%98%E7%BA%A7%E4%BD%BF%E7%94%A8%E7%AF%87/" target="_blank" rel="noopener noreferrer">Spring定时任务高级使用篇 - 一灰灰Blog</a></li>
</ul>
</li>
<li>数据库统计每日新增
<ul>
<li>mysql直接统计日新增，sql怎么写？ 时间不连续，如何规避？ -&gt; <a href="https://blog.hhui.top/hexblog/2022/07/07/220707-MySql%E6%8C%89%E6%97%B6%E3%80%81%E5%A4%A9%E3%80%81%E5%91%A8%E3%80%81%E6%9C%88%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1/" target="_blank" rel="noopener noreferrer">MySql按时、天、周、月进行数据统计 - 一灰灰Blog</a></li>
<li>mybatis操作db怎么玩？ -&gt; <a href="https://spring.hhui.top/spring-blog/categories/SpringBoot/DB%E7%B3%BB%E5%88%97/Mybatis/" target="_blank" rel="noopener noreferrer">Mybatis系列教程</a></li>
</ul>
</li>
<li>模板渲染
<ul>
<li>数据报表生成，直接字符串拼接？还是模板引擎的渲染？</li>
<li>更多的spring web知识点 -&gt; <a href="https://hhui.top/spring-web/" target="_blank" rel="noopener noreferrer">一灰灰的SpringWeb专栏 | 免费</a></li>
</ul>
</li>
<li>邮件发送
<ul>
<li>怎么发邮件？ -&gt; <a href="https://hhui.top/spring-middle/01.email/" target="_blank" rel="noopener noreferrer">SpringBoot无障碍使用邮箱服务</a></li>
<li>如何避免上线不采坑 -&gt; <a href="https://blog.hhui.top/hexblog/2021/10/28/211028-Email%E5%8F%91%E9%80%81%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/" target="_blank" rel="noopener noreferrer">Email生产环境发送排雷指南，你值得拥有</a></li>
</ul>
</li>
</ul>
<p>除了上面比较突出的知识点之外，当然还有其他的，如Spring如何读取配置参数，SpringMVC如何向模板中传递上下文，模板语法，静态资源怎么放等等</p>
<p>写到这我自己都惊呆了好么，一篇文章这么多知识点，还有啥好犹豫的，一键三连走起啊，我是一灰灰，这可能是我这个假期内最后一篇实战干货了，马上要开学了，老婆孩子回归之后，后续的更新就靠各位读友的崔更保持了</p>
<p>本文中所有知识点，都可以在我的个人站点获取，欢迎关注： <a href="https://hhui.top/" target="_blank" rel="noopener noreferrer">https://hhui.top/</a></p>
<h2> III. 不能错过的源码和相关知识点</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/220819/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>8. Session与Cookie</title>
      <link>https://liuyueyi.github.io/tutorial/spring/web/Web%E4%B8%89%E5%89%91%E5%AE%A2/230323-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8BSession%E4%B8%8ECookie.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/web/Web%E4%B8%89%E5%89%91%E5%AE%A2/230323-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8BSession%E4%B8%8ECookie.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">8. Session与Cookie</source>
      <description>虽然我们现在基本上已经进入了分布式session的时代了，但是在切实去看最新的oauth, sso, jwt等各种登录方案之前，我们有必要学习一下最早的cookie/session方案，看一下它们是怎么协同工作的，又有什么局限性</description>
      <category>SpringBoot</category>
      <category>WEB系列</category>
      <pubDate>Thu, 23 Mar 2023 22:03:01 GMT</pubDate>
      <content:encoded><![CDATA[<p>虽然我们现在基本上已经进入了分布式session的时代了，但是在切实去看最新的oauth, sso, jwt等各种登录方案之前，我们有必要学习一下最早的cookie/session方案，看一下它们是怎么协同工作的，又有什么局限性</p>
<!-- more -->
<h2> 项目配置</h2>
<h3> 1. 依赖</h3>
<p>首先搭建一个标准的SpringBoot项目工程，相关版本以及依赖如下</p>
<p>本项目借助<code>SpringBoot 2.2.1.RELEASE</code> + <code>maven 3.5.3</code> + <code>IDEA</code>进行开发</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 启动入口</h3>
<p>我们使用默认的配置进行测试，因此启动入口也可以使用最基础的</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> Session/Cookie使用姿势</h2>
<p>接下来我们再看一下如何在SpringBoot项目中是session/cookie</p>
<h3> 1. 登录入口，保存session</h3>
<p>首先我们设计一个登录的接口，用来模拟真实场景下的登录，注意下面的实现</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面的实现中，方法中定义了一个<code>HttpSession</code>的参数类型，具体的实现中，就是表示写入sesion的操作</p>
<p>当session写入完毕之后，在这个会话结束之前，后续的所有请求都可以直接获取到对应的session</p>
<h3> 2. session读取测试</h3>
<p>下面给出两种常见的session获取方式</p>
<ul>
<li>直接从HttpSession中获取</li>
<li>通过HttpServletRequest来获取</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来我们来模拟验证一下</p>
<figure><img src="/imgs/230323/00.gif" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>从上面的演示图中，也可以看出，在登录之后，访问上面的接口，可以直接拿到session中存储的用户名；</p>
<p>且不同用户登录（不同的浏览器），他们的session不会出现串掉的情况</p>
<h3> 3. 退出登录</h3>
<p>有登陆当然就有登出，如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4. session实现原理</h3>
<p>SpringBoot提供了一套非常简单的session机制，那么它又是怎么工作的呢？ 特别是它是怎么识别用户身份的呢？ session又是存在什么地方的呢？</p>
<p>session：再浏览器窗口打开期间，这个会话一直有效，即先访问login，然后再访问time，可以直接拿到name， 若再此过程中，再次访问了login更新了name，那么访问time获取到的也是新的name</p>
<p>当浏览器关闭之后，重新再访问 time 接口，则此时将拿不到 name</p>
<p>核心工作原理：</p>
<ul>
<li>借助cookie中的 JESSIONID 来作为用户身份标识，这个数据相同的，认为是同一个用户；然后会将session再内存中存一份，有过期时间的限制，通常每次访问一次，过期时间重新刷新</li>
<li>当浏览器不支持cookie时，借助url重写，将 sessionId 写道url的地址中，参数名 = jsessionid</li>
</ul>
<figure><img src="/imgs/230323/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>从上面的描述中，就可以看出几个关键点：</p>
<ul>
<li>session主要是存在内存中，根据用户请求的cookie来识别用户身份，且有一个过期时间 （那么问题来了，内存有大小限制么？会出现oom么？）</li>
<li>对于用户而言，每次关闭浏览器再重新打开，会重新生成 JESSIONID 的cookies值，由于这个值的更改，导致后端无法记录之前访问的是谁</li>
</ul>
<h2> 不能错过的源码和相关知识点</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/224-web-session" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/224-web-session</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/230323/00.gif" type="image/gif"/>
    </item>
    <item>
      <title>6.基于JWT的用户鉴权实战</title>
      <link>https://liuyueyi.github.io/tutorial/spring/web/%E5%85%B6%E4%BB%96/230816-SpringBoot%E7%B3%BB%E5%88%97WEB%E4%B9%8B%E5%9F%BA%E4%BA%8EJWT%E7%9A%84%E7%94%A8%E6%88%B7%E9%89%B4%E6%9D%83.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/web/%E5%85%B6%E4%BB%96/230816-SpringBoot%E7%B3%BB%E5%88%97WEB%E4%B9%8B%E5%9F%BA%E4%BA%8EJWT%E7%9A%84%E7%94%A8%E6%88%B7%E9%89%B4%E6%9D%83.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">6.基于JWT的用户鉴权实战</source>
      <description>再传统的基于session的用户身份认证方式之中，用户相关信息存储与后端，通常基于cookie来携带用户的会话id，然后后端在基于会话id查到对应的用户身份信息；区别于session的身份认证方式，jwt作为一个基于RFC 7519的开发标准，提供了一种通过JSON形式的web令牌，用于在各系统之间的安全可信的数据传输、身份标识 本文将主要介绍jwt的相关知识点，以及如何基于jwt来实现一个简单的用户鉴权方案 I. JWT知识点 jwt，全称 json web token, JSON Web 令牌是一种开放的行业标准 RFC 7519 方法，用于在两方之间安全地表示声明。</description>
      <category>SpringBoot</category>
      <category>WEB系列</category>
      <category>JWT</category>
      <pubDate>Wed, 16 Aug 2023 14:36:37 GMT</pubDate>
      <content:encoded><![CDATA[<p>再传统的基于session的用户身份认证方式之中，用户相关信息存储与后端，通常基于cookie来携带用户的会话id，然后后端在基于会话id查到对应的用户身份信息；区别于session的身份认证方式，jwt作为一个基于RFC 7519的开发标准，提供了一种通过JSON形式的web令牌，用于在各系统之间的安全可信的数据传输、身份标识</p>
<p>本文将主要介绍jwt的相关知识点，以及如何基于jwt来实现一个简单的用户鉴权方案</p>
<!-- more  -->
<h2> I. JWT知识点</h2>
<p>jwt，全称 json web token, JSON Web 令牌是一种开放的行业标准 RFC 7519 方法，用于在两方之间安全地表示声明。</p>
<blockquote>
<p>详情可以参考： <a href="https://jwt.io/introduction" target="_blank" rel="noopener noreferrer">hhttps://jwt.io/introduction</a></p>
</blockquote>
<h3> 1. 数据结构</h3>
<p>JSON Web Token由三部分组成，它们之间用圆点<code>.</code>进行分割， 一个标准的JWT形如 <code>xxx.yyy.zzz</code></p>
<ul>
<li>Header</li>
<li>Payload</li>
<li>Signature</li>
</ul>
<h4> 1.1 header</h4>
<p>即第一部分，由两部分组成：token的类型（<code>JWT</code>）和算法名称（比如：<code>HMAC</code> <code>SHA256</code>或者<code>RSA</code>等等）。</p>
<p>一个具体实例如</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后，用Base64对这个JSON编码就得到JWT的第一部分</p>
<h4> 1.2 Payload</h4>
<p>第二部分具体的实体，可以写入自定义的数据信息，有三种类型</p>
<ul>
<li><code>Registered claims</code> : 这里有一组预定义的声明，它们不是强制的，但是推荐。比如：iss (issuer 签发者), exp (expiration time 有效期), sub (subject), aud (audience)等。</li>
<li><code>Public claims</code> : 可以随意定义。</li>
<li><code>Private claims</code> : 用于在同意使用它们的各方之间共享信息，并且不是注册的或公开的声明</li>
</ul>
<p>如一个具体实例</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对payload进行Base64编码就得到JWT的第二部分</p>
<h4> 1.3 Signature</h4>
<p>为了得到签名部分，你必须有编码过的header、编码过的payload、一个秘钥，签名算法是header中指定的那个，然对它们签名即可。</p>
<p>如 <code>HMACSHA256(base64UrlEncode(header) + "." + base64UrlEncode(payload), secret)</code></p>
<p>签名是用于验证消息在传递过程中有没有被更改，并且，对于使用私钥签名的token，它还可以验证JWT的发送方是否为它所称的发送方。</p>
<h4> 1.4 具体实例</h4>
<p>下面给出一个基于 <code>java-jwt</code> 生成的具体实例</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/230816/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> II. 使用实例</h2>
<p>接下来我们基于jwt方案实现一个用户鉴权的示例demo</p>
<h3> 1. 项目搭建</h3>
<p>首先搭建一个标准的SpringBoot项目工程，相关版本以及依赖如下</p>
<p>本项目借助<code>SpringBoot 2.2.1.RELEASE</code> + <code>maven 3.5.3</code> + <code>IDEA</code>进行开发</p>
<p>添加web支持，用于配置刷新演示</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们采用thymeleaf来进行前端页面的渲染，添加一些相关的配置 <code>application.yml</code></p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. JWT鉴权流程</h3>
<p>一个简单的基于jwt的身份验证方案如下图</p>
<figure><img src="/imgs/230816/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>基本流程分三步：</p>
<ol>
<li>
<p>用户登录成功之后，后端将生成的jwt返回给前端，然后前端将其保存在本地缓存；</p>
</li>
<li>
<p>之后前端与后端的交互时，都将jwt放在请求头中，我们这里借助Http的身份认证的请求头<code>Authorization</code></p>
</li>
<li>
<p>后端接收到用户的请求，从请求头中获取jwt，然后进行校验，通过之后，才响应相关的接口；否则表示未登录</p>
</li>
</ol>
<h3> 3. 实现方案</h3>
<p>基于上面的流程，我们可以实现一个非常简单的登录认证演示工程</p>
<p>首先在内存中，维护几个简单用户名/密码信息，用于模拟用户名+密码的校验</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后提供登录接口</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的接口实现，接收两个请求参数: 用户名 + 密码</p>
<p>当用户身份校验通过之后，将生成一个jwt，这里直接使用开源项目<code>java-jwt</code>来生成(当然有兴趣的小伙伴也可以自己来实现)</p>
<p>需要注意的一点是，我们在上面的实现中，除了直接返回jwt之外，也将这个jwt写在cookie中，这种将jwt写入cookie的方案，主要的好处就是前端不需要针对jwt进行特殊处理
当然对应的缺点也和直接使用session的鉴权方式一样，存在csrf风险，以及对于跨资源共享时的资源共享问题(CORS)</p>
<blockquote>
<p>本项目的实际演示中，采用前端存储返回的jwt，然后通过请求头方式来传递jwt</p>
</blockquote>
<p>上面登录完成之后，再提供一个简单的要求登录之后才能查看的查询接口</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>最后再写一个前端页面来完成整个测试</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对应的前端页面如下:</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4. 实例演示</h3>
<p>基于上面的实现，接下来我们看一下具体表现情况</p>
<figure><img src="/imgs/230816/02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<figure><img src="/imgs/230816/03.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>从上面的两张图也可以看出，登录成功之后，jwt写入到本地的session storage中，再后续的请求中，若请求头<code>Authroization</code>中携带了jwt信息，则后端可以进行正常校验</p>
<p>有兴趣的小伙伴可以尝试修改一下本地存储中的jwt值，看一下非法或者过期的jwt会怎么表现</p>
<h3> 5. 小结</h3>
<p>本文主要介绍了jwt的基本知识点，并给出了一个基于jwt的使用实例，下面针对jwt和session做一个简单的对比</p>
<table>
<thead>
<tr>
<th>jwt</th>
<th>session</th>
</tr>
</thead>
<tbody>
<tr>
<td>前端存储，通用的校验规则，后端再获取jwt时校验是否有效</td>
<td>前端存索引，后端判断session是否有效</td>
</tr>
<tr>
<td>验签，不可篡改</td>
<td>无签名保障，安全性由后端保障</td>
</tr>
<tr>
<td>可存储非敏感信息，如用户名，头像等</td>
<td>一般不存储业务信息</td>
</tr>
<tr>
<td>jwt生成时，指定了有效期，本身不支持续期以及提前失效</td>
<td>后端控制有效期，可提前失效或者自动续期</td>
</tr>
<tr>
<td>通常以请求头方式传递</td>
<td>通常以cookie方式传递</td>
</tr>
<tr>
<td>可预发csrf攻击</td>
<td>session-cookie方式存在csrf风险</td>
</tr>
</tbody>
</table>
<p>关于上面的两个风险，给一个简单的扩展说明</p>
<p><strong>csrf攻击</strong></p>
<p>如再我自己的网站页面上，添加下面内容</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>然后当你访问我的网站时，结果发现你在技术派上的登录用户被注销了!!!</p>
<p>使用jwt预防csrf攻击的主要原理就是jwt是通过请求头，由js主动塞进去传递给后端的，而非cookie的方式，从而避免csrf漏洞攻击</p>
<h2> III. 不能错过的源码和相关知识点</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/225-web-jwt" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/230816/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>9. 实战之基于WebListener实现实时在线人数统计</title>
      <link>https://liuyueyi.github.io/tutorial/spring/web/%E5%AE%9E%E4%BE%8B/230325-SpringBoot%E5%AE%9E%E6%88%98%E4%B9%8B%E5%9F%BA%E4%BA%8EWebListener%E5%AE%9E%E7%8E%B0%E5%AE%9E%E6%97%B6%E5%9C%A8%E7%BA%BF%E4%BA%BA%E6%95%B0%E7%BB%9F%E8%AE%A1.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/web/%E5%AE%9E%E4%BE%8B/230325-SpringBoot%E5%AE%9E%E6%88%98%E4%B9%8B%E5%9F%BA%E4%BA%8EWebListener%E5%AE%9E%E7%8E%B0%E5%AE%9E%E6%97%B6%E5%9C%A8%E7%BA%BF%E4%BA%BA%E6%95%B0%E7%BB%9F%E8%AE%A1.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">9. 实战之基于WebListener实现实时在线人数统计</source>
      <description>很多pc网站都有一个实时在线人数的统计功能，那么一般这种是采用什么方式来实现的呢？ 这里我们介绍一个最基础的是实现方式，基于Session结合WebListener来实现在线人数统计</description>
      <category>SpringBoot</category>
      <category>WEB系列</category>
      <category>应用篇</category>
      <pubDate>Sat, 25 Mar 2023 20:33:47 GMT</pubDate>
      <content:encoded><![CDATA[<p>很多pc网站都有一个实时在线人数的统计功能，那么一般这种是采用什么方式来实现的呢？ 这里我们介绍一个最基础的是实现方式，基于Session结合WebListener来实现在线人数统计</p>
<!-- more -->
<h2> 项目配置</h2>
<h3> 1. 依赖</h3>
<p>首先搭建一个标准的SpringBoot项目工程，相关版本以及依赖如下</p>
<p>本项目借助<code>SpringBoot 2.2.1.RELEASE</code> + <code>maven 3.5.3</code> + <code>IDEA</code>进行开发</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 启动入口</h3>
<p>我们使用默认的配置进行测试，因此启动入口也可以使用最基础的</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. web配置</h3>
<p>我们主要根据用户的session来创建与销毁来判断是否有新的用户访问站点、以及长时间没有访问之后认为已经离线，为了简化这个注销的模拟过程，我们将session的生命周期设置短一点</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 在线人数统计实现</h2>
<p>接下来我们看一下具体的实现思路：</p>
<ul>
<li>借助Servelt的Listener机制，主要监听Session的创建与销毁</li>
<li>当session创建时，认为新来一个用户，计数+1</li>
<li>当session销毁时，认为用户已经离开，或者长时间没有访问，计数-1</li>
</ul>
<h3> 1. 计数服务</h3>
<p>一个简单基础的计数服务，借助 <code>AtomicInteger</code> 来实现计数统计（为啥不直接是int ?)</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. Session监听器</h3>
<p>自定义一个Session的监听器，监听HttpSession的相关操作</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. 登录登出接口</h3>
<p>最后再设计一个登录、登出、查询实时在线人数的统计接口</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来验证一下，实时在线人数统计情况</p>
<figure><img src="/imgs/230325/00.gif" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 4. 小结</h3>
<p>上面虽然是实现了实时在线人数统计，但是存在一个非常明显的短板问题，那就是只适用于单机的场景，如果后台有多个服务部署，那应该怎么处理呢？</p>
<p>基于此，自然而然想到的就是分布式session 结合 redis 计数来实现，但是这个思路可行么？ 分布式session失效会抛出一个事件么？或许通过监听redis的key失效能处理，但是整体来看，还是有些麻烦，有没有更简单实用的场景呢</p>
<p>且待下文详解</p>
<h2> 不能错过的源码和相关知识点</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-case/206-web-loginuser-count" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-case/206-web-loginuser-count</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/230325/00.gif" type="image/gif"/>
    </item>
    <item>
      <title>MongoDB之Collection导入导出</title>
      <link>https://liuyueyi.github.io/tutorial/db/mongodb/basic/01.MongoDB%E4%B9%8BCollection%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA.html</link>
      <guid>https://liuyueyi.github.io/tutorial/db/mongodb/basic/01.MongoDB%E4%B9%8BCollection%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">MongoDB之Collection导入导出</source>
      <description>mongodb中集合的导入导出，在robot3t工具中没有找到对应的方法，记录下控制台的操作流程 主要利用： mongoexport 与 mongoimport</description>
      <category>DB</category>
      <category>Mongo</category>
      <pubDate>Sat, 16 Feb 2019 10:25:19 GMT</pubDate>
      <content:encoded><![CDATA[<p>mongodb中集合的导入导出，在robot3t工具中没有找到对应的方法，记录下控制台的操作流程</p>
<p>主要利用： <code>mongoexport</code> 与 <code>mongoimport</code></p>
<!-- more -->
<h3> 1. 集合导出</h3>
<p>直接使用 <code>mognoexport</code> 即可，通过<code>mongoexport --help</code>查看对应的使用说明</p>
<p>将库<code>database</code>中的集合<code>collection</code>导出到json文件<code>out.json</code></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 2. 集合导入</h3>
<p>使用 <code>mongoimport</code> 实现导入，同样可以输入<code>--help</code>查看使用说明</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>零：环境安装与初始化</title>
      <link>https://liuyueyi.github.io/tutorial/db/mongodb/basic/02.MongoDb%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E9%9B%B6-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96.html</link>
      <guid>https://liuyueyi.github.io/tutorial/db/mongodb/basic/02.MongoDb%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E9%9B%B6-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">零：环境安装与初始化</source>
      <description>MongoDB 是一个基于分布式文件存储的数据库。由 C++ 语言编写。旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。 MongoDB 是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。 本篇为mongodb系列教程第一篇，环境安装与连接设置</description>
      <category>DB</category>
      <category>Mongo</category>
      <pubDate>Thu, 19 Mar 2020 20:13:29 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>MongoDB 是一个基于分布式文件存储的数据库。由 C++ 语言编写。旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。</p>
</blockquote>
<p>MongoDB 是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。</p>
<p>本篇为mongodb系列教程第一篇，环境安装与连接设置</p>
<!-- more -->
<h3> 1. docker安装</h3>
<p>首先介绍最简单的安装方式，docker安装，请先保证docker环境存在（没有安装的推荐查看: <a href="https://blog.hhui.top/2019/12/06/191206-Centos%E5%AE%89%E8%A3%85docker%E4%B8%8E%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/" target="_blank" rel="noopener noreferrer">Centos安装docker与使用说明</a>）</p>
<p>安装命令如下:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. centos安装</h3>
<p>直接借助yum进行安装，命令如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. 用户配置</h3>
<p>直接通过mongodb提供的终端命令进行设置，</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4. 终端控制台</h3>
<p>mongodb集成了终端控制台，通过<code>mongo</code>进入；</p>
<p>但是当我们设置了登录认证时，有下面两种使用姿势</p>
<p><strong>case1</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/200319/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p><strong>case2</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/200319/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 5. 可视化操作工具</h3>
<p>终端虽好，使用起来终究不太顺手，可视化工具推荐使用<code>ROBO 3T</code>操作mongodb，官网下载地址: <a href="https://robomongo.org/" target="_blank" rel="noopener noreferrer">https://robomongo.org/</a></p>
<p>然后配置mongodb连接信息（支持ssh验证方式哦），下面是一个简单的配置</p>
<figure><img src="/imgs/200319/02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>然后就可以通过它来操作mongodb了</p>
<figure><img src="/imgs/200319/03.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/200319/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>一：基本概念</title>
      <link>https://liuyueyi.github.io/tutorial/db/mongodb/basic/03.MongoDb%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B8%80-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5.html</link>
      <guid>https://liuyueyi.github.io/tutorial/db/mongodb/basic/03.MongoDb%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B8%80-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">一：基本概念</source>
      <description>mongodb和我们通常使用的关系型数据库如mysql，在一些基本概念上有相同之处，但也有一些区别，在进行mongodb的语言介绍之前，有必要先了解一些基础概念 本文将对比sql对一些基础概念进行解释说明</description>
      <category>DB</category>
      <category>Mongo</category>
      <pubDate>Sat, 21 Mar 2020 19:40:22 GMT</pubDate>
      <content:encoded><![CDATA[<p>mongodb和我们通常使用的关系型数据库如mysql，在一些基本概念上有相同之处，但也有一些区别，在进行mongodb的语言介绍之前，有必要先了解一些基础概念</p>
<p>本文将对比sql对一些基础概念进行解释说明</p>
<!-- more -->
<h2> I. 基本概念</h2>
<blockquote>
<p><a href="https://www.runoob.com/mongodb/mongodb-databases-documents-collections.html" target="_blank" rel="noopener noreferrer">MongoDB 概念解析</a></p>
</blockquote>
<p>在sql中，会区分database, table, row, column, index, primaryId；在mongodb中也有对应的概念</p>
<table>
<thead>
<tr>
<th>sql</th>
<th>mongodb</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>database</td>
<td>db</td>
<td>数据库</td>
</tr>
<tr>
<td>table</td>
<td>collection</td>
<td>表/集合</td>
</tr>
<tr>
<td>row</td>
<td>document</td>
<td>行/文档</td>
</tr>
<tr>
<td>column</td>
<td>field</td>
<td>字段</td>
</tr>
<tr>
<td>index</td>
<td>index</td>
<td>索引</td>
</tr>
<tr>
<td>primaryId</td>
<td>_id</td>
<td>主键</td>
</tr>
<tr>
<td>lock</td>
<td>lock</td>
<td>锁</td>
</tr>
</tbody>
</table>
<p>下面对以上基本概念进行简单说明，详情的后续博文会补上</p>
<h3> 1. 数据库</h3>
<p>数据库可以理解为collection的聚集体，每个mongodb实例可以有多个database，每个database可以有多个collection</p>
<p>常见的几个命令如下：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 集合</h3>
<p>document的集合，与table最大的区别是它的结构不是固定的，不需要事先定义字段、类型</p>
<p>首次新增document时，集合被创建；</p>
<h3> 3. document</h3>
<p>文档，也就是具体的数据；bson结构，kv方式</p>
<p>最大的特点是不要求所有的document的结构一致，相同的field的数据类型可以不一致</p>
<h3> 4. index</h3>
<p>索引，同样是用来提高查询效率，避免全盘扫描</p>
<h3> 5. lock</h3>
<p>支持读写锁，document加读锁时，其他读操作ok，写操作禁止；加写锁时，其他读写操作禁止</p>
<h3> 6. 事务</h3>
<blockquote>
<p><a href="https://yq.aliyun.com/articles/610159" target="_blank" rel="noopener noreferrer">MongoDB 4.0 事务实现解析</a></p>
</blockquote>
<p>版本<code>&gt;= 4.0</code>，支持事务，支持多文档ACID，后续详细说明</p>
]]></content:encoded>
    </item>
    <item>
      <title>二：连接</title>
      <link>https://liuyueyi.github.io/tutorial/db/mongodb/basic/04.MongoDb%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%BA%8C-%E8%BF%9E%E6%8E%A5.html</link>
      <guid>https://liuyueyi.github.io/tutorial/db/mongodb/basic/04.MongoDb%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%BA%8C-%E8%BF%9E%E6%8E%A5.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">二：连接</source>
      <description>后续的所有文章的基础，都是需要先连上mongodb，然后才能执行各种命令操作； 本文将介绍一下如何连接一个已经启动的mongodb服务器</description>
      <category>DB</category>
      <category>Mongo</category>
      <pubDate>Sun, 22 Mar 2020 22:11:09 GMT</pubDate>
      <content:encoded><![CDATA[<p>后续的所有文章的基础，都是需要先连上mongodb，然后才能执行各种命令操作；</p>
<p>本文将介绍一下如何连接一个已经启动的mongodb服务器</p>
<!-- more -->
<h3> 1. 连接语法</h3>
<p>标准URI连接语法：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul>
<li><code>mongodb://</code> 固定前缀</li>
<li><code>username:password@</code>: 如果开启了用户登录验证，需要指定用户名密码</li>
<li><code>host1:port1</code>: mongodb服务器的ip/域名 + 端口(不填时，默认为27017)</li>
<li><code>database</code>: 如果指定<code>username:password@</code>，连接并验证登陆指定数据库。若不指定，默认打开 test 数据库</li>
<li><code>?options</code>: 是连接选项。如果不使用/database，则前面需要加上</li>
</ul>
<h3> 2. 实例</h3>
<p>直接连接方式如下，注意这种方式会保留用户名和密码，会有一定的安全风险</p>
<p><strong>连接目标服务器</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>连接多台服务器</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>连接 replica set 三台服务器, 写入操作应用在主服务器 并且分布查询到从服务器</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>三：基本工具介绍</title>
      <link>https://liuyueyi.github.io/tutorial/db/mongodb/basic/05.MongoDb%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B8%89-%E5%9F%BA%E6%9C%AC%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D.html</link>
      <guid>https://liuyueyi.github.io/tutorial/db/mongodb/basic/05.MongoDb%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B8%89-%E5%9F%BA%E6%9C%AC%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">三：基本工具介绍</source>
      <description>mongodb服务器安装完毕之后，提供了一些配套的操作工具，接下来我们有必要认识一下它们，并了解基本用法</description>
      <category>DB</category>
      <category>Mongo</category>
      <pubDate>Wed, 25 Mar 2020 21:32:39 GMT</pubDate>
      <content:encoded><![CDATA[<p>mongodb服务器安装完毕之后，提供了一些配套的操作工具，接下来我们有必要认识一下它们，并了解基本用法</p>
<!-- more -->
<h3> 0. mongod</h3>
<p>启动mongodb实例的主要命令，常见的使用姿势如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 1. mongo 命令行使用</h3>
<p>mongodb安装完毕之后，会自带一个终端命令行工具，通过它可以连接mongodb，并执行相关命令</p>
<h4> a. 连接</h4>
<p>介绍三种连接mongodb的姿势</p>
<p><strong>case1</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>case2</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>case3</strong></p>
<p>上面两种姿势虽然简单，但是用户名密码有暴露的风险，推荐使用下面这种方式</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> b. 操作</h4>
<p>连接上mongodb服务器之后，就可以执行mongo命令，查看数据库，管理文档，比如下面给几个常见的操作</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/200325/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 2. mongoimport/mongoexport</h3>
<p>用于导入导出数据，如</p>
<p>将库<code>database</code>中的集合<code>collection</code>导出到json文件<code>out.json</code></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>从json文件导入到目标集合<code>new_collection</code></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 3. mongodump/mongorestore</h3>
<p>使用mongodump命令来备份MongoDB数据, 将数据库<code>basic</code>的所有集合备份到目录 <code>/tmp/outDir</code>下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>使用mongorestore恢复，如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4. mongostate</h3>
<p>mongostat是mongodb自带的状态检测工具，在命令行下使用。它会间隔固定时间获取mongodb的当前运行状态，并输出。如果你发现数据库突然变慢或者有其他问题的话，你第一手的操作就考虑采用mongostat来查看mongo的状态。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="/imgs/200325/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 5. mongotop</h3>
<p>mongotop提供每个集合的水平的统计数据，默认每s输出一次</p>
<figure><img src="/imgs/200325/02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/200325/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>四：数据库 Database</title>
      <link>https://liuyueyi.github.io/tutorial/db/mongodb/basic/06.MongoDb%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E5%9B%9B-%E6%95%B0%E6%8D%AE%E5%BA%93-Database.html</link>
      <guid>https://liuyueyi.github.io/tutorial/db/mongodb/basic/06.MongoDb%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E5%9B%9B-%E6%95%B0%E6%8D%AE%E5%BA%93-Database.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">四：数据库 Database</source>
      <description>我们通常把mongodb叫文档型数据库，mysql叫关系型数据库，influxdb叫时序数据库，如果熟悉这三个的话，会发现他们都有一个database，它是collection/table/measurement的上一级，可以简单的把它理解为更高层级的集合，方便统一管理/权限划分/业务拆分 下面简单介绍一下database的基础操作</description>
      <category>DB</category>
      <category>Mongo</category>
      <pubDate>Thu, 26 Mar 2020 16:49:32 GMT</pubDate>
      <content:encoded><![CDATA[<p>我们通常把mongodb叫文档型数据库，mysql叫关系型数据库，influxdb叫时序数据库，如果熟悉这三个的话，会发现他们都有一个<code>database</code>，它是<code>collection/table/measurement</code>的上一级，可以简单的把它理解为更高层级的集合，方便统一管理/权限划分/业务拆分</p>
<p>下面简单介绍一下database的基础操作</p>
<!-- more -->
<h3> 1. 创建数据库</h3>
<p>当数据库不存在时，通过<code>use + 数据库</code>命令可以用来创建数据库；当数据库存在时，表示选中</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 2. 查看数据库</h3>
<p>通过 <code>db</code>查看当前的数据库</p>
<p>通过 <code>show dbs</code> 查看当前的数据库列表</p>
<p>请注意，新创建一个数据库时，直接使用<code>show dbs</code>命令，并不会显示出来，如下</p>
<figure><img src="/imgs/200326/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>为了显示这个数据库，需要插入一个文档</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="/imgs/200326/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 3. 删除数据库</h3>
<p>对于数据库而言，任何删除命令都需要慎重处理，一不小心就得跑路了。。。</p>
<p>命令如下: <code>db.dropDatabase()</code></p>
<p>实例说明：</p>
<p>一般来说我们需要删除时，两步走</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/200326/02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 4. 潜规则</h3>
<p>需要注意，有三个数据库属于预留的，有特殊的作用，不能新建同名的数据</p>
<ul>
<li>admin: 将一个用户添加到这个数据库，这个用户自动继承所有数据库的权限; 一些特定的服务器端命令也只能从这个数据库运行，比如列出所有的数据库或者关闭服务器。</li>
<li>local: 这个数据永远不会被复制，可以用来存储限于本地单台服务器的任意集合</li>
<li>config: 当Mongo用于分片设置时，config数据库在内部使用，用于保存分片的相关信息。</li>
</ul>
<p>命名规则：</p>
<ul>
<li>不能是空字符串</li>
<li>不能含有特殊字符（如<code> </code>，<code>.</code>，<code>$</code>, <code>\</code>, <code>/</code>, <code>\0</code></li>
<li>小写</li>
<li>最多64字节</li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/200326/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>五：集合 Collection</title>
      <link>https://liuyueyi.github.io/tutorial/db/mongodb/basic/07.MongoDb%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%BA%94-%E9%9B%86%E5%90%88-Collection.html</link>
      <guid>https://liuyueyi.github.io/tutorial/db/mongodb/basic/07.MongoDb%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%BA%94-%E9%9B%86%E5%90%88-Collection.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">五：集合 Collection</source>
      <description>集合，相当于关系型数据库中的table，在mongodb中，集合的概念非常贴切，属于文档(Document)的集合 其最大的特点是： 没有固定的结构</description>
      <category>DB</category>
      <category>Mongo</category>
      <pubDate>Thu, 26 Mar 2020 16:52:20 GMT</pubDate>
      <content:encoded><![CDATA[<p>集合，相当于关系型数据库中的table，在mongodb中，集合的概念非常贴切，属于文档(Document)的集合</p>
<p>其最大的特点是：</p>
<ul>
<li>没有固定的结构</li>
</ul>
<!-- more -->
<h3> 1. 创建集合</h3>
<p>创建命令如: <code>db.createCollection(name, options)</code></p>
<p>重点看一下参数<code>options</code>的可选项</p>
<ul>
<li>capped: true，表示创建固定大小的集合，需要指定size；超过数量之后，覆盖最早的文档</li>
<li>size: 固定集合时配套使用，KB为单位</li>
<li>autoIndexId: 自动为<code>_id</code>添加索引，默认true</li>
<li>max: 固定集合时，文档的最大数量</li>
</ul>
<p>一个简单的实例</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>除此之外，新插入一个文档时，集合若不存在，也会创建对应的集合，如</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 查看集合</h3>
<p>通过 <code>show collections</code> 查看数据库下的集合列表</p>
<figure><img src="/imgs/200326/03.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 3. 删除集合</h3>
<p>通过命令 <code>db.col.drop()</code>来删除</p>
<figure><img src="/imgs/200326/04.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 4. 命名规则</h3>
<ul>
<li>不能全是空白字符</li>
<li>不应包含特殊字符</li>
<li>不要以<code>system.</code>开头</li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/200326/03.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>六：文档 Document 插入姿势</title>
      <link>https://liuyueyi.github.io/tutorial/db/mongodb/basic/08.MongoDb%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E5%85%AD-%E6%96%87%E6%A1%A3-Document-%E6%8F%92%E5%85%A5%E5%A7%BF%E5%8A%BF.html</link>
      <guid>https://liuyueyi.github.io/tutorial/db/mongodb/basic/08.MongoDb%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E5%85%AD-%E6%96%87%E6%A1%A3-Document-%E6%8F%92%E5%85%A5%E5%A7%BF%E5%8A%BF.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">六：文档 Document 插入姿势</source>
      <description>文档相当于关系数据库中数据行，也是我们最关心的数据本身；以BSON格式存储（和json区别不大） 我们通常所说业务开发者的CURD四大技能，在mongodb中，就是针对Document而言，接下来我们先看一下文档的新增使用姿势</description>
      <category>DB</category>
      <category>Mongo</category>
      <pubDate>Thu, 26 Mar 2020 17:04:06 GMT</pubDate>
      <content:encoded><![CDATA[<p>文档相当于关系数据库中数据行，也是我们最关心的数据本身；以BSON格式存储（和json区别不大）</p>
<p>我们通常所说业务开发者的CURD四大技能，在mongodb中，就是针对Document而言，接下来我们先看一下文档的新增使用姿势</p>
<!-- more -->
<h3> 1. 基本语法</h3>
<p>插入语法： <code>db.collection.insert()</code></p>
<p>因为集合不要求定义数据结构，所以插入的文档格式理论上可以完全不一样，可以拥有完全不同的数据结构，相同的字段拥有不同的数据类型</p>
<h3> 2. 实例演示</h3>
<p>下面给出几个实例进行说明</p>
<p><strong>基本数据类型插入</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>数组类型插入</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>Object类型插入</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="/imgs/200326/05.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 3. 数据类型</h3>
<p>mongodb支持的基本数据类型，除了我们常见的string,int,float,boolean之外，还有一些其他的;</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>String</td>
<td>字符串， UTF8编码</td>
</tr>
<tr>
<td>Integer</td>
<td>整型，32/64位</td>
</tr>
<tr>
<td>Boolean</td>
<td>布尔</td>
</tr>
<tr>
<td>Double</td>
<td>浮点</td>
</tr>
<tr>
<td>Min/Max keys</td>
<td>将一个值与 BSON（二进制的 JSON）元素的最低值和最高值相对比</td>
</tr>
<tr>
<td>Array</td>
<td>数组</td>
</tr>
<tr>
<td>Timestamp</td>
<td>时间戳，记录文档修改或添加的具体时间</td>
</tr>
<tr>
<td>Object</td>
<td>内嵌文档</td>
</tr>
<tr>
<td>Null</td>
<td>创建空值</td>
</tr>
<tr>
<td>Symbol</td>
<td>符号。该数据类型基本上等同于字符串类型，但不同的是，它一般用于采用特殊符号类型的语言。</td>
</tr>
<tr>
<td>Date</td>
<td>日期，用 UNIX 时间格式来存储当前日期或时间。你可以指定自己的日期时间：创建 Date 对象，传入年月日信息。</td>
</tr>
<tr>
<td>ObjectID</td>
<td>对象ID</td>
</tr>
<tr>
<td>Binary Data</td>
<td>二进制</td>
</tr>
<tr>
<td>code</td>
<td>代码类型。用于在文档中存储 JavaScript 代码。</td>
</tr>
<tr>
<td>Regular expression</td>
<td>正则表达式类型。用于存储正则表达式。</td>
</tr>
</tbody>
</table>
<p><strong>ObjectId 类似唯一主键</strong>，可以很快的去生成和排序，包含 12 bytes，含义是：</p>
<ul>
<li>前 4 个字节表示创建 unix 时间戳,格林尼治时间 UTC 时间，比北京时间晚了 8 个小时</li>
<li>接下来的 3 个字节是机器标识码</li>
<li>紧接的两个字节由进程 id 组成 PID</li>
<li>最后三个字节是随机数</li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/200326/05.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>七：文档 Document 删除姿势</title>
      <link>https://liuyueyi.github.io/tutorial/db/mongodb/basic/09.MongoDb%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B8%83-%E6%96%87%E6%A1%A3-Document-%E5%88%A0%E9%99%A4%E5%A7%BF%E5%8A%BF.html</link>
      <guid>https://liuyueyi.github.io/tutorial/db/mongodb/basic/09.MongoDb%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B8%83-%E6%96%87%E6%A1%A3-Document-%E5%88%A0%E9%99%A4%E5%A7%BF%E5%8A%BF.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">七：文档 Document 删除姿势</source>
      <description>前面一篇介绍了插入文档的使用姿势，这一篇则主要介绍删除的使用case</description>
      <category>DB</category>
      <category>Mongo</category>
      <pubDate>Thu, 26 Mar 2020 18:02:03 GMT</pubDate>
      <content:encoded><![CDATA[<p>前面一篇介绍了插入文档的使用姿势，这一篇则主要介绍删除的使用case</p>
<!-- more -->
<h3> 1. 基本语法</h3>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>第一个为需要删除的匹配条件；第二个表示是否只删除一个，默认是false，删除所有满足条件的文档</p>
<p><strong>注意</strong></p>
<ul>
<li>当query为空时，表示删除所有文档，高危操作，谨慎执行</li>
</ul>
<h3> 2. 实例演示</h3>
<p>借用给我们上一篇插入的文档来进行演示，当前存在的文档为</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>根据id进行删除</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>根据name删除第一个满足条件的记录</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>再次查看剩下的内容如下：</p>
<figure><img src="/imgs/200326/06.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/200326/06.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>八：文档 Document 更新姿势</title>
      <link>https://liuyueyi.github.io/tutorial/db/mongodb/basic/10.MongoDb%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E5%85%AB-%E6%96%87%E6%A1%A3-Document-%E6%9B%B4%E6%96%B0%E5%A7%BF%E5%8A%BF.html</link>
      <guid>https://liuyueyi.github.io/tutorial/db/mongodb/basic/10.MongoDb%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E5%85%AB-%E6%96%87%E6%A1%A3-Document-%E6%9B%B4%E6%96%B0%E5%A7%BF%E5%8A%BF.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">八：文档 Document 更新姿势</source>
      <description>本篇介绍update/save两种方法提供的更新姿势</description>
      <category>DB</category>
      <category>Mongo</category>
      <pubDate>Fri, 27 Mar 2020 11:04:36 GMT</pubDate>
      <content:encoded><![CDATA[<p>本篇介绍update/save两种方法提供的更新姿势</p>
<!-- more -->
<h3> 1. update</h3>
<p>用于更新已经存在的文档，语法如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>query: 查询条件</li>
<li>update: 更新语句</li>
<li>upsert: （可选）true, 不存在update的记录时插入；默认是false，不插入</li>
<li>multi: (可选) true，表示更新所有满足条件的记录；默认false，只更新第一条</li>
<li>writeConcern: (可选)，抛出异常的级别</li>
</ul>
<p>插入两条用于测试的数据</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>下面给出几个更新的实例</p>
<p><strong>更新age</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/200327/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p><strong>更新所有age为20的文档，新增一个tag成员</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="/imgs/200327/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p><strong>更新一个不存在的文档</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="/imgs/200327/02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 2. save</h3>
<p>save最大的特点是覆盖，用新的文档完全覆盖旧的文档；而update，则是更新指定的field</p>
<p>语法如下：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>举例如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="/imgs/200327/03.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>那么问题来了，<strong>怎样判定是新增一条记录，还是覆盖已经存在的记录呢？</strong></p>
<ul>
<li>有唯一键来判定</li>
<li>即：如果save的文档中，某个field有唯一性要求，那么当数据库中存在这个field文档文档时，执行覆盖操作；否则执行插入</li>
</ul>
<p>举例如下, 指定ObjectId</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="/imgs/200327/04.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/200327/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>九：文档 Document 查询基础篇</title>
      <link>https://liuyueyi.github.io/tutorial/db/mongodb/basic/11.MongoDb%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B9%9D-%E6%96%87%E6%A1%A3-Document-%E6%9F%A5%E8%AF%A2%E5%9F%BA%E7%A1%80%E7%AF%87.html</link>
      <guid>https://liuyueyi.github.io/tutorial/db/mongodb/basic/11.MongoDb%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B9%9D-%E6%96%87%E6%A1%A3-Document-%E6%9F%A5%E8%AF%A2%E5%9F%BA%E7%A1%80%E7%AF%87.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">九：文档 Document 查询基础篇</source>
      <description>MongoDb文档查询，主要借助find方法来完成，在实际的业务开发中，为了满足各种复杂的业务场景，查询的姿势也是各种各样，本篇则主要介绍基本的使用姿势，不涉及到聚合、排序、分页相关内容</description>
      <category>DB</category>
      <category>Mongo</category>
      <pubDate>Sat, 28 Mar 2020 19:27:12 GMT</pubDate>
      <content:encoded><![CDATA[<p>MongoDb文档查询，主要借助find方法来完成，在实际的业务开发中，为了满足各种复杂的业务场景，查询的姿势也是各种各样，本篇则主要介绍基本的使用姿势，不涉及到聚合、排序、分页相关内容</p>
<!-- more -->
<h3> 1. 查询语法</h3>
<p>查询语法定义比较简单，复杂的是查询条件的组合；语法定义如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul>
<li>query: 查询条件，如果不填，则表示查询所有文档</li>
<li>projection: 查询需要返回的field，如果不填则返回所有的数据</li>
</ul>
<p>此外为了mongo-cli的返回结果更加友好，可以在最后添加<code>.pretty()</code>，使输出更友好</p>
<h3> 2. 查询所有</h3>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="/imgs/200328/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 3. 根据条件精准查询</h3>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="/imgs/200328/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 4. 数字比较查询</h3>
<p>对于数字类型的field，可以借助符号<code>$gt</code>(&gt;), <code>$get</code>(&gt;=), <code>$lt</code>(&lt;), <code>$lte</code>(&lt;=), <code>$ne</code>(!=) 来表示具体的操作</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/200328/02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 5. 模糊查询</h3>
<p>在mysql中有一个like用于模糊查询，在mongodb中，同样支持基于正则的模糊查询</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/200328/03.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 6. and条件</h3>
<p>多个查询条件需要满足时，并不需要什么特殊的操作，只需要在查询bson中，加上多个条件即可</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/200328/04.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 7. or条件</h3>
<p>和and不需要额外的操作不同，or条件需要借助 <code>$or</code> 来实现，语法如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>实例如下：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/200328/05.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 8. 限制返回成员</h3>
<p>有些时候我们只需要获取文档中的部分成员，可以在第二个参数中进行指定，规则如下</p>
<ul>
<li><code>成员名: 1</code>： 表示这个成员需要返回</li>
<li><code>成员名: 0</code>： 表示这个成员不返回</li>
</ul>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/200328/06.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>请注意，一般在使用了 <code>成员名: 1</code> 来指定返回field时，会自动返回<code>_id</code>，如果不需要，请显示加上 <code>_id: 0</code></p>
<h3> 9. field类型查询</h3>
<p>根据field的成员类型来作为查询条件，一般有两种方式，这里只介绍更优雅的，语法如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>举例说明</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="/imgs/200328/07.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 10. 存在查询</h3>
<p>mongodb的一个特点就是集合的结构不固定，所以某个成员可能存在也可能不存在，所以当我们的查询条件中需要加一个是否存在的判断时，可以如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/200328/08.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/200328/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>十：文档 Document 查询高级篇</title>
      <link>https://liuyueyi.github.io/tutorial/db/mongodb/basic/12.MongoDb%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E5%8D%81-%E6%96%87%E6%A1%A3-Document-%E6%9F%A5%E8%AF%A2%E9%AB%98%E7%BA%A7%E7%AF%87.html</link>
      <guid>https://liuyueyi.github.io/tutorial/db/mongodb/basic/12.MongoDb%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E5%8D%81-%E6%96%87%E6%A1%A3-Document-%E6%9F%A5%E8%AF%A2%E9%AB%98%E7%BA%A7%E7%AF%87.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">十：文档 Document 查询高级篇</source>
      <description>上一篇的mongodb查询，主要介绍的是一些基本操作，当然有基本就高阶操作； 本文将带来更多的查询姿势 排序 分页 聚合</description>
      <category>DB</category>
      <category>Mongo</category>
      <pubDate>Tue, 31 Mar 2020 21:50:13 GMT</pubDate>
      <content:encoded><![CDATA[<p>上一篇的mongodb查询，主要介绍的是一些基本操作，当然有基本就高阶操作；</p>
<p>本文将带来更多的查询姿势</p>
<ul>
<li>排序</li>
<li>分页</li>
<li>聚合</li>
</ul>
<!-- more -->
<h3> 1. 排序</h3>
<p>在mongodb中，使用sort方法进行排序，语法如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>请注意，sort内部是一个对象，key为field，value为1或者-1，其中1表示升序，-1表示降序</p>
<p>实例说明，根据age进行排序</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>输出如下:</p>
<figure><img src="/imgs/200331/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>上面的演示属于常规的操作，但是针对mongodb的特点，自然会有一些疑问</p>
<p><strong>q1: 如果某个文档没有包含这个field，排序是怎样的？</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="/imgs/200331/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>从输出来看，升序时，不包含这个field的文档，在最前面；降序时，不包含这个field的文档，在最后面</p>
<p><strong>q2: 支持多个field排序吗？</strong></p>
<p>原则上一般不建议多个field的排序（比较影响性能），但对于数据库而言，你得支持吧</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/200331/02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>请注意上的输出，在涉及到多个field排序时，优先根据第一个进行排序，当文档的field相同时，再根据后面的进行排序</p>
<h3> 2. 分页</h3>
<p>当文档很多时，我们不可能把所有的文档一次返回，所以就有了常见的分页，在sql中我们一般使用<code>limit</code> <code>offset</code>来实现分页，在mongodb中也差不多</p>
<p><strong>limit()</strong></p>
<p>限制返回的文档数</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="/imgs/200331/03.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p><strong>skip()</strong></p>
<p>使用limit进行返回条数限制，使用skip进行分页，表示跳过前面的n条数据</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/200331/04.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 3. 聚合</h3>
<p>使用<code>aggregate()</code>来实现聚合，用于处理求和、平均值，最大值，分组等</p>
<p>数据准备:</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>分组查询</strong></p>
<p>根据name进行分组统计</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/200331/05.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>请注意，分组的条件中</p>
<ul>
<li><code>_id</code>: 表示根据哪个字段进行分组</li>
<li><code>size: {}</code>: 表示聚合条件指定，将结果输出到名为size的field中</li>
<li><code>filed</code>名前加<code>$</code>进行指定</li>
</ul>
<p>当前mongodb支持的聚合表达式包括:</p>
<table>
<thead>
<tr>
<th>表达式</th>
<th>说明</th>
<th>举例说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>sum</td>
<td>求和</td>
<td><code>db.doc_demo.aggregate([{$group: {_id: "$name", size: {$sum: '$age'}}}])</code></td>
</tr>
<tr>
<td>avg</td>
<td>平均值</td>
<td><code>db.doc_demo.aggregate([{$group: {_id: "$name", size: {$avg: '$age'}}}])</code></td>
</tr>
<tr>
<td>min</td>
<td>取最小</td>
<td><code>db.doc_demo.aggregate([{$group: {_id: "$name", age: {$min: '$age'}}}])</code></td>
</tr>
<tr>
<td>max</td>
<td>取最大</td>
<td><code>db.doc_demo.aggregate([{$group: {_id: "$name", age: {$max: '$age'}}}])</code></td>
</tr>
<tr>
<td>push</td>
<td>结果插入到一个数组中</td>
<td><code>db.doc_demo.aggregate([{$group: {_id: "$name", age: {$push: '$age'}}}])</code></td>
</tr>
<tr>
<td>addToSet</td>
<td>结果插入集合，过滤重复</td>
<td><code>db.doc_demo.aggregate([{$group: {_id: "$name", age: {$addToSet: '$age'}}}])</code></td>
</tr>
<tr>
<td>first</td>
<td>第一个</td>
<td><code>db.doc_demo.aggregate([{$group: {_id: "$name", age: {$first: '$age'}}}])</code></td>
</tr>
<tr>
<td>last</td>
<td>最后一个</td>
<td><code>db.doc_demo.aggregate([{$group: {_id: "$name", age: {$last: '$age'}}}])</code></td>
</tr>
</tbody>
</table>
<figure><img src="/imgs/200331/06.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>上面虽然介绍了分组支持的一些表达式，但是没有查询条件，难道只能针对所有的文档进行分组统计么？</p>
<p><strong>分组过滤</strong></p>
<p>借助<code>$match</code>来实现过滤统计，如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/200331/07.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>请注意，$match的语法规则和find的查询条件一样，会将满足条件的数据传递给后面的分组计算</p>
<p>这种方式和liux中的管道特别相似，aggregate方法的参数数组中，前面的执行完毕之后，将结果传递给后面的继续执行，除了<code>$match</code>和<code>$group</code>之外，还有一些其他的操作</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>$project</td>
<td>修改输入文档的结构。可以用来重命名、增加或删除域，也可以用于创建计算结果以及嵌套文档。</td>
</tr>
<tr>
<td>$match</td>
<td>用于过滤数据，只输出符合条件的文档。$match使用MongoDB的标准查询操作。</td>
</tr>
<tr>
<td>$limit</td>
<td>用来限制MongoDB聚合管道返回的文档数。</td>
</tr>
<tr>
<td>$skip</td>
<td>在聚合管道中跳过指定数量的文档，并返回余下的文档。</td>
</tr>
<tr>
<td>$unwind</td>
<td>将文档中的某一个数组类型字段拆分成多条，每条包含数组中的一个值。</td>
</tr>
<tr>
<td>$group</td>
<td>将集合中的文档分组，可用于统计结果。</td>
</tr>
<tr>
<td>$sort</td>
<td>将输入文档排序后输出。</td>
</tr>
<tr>
<td>$geoNear</td>
<td>输出接近某一地理位置的有序文档。</td>
</tr>
</tbody>
</table>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/200331/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>十一：文档 Document 查询非典型篇</title>
      <link>https://liuyueyi.github.io/tutorial/db/mongodb/basic/13.MongoDb%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E5%8D%81%E4%B8%80-%E6%96%87%E6%A1%A3-Document-%E6%9F%A5%E8%AF%A2%E9%9D%9E%E5%85%B8%E5%9E%8B%E7%AF%87.html</link>
      <guid>https://liuyueyi.github.io/tutorial/db/mongodb/basic/13.MongoDb%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E5%8D%81%E4%B8%80-%E6%96%87%E6%A1%A3-Document-%E6%9F%A5%E8%AF%A2%E9%9D%9E%E5%85%B8%E5%9E%8B%E7%AF%87.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">十一：文档 Document 查询非典型篇</source>
      <description>前面介绍的查询可以说是常见的典型case，但是mongodb中有两个比价特殊的数据类型，数组 + 对象，自然的也会有一些非典型的查询case，下面主要针对这两种数据类型的查询姿势，给出实例讲解</description>
      <category>DB</category>
      <category>Mongo</category>
      <pubDate>Wed, 08 Apr 2020 21:12:29 GMT</pubDate>
      <content:encoded><![CDATA[<p>前面介绍的查询可以说是常见的典型case，但是mongodb中有两个比价特殊的数据类型，数组 + 对象，自然的也会有一些非典型的查询case，下面主要针对这两种数据类型的查询姿势，给出实例讲解</p>
<!-- more -->
<h3> 1. 数组</h3>
<p>首先准备一些供数组操作的文档如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>长度查询</strong></p>
<p>根据数组长度进行查询，借助<code>$size</code>来统计数组长度</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>长度范围查询</strong></p>
<p>请注意，不支持长度的比较查询，如下，会报语法错误</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="/imgs/200408/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>要实现范围查询，可以借助<code>$where</code>来实现(<code>$where</code>比较强大，后面单独说明)</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/200408/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p><strong>数组内容查询</strong></p>
<p>根据数组内容进行查询，常见的有两种方式，一个是直接根据数组定位比较如</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这种实用性可能并不大，另外一个常见的case就是查询数组中包含某个元素的文档，这时可以借助<code>$elemMatch</code>来实现</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/200408/02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>说明，当数组的元素是Object类型时，还可以用右边这种姿势：<code>db.doc_demo.find({'skill': {$elemMatch: {'subField': 'xxx'}}})</code></p>
<h3> 2. Object</h3>
<p>因为mongodb支持内嵌文档，所以根据内嵌文档进行查询的场景也是不少的</p>
<p>首先准备三个用于后续查询测试的文档</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>根据内嵌文档字段查询</strong></p>
<p>查询姿势和field查询相似，只是需要注意一下key的语法为: <code>field.subField</code>, 实例如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="/imgs/200408/03.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p><strong>存在性查询</strong></p>
<p>查询嵌入文档包含某个field的case，和普通的查询姿势也一样</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>排序</strong></p>
<p>根据Object的成员进行排序，操作姿势也基本一样</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="/imgs/200408/04.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/200408/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>十二：文档更新删除之非典型篇</title>
      <link>https://liuyueyi.github.io/tutorial/db/mongodb/basic/14.MongoDB%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E5%8D%81%E4%BA%8C-%E6%96%87%E6%A1%A3%E6%9B%B4%E6%96%B0%E5%88%A0%E9%99%A4%E4%B9%8B%E9%9D%9E%E5%85%B8%E5%9E%8B%E7%AF%87.html</link>
      <guid>https://liuyueyi.github.io/tutorial/db/mongodb/basic/14.MongoDB%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E5%8D%81%E4%BA%8C-%E6%96%87%E6%A1%A3%E6%9B%B4%E6%96%B0%E5%88%A0%E9%99%A4%E4%B9%8B%E9%9D%9E%E5%85%B8%E5%9E%8B%E7%AF%87.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">十二：文档更新删除之非典型篇</source>
      <description>前面介绍document的新增、删除、更新都处于相对常见和基础的说明，但是考虑到mongodb非结构化的特点，它的一些特性是我们的mysql不会遇到的，本文将针对这些特殊场景给出示例说明 在现有文档中，增加一个field 删除文档中的某个field 重命名文档的field 在文档的数组orObject中，添加/删除/更新数据</description>
      <category>DB</category>
      <category>Mongo</category>
      <pubDate>Fri, 10 Apr 2020 09:13:52 GMT</pubDate>
      <content:encoded><![CDATA[<p>前面介绍document的新增、删除、更新都处于相对常见和基础的说明，但是考虑到mongodb非结构化的特点，它的一些特性是我们的mysql不会遇到的，本文将针对这些特殊场景给出示例说明</p>
<ul>
<li>在现有文档中，增加一个field</li>
<li>删除文档中的某个field</li>
<li>重命名文档的field</li>
<li>在文档的数组orObject中，添加/删除/更新数据</li>
</ul>
<!-- more -->
<h3> 1. 增加field</h3>
<p>我们知道修改文档的命令格式如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当我们更新一个文档中，不存在的field，会怎样</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/200410/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 2. 重命名field</h3>
<p>同样是借助update方法，但是我们用到的关键字为 <code>$rename</code></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="/imgs/200410/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p><strong>请注意，当文档中不存在这个field，则不会有任何影响</strong></p>
<h3> 3. 删除field</h3>
<p>既然<code>$set</code>可以新增一个不存在的field，那么是不是就可以用<code>$unset</code>来删除一个已存在的field呢</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="/imgs/200410/02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 4. 数组元素修改</h3>
<blockquote>
<p>数组元素的修改删除增加，可以参考官方教程: <a href="https://www.mongodb.org.cn/manual/update-array/" target="_blank" rel="noopener noreferrer">MongoDB update-array Method</a></p>
</blockquote>
<p>如果我们希望直接修改数组中的某个元素，可以借助之前查询的case</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/200410/03.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p><strong>请注意，使用<code>$</code>占位符的前途是，前面的查询条件可以限定数组元素</strong></p>
<h3> 5. 数组元素新增</h3>
<p>元素添加支持两种方式，一是<code>addToSet</code>，一是<code>push</code></p>
<p><strong><code>$addToSet</code></strong></p>
<ul>
<li>确保没有重复的项添加到数组集合，对于已经存在的重复元素不受影响；</li>
<li>不能保证添加时元素的顺序</li>
<li>如果值是数组，则作为一个元素添加进去</li>
<li>可以通过 <code>$each</code> 实现添加多个元素到数组中</li>
</ul>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/200410/04.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p><strong><code>$push</code></strong></p>
<ul>
<li>如果被更新的文档该数组不存在，那么$push将添加数组字段和值</li>
<li>如果字段不是数组，失败</li>
<li>如果值是数组，那么整个数组作为一个单个元素添加到数组</li>
</ul>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/200410/05.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 6. 数组元素删除</h3>
<p><strong><code>$pop</code></strong> 删除第一个or最后一个</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/200410/06.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p><strong><code>$pull</code></strong> 删除满足条件的数组元素</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/200410/07.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>注意，<code>$pull</code>后面跟上的可以理解为限定条件，查询教程篇的一些操作也是支持的（如比较查询等）</p>
<h3> 7. 内嵌文档操作</h3>
<p>对于内嵌文档的操作，实际上普通的field的操作姿势没有什么区别，只是对于key加了一个<code>xx.xx</code>的限定而已</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/200410/08.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/200410/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>十三：索引</title>
      <link>https://liuyueyi.github.io/tutorial/db/mongodb/basic/15.MongoDb%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E5%8D%81%E4%B8%89-%E7%B4%A2%E5%BC%95.html</link>
      <guid>https://liuyueyi.github.io/tutorial/db/mongodb/basic/15.MongoDb%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E5%8D%81%E4%B8%89-%E7%B4%A2%E5%BC%95.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">十三：索引</source>
      <description>索引一般用来提高查询效率，避免全集合搜索，那么在mongodb中，支持索引么？如果支持，如何定义索引，如何使用索引，如何确定一个sql是否走索引？</description>
      <category>DB</category>
      <category>Mongo</category>
      <pubDate>Sat, 18 Apr 2020 08:55:17 GMT</pubDate>
      <content:encoded><![CDATA[<p>索引一般用来提高查询效率，避免全集合搜索，那么在mongodb中，支持索引么？如果支持，如何定义索引，如何使用索引，如何确定一个sql是否走索引？</p>
<!-- more -->
<h3> 1. 创建索引</h3>
<p><strong>语法定义:</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>请注意，在3.0之前的版本中，也可以使用<code>ensureIndex</code>来创建索引</p>
<p><strong>参数说明:</strong></p>
<ul>
<li>keys：kv结构，key为fieldName, value为1 表示升序创建索引；-1 表示降序创建索引；支持多字段索引</li>
<li>options：可选参数</li>
</ul>
<p>常见参数说明如下表:</p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>background</code></td>
<td>true，则后台方式创建索引，不阻塞其他操作；默认为false</td>
</tr>
<tr>
<td><code>unique</code></td>
<td>true，则表示唯一约束索引，比如<code>_id</code>就有唯一约束；默认为false</td>
</tr>
<tr>
<td><code>name</code></td>
<td>索引名，不指定时，根据field + 方向生成索引名</td>
</tr>
<tr>
<td><code>sparse</code></td>
<td>true, 则不包含这个字段的不创建索引，且索引查询时查不到不包含这个字段的文档；默认false</td>
</tr>
<tr>
<td><code>expireAfterSeconds</code></td>
<td>设置文档在集合的生存时间，s为单位</td>
</tr>
<tr>
<td><code>v</code></td>
<td>版本号</td>
</tr>
<tr>
<td><code>weight</code></td>
<td>索引权重值，数值在 1 到 99,999 之间，表示该索引相对于其他索引字段的得分权重</td>
</tr>
<tr>
<td><code>default_language</code></td>
<td>对于文本索引，该参数决定了停用词及词干和词器的规则的列表。 默认为英语</td>
</tr>
<tr>
<td><code>language_override</code></td>
<td>对于文本索引，该参数指定了包含在文档中的字段名，语言覆盖默认的language，默认值为 language</td>
</tr>
</tbody>
</table>
<p>实例如下：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 2. 索引查询</h3>
<p>查看一个集合定义了哪些索引，借助<code>getIndexes()</code>方法即可，如</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="/imgs/200418/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 3. 索引分析</h3>
<p>虽然我们创建了索引，但是我们的查询语句却并不一定会走索引，在mysql中我们知道有一个<code>explain</code>语句来分析索引情况，在mongodb中也存在类似的方法</p>
<p>集合数据如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当前集合上除了默认的<code>_id</code>索引之外，针对<code>name</code>也创建了升序索引</p>
<p>如需要判断一个查询语句的情况，可以在后面加上<code>explain()</code>方法，如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>输出如下</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>关于是否走索引，主要看stage，通常会有以下几种状态</p>
<table>
<thead>
<tr>
<th>stage</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>COLLSCAN</td>
<td>全表扫描</td>
</tr>
<tr>
<td>IXSCAN</td>
<td>扫描索引</td>
</tr>
<tr>
<td>FETCH</td>
<td>根据索引去检索指定document</td>
</tr>
<tr>
<td>SHARD_MERGE</td>
<td>将各个分片返回数据进行merge</td>
</tr>
<tr>
<td>SORT</td>
<td>表明在内存中进行了排序</td>
</tr>
<tr>
<td>LIMIT</td>
<td>使用limit限制返回数</td>
</tr>
<tr>
<td>SKIP</td>
<td>使用skip进行跳过</td>
</tr>
<tr>
<td>IDHACK</td>
<td>针对_id进行查询</td>
</tr>
<tr>
<td>SHARDING_FILTER</td>
<td>通过mongos对分片数据进行查询</td>
</tr>
<tr>
<td>COUNT</td>
<td>利用db.coll.explain().count()之类进行count运算</td>
</tr>
<tr>
<td>COUNTSCAN</td>
<td>count不使用Index进行count时的stage返回</td>
</tr>
<tr>
<td>COUNT_SCAN</td>
<td>count使用了Index进行count时的stage返回</td>
</tr>
<tr>
<td>SUBPLA</td>
<td>未使用到索引的$or查询的stage返回</td>
</tr>
<tr>
<td>TEXT</td>
<td>使用全文索引进行查询时候的stage返回</td>
</tr>
<tr>
<td>PROJECTION</td>
<td>限定返回字段时候stage的返回</td>
</tr>
</tbody>
</table>
<p>上面的具体查询，对应的stage组合是<code>Fetch+ixscan</code>，也就是说会根据索引查询</p>
<p>虽然mongodb会根据查询来选择索引，但并不能保证都能选到最优的索引；这种时候我们可以通过<code>hint</code>来强制指定索引，举例如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 4. 删除索引</h3>
<p>一般有下面两种删除方式，全量删除和指定索引删除</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>请注意，指定索引名删除时，如果不确定索引名是啥，可以通过<code>getIndexes()</code>来查看</p>
<h3> 5. 文档自动删除</h3>
<p>在创建索引的时候，其中有一个参数比较有意思，有必要单独拿出来说明一下，<code>expireAfterSeconds</code> 设置文档的生存时间</p>
<p>使用它有几个潜规则：</p>
<ul>
<li>索引字段为Date类型</li>
<li>单字段索引，不支持混合索引</li>
<li>非立即执行</li>
</ul>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后过一段时间（并不一定10:55分的时候会删除）再去查询，会发现插入的文档被删除了</p>
<p>利用这种特性，在mongodb中存一些需要定时删除的数据，相比较我们常用的mysql而言，还是有很大优势的</p>
<h3> 6. 覆盖索引</h3>
<p>覆盖索引的概念有些类似mysql中的不回表查询的case，直接查询索引，就可以返回所需要的字段了</p>
<p>比如在前面的case中，我只查询name字段，可以走覆盖索引；但是返回除了name，还有<code>_id</code>，那么就不能了</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>注意：所有索引字段是一个数组时，不能使用覆盖索引</strong></p>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/200418/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>MongoDB基础教程</title>
      <link>https://liuyueyi.github.io/tutorial/db/mongodb/basic/</link>
      <guid>https://liuyueyi.github.io/tutorial/db/mongodb/basic/</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">MongoDB基础教程</source>
      <description>文档数据库MongoDB的基本使用姿势教程，手把手教你学会MongoDB的CURD</description>
      <pubDate>Fri, 24 Feb 2023 08:19:09 GMT</pubDate>
      <content:encoded><![CDATA[<p>文档数据库MongoDB的基本使用姿势教程，手把手教你学会MongoDB的CURD</p>
]]></content:encoded>
    </item>
    <item>
      <title>SpringBoot整合MongoDB</title>
      <link>https://liuyueyi.github.io/tutorial/db/mongodb/spring/</link>
      <guid>https://liuyueyi.github.io/tutorial/db/mongodb/spring/</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">SpringBoot整合MongoDB</source>
      <description>SpringBoot 整合 MongoDB SpringBoot + MongoDB SpringBoot生态下，掌握MongoDB的CURD</description>
      <pubDate>Fri, 24 Feb 2023 08:19:09 GMT</pubDate>
      <content:encoded><![CDATA[<p><a href="/tutorial/spring/db/MongoDB/" target="blank">SpringBoot 整合 MongoDB</a></p>
<div class="hint-container info">
<p class="hint-container-title">SpringBoot + MongoDB</p>
<p>SpringBoot生态下，掌握MongoDB的CURD</p>
</div>
]]></content:encoded>
    </item>
    <item>
      <title>数据库</title>
      <link>https://liuyueyi.github.io/tutorial/db/</link>
      <guid>https://liuyueyi.github.io/tutorial/db/</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">数据库</source>
      <description>数据库 ❤️ MySql 📝 MongoDB ⌛ InfluxDB 🪧 ClickHouse 🫶 Redis 🔍 ES</description>
      <pubDate>Fri, 24 Feb 2023 02:18:35 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 数据库</h1>
<h2> ❤️ MySql</h2>
<h2> 📝 MongoDB</h2>
<h2> ⌛ InfluxDB</h2>
<h2> 🪧 ClickHouse</h2>
<h2> 🫶 Redis</h2>
<h2> 🔍 ES</h2>
]]></content:encoded>
    </item>
    <item>
      <title>ClickHouse系列教程</title>
      <link>https://liuyueyi.github.io/tutorial/db/clickhouse/</link>
      <guid>https://liuyueyi.github.io/tutorial/db/clickhouse/</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">ClickHouse系列教程</source>
      <description>列式数据库ClickHouse</description>
      <pubDate>Fri, 24 Feb 2023 02:18:35 GMT</pubDate>
      <content:encoded><![CDATA[<p>列式数据库ClickHouse</p>
]]></content:encoded>
    </item>
    <item>
      <title>ES系列教程</title>
      <link>https://liuyueyi.github.io/tutorial/db/es/</link>
      <guid>https://liuyueyi.github.io/tutorial/db/es/</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">ES系列教程</source>
      <description>近实时搜索引擎ElasticSearch</description>
      <pubDate>Fri, 24 Feb 2023 02:18:35 GMT</pubDate>
      <content:encoded><![CDATA[<p>近实时搜索引擎ElasticSearch</p>
]]></content:encoded>
    </item>
    <item>
      <title>InfluxDB系列教程</title>
      <link>https://liuyueyi.github.io/tutorial/db/influxdb/</link>
      <guid>https://liuyueyi.github.io/tutorial/db/influxdb/</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">InfluxDB系列教程</source>
      <description>时序数据库Influxdb</description>
      <pubDate>Fri, 24 Feb 2023 02:18:35 GMT</pubDate>
      <content:encoded><![CDATA[<p>时序数据库Influxdb</p>
]]></content:encoded>
    </item>
    <item>
      <title>MongoDB系列教程</title>
      <link>https://liuyueyi.github.io/tutorial/db/mongodb/</link>
      <guid>https://liuyueyi.github.io/tutorial/db/mongodb/</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">MongoDB系列教程</source>
      <description>专栏说明 文档数据库MongoDB的基本使用姿势教程，手把手教你学会MongoDB的CURD MongoDB 0基础入门 mongodb 基础知识 原生的mongodb知识点，如基础概念，CURD等</description>
      <pubDate>Fri, 24 Feb 2023 02:18:35 GMT</pubDate>
      <content:encoded><![CDATA[<div class="hint-container tip">
<p class="hint-container-title">专栏说明</p>
<p>文档数据库MongoDB的基本使用姿势教程，手把手教你学会MongoDB的CURD</p>
</div>
<ul>
<li><a href="./basic">MongoDB 0基础入门</a></li>
</ul>
<div class="hint-container info">
<p class="hint-container-title">mongodb 基础知识</p>
<p>原生的mongodb知识点，如基础概念，CURD等</p>
</div>
<ul>
<li><a href="/tutorial/spring/db/MongoDB/" target="blank">SpringBoot 整合 MongoDB</a></li>
</ul>
<div class="hint-container info">
<p class="hint-container-title">SpringBoot + MongoDB</p>
<p>SpringBoot生态下，掌握MongoDB的CURD</p>
</div>
]]></content:encoded>
    </item>
    <item>
      <title>mongodb零基础入门</title>
      <link>https://liuyueyi.github.io/tutorial/db/mongodb/merge.html</link>
      <guid>https://liuyueyi.github.io/tutorial/db/mongodb/merge.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">mongodb零基础入门</source>
      <description>MongoDB零基础入门 MongoDB 是一个基于分布式文件存储的数据库，本片文档主要面向0基础的小伙伴，如何迅速的学会MongoDB的基本知识点以及掌握基础的CURD，实现业务支撑 第一卷：MongoDB原生知识点 环境安装与初始化 MongoDB 是一个基于分布式文件存储的数据库。由 C++ 语言编写。旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。 MongoDB 是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。 本篇为mongodb系列教程第一篇，环境安装与连接设置</description>
      <pubDate>Fri, 24 Feb 2023 02:18:35 GMT</pubDate>
      <content:encoded><![CDATA[<figure><img src="http://cdn.hhui.top/column/mongo_cover.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> MongoDB零基础入门</h2>
<p>MongoDB 是一个基于分布式文件存储的数据库，本片文档主要面向0基础的小伙伴，如何迅速的学会MongoDB的基本知识点以及掌握基础的CURD，实现业务支撑</p>
<h1> 第一卷：MongoDB原生知识点</h1>
<h2> 环境安装与初始化</h2>
<blockquote>
<p>MongoDB 是一个基于分布式文件存储的数据库。由 C++ 语言编写。旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。</p>
</blockquote>
<p>MongoDB 是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。</p>
<p>本篇为mongodb系列教程第一篇，环境安装与连接设置</p>
<!-- more -->
<h3> 1. docker安装</h3>
<p>首先介绍最简单的安装方式，docker安装，请先保证docker环境存在（没有安装的推荐查看: <a href="https://blog.hhui.top/2019/12/06/191206-Centos%E5%AE%89%E8%A3%85docker%E4%B8%8E%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/" target="_blank" rel="noopener noreferrer">Centos安装docker与使用说明</a>）</p>
<p>安装命令如下:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. centos安装</h3>
<p>直接借助yum进行安装，命令如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. 用户配置</h3>
<p>直接通过mongodb提供的终端命令进行设置，</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4. 终端控制台</h3>
<p>mongodb集成了终端控制台，通过<code>mongo</code>进入；</p>
<p>但是当我们设置了登录认证时，有下面两种使用姿势</p>
<p><strong>case1</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://hhui.top/imgs/200319/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p><strong>case2</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://hhui.top/imgs/200319/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 5. 可视化操作工具</h3>
<p>终端虽好，使用起来终究不太顺手，可视化工具推荐使用<code>ROBO 3T</code>操作mongodb，官网下载地址: <a href="https://robomongo.org/" target="_blank" rel="noopener noreferrer">https://robomongo.org/</a></p>
<p>然后配置mongodb连接信息（支持ssh验证方式哦），下面是一个简单的配置</p>
<figure><img src="https://hhui.top/imgs/200319/02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>然后就可以通过它来操作mongodb了</p>
<figure><img src="https://hhui.top/imgs/200319/03.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> 基本概念</h2>
<p>mongodb和我们通常使用的关系型数据库如mysql，在一些基本概念上有相同之处，但也有一些区别，在进行mongodb的语言介绍之前，有必要先了解一些基础概念</p>
<p>本文将对比sql对一些基础概念进行解释说明</p>
<!-- more -->
<blockquote>
<p><a href="https://www.runoob.com/mongodb/mongodb-databases-documents-collections.html" target="_blank" rel="noopener noreferrer">MongoDB 概念解析</a></p>
</blockquote>
<p>在sql中，会区分database, table, row, column, index, primaryId；在mongodb中也有对应的概念</p>
<table>
<thead>
<tr>
<th>sql</th>
<th>mongodb</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>database</td>
<td>db</td>
<td>数据库</td>
</tr>
<tr>
<td>table</td>
<td>collection</td>
<td>表/集合</td>
</tr>
<tr>
<td>row</td>
<td>document</td>
<td>行/文档</td>
</tr>
<tr>
<td>column</td>
<td>field</td>
<td>字段</td>
</tr>
<tr>
<td>index</td>
<td>index</td>
<td>索引</td>
</tr>
<tr>
<td>primaryId</td>
<td>_id</td>
<td>主键</td>
</tr>
<tr>
<td>lock</td>
<td>lock</td>
<td>锁</td>
</tr>
</tbody>
</table>
<p>下面对以上基本概念进行简单说明，详情的后续博文会补上</p>
<h3> 1. 数据库</h3>
<p>数据库可以理解为collection的聚集体，每个mongodb实例可以有多个database，每个database可以有多个collection</p>
<p>常见的几个命令如下：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 集合</h3>
<p>document的集合，与table最大的区别是它的结构不是固定的，不需要事先定义字段、类型</p>
<p>首次新增document时，集合被创建；</p>
<h3> 3. document</h3>
<p>文档，也就是具体的数据；bson结构，kv方式</p>
<p>最大的特点是不要求所有的document的结构一致，相同的field的数据类型可以不一致</p>
<h3> 4. index</h3>
<p>索引，同样是用来提高查询效率，避免全盘扫描</p>
<h3> 5. lock</h3>
<p>支持读写锁，document加读锁时，其他读操作ok，写操作禁止；加写锁时，其他读写操作禁止</p>
<h3> 6. 事务</h3>
<blockquote>
<p><a href="https://yq.aliyun.com/articles/610159" target="_blank" rel="noopener noreferrer">MongoDB 4.0 事务实现解析</a></p>
</blockquote>
<p>版本<code>&gt;= 4.0</code>，支持事务，支持多文档ACID，后续详细说明</p>
<hr>
<p>微信搜 <strong>楼仔</strong> 或扫描下方二维码关注楼仔的原创公众号，回复 <strong>110</strong> 即可免费领取 10 本面试必刷八股文。
<img src="https://files.mdnice.com/user/13837/4b47ac79-8256-47cf-ac1a-036729635246.png" alt="" loading="lazy"></p>
<hr>
<h2> 连接</h2>
<p>后续的所有文章的基础，都是需要先连上mongodb，然后才能执行各种命令操作；</p>
<p>本文将介绍一下如何连接一个已经启动的mongodb服务器</p>
<!-- more -->
<h3> 1. 连接语法</h3>
<p>标准URI连接语法：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul>
<li><code>mongodb://</code> 固定前缀</li>
<li><code>username:password@</code>: 如果开启了用户登录验证，需要指定用户名密码</li>
<li><code>host1:port1</code>: mongodb服务器的ip/域名 + 端口(不填时，默认为27017)</li>
<li><code>database</code>: 如果指定<code>username:password@</code>，连接并验证登陆指定数据库。若不指定，默认打开 test 数据库</li>
<li><code>?options</code>: 是连接选项。如果不使用/database，则前面需要加上</li>
</ul>
<h3> 2. 实例</h3>
<p>直接连接方式如下，注意这种方式会保留用户名和密码，会有一定的安全风险</p>
<p><strong>连接目标服务器</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>连接多台服务器</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>连接 replica set 三台服务器, 写入操作应用在主服务器 并且分布查询到从服务器</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2> 基本工具介绍</h2>
<p>mongodb服务器安装完毕之后，提供了一些配套的操作工具，接下来我们有必要认识一下它们，并了解基本用法</p>
<!-- more -->
<h3> 0. mongod</h3>
<p>启动mongodb实例的主要命令，常见的使用姿势如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 1. mongo 命令行使用</h3>
<p>mongodb安装完毕之后，会自带一个终端命令行工具，通过它可以连接mongodb，并执行相关命令</p>
<h4> a. 连接</h4>
<p>介绍三种连接mongodb的姿势</p>
<p><strong>case1</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>case2</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>case3</strong></p>
<p>上面两种姿势虽然简单，但是用户名密码有暴露的风险，推荐使用下面这种方式</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> b. 操作</h4>
<p>连接上mongodb服务器之后，就可以执行mongo命令，查看数据库，管理文档，比如下面给几个常见的操作</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://hhui.top/imgs/200325/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 2. mongoimport/mongoexport</h3>
<p>用于导入导出数据，如</p>
<p>将库<code>database</code>中的集合<code>collection</code>导出到json文件<code>out.json</code></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>从json文件导入到目标集合<code>new_collection</code></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 3. mongodump/mongorestore</h3>
<p>使用mongodump命令来备份MongoDB数据, 将数据库<code>basic</code>的所有集合备份到目录 <code>/tmp/outDir</code>下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>使用mongorestore恢复，如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4. mongostate</h3>
<p>mongostat是mongodb自带的状态检测工具，在命令行下使用。它会间隔固定时间获取mongodb的当前运行状态，并输出。如果你发现数据库突然变慢或者有其他问题的话，你第一手的操作就考虑采用mongostat来查看mongo的状态。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="https://hhui.top/imgs/200325/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 5. mongotop</h3>
<p>mongotop提供每个集合的水平的统计数据，默认每s输出一次</p>
<figure><img src="https://hhui.top/imgs/200325/02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> 数据库 Database</h2>
<p>我们通常把mongodb叫文档型数据库，mysql叫关系型数据库，influxdb叫时序数据库，如果熟悉这三个的话，会发现他们都有一个<code>database</code>，它是<code>collection/table/measurement</code>的上一级，可以简单的把它理解为更高层级的集合，方便统一管理/权限划分/业务拆分</p>
<p>下面简单介绍一下database的基础操作</p>
<!-- more -->
<h3> 1. 创建数据库</h3>
<p>当数据库不存在时，通过<code>use + 数据库</code>命令可以用来创建数据库；当数据库存在时，表示选中</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 2. 查看数据库</h3>
<p>通过 <code>db</code>查看当前的数据库</p>
<p>通过 <code>show dbs</code> 查看当前的数据库列表</p>
<p>请注意，新创建一个数据库时，直接使用<code>show dbs</code>命令，并不会显示出来，如下</p>
<figure><img src="https://hhui.top/imgs/200326/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>为了显示这个数据库，需要插入一个文档</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="https://hhui.top/imgs/200326/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 3. 删除数据库</h3>
<p>对于数据库而言，任何删除命令都需要慎重处理，一不小心就得跑路了。。。</p>
<p>命令如下: <code>db.dropDatabase()</code></p>
<p>实例说明：</p>
<p>一般来说我们需要删除时，两步走</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://hhui.top/imgs/200326/02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 4. 潜规则</h3>
<p>需要注意，有三个数据库属于预留的，有特殊的作用，不能新建同名的数据</p>
<ul>
<li>admin: 将一个用户添加到这个数据库，这个用户自动继承所有数据库的权限; 一些特定的服务器端命令也只能从这个数据库运行，比如列出所有的数据库或者关闭服务器。</li>
<li>local: 这个数据永远不会被复制，可以用来存储限于本地单台服务器的任意集合</li>
<li>config: 当Mongo用于分片设置时，config数据库在内部使用，用于保存分片的相关信息。</li>
</ul>
<p>命名规则：</p>
<ul>
<li>不能是空字符串</li>
<li>不能含有特殊字符（如<code> </code>，<code>.</code>，<code>$</code>, <code>\</code>, <code>/</code>, <code>\0</code></li>
<li>小写</li>
<li>最多64字节</li>
</ul>
<h2> 集合 Collection</h2>
<p>集合，相当于关系型数据库中的table，在mongodb中，集合的概念非常贴切，属于文档(Document)的集合</p>
<p>其最大的特点是：</p>
<ul>
<li>没有固定的结构</li>
</ul>
<!-- more -->
<h3> 1. 创建集合</h3>
<p>创建命令如: <code>db.createCollection(name, options)</code></p>
<p>重点看一下参数<code>options</code>的可选项</p>
<ul>
<li>capped: true，表示创建固定大小的集合，需要指定size；超过数量之后，覆盖最早的文档</li>
<li>size: 固定集合时配套使用，KB为单位</li>
<li>autoIndexId: 自动为<code>_id</code>添加索引，默认true</li>
<li>max: 固定集合时，文档的最大数量</li>
</ul>
<p>一个简单的实例</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>除此之外，新插入一个文档时，集合若不存在，也会创建对应的集合，如</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 查看集合</h3>
<p>通过 <code>show collections</code> 查看数据库下的集合列表</p>
<figure><img src="https://hhui.top/imgs/200326/03.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 3. 删除集合</h3>
<p>通过命令 <code>db.col.drop()</code>来删除</p>
<figure><img src="https://hhui.top/imgs/200326/04.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 4. 命名规则</h3>
<ul>
<li>不能全是空白字符</li>
<li>不应包含特殊字符</li>
<li>不要以<code>system.</code>开头</li>
</ul>
<hr>
<p>微信搜 <strong>楼仔</strong> 或扫描下方二维码关注楼仔的原创公众号，回复 <strong>110</strong> 即可免费领取 10 本面试必刷八股文。 <img src="https://files.mdnice.com/user/13837/4b47ac79-8256-47cf-ac1a-036729635246.png" alt="" loading="lazy"></p>
<hr>
<h2> 文档 Document 插入姿势</h2>
<p>文档相当于关系数据库中数据行，也是我们最关心的数据本身；以BSON格式存储（和json区别不大）</p>
<p>我们通常所说业务开发者的CURD四大技能，在mongodb中，就是针对Document而言，接下来我们先看一下文档的新增使用姿势</p>
<!-- more -->
<h3> 1. 基本语法</h3>
<p>插入语法： <code>db.collection.insert()</code></p>
<p>因为集合不要求定义数据结构，所以插入的文档格式理论上可以完全不一样，可以拥有完全不同的数据结构，相同的字段拥有不同的数据类型</p>
<h3> 2. 实例演示</h3>
<p>下面给出几个实例进行说明</p>
<p><strong>基本数据类型插入</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>数组类型插入</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>Object类型插入</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="https://hhui.top/imgs/200326/05.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 3. 数据类型</h3>
<p>mongodb支持的基本数据类型，除了我们常见的string,int,float,boolean之外，还有一些其他的;</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>String</td>
<td>字符串， UTF8编码</td>
</tr>
<tr>
<td>Integer</td>
<td>整型，32/64位</td>
</tr>
<tr>
<td>Boolean</td>
<td>布尔</td>
</tr>
<tr>
<td>Double</td>
<td>浮点</td>
</tr>
<tr>
<td>Min/Max keys</td>
<td>将一个值与 BSON（二进制的 JSON）元素的最低值和最高值相对比</td>
</tr>
<tr>
<td>Array</td>
<td>数组</td>
</tr>
<tr>
<td>Timestamp</td>
<td>时间戳，记录文档修改或添加的具体时间</td>
</tr>
<tr>
<td>Object</td>
<td>内嵌文档</td>
</tr>
<tr>
<td>Null</td>
<td>创建空值</td>
</tr>
<tr>
<td>Symbol</td>
<td>符号。该数据类型基本上等同于字符串类型，但不同的是，它一般用于采用特殊符号类型的语言。</td>
</tr>
<tr>
<td>Date</td>
<td>日期，用 UNIX 时间格式来存储当前日期或时间。你可以指定自己的日期时间：创建 Date 对象，传入年月日信息。</td>
</tr>
<tr>
<td>ObjectID</td>
<td>对象ID</td>
</tr>
<tr>
<td>Binary Data</td>
<td>二进制</td>
</tr>
<tr>
<td>code</td>
<td>代码类型。用于在文档中存储 JavaScript 代码。</td>
</tr>
<tr>
<td>Regular expression</td>
<td>正则表达式类型。用于存储正则表达式。</td>
</tr>
</tbody>
</table>
<p><strong>ObjectId 类似唯一主键</strong>，可以很快的去生成和排序，包含 12 bytes，含义是：</p>
<ul>
<li>前 4 个字节表示创建 unix 时间戳,格林尼治时间 UTC 时间，比北京时间晚了 8 个小时</li>
<li>接下来的 3 个字节是机器标识码</li>
<li>紧接的两个字节由进程 id 组成 PID</li>
<li>最后三个字节是随机数</li>
</ul>
<h2> 文档 Document 删除姿势</h2>
<p>前面一篇介绍了插入文档的使用姿势，这一篇则主要介绍删除的使用case</p>
<!-- more -->
<h3> 1. 基本语法</h3>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>第一个为需要删除的匹配条件；第二个表示是否只删除一个，默认是false，删除所有满足条件的文档</p>
<p><strong>注意</strong></p>
<ul>
<li>当query为空时，表示删除所有文档，高危操作，谨慎执行</li>
</ul>
<h3> 2. 实例演示</h3>
<p>借用给我们上一篇插入的文档来进行演示，当前存在的文档为</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>根据id进行删除</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>根据name删除第一个满足条件的记录</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>再次查看剩下的内容如下：</p>
<figure><img src="https://hhui.top/imgs/200326/06.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> 文档 Document 更新姿势</h2>
<p>本篇介绍update/save两种方法提供的更新姿势</p>
<!-- more -->
<h3> 1. update</h3>
<p>用于更新已经存在的文档，语法如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>query: 查询条件</li>
<li>update: 更新语句</li>
<li>upsert: （可选）true, 不存在update的记录时插入；默认是false，不插入</li>
<li>multi: (可选) true，表示更新所有满足条件的记录；默认false，只更新第一条</li>
<li>writeConcern: (可选)，抛出异常的级别</li>
</ul>
<p>插入两条用于测试的数据</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>下面给出几个更新的实例</p>
<p><strong>更新age</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://hhui.top/imgs/200327/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p><strong>更新所有age为20的文档，新增一个tag成员</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="https://hhui.top/imgs/200327/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p><strong>更新一个不存在的文档</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="https://hhui.top/imgs/200327/02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 2. save</h3>
<p>save最大的特点是覆盖，用新的文档完全覆盖旧的文档；而update，则是更新指定的field</p>
<p>语法如下：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>举例如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="https://hhui.top/imgs/200327/03.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>那么问题来了，<strong>怎样判定是新增一条记录，还是覆盖已经存在的记录呢？</strong></p>
<ul>
<li>有唯一键来判定</li>
<li>即：如果save的文档中，某个field有唯一性要求，那么当数据库中存在这个field文档文档时，执行覆盖操作；否则执行插入</li>
</ul>
<p>举例如下, 指定ObjectId</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="https://hhui.top/imgs/200327/04.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<hr>
<p>微信搜 <strong>楼仔</strong> 或扫描下方二维码关注楼仔的原创公众号，回复 <strong>110</strong> 即可免费领取 10 本面试必刷八股文。 <img src="https://files.mdnice.com/user/13837/4b47ac79-8256-47cf-ac1a-036729635246.png" alt="" loading="lazy"></p>
<hr>
<h2> 文档 Document 查询基础篇</h2>
<p>MongoDb文档查询，主要借助find方法来完成，在实际的业务开发中，为了满足各种复杂的业务场景，查询的姿势也是各种各样，本篇则主要介绍基本的使用姿势，不涉及到聚合、排序、分页相关内容</p>
<!-- more -->
<h3> 1. 查询语法</h3>
<p>查询语法定义比较简单，复杂的是查询条件的组合；语法定义如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul>
<li>query: 查询条件，如果不填，则表示查询所有文档</li>
<li>projection: 查询需要返回的field，如果不填则返回所有的数据</li>
</ul>
<p>此外为了mongo-cli的返回结果更加友好，可以在最后添加<code>.pretty()</code>，使输出更友好</p>
<h3> 2. 查询所有</h3>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="https://hhui.top/imgs/200328/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 3. 根据条件精准查询</h3>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="https://hhui.top/imgs/200328/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 4. 数字比较查询</h3>
<p>对于数字类型的field，可以借助符号<code>$gt</code>(&gt;), <code>$get</code>(&gt;=), <code>$lt</code>(&lt;), <code>$lte</code>(&lt;=), <code>$ne</code>(!=) 来表示具体的操作</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://hhui.top/imgs/200328/02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 5. 模糊查询</h3>
<p>在mysql中有一个like用于模糊查询，在mongodb中，同样支持基于正则的模糊查询</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://hhui.top/imgs/200328/03.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 6. and条件</h3>
<p>多个查询条件需要满足时，并不需要什么特殊的操作，只需要在查询bson中，加上多个条件即可</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://hhui.top/imgs/200328/04.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 7. or条件</h3>
<p>和and不需要额外的操作不同，or条件需要借助 <code>$or</code> 来实现，语法如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>实例如下：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://hhui.top/imgs/200328/05.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 8. 限制返回成员</h3>
<p>有些时候我们只需要获取文档中的部分成员，可以在第二个参数中进行指定，规则如下</p>
<ul>
<li><code>成员名: 1</code>： 表示这个成员需要返回</li>
<li><code>成员名: 0</code>： 表示这个成员不返回</li>
</ul>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://hhui.top/imgs/200328/06.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>请注意，一般在使用了 <code>成员名: 1</code> 来指定返回field时，会自动返回<code>_id</code>，如果不需要，请显示加上 <code>_id: 0</code></p>
<h3> 9. field类型查询</h3>
<p>根据field的成员类型来作为查询条件，一般有两种方式，这里只介绍更优雅的，语法如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>举例说明</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="https://hhui.top/imgs/200328/07.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 10. 存在查询</h3>
<p>mongodb的一个特点就是集合的结构不固定，所以某个成员可能存在也可能不存在，所以当我们的查询条件中需要加一个是否存在的判断时，可以如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://hhui.top/imgs/200328/08.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> 文档 Document 查询高级篇</h2>
<p>上一篇的mongodb查询，主要介绍的是一些基本操作，当然有基本就高阶操作；</p>
<p>本文将带来更多的查询姿势</p>
<ul>
<li>排序</li>
<li>分页</li>
<li>聚合</li>
</ul>
<!-- more -->
<h3> 1. 排序</h3>
<p>在mongodb中，使用sort方法进行排序，语法如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>请注意，sort内部是一个对象，key为field，value为1或者-1，其中1表示升序，-1表示降序</p>
<p>实例说明，根据age进行排序</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>输出如下:</p>
<figure><img src="https://hhui.top/imgs/200331/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>上面的演示属于常规的操作，但是针对mongodb的特点，自然会有一些疑问</p>
<p><strong>q1: 如果某个文档没有包含这个field，排序是怎样的？</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="https://hhui.top/imgs/200331/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>从输出来看，升序时，不包含这个field的文档，在最前面；降序时，不包含这个field的文档，在最后面</p>
<p><strong>q2: 支持多个field排序吗？</strong></p>
<p>原则上一般不建议多个field的排序（比较影响性能），但对于数据库而言，你得支持吧</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://hhui.top/imgs/200331/02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>请注意上的输出，在涉及到多个field排序时，优先根据第一个进行排序，当文档的field相同时，再根据后面的进行排序</p>
<h3> 2. 分页</h3>
<p>当文档很多时，我们不可能把所有的文档一次返回，所以就有了常见的分页，在sql中我们一般使用<code>limit</code> <code>offset</code>来实现分页，在mongodb中也差不多</p>
<p><strong>limit()</strong></p>
<p>限制返回的文档数</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="https://hhui.top/imgs/200331/03.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p><strong>skip()</strong></p>
<p>使用limit进行返回条数限制，使用skip进行分页，表示跳过前面的n条数据</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://hhui.top/imgs/200331/04.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 3. 聚合</h3>
<p>使用<code>aggregate()</code>来实现聚合，用于处理求和、平均值，最大值，分组等</p>
<p>数据准备:</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>分组查询</strong></p>
<p>根据name进行分组统计</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://hhui.top/imgs/200331/05.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>请注意，分组的条件中</p>
<ul>
<li><code>_id</code>: 表示根据哪个字段进行分组</li>
<li><code>size: {}</code>: 表示聚合条件指定，将结果输出到名为size的field中</li>
<li><code>filed</code>名前加<code>$</code>进行指定</li>
</ul>
<p>当前mongodb支持的聚合表达式包括:</p>
<table>
<thead>
<tr>
<th>表达式</th>
<th>说明</th>
<th>举例说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>sum</td>
<td>求和</td>
<td><code>db.doc_demo.aggregate([{$group: {_id: "$name", size: {$sum: '$age'}}}])</code></td>
</tr>
<tr>
<td>avg</td>
<td>平均值</td>
<td><code>db.doc_demo.aggregate([{$group: {_id: "$name", size: {$avg: '$age'}}}])</code></td>
</tr>
<tr>
<td>min</td>
<td>取最小</td>
<td><code>db.doc_demo.aggregate([{$group: {_id: "$name", age: {$min: '$age'}}}])</code></td>
</tr>
<tr>
<td>max</td>
<td>取最大</td>
<td><code>db.doc_demo.aggregate([{$group: {_id: "$name", age: {$max: '$age'}}}])</code></td>
</tr>
<tr>
<td>push</td>
<td>结果插入到一个数组中</td>
<td><code>db.doc_demo.aggregate([{$group: {_id: "$name", age: {$push: '$age'}}}])</code></td>
</tr>
<tr>
<td>addToSet</td>
<td>结果插入集合，过滤重复</td>
<td><code>db.doc_demo.aggregate([{$group: {_id: "$name", age: {$addToSet: '$age'}}}])</code></td>
</tr>
<tr>
<td>first</td>
<td>第一个</td>
<td><code>db.doc_demo.aggregate([{$group: {_id: "$name", age: {$first: '$age'}}}])</code></td>
</tr>
<tr>
<td>last</td>
<td>最后一个</td>
<td><code>db.doc_demo.aggregate([{$group: {_id: "$name", age: {$last: '$age'}}}])</code></td>
</tr>
</tbody>
</table>
<figure><img src="https://hhui.top/imgs/200331/06.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>上面虽然介绍了分组支持的一些表达式，但是没有查询条件，难道只能针对所有的文档进行分组统计么？</p>
<p><strong>分组过滤</strong></p>
<p>借助<code>$match</code>来实现过滤统计，如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://hhui.top/imgs/200331/07.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>请注意，$match的语法规则和find的查询条件一样，会将满足条件的数据传递给后面的分组计算</p>
<p>这种方式和liux中的管道特别相似，aggregate方法的参数数组中，前面的执行完毕之后，将结果传递给后面的继续执行，除了<code>$match</code>和<code>$group</code>之外，还有一些其他的操作</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>$project</td>
<td>修改输入文档的结构。可以用来重命名、增加或删除域，也可以用于创建计算结果以及嵌套文档。</td>
</tr>
<tr>
<td>$match</td>
<td>用于过滤数据，只输出符合条件的文档。$match使用MongoDB的标准查询操作。</td>
</tr>
<tr>
<td>$limit</td>
<td>用来限制MongoDB聚合管道返回的文档数。</td>
</tr>
<tr>
<td>$skip</td>
<td>在聚合管道中跳过指定数量的文档，并返回余下的文档。</td>
</tr>
<tr>
<td>$unwind</td>
<td>将文档中的某一个数组类型字段拆分成多条，每条包含数组中的一个值。</td>
</tr>
<tr>
<td>$group</td>
<td>将集合中的文档分组，可用于统计结果。</td>
</tr>
<tr>
<td>$sort</td>
<td>将输入文档排序后输出。</td>
</tr>
<tr>
<td>$geoNear</td>
<td>输出接近某一地理位置的有序文档。</td>
</tr>
</tbody>
</table>
<h2> 文档 Document 查询非典型篇</h2>
<p>前面介绍的查询可以说是常见的典型case，但是mongodb中有两个比价特殊的数据类型，数组 + 对象，自然的也会有一些非典型的查询case，下面主要针对这两种数据类型的查询姿势，给出实例讲解</p>
<!-- more -->
<h3> 1. 数组</h3>
<p>首先准备一些供数组操作的文档如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>长度查询</strong></p>
<p>根据数组长度进行查询，借助<code>$size</code>来统计数组长度</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>长度范围查询</strong></p>
<p>请注意，不支持长度的比较查询，如下，会报语法错误</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="https://hhui.top/imgs/200408/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>要实现范围查询，可以借助<code>$where</code>来实现(<code>$where</code>比较强大，后面单独说明)</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://hhui.top/imgs/200408/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p><strong>数组内容查询</strong></p>
<p>根据数组内容进行查询，常见的有两种方式，一个是直接根据数组定位比较如</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这种实用性可能并不大，另外一个常见的case就是查询数组中包含某个元素的文档，这时可以借助<code>$elemMatch</code>来实现</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://hhui.top/imgs/200408/02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>说明，当数组的元素是Object类型时，还可以用右边这种姿势：<code>db.doc_demo.find({'skill': {$elemMatch: {'subField': 'xxx'}}})</code></p>
<h3> 2. Object</h3>
<p>因为mongodb支持内嵌文档，所以根据内嵌文档进行查询的场景也是不少的</p>
<p>首先准备三个用于后续查询测试的文档</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>根据内嵌文档字段查询</strong></p>
<p>查询姿势和field查询相似，只是需要注意一下key的语法为: <code>field.subField</code>, 实例如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="https://hhui.top/imgs/200408/03.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p><strong>存在性查询</strong></p>
<p>查询嵌入文档包含某个field的case，和普通的查询姿势也一样</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>排序</strong></p>
<p>根据Object的成员进行排序，操作姿势也基本一样</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="https://hhui.top/imgs/200408/04.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> 文档更新删除之非典型篇</h2>
<p>前面介绍document的新增、删除、更新都处于相对常见和基础的说明，但是考虑到mongodb非结构化的特点，它的一些特性是我们的mysql不会遇到的，本文将针对这些特殊场景给出示例说明</p>
<ul>
<li>在现有文档中，增加一个field</li>
<li>删除文档中的某个field</li>
<li>重命名文档的field</li>
<li>在文档的数组orObject中，添加/删除/更新数据</li>
</ul>
<!-- more -->
<h3> 1. 增加field</h3>
<p>我们知道修改文档的命令格式如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当我们更新一个文档中，不存在的field，会怎样</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://hhui.top/imgs/200410/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 2. 重命名field</h3>
<p>同样是借助update方法，但是我们用到的关键字为 <code>$rename</code></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="https://hhui.top/imgs/200410/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p><strong>请注意，当文档中不存在这个field，则不会有任何影响</strong></p>
<h3> 3. 删除field</h3>
<p>既然<code>$set</code>可以新增一个不存在的field，那么是不是就可以用<code>$unset</code>来删除一个已存在的field呢</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="https://hhui.top/imgs/200410/02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 4. 数组元素修改</h3>
<blockquote>
<p>数组元素的修改删除增加，可以参考官方教程: <a href="https://www.mongodb.org.cn/manual/update-array/" target="_blank" rel="noopener noreferrer">MongoDB update-array Method</a></p>
</blockquote>
<p>如果我们希望直接修改数组中的某个元素，可以借助之前查询的case</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://hhui.top/imgs/200410/03.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p><strong>请注意，使用<code>$</code>占位符的前途是，前面的查询条件可以限定数组元素</strong></p>
<h3> 5. 数组元素新增</h3>
<p>元素添加支持两种方式，一是<code>addToSet</code>，一是<code>push</code></p>
<p><strong><code>$addToSet</code></strong></p>
<ul>
<li>确保没有重复的项添加到数组集合，对于已经存在的重复元素不受影响；</li>
<li>不能保证添加时元素的顺序</li>
<li>如果值是数组，则作为一个元素添加进去</li>
<li>可以通过 <code>$each</code> 实现添加多个元素到数组中</li>
</ul>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://hhui.top/imgs/200410/04.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p><strong><code>$push</code></strong></p>
<ul>
<li>如果被更新的文档该数组不存在，那么$push将添加数组字段和值</li>
<li>如果字段不是数组，失败</li>
<li>如果值是数组，那么整个数组作为一个单个元素添加到数组</li>
</ul>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://hhui.top/imgs/200410/05.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 6. 数组元素删除</h3>
<p><strong><code>$pop</code></strong> 删除第一个or最后一个</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://hhui.top/imgs/200410/06.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p><strong><code>$pull</code></strong> 删除满足条件的数组元素</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://hhui.top/imgs/200410/07.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>注意，<code>$pull</code>后面跟上的可以理解为限定条件，查询教程篇的一些操作也是支持的（如比较查询等）</p>
<h3> 7. 内嵌文档操作</h3>
<p>对于内嵌文档的操作，实际上普通的field的操作姿势没有什么区别，只是对于key加了一个<code>xx.xx</code>的限定而已</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://hhui.top/imgs/200410/08.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> 索引</h2>
<p>索引一般用来提高查询效率，避免全集合搜索，那么在mongodb中，支持索引么？如果支持，如何定义索引，如何使用索引，如何确定一个sql是否走索引？</p>
<!-- more -->
<h3> 1. 创建索引</h3>
<p><strong>语法定义:</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>请注意，在3.0之前的版本中，也可以使用<code>ensureIndex</code>来创建索引</p>
<p><strong>参数说明:</strong></p>
<ul>
<li>keys：kv结构，key为fieldName, value为1 表示升序创建索引；-1 表示降序创建索引；支持多字段索引</li>
<li>options：可选参数</li>
</ul>
<p>常见参数说明如下表:</p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>background</code></td>
<td>true，则后台方式创建索引，不阻塞其他操作；默认为false</td>
</tr>
<tr>
<td><code>unique</code></td>
<td>true，则表示唯一约束索引，比如<code>_id</code>就有唯一约束；默认为false</td>
</tr>
<tr>
<td><code>name</code></td>
<td>索引名，不指定时，根据field + 方向生成索引名</td>
</tr>
<tr>
<td><code>sparse</code></td>
<td>true, 则不包含这个字段的不创建索引，且索引查询时查不到不包含这个字段的文档；默认false</td>
</tr>
<tr>
<td><code>expireAfterSeconds</code></td>
<td>设置文档在集合的生存时间，s为单位</td>
</tr>
<tr>
<td><code>v</code></td>
<td>版本号</td>
</tr>
<tr>
<td><code>weight</code></td>
<td>索引权重值，数值在 1 到 99,999 之间，表示该索引相对于其他索引字段的得分权重</td>
</tr>
<tr>
<td><code>default_language</code></td>
<td>对于文本索引，该参数决定了停用词及词干和词器的规则的列表。 默认为英语</td>
</tr>
<tr>
<td><code>language_override</code></td>
<td>对于文本索引，该参数指定了包含在文档中的字段名，语言覆盖默认的language，默认值为 language</td>
</tr>
</tbody>
</table>
<p>实例如下：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 2. 索引查询</h3>
<p>查看一个集合定义了哪些索引，借助<code>getIndexes()</code>方法即可，如</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="https://hhui.top/imgs/200418/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 3. 索引分析</h3>
<p>虽然我们创建了索引，但是我们的查询语句却并不一定会走索引，在mysql中我们知道有一个<code>explain</code>语句来分析索引情况，在mongodb中也存在类似的方法</p>
<p>集合数据如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当前集合上除了默认的<code>_id</code>索引之外，针对<code>name</code>也创建了升序索引</p>
<p>如需要判断一个查询语句的情况，可以在后面加上<code>explain()</code>方法，如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>输出如下</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>关于是否走索引，主要看stage，通常会有以下几种状态</p>
<table>
<thead>
<tr>
<th>stage</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>COLLSCAN</td>
<td>全表扫描</td>
</tr>
<tr>
<td>IXSCAN</td>
<td>扫描索引</td>
</tr>
<tr>
<td>FETCH</td>
<td>根据索引去检索指定document</td>
</tr>
<tr>
<td>SHARD_MERGE</td>
<td>将各个分片返回数据进行merge</td>
</tr>
<tr>
<td>SORT</td>
<td>表明在内存中进行了排序</td>
</tr>
<tr>
<td>LIMIT</td>
<td>使用limit限制返回数</td>
</tr>
<tr>
<td>SKIP</td>
<td>使用skip进行跳过</td>
</tr>
<tr>
<td>IDHACK</td>
<td>针对_id进行查询</td>
</tr>
<tr>
<td>SHARDING_FILTER</td>
<td>通过mongos对分片数据进行查询</td>
</tr>
<tr>
<td>COUNT</td>
<td>利用db.coll.explain().count()之类进行count运算</td>
</tr>
<tr>
<td>COUNTSCAN</td>
<td>count不使用Index进行count时的stage返回</td>
</tr>
<tr>
<td>COUNT_SCAN</td>
<td>count使用了Index进行count时的stage返回</td>
</tr>
<tr>
<td>SUBPLA</td>
<td>未使用到索引的$or查询的stage返回</td>
</tr>
<tr>
<td>TEXT</td>
<td>使用全文索引进行查询时候的stage返回</td>
</tr>
<tr>
<td>PROJECTION</td>
<td>限定返回字段时候stage的返回</td>
</tr>
</tbody>
</table>
<p>上面的具体查询，对应的stage组合是<code>Fetch+ixscan</code>，也就是说会根据索引查询</p>
<p>虽然mongodb会根据查询来选择索引，但并不能保证都能选到最优的索引；这种时候我们可以通过<code>hint</code>来强制指定索引，举例如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 4. 删除索引</h3>
<p>一般有下面两种删除方式，全量删除和指定索引删除</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>请注意，指定索引名删除时，如果不确定索引名是啥，可以通过<code>getIndexes()</code>来查看</p>
<h3> 5. 文档自动删除</h3>
<p>在创建索引的时候，其中有一个参数比较有意思，有必要单独拿出来说明一下，<code>expireAfterSeconds</code> 设置文档的生存时间</p>
<p>使用它有几个潜规则：</p>
<ul>
<li>索引字段为Date类型</li>
<li>单字段索引，不支持混合索引</li>
<li>非立即执行</li>
</ul>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后过一段时间（并不一定10:55分的时候会删除）再去查询，会发现插入的文档被删除了</p>
<p>利用这种特性，在mongodb中存一些需要定时删除的数据，相比较我们常用的mysql而言，还是有很大优势的</p>
<h3> 6. 覆盖索引</h3>
<p>覆盖索引的概念有些类似mysql中的不回表查询的case，直接查询索引，就可以返回所需要的字段了</p>
<p>比如在前面的case中，我只查询name字段，可以走覆盖索引；但是返回除了name，还有<code>_id</code>，那么就不能了</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>注意：所有索引字段是一个数组时，不能使用覆盖索引</strong></p>
<hr>
<p>微信搜 <strong>楼仔</strong> 或扫描下方二维码关注楼仔的原创公众号，回复 <strong>110</strong> 即可免费领取 10 本面试必刷八股文。 <img src="https://files.mdnice.com/user/13837/4b47ac79-8256-47cf-ac1a-036729635246.png" alt="" loading="lazy"></p>
<hr>
<h1> 第二卷：Spring整合MongoDB</h1>
<p>文档数据库SpringBoot的系列教程，彻底扫平阻碍我们CURD的路障，适用于对Mongodb不了解或了解不够的小伙伴</p>
<h2> 基本环境搭建与使用</h2>
<p>SpringBoot结合mongodb进行业务开发，也属于比较基本的需求了，本文为mongo系列的基本篇，主要就是环境搭建、工程的配置设置相关</p>
<!-- more -->
<h3> 1. 环境搭建</h3>
<p>正式开始之前，第一步就是需要安装Mongo的环境了，因为环境的安装和我们spring的主题没有太大的关系，因此我们选择最简单的使用姿势：直接用docker来安装mongo来使用</p>
<p>下面的安装过程都是mac环境，其他操作系统可以直接安装mongodb，移步相关教程</p>
<h4> 1.1 docker 安装</h4>
<p>可以直接到官网进行下载安装，但是对系统版本有要求，所以需要使用<code>Docker ToolBox</code>，实际试过之后，感觉不太好用，实际上是将docker安装到虚拟机中了，下面直接使用<code>brew</code>命令进行安装</p>
<p><strong>安装命令</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>执行完毕之后，会多一个应用名为 <code>docker</code>， 双击运行，输入密码等即可</p>
<h4> 1.2 mongo 安装使用</h4>
<p>直接使用官方的mongo镜像即可，然后绑定端口映射，就可以在宿主机中使用mongo</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面完毕之后，可以在宿主机进行连接测试，判断是否安装成功</p>
<h3> 2. SpringBoot工程配置</h3>
<h4> 2.1 pom依赖</h4>
<p>整个框架选择的是spring-boot，所有spring这一套相关的pom配置少不了，我们主要需要注意的包就是<code>spring-boot-starter-data-mongodb</code></p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 2.2 配置文件</h4>
<p>配置文件如下，主要就是连接mongo的url</p>
<div class="language-properties line-numbers-mode" data-ext="properties"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>通过上面的实例，也知道格式如下:</p>
<p><code>mongodb://用户名:密码@host:port/dbNmae?参数</code></p>
<ul>
<li>当没有用户名和密码时，可以省略掉中间的 <code>root:root@</code>；</li>
<li>当需要认证时，请格外注意
<ul>
<li>mongodb新版的验证方式改成了<code>SCRAM-SHA-1</code>，所以参数中一定一定一定得加上
<ul>
<li><code>?authSource=admin&amp;authMechanism=SCRAM-SHA-1</code></li>
</ul>
</li>
<li>如果将mongodb的验证方式改成了<code>MONGODB-CR</code>, 则上面的可以不需要</li>
</ul>
</li>
</ul>
<h4> 2.3 测试使用</h4>
<p>写一个简单的测试类，看下mongodb是否连接成功，是否可以正常操作</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面提供了两个方法，新增和查询，简单的使用姿势如</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后开始执行，查看输出，结果演示如下</p>
<figure><img src="https://hhui.top/imgs/181213/00.gif" alt="gif.gif" tabindex="0" loading="lazy"><figcaption>gif.gif</figcaption></figure>
<h4> 2.4 说明</h4>
<p>最后针对认证的问题，需要额外提一句，开始测试的时候，使用的配置如下</p>
<div class="language-properties line-numbers-mode" data-ext="properties"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然而因为mongo采用的是SHA-1加密方式，所以始终验证不通过；然后查了一下，各种让改mongo的验证版本，改回去用CR的方式；但明显这种并不是一种好的解决方式，既然新的版本选择了新的加密方式，总有他的理由，所以应该改的还是spring的使用姿势；目前还没找到匹配上面这种配置方式的解决方案；</p>
<p>本文选择的是用url的方式指定加密方式来解决这个问题，当然研究下后面这种方式内部实现，应该就能知道前面的可以怎么解决，这点记下来，后续再开坑填</p>
<h3> 3. 其他</h3>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">spring-boot-demo</a></li>
<li>module: <a href="https://github.com/liuyueyi/spring-boot-demo/blob/master/spring-boot/110-mongo-basic/README.md" target="_blank" rel="noopener noreferrer">110-mongo-basic</a></li>
</ul>
<hr>
<p>微信搜 <strong>楼仔</strong> 或扫描下方二维码关注楼仔的原创公众号，回复 <strong>110</strong> 即可免费领取 10 本面试必刷八股文。 <img src="https://files.mdnice.com/user/13837/4b47ac79-8256-47cf-ac1a-036729635246.png" alt="" loading="lazy"></p>
<hr>
<h2> 查询基本使用姿势</h2>
<p>学习一个新的数据库，一般怎么下手呢？基本的CURD没跑了，当可以熟练的增、删、改、查一个数据库时，可以说对这个数据库算是入门了，如果需要更进一步的话，就需要了解下数据库的特性，比如索引、事物、锁、分布式支持等</p>
<p>本篇博文为mongodb的入门篇，将介绍一下基本的查询操作，在Spring中可以怎么玩</p>
<!-- more -->
<h3> 1. 基本使用</h3>
<h4> 1.0. 环境准备</h4>
<p>在正式开始之前，先准备好环境，搭建好工程，对于这一步的详细信息，可以参考博文: <a href="http://spring.hhui.top/spring-blog/2018/12/13/181213-SpringBoot%E9%AB%98%E7%BA%A7%E7%AF%87MongoDB%E4%B9%8B%E5%9F%BA%E6%9C%AC%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8/" target="_blank" rel="noopener noreferrer">181213-SpringBoot高级篇MongoDB之基本环境搭建与使用</a></p>
<p>接下来，在一个集合中，准备一下数据如下，我们的基本查询范围就是这些数据</p>
<figure><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy9kWVY5Y0FXNjVrYTJnZHpOWjZKaWFpYmljOHhaNGliRHJVS1V1N3oxc1FoaWFKeHBieTRwMk1uSmtpY2ljVDIyOVVpYXNMZWlid3FmaWJTZHlKTnprWVdhUE1iTmtvQkEvNjQwP3d4X2ZtdD1qcGVn?x-oss-process=image/format,png" alt="data" tabindex="0" loading="lazy"><figcaption>data</figcaption></figure>
<h4> 1.1. 根据字段进行查询</h4>
<p>最常见的查询场景，比如我们根据查询<code>user=一灰灰blog</code>的数据，这里主要会使用<code>Query</code> + <code>Criteria</code> 来完成</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面是一个实际的case，从中可以知道一般的查询方式为:</p>
<ul>
<li><code>Criteria.where(xxx).is(xxx)</code>来指定具体的查询条件</li>
<li>封装Query对象 <code>new Query(criteria)</code></li>
<li>借助<code>mongoTemplate</code>执行查询 <code>mongoTemplate.findOne(query, resultType, collectionName)</code></li>
</ul>
<p>其中findOne表示只获取一条满足条件的数据；find则会将所有满足条件的返回；上面执行之后，输出结果如</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h4> 1.2. and多条件查询</h4>
<p>前面是只有一个条件满足，现在如果是要求同时满足多个条件，则利用<code>org.springframework.data.mongodb.core.query.Criteria#and</code>来斜街多个查询条件</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4> 1.3. or或查询</h4>
<p>and对应的就是or，多个条件中只要一个满足即可，这个与and的使用有些区别, 借助<code>org.springframework.data.mongodb.core.query.Criteria#orOperator</code>来实现，传参为多个<code>Criteria</code>对象，其中每一个表示一种查询条件</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>执行后输出结果为</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h4> 1.4. in查询</h4>
<p>标准的in查询case</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4> 1.5. 数值比较</h4>
<p>数值的比较大小，主要使用的是 <code>get</code>, <code>gt</code>, <code>lt</code>, <code>let</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 1.6. 正则查询</h4>
<p>牛逼高大上的功能</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4> 1.7. 查询总数</h4>
<p>统计常用，这个主要利用的是<code>mongoTemplate.count</code>方法</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4> 1.8. 分组查询</h4>
<p>这个对应的是mysql中的group查询，但是在mongodb中，更多的是通过聚合查询，可以完成很多类似的操作，下面借助聚合，来看一下分组计算总数怎么玩</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意下，这里用<code>Aggregation</code>而不是前面的<code>Query</code>和<code>Criteria</code>，输出如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4> 1.9. 排序</h4>
<p>sort，比较常见的了，在mongodb中有个有意思的地方在于某个字段，document中并不一定存在，这是会怎样呢？</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果如下，对于没有这个字段的document也被查出来了</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4> 1.10. 分页</h4>
<p>数据量多的时候，分页查询比较常见，用得多就是limit和skip了</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果表明，limit用来限制查询多少条数据，skip则表示跳过前面多少条数据</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h4> 1.11. 小结</h4>
<p>上面给出的一些常见的查询姿势，当然并不全面，比如我们如果需要查询document中的部分字段怎么办？比如document内部结果比较复杂，有内嵌的对象或者数组时，嵌套查询可以怎么玩？索引什么的又可以怎么利用起来，从而优化查询效率？如何通过传说中自动生成的<code>_id</code>来获取文档创建的时间戳？</p>
<p>先留着这些疑问，后面再补上</p>
<h3> 2. 其他</h3>
<h3> 2.0. 项目</h3>
<ul>
<li>
<p>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">spring-boot-demo</a></p>
</li>
<li>
<p>module: <a href="https://github.com/liuyueyi/spring-boot-demo/blob/master/spring-boot/111-mongo-template" target="_blank" rel="noopener noreferrer">mongo-template</a></p>
</li>
<li>
<p>相关博文: <a href="http://spring.hhui.top/spring-blog/2018/12/13/181213-SpringBoot%E9%AB%98%E7%BA%A7%E7%AF%87MongoDB%E4%B9%8B%E5%9F%BA%E6%9C%AC%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8/" target="_blank" rel="noopener noreferrer">181213-SpringBoot高级篇MongoDB之基本环境搭建与使用</a></p>
</li>
</ul>
<h2> 新增文档使用姿势</h2>
<p>本篇博文为mongodb的curd中一篇，前面介绍简单的查询使用，这一篇重点则放在插入数据;</p>
<!-- more -->
<h3> 1. 基本使用</h3>
<p>首先是准备好基本环境，可以参考博文</p>
<ul>
<li><a href="http://spring.hhui.top/spring-blog/2018/12/13/181213-SpringBoot%E9%AB%98%E7%BA%A7%E7%AF%87MongoDB%E4%B9%8B%E5%9F%BA%E6%9C%AC%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8/" target="_blank" rel="noopener noreferrer">181213-SpringBoot高级篇MongoDB之基本环境搭建与使用</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2019/01/13/190113-SpringBoot%E9%AB%98%E7%BA%A7%E7%AF%87MongoDB%E4%B9%8B%E6%9F%A5%E8%AF%A2%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF/" target="_blank" rel="noopener noreferrer">190113-SpringBoot高级篇MongoDB之查询基本使用姿势</a></li>
</ul>
<h4> 1.1. 新增一条数据</h4>
<p>MongoDB一个基本数据称为document，和mysql不一样，没有强制约束哪些字段，可以随意的插入，下面是一个简单的插入演示</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用的关键地方为一行: <code>mongoTemplate.insert(object, COLLECTION_NAME);</code></p>
<ul>
<li>第一个参数为待插入的document</li>
<li>第二个参数为collection name （相当于mysql的table)</li>
</ul>
<p>执行后输出结果为如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4> 1.2. 批量插入</h4>
<p>一次插入多条记录，传集合进去即可</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>返回结果如下:</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4> 1.3. upsert，不存在才插入</h4>
<p>我们希望在插入之前，判断数据是否存在，如果不存在则插入；如果存在则更新；此时就可以采用upsert来使用，一般三个参数</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>第一个为查询条件，第二个为需要更新的字段，最后一个指定对应的collection，一个简单的实例如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果如下:</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 1.4. upsert，存在则更新</h4>
<p>前面的demo是演示不存在，那么存在数据呢?</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果如下，注意下面的输出数据的 <code>_id</code>，正视前面插入的那条数据，两个数据唯一的不同，就是age被修改了</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h4> 1.5. upsert，多条满足时</h4>
<p>如果query条件命中多条数据，怎么办？会修改几条数据呢？</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>根据实际输出进行查看，发现只有一条数据被修改；另外一条保持不变，结果如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 其他</h3>
<h4> 2.0. 项目</h4>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">spring-boot-demo</a></li>
<li>module: <a href="https://github.com/liuyueyi/spring-boot-demo/blob/master/spring-boot/111-mongo-template" target="_blank" rel="noopener noreferrer">mongo-template</a></li>
</ul>
<p><strong>相关博文</strong></p>
<ul>
<li><a href="http://spring.hhui.top/spring-blog/2018/12/13/181213-SpringBoot%E9%AB%98%E7%BA%A7%E7%AF%87MongoDB%E4%B9%8B%E5%9F%BA%E6%9C%AC%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8/" target="_blank" rel="noopener noreferrer">181213-SpringBoot高级篇MongoDB之基本环境搭建与使用</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2019/01/13/190113-SpringBoot%E9%AB%98%E7%BA%A7%E7%AF%87MongoDB%E4%B9%8B%E6%9F%A5%E8%AF%A2%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF/" target="_blank" rel="noopener noreferrer">190113-SpringBoot高级篇MongoDB之查询基本使用姿势</a></li>
</ul>
<hr>
<p>微信搜 <strong>楼仔</strong> 或扫描下方二维码关注楼仔的原创公众号，回复 <strong>110</strong> 即可免费领取 10 本面试必刷八股文。 <img src="https://files.mdnice.com/user/13837/4b47ac79-8256-47cf-ac1a-036729635246.png" alt="" loading="lazy"></p>
<hr>
<h2> 修改基本使用姿势</h2>
<p>本篇依然是MongoDB curd中的一篇，主要介绍document的更新，主要内容如下</p>
<ul>
<li>常见类型成员的修改</li>
<li>数组类型成员的增删改</li>
<li>document类型成员的增删改</li>
</ul>
<!-- more -->
<h3> 1. 基本使用</h3>
<p>首先是准备好基本环境，可以参考博文</p>
<ul>
<li><a href="http://spring.hhui.top/spring-blog/2018/12/13/181213-SpringBoot%E9%AB%98%E7%BA%A7%E7%AF%87MongoDB%E4%B9%8B%E5%9F%BA%E6%9C%AC%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8/" target="_blank" rel="noopener noreferrer">181213-SpringBoot高级篇MongoDB之基本环境搭建与使用</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2019/01/13/190113-SpringBoot%E9%AB%98%E7%BA%A7%E7%AF%87MongoDB%E4%B9%8B%E6%9F%A5%E8%AF%A2%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF/" target="_blank" rel="noopener noreferrer">190113-SpringBoot高级篇MongoDB之查询基本使用姿势</a></li>
</ul>
<p>在开始之前，先封装一个输出方法，用于打印修改后的record对象</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 1.1. 基本类型修改</h4>
<p>mongodb支持我们常见的各种基本类型，而MongoTemplate也封装了不少对应的修改方法，最基础的修改，主要是借助<code>Update</code>来实现</p>
<p>常见的使用姿势如:</p>
<h5> a. 基本使用姿势</h5>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果为：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5> b. 数字增加/减少</h5>
<p>数字类型修改，使用 <code>org.springframework.data.mongodb.core.query.Update#inc</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果为:</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5> c. 数字比较修改</h5>
<p>数字简单比较之后修改，如<code>org.springframework.data.mongodb.core.query.Update#max</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5> d. 乘法</h5>
<p>乘法运算, 主要使用 <code>org.springframework.data.mongodb.core.query.Update#multiply</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5> e. 日期修改</h5>
<p>日期修改, 如 <code>org.springframework.data.mongodb.core.query.Update#currentDate</code></p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 1.2. field修改</h4>
<p>不同于mysql的列表是固定的,mongodb的field可以增加、删除和重命名，下面分别看下三种case如何使用</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5> a. 重命名</h5>
<p>利用<code>org.springframework.data.mongodb.core.query.Update#rename</code>来实现重命名，需要注意的是，当修改的docuemnt没有这个成员时，相当于没有任务操作</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果如下，后面一个语句相当于没有执行</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5> b. 新增成员</h5>
<p>新增也是直接利用的<code>Update#set</code>方法，当存在时，修改；不存在时，添加</p>
<ul>
<li>另外提一下<code>setOnInsert</code>, 如果要更新的文档存在那么$setOnInsert操作符不做任何处理；</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果如下：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5> c. 删除成员</h5>
<p>删除document中的某个成员，借助<code>org.springframework.data.mongodb.core.query.Update#unset</code>， 正好与添加对上</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 1.3. 数组操作</h4>
<p>在MongoDB的document中，有两个有意思的类型，一个是数组，一个是document（即可以嵌套），这里则主要介绍下如何操作数组中的成员</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5> a. 添加到数组中</h5>
<p>在数组中新增一个数据，提供了两种方式，一个是<code>org.springframework.data.mongodb.core.query.Update#addToSet(java.lang.String, java.lang.Object)</code>，一个是<code>org.springframework.data.mongodb.core.query.Update#push(java.lang.String, java.lang.Object)</code>；两个的区别在于前者不能插入重复数据，后者可以</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5> b. 批量添加</h5>
<p>一次添加多个，借助<code>addToSet</code>的<code>each</code>来实现</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果:</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5> c. 删除</h5>
<p>借助pull来精确删除某个值</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出如下，注意对比，<code>2</code>没有了</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5> d. 修改</h5>
<p>修改，首先的问题是要定位，确定删除数组中某个下标的元素，这里借助了一个有意思的站位</p>
<ul>
<li>定位删除的数组元素方法： <code>arrayKey.index</code>
<ul>
<li><code>arrayKey</code> 是数组在docment中的名</li>
<li><code>index</code> 表示要删除的索引</li>
</ul>
</li>
</ul>
<p>一个实例如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果，注意后面的，如果数组个数小于待更新的索引位置，则前面补null</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 1.4. document操作</h4>
<p>内嵌文档，可以所是MongoDB的一个特色了，我们则来看下如何进行操作</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5> a. 添加</h5>
<p>借助前面的站位思想，就很好实现了，定位元素的方式采用</p>
<ul>
<li>docName.fieldName
<ul>
<li>docName 为内嵌文档在docunent中的fieldName</li>
<li>fieldName 为内嵌文档内部需要修改的fieldName</li>
</ul>
</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5> c. 修改</h5>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5> d. 删除</h5>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 其他</h3>
<h4> 2.0. 项目</h4>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">spring-boot-demo</a></li>
<li>子module：<a href="https://github.com/liuyueyi/spring-boot-demo/blob/master/spring-boot/111-mongo-template/README.md" target="_blank" rel="noopener noreferrer">111-mongo-template</a></li>
</ul>
<hr>
<p>微信搜 <strong>楼仔</strong> 或扫描下方二维码关注楼仔的原创公众号，回复 <strong>110</strong> 即可免费领取 10 本面试必刷八股文。 <img src="https://files.mdnice.com/user/13837/4b47ac79-8256-47cf-ac1a-036729635246.png" alt="" loading="lazy"></p>
<hr>
]]></content:encoded>
      <enclosure url="http://cdn.hhui.top/column/mongo_cover.png" type="image/png"/>
    </item>
    <item>
      <title>MySql系列教程</title>
      <link>https://liuyueyi.github.io/tutorial/db/mysql/</link>
      <guid>https://liuyueyi.github.io/tutorial/db/mysql/</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">MySql系列教程</source>
      <description>关系数据库MySql系列教程</description>
      <pubDate>Fri, 24 Feb 2023 02:18:35 GMT</pubDate>
      <content:encoded><![CDATA[<p>关系数据库MySql系列教程</p>
]]></content:encoded>
    </item>
    <item>
      <title>redis系列教程</title>
      <link>https://liuyueyi.github.io/tutorial/db/redis/</link>
      <guid>https://liuyueyi.github.io/tutorial/db/redis/</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">redis系列教程</source>
      <description>KV数据库Redis系列教程</description>
      <pubDate>Fri, 24 Feb 2023 02:18:35 GMT</pubDate>
      <content:encoded><![CDATA[<p>KV数据库Redis系列教程</p>
]]></content:encoded>
    </item>
    <item>
      <title>Java实战系列</title>
      <link>https://liuyueyi.github.io/tutorial/java/skill/Java%E5%AE%9E%E6%88%9836%E8%AE%B2.html</link>
      <guid>https://liuyueyi.github.io/tutorial/java/skill/Java%E5%AE%9E%E6%88%9836%E8%AE%B2.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">Java实战系列</source>
      <description>Java实战演练 实战小技巧，可用于实际编码过程中的 code snippets 带你再日常得编码中写得更加顺畅 本专栏中所有内容来自于笔者（一灰灰blog）的日常收集与分享，其中每一个主题都是针对真实的应用场景，通过提供切实可用与项目中的代码片段或者工具类，来给给位小伙伴提供帮助 实战1：字符串占位替换 字符串占位替换，相信没有小伙伴是陌生的，这东西可以说是伴随着我们所有的项目工程，编码过程；别不相信，如 String.format sql参数拼接的占位 log日志输出 接下来我们看一下在我们的日常工作生涯中，经常涉及到的几种占位替换方式</description>
      <pubDate>Fri, 24 Feb 2023 02:18:35 GMT</pubDate>
      <content:encoded><![CDATA[<figure><img src="http://cdn.hhui.top/column/java_cover.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h1> Java实战演练</h1>
<blockquote>
<p>实战小技巧，可用于实际编码过程中的 <code>code snippets</code> 带你再日常得编码中写得更加顺畅</p>
</blockquote>
<p>本专栏中所有内容来自于笔者（一灰灰blog）的日常收集与分享，其中每一个主题都是针对真实的应用场景，通过提供切实可用与项目中的代码片段或者工具类，来给给位小伙伴提供帮助</p>
<hr>
<h1> 实战1：字符串占位替换</h1>
<p>字符串占位替换，相信没有小伙伴是陌生的，这东西可以说是伴随着我们所有的项目工程，编码过程；别不相信，如</p>
<ul>
<li>String.format</li>
<li>sql参数拼接的占位</li>
<li>log日志输出</li>
</ul>
<p>接下来我们看一下在我们的日常工作生涯中，经常涉及到的几种占位替换方式</p>
<!-- more -->
<h2> 1. String.format</h2>
<p>这种可以说是最原始最基础的方式了，基本上在最开始学习java这门语言的时候就会涉及到，语法也比较简单</p>
<p>举例如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>使用<code>%</code>来表示占位，后面跟上不同的标识符，用于限定这个占位处的参数类型</p>
<p>这种使用姿势，由jdk原生提供支持，下表为不同的转换符对应的说明</p>
<table>
<thead>
<tr>
<th>转换符</th>
<th>说明</th>
<th>参数实例</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>%s</code></td>
<td>字符串替换</td>
<td>"一灰灰"</td>
</tr>
<tr>
<td><code>%c</code></td>
<td>字符类型</td>
<td>'a'</td>
</tr>
<tr>
<td><code>%b</code></td>
<td>布尔类型</td>
<td>true/false</td>
</tr>
<tr>
<td><code>%d</code></td>
<td>整数，十进制</td>
<td>10</td>
</tr>
<tr>
<td><code>%x</code></td>
<td>整数，十六进制</td>
<td>0x12</td>
</tr>
<tr>
<td><code>%o</code></td>
<td>整数，八进制</td>
<td>012</td>
</tr>
<tr>
<td><code>%f</code></td>
<td>浮点</td>
<td>0.12f</td>
</tr>
<tr>
<td><code>%e</code></td>
<td>指数</td>
<td>2e2</td>
</tr>
<tr>
<td><code>%g</code></td>
<td>通用浮点型</td>
<td></td>
</tr>
<tr>
<td><code>%h</code></td>
<td>散列</td>
<td></td>
</tr>
<tr>
<td><code>%%</code></td>
<td>百分比</td>
<td></td>
</tr>
<tr>
<td><code>%n</code></td>
<td>换行</td>
<td></td>
</tr>
<tr>
<td><code>%tx</code></td>
<td>日期与时间类型（x代表不同的日期与时间转换符</td>
<td></td>
</tr>
</tbody>
</table>
<p>虽然上面表中列出了很多，但实际使用时，<code>%s</code>, <code>%d</code>, <code>%f</code> 这三个就足以应付绝大部分的场景了；使用姿势和上面的实例参不多，第一个参数为字符串模板，后面的可变参数为待替换的值</p>
<p>下面是在实际使用过程中的注意事项</p>
<h3> 1.1 类型不匹配</h3>
<p>上面的表中介绍了不同的转换符，要求的参数类型，如果没有对应上，会怎样</p>
<p><strong><code>%s</code>，传入非字符串类型</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>也就是说，<code>%s</code>的占位标记，传参如果不是String类型，那么实际替换的是 <code>arg.toString()</code> (所以数组输出的是地址，而list输出了内容)</p>
<p><strong><code>%d</code>，传入非整数</strong></p>
<p>与字符串的不一样的是，如果我们定义要求替换的参数类型为整数，那么传参不是整数，就会抛异常</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这两个，一个传入的参数为浮点，一个传入的是字符串，在实际替换的时候，可不会调用<code>Integer.valufOf(String.valueOf(xxx))</code>来强转，而是采用更直接的方式，抛异常</p>
<p>关键的提示信息如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>因此在实际使用这种方式进行替换时，推荐选择 <code>%s</code>，毕竟兼容性更好</p>
<h3> 1.2 参数个数不匹配</h3>
<p>我们会注意到,<code>String.format</code>接收的参数是不定长的，那么就可能存在字符串模板中预留的占位与实际传入的参数个数不匹配的场景，那么出现这种场景时，会怎样</p>
<p><strong>参数缺少</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面的例子中，模板要求两个，实际只传入一个参数，会直接抛异常<code>MissingFormatArgumentException</code></p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>参数过多</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>执行正常，多余的参数不会被替换</p>
<p>因此，我们在使用<code>String.format</code>进行字符串替换时，请确保传参不要少于实际定义的参数个数；多了还好，少了就会抛异常</p>
<h2> 2. MessageFormat</h2>
<p>上面介绍的String.format虽说简单好用，但我们用多之后，自然会遇到，一个参数，需要替换模板中多个占位的场景，针对这种场景，更友好的方式是<code>MessageFormat</code>，这个也是jdk原生提供的</p>
<p>我们来简单看一下它的使用姿势</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>使用<code>{数字}</code>来表示占位，其中数字对应的是传参的下标，因此当一个参数需要复用时，使用MessageFormat就可以比较简单的实现了，上面就是一个实例，替换之后的字符串为</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>接下来说一下它使用时的注意事项</p>
<h3> 2.1 {}成对出现</h3>
<p>如果字符串中，只出现一个<code>{</code>，而没有配套的<code>}</code>，会抛异常</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>注意上面两种case，上面一个是有<code>}</code>而缺少<code>{</code>，这样是没有问题的；而下面那个则会抛异常</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>如果字符串中却是希望输出<code>{</code>，可以使用单引号来处理</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 2.2 单引号</h3>
<p>上面提到需要转移时，可以用单引号进行处理，在字符串模板的定义中，如果有单引号，需要各位注意</p>
<p><strong>只有一个单引号，会导致后面所有占位都不生效</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面这个输出结果可能和我们实际希望的不一致</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>要解决上面这个，就是使用两个单引号</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这样输出的就是我们预期的</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 2.3 序号省略</h3>
<p>上面的定义中，已经明确要求我们在<code>{}</code>中指定参数的序号，如果模板中没有指定会怎样?</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>直接抛异常</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2> 3. 小结</h2>
<p>本文介绍的实战小技巧属于是jdk原生提供的两种实现字符串占位替换的方式，除了这两个之外，我们日常开发中还会遇到其他的占位替换方式</p>
<p>比如sql的<code>?</code>替换，mybatis中sql参数组装使用<code>${paramName}</code>，或者logback日志输出中的<code>{}</code>来表示占位，spring的@Value注解声明的配置注入方式<code>${name:defaultValue}</code>，这些也都属于占位替换的范畴，那么它们又是怎么实现的呢？</p>
<p>微信搜 <strong>楼仔</strong> 或扫描下方二维码关注楼仔的原创公众号，回复 <strong>110</strong> 即可免费领取 10 本面试必刷八股文。
<img src="https://files.mdnice.com/user/13837/4b47ac79-8256-47cf-ac1a-036729635246.png" alt="" loading="lazy"></p>
<hr>
<h1> 实战2：数组与list互转</h1>
<p>这个考题比较常见，也比较简单，难道就这也有什么可以说到的门路不成？</p>
<p>接下来本文好好的说一说它的几种实现姿势，总有一款你喜欢的</p>
<h2> 1.数组转List</h2>
<h3> 1.1. Array.asList</h3>
<p>这个考题太简单了，直接使用<code>Array.asList</code>不就完事了么，比如</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>数组转list，so easy!!!</p>
<p>真的就这么简单么？？？</p>
<p>且看下面这一段代码</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>直接抛出了异常<code>java.lang.UnsupportedOperationException</code></p>
<p>有兴趣的小伙伴可以看一下源码实现方式，通过<code>Arrays.asList</code>创建的List，虽说也命名是<code>ArrayList</code>，但是它的全路径为 <code>java.util.Arrays.ArrayList</code>， 不支持<code>add</code>, <code>remove</code>等操作（所以下次再有面试官问ArrayList的知识点时，就可以反问一句，老哥你指的是哪个ArrayList😝，逼格是不是立马拉起来）</p>
<p><strong>知识点</strong></p>
<ul>
<li>通过<code>Arrays.asList</code>创建的列表，不允许新增，删除元素；但是可以更新列表中元素的值</li>
</ul>
<h3> 1.2. new ArrayList</h3>
<p>上面的数组转list方式虽然是最简单的，但不一定是合适的，特别是当我们可能对转换后的list进行操作时，可能埋坑（而且这种坑还非常隐晦，代码层面上很难发现）</p>
<p>为了减少在代码里面下毒的可能性，不妨使用下面这种方式<code>new ArrayList&lt;&gt;(Arrays.asList(ary))</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过上面这种方式创建的List，就是我们熟知的<code>ArrayList</code>了</p>
<p><strong>避雷预警</strong></p>
<p>看到上面这个使用姿势，就很容易想到一个常见的踩雷点，比如我们的应用中，有一个全局共享的配置列表，张三需要拿id为奇数的配置，李四拿id为偶数的配置，然后他们都是这么做的</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>然后跑了一次之后发现这个全局的列表清空了，这就是典型的没有做好资源隔离的case了，针对这种场景，要么是限制使用方，直接针对全局的资源进行修改，要么就是使用方拿到的是一个隔离的备份</p>
<p><strong>禁止修改：</strong></p>
<ul>
<li>使用不可变的容器，如前面提到的<code>java.util.Arrays.ArrayList</code> ()</li>
<li>使用<code>Collections.unmodifiableList</code>创建</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>列表拷贝</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>（上面这种属于深拷贝的实现，具体可以看一下jdk的源码实现）</p>
<h3> 1.3. Collections.addAll</h3>
<p>第三种方式借助jdk提供的容器工具类<code>Collections</code>来实现</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>原则上是比较推荐这种方式来实现的，至于为啥？看下源码实现</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码的实现是不是非常眼熟，如果让我们自己来写，也差不多会写成这样吧，简单直观高效，完美</p>
<h2> 2. 列表转数组</h2>
<p>不同于数组转列表的几种玩法，列表转数组就简单多了，直接调用<code>List.toArray</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 3. 小结</h2>
<p>今天的博文主题是数组与列表的互转，虽说题目简单，但是实现方式也是多种，需要搞清楚它们之间的本质区别，一不小心就可能采坑，而最简单的地方掉坑里，往往是最难发现和爬出来的</p>
<p>核心知识点小结如下</p>
<p><strong>数组转list：</strong></p>
<ul>
<li><code>Arrays.asList(xxx)</code>：创建的是不可变列表，不能删除和新增元素</li>
<li><code>new ArrayList&lt;&gt;(Arrays.asList(xxx)</code>: 相当于用列表创建列表，属于深拷贝的一种表现，获取到的列表支持新增、删除</li>
<li>推荐写法 <code>Collections.addAll()</code></li>
</ul>
<p><strong>列表转数组</strong></p>
<ul>
<li><code>list.toArray</code>: 如果需要指定数组类型，则传参指定</li>
</ul>
<hr>
<p>微信搜 <strong>楼仔</strong> 或扫描下方二维码关注楼仔的原创公众号，回复 <strong>110</strong> 即可免费领取 10 本面试必刷八股文。
<img src="https://files.mdnice.com/user/13837/4b47ac79-8256-47cf-ac1a-036729635246.png" alt="" loading="lazy"></p>
<hr>
<h1> 实战3：字符串与Collection的互转</h1>
<p>将字符串转换为List，这种业务场景可以说非常非常常见了，实现方式也比较简单</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>那么除了上面这种实现方式之外，还有其他的么？</p>
<!-- more -->
<h2> 1. 字符串转列表</h2>
<p>上面的实现姿势相当于字符串先转数组，然后在通过数组转列表，所以可以沿用前一篇字数组转list的几种方式</p>
<h3> 1.1. jdk支持方式</h3>
<p>借助<code>Collections.addAll</code>来实现</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这种方式适用于输出String的列表，如果我希望转成int列表呢？可以采用下面的方式</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>直接将数组转换为流，然后基于jdk8的特性，来实现转换为int列表</p>
<h3> 1.2. guava方式</h3>
<p>引入依赖</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>除了使用jdk原生的方式之外，借助guava也是非常常见的的case了，主要通过Splitter来实现，写法看起来非常秀</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>简单直接的一行代码搞定，如果我们希望是对输出的列表类型进行指定，也可以如下操作</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1.3. apache-commons</h3>
<p>引入依赖</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面流的方式就很赞了，但是注意它是有jdk版本限制的，虽说现在基本上都是1.8以上的环境进行开发，但也不排除有上古的代码，比如我现在手上的项目，spring还是3...</p>
<p>如果我们不能使用流的方式，那么有什么简单的方式来实现字符串转换为指定类型的列表么？</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这个实现也没有多优雅，不过这里有个编程小技巧可以学习，<code>new Transformer(){}</code>的传参方式，这种实现方式有点像回调的写法，虽然他们有本质的区别，此外就是jdk8之后的函数方法，就充分的体现这种设计思路，比如上面的换成jdk8的写法，直接简化为</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 2. 列表转字符串</h2>
<h3> 2.1. StringBuilder</h3>
<p>最容易想到的，直接使用StringBuilder来实现拼接</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意两点：</p>
<ul>
<li>使用StringBuilder而不是StringBuffer (why?)</li>
<li>注意最后一个拼接符号不要</li>
</ul>
<h3> 2.2. String.join</h3>
<p>一个更简单的实现方式如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当然上面这个的缺点就是列表必须是字符串列表，如果换成int列表，则不行</p>
<h3> 2.3. gauva</h3>
<p>guava也提供了列表转String的方式，同样很简单，而且还没有列表类型的限制</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 3. 小结</h2>
<p>本文的考题也非常常见，列表与字符串的互转，这里介绍了多种实现方式，有jdk原生的case（如果没有什么限制，推荐使用它， <code>String.split</code>除外，原因后面再说），如果有更高级的定制场景，如非String类型类表，则可以考虑guava的Splitter/Joinner来实现</p>
<p>在上面的实现中，也提供了几种有意思的编程方式</p>
<ul>
<li>Stream: 流，jdk8之后非常常见了</li>
<li>函数方法，回调写法case</li>
</ul>
<hr>
<p>微信搜 <strong>楼仔</strong> 或扫描下方二维码关注楼仔的原创公众号，回复 <strong>110</strong> 即可免费领取 10 本面试必刷八股文。
<img src="https://files.mdnice.com/user/13837/4b47ac79-8256-47cf-ac1a-036729635246.png" alt="" loading="lazy"></p>
<hr>
<h1> 实战4：字符串拼接</h1>
<p>相信没有小伙伴没有写过这样的代码，比如说现在让我们来实现一个字符串拼接的场景，怎样的实现才算是优雅的呢？</p>
<!-- more -->
<p>以将int数组转为英文逗号分隔的字符串为例进行演示</p>
<h2> 1. 实现</h2>
<h3> 1.1. 普通写法</h3>
<p>直接使用StringBuilder来拼接</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这种写法相信比较常见，相对来说不太顺眼的地方就是最后的toString，需要将最后的一个英文逗号给干掉</p>
<p>当然也可以用下面这种事前判断方式，避免最终的字符串截取</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1.2. StringJoiner</h3>
<p>上面实现中，干掉最后的一个分隔符实在不是很优雅，那么有更好一点的用法么，接下来看一下使用<code>StringJoiner</code>的方式</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>StringJoiner由jdk1.8提供，除了上面的基础玩法之外，结合jdk1.8带来的流操作方式，可以更简洁的实现</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>怎么样，上面这个实现比起前面的代码是不是要简洁多了，一行代码完事</p>
<h3> 1.3. guava joiner</h3>
<p>如果使用的jdk还不是1.8版本，不能使用上面的StringJoiner，没关系，还有guava的Joiner也可以实现</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>注意</strong></p>
<ul>
<li>接收的参数类型为: 数组/Iterable/Iterator/可变参数, 基本上可以覆盖我们日常的业务场景</li>
</ul>
<h2> 2. 小结</h2>
<p>本篇文章的主题是一个非常非常常见的字符串拼接，一般来讲，我们在做字符串拼接时，最麻烦的事情就是分隔符的处理，要么就是分隔符前置添加，每次循环都需要判断是否为开头；要么就是后置，最后取字符串时，干掉最后一个分隔符</p>
<p>本文提供了一个非常使用的方式<code>StringJoiner</code>，完全解决了上面的分隔符问题，它的使用有两种场景</p>
<ul>
<li>简单的容器转String：直接借助Stream的<code>Collectors.joining</code>来实现</li>
<li>for循环 （这种场景一般是for循环内的逻辑不仅仅包括字符串拼接，还包括其他的业务逻辑）： 循环内直接执行<code>stringJoiner.add()</code>添加</li>
</ul>
<p>对于jdk1.8及以上的版本，优先推荐使用上面说的StringJoiner来实现字符串拼接；至于jdk1.8之下，那么Guava就是一个不错的选择了，使用姿势也很很简单</p>
<hr>
<p>微信搜 <strong>楼仔</strong> 或扫描下方二维码关注楼仔的原创公众号，回复 <strong>110</strong> 即可免费领取 10 本面试必刷八股文。
<img src="https://files.mdnice.com/user/13837/4b47ac79-8256-47cf-ac1a-036729635246.png" alt="" loading="lazy"></p>
<hr>
<h1> 实战5：驼峰与下划线划转</h1>
<p>这个考题非常实用，特别是对于我们这些号称只需要CURD的后端开发来说，驼峰与下划线互转，这不是属于日常任务么；一般来讲db中的列名，要求是下划线格式（why? 阿里的数据库规范是这么定义的，就我感觉驼峰也没毛病），而java实体命名则是驼峰格式，所以它们之间的互转，就必然存在一个驼峰与下划线的互转</p>
<p>今天我们就来看一下，这两个的互转支持方式</p>
<!-- more -->
<h2> 1.实现</h2>
<h3> 1.1. Gauva</h3>
<p>一般来讲遇到这种普适性的问题，大部分都是有现成的工具类可以来直接使用的；在java生态中，说到好用的工具百宝箱，guava可以说是排列靠前的</p>
<p>接下来我们看一下如何使用Gauva来实现我们的目的</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这里主要使用的是<code>CaseFormat</code>来实现互转，guava的CaseFormat还提供了其他几种方式</p>
<p>上面这个虽然可以实现互转，但是如果我们有一个字符串为 <code>helloWorld_Case</code></p>
<p>将其他转换输出结果如下:</p>
<ul>
<li>下划线：<code>hello_world__case</code></li>
<li>驼峰：<code>helloworldCase</code></li>
</ul>
<p>这种输出，和标准的驼峰/下划线不太一样了（当然原因是由于输入也不标准）</p>
<h3> 1.2. Hutool</h3>
<p>除了上面的guava，hutool的使用也非常广，其中包含很多工具类，其<code>StrUtil</code>也提供了下划线与驼峰的互转支持</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>同样的我们再来看一下特殊的case</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果如下</p>
<ul>
<li>驼峰：<code>helloworldCase</code></li>
<li>下划线: <code>hello_world_case</code></li>
</ul>
<p>相比较上面的guava的场景，下划线这个貌似还行</p>
<h3> 1.3. 自定义实现</h3>
<p>接下来为了满足我们希望转换为标砖的驼峰/下划线输出方式的需求，我们自己来手撸一个</p>
<p><strong>下划线转驼峰:</strong></p>
<ul>
<li>关键点就是找到下划线，然后去掉它，下一个字符转大写续上（如果下一个还是下划线，那继续找下一个）</li>
</ul>
<p>根据上面这个思路来实现，如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>驼峰转下划线</strong></p>
<ul>
<li>关键点：大写的，则前位补一个下划线，当前字符转小写（如果前面已经是一个下划线了，那前面不补，直接转小写即可）</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>再次测试<code>helloWorld_Case</code>，输出如下</p>
<ul>
<li>驼峰：<code>helloWorldCase</code></li>
<li>下划线: <code>hello_world_case</code></li>
</ul>
<hr>
<p>微信搜 <strong>楼仔</strong> 或扫描下方二维码关注楼仔的原创公众号，回复 <strong>110</strong> 即可免费领取 10 本面试必刷八股文。
<img src="https://files.mdnice.com/user/13837/4b47ac79-8256-47cf-ac1a-036729635246.png" alt="" loading="lazy"></p>
<hr>
<h1> 实战6：枚举的特殊用法</h1>
<p>难道我们日常使用的枚举还有什么特殊的玩法不成？没错，还真有，本文主要介绍枚举的两种不那么常见的使用姿势</p>
<ul>
<li>利用枚举来实现单例模式</li>
<li>利用枚举来实现策略模式</li>
</ul>
<!-- more -->
<h2> 1. 使用场景</h2>
<h3> 1.1. 单例模式</h3>
<p>单例模式可以说是每个java开发者必须掌握的一个设计模式了，通常我们说它的实现，有饱汉式和饿汉式，也有经常说的双重判断，今天我们介绍另外一种方式，借助枚举来实现</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用枚举来实现单例模式非常非常简单，将类声明为枚举，内部只定义一个值即可</p>
<p>为什么可以这样做？</p>
<ul>
<li>枚举类不能<code>new</code>，因此保证单例</li>
<li>枚举类不能被继承</li>
<li>类不加载时，不会实例化</li>
</ul>
<p>使用枚举类创建的单例有一个好处，就是即使用反射，也无法打破它的单例性质，这是相比较于其他的实现方式的一个优点</p>
<p>那么，为啥在实际的项目中，不太常见这种写法？</p>
<ul>
<li>就我个人的一点认知（不保证准确）：这个与我们对枚举的认知有一定关系，在 《Effect in java》一书中，推荐我们使用这种方式来实现单例，但是在实际的项目开发中，我们更多的将枚举作为常量来使用，很少在枚举类中，添加复杂的业务逻辑</li>
</ul>
<h3> 1.2. 策略模式</h3>
<p>枚举除了很容易就实现上面的单例模式之外，还可以非常简单的实现策略模式</p>
<p>举一个简单的例子，我现在有一个接口，通过接受的参数，来决定最终的数据存在什么地方</p>
<p>如果按照正常的写法，可能就是很多的if/else</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这种写法虽说简单直观，但是当type类型一多了之后，这个if/else的代码行数就会很多很多了，而且看起来也不美观</p>
<p>接下来我们介绍一种利用枚举，基于策略模式的思想来解决上面的if/else问题</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的实现，主要利用的是<code>抽象类 + 枚举</code>来完成不同的策略具体实现</p>
<p>这种实现方式，相比较与前面的单例模式，还是更常见一点，虽然整体看下来没有什么难度，但是仔细看一看，会发现几个知识点</p>
<ul>
<li>抽象方法的使用 （在模板设计模式中，更能体会抽象方法的使用妙处）</li>
<li>利用枚举原生提供的<code>values()</code>，来实现遍历，找到目标</li>
</ul>
<h2> 2. 小结</h2>
<p>枚举虽然说是jdk原生提供的一个基础数据类型，但是它的使用姿势除了我们熟知的常量之外，还可以有效的运用在设计模式中，让我们的代码实现更优雅</p>
<p>比如使用枚举来实现单例模式，就不用再面对让人烦躁的双重判断/内部类的方式了</p>
<p>使用枚举的策略模式，也可以有效解决我们类中大量的if/else</p>
<hr>
<p>微信搜 <strong>楼仔</strong> 或扫描下方二维码关注楼仔的原创公众号，回复 <strong>110</strong> 即可免费领取 10 本面试必刷八股文。
<img src="https://files.mdnice.com/user/13837/4b47ac79-8256-47cf-ac1a-036729635246.png" alt="" loading="lazy"></p>
<hr>
<h1> 实战7：排序比较要慎重</h1>
<p>今天介绍的又是一个非常非常基本的基本知识点，为啥要单独拎出来？还是因为这个东西虽然非常简单，但是很容易掉坑，我已经遇到几次不严谨的写法了</p>
<!-- more -->
<h2> 1.排序</h2>
<h3> 1.1. Comparator 与 Comparable</h3>
<p>输掉排序，这两个接口好像不太容易绕过去，我们简单介绍下它们的区别</p>
<ul>
<li>如果你有一个类，希望支持同类型的自定义比较策略，可以实现接口<code>Compareable</code></li>
<li>如果某个类，没有实现<code>Compareable</code>接口，但是又希望对它进行比较，则可以自自定义一个<code>Comparator</code>，来定义这个类的比较规则</li>
</ul>
<p>通过一个简单的实例进行演示说明</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的实现中，重点关注 Demo类，实现了<code>Comparable</code>接口，因此可以直接调用<code>list.sort(null)</code>来进行比较；</p>
<p>但是如果我们现在需求改变了，希望实现针对demo类的age字段，进行升序排列，那么就可以利用<code>Comparator</code>来实现了</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1.2. 踩坑预告</h3>
<p>再上面的compare方法实现中，我们可以发现里面的实现有点不太美观，我们最终的目的是什么？</p>
<ul>
<li>如果左边的小于右边的，返回 -1</li>
<li>如果左边的大于右边的，返回 0</li>
<li>如果左边的等于右边的，返回 1</li>
</ul>
<p>基于此，经常可以看到的实现如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这个实现虽然简洁了，但是有一个致命的问题，可能溢出!!!</p>
<p>所以请注意，千万千万不要用上面这种写法</p>
<p>那么有没有更优雅的方式呢？</p>
<ul>
<li>有，使用基础类的<code>compare</code>方法</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这一段代码，再jdk1.8中，可以简化为下面一句</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>再扩展一下，如果希望倒排呢？</p>
<ul>
<li>第一种实现方式，调换位置</li>
<li>Jdk1.8方式，使用负数</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 2. 小结</h2>
<p>今天主要介绍的知识点是排序，再我们日常使用中，如果一个类希望支持排序，最好的方式就是让它实现<code>Comparable</code>接口，然后自定义排序方式</p>
<p>这样再容器中，如果需要排序，直接调用 <code>list.sort(null)</code> 或者 <code>CollectionUtils.sort(list)</code></p>
<p>如果目标类没有实现排序接口，或者希望使用另外一种排序方式，则通过自定义的<code>Comparator</code>来实现</p>
<p>最后关于<code>compare</code>方法的实现，设计到两个类的比较，这种最终的落脚地，多半是基础类型的比较</p>
<ul>
<li>o1 与 o2 比较，返回负数，则最终的结果中o1再前面（即升序排列）</li>
<li>不要直接使用 <code>o1-o2</code>会溢出，推荐使用 <code>Integer.compare(o1, o2);</code></li>
</ul>
<hr>
<p>微信搜 <strong>楼仔</strong> 或扫描下方二维码关注楼仔的原创公众号，回复 <strong>110</strong> 即可免费领取 10 本面试必刷八股文。
<img src="https://files.mdnice.com/user/13837/4b47ac79-8256-47cf-ac1a-036729635246.png" alt="" loading="lazy"></p>
<hr>
<h1> 实战8：容器的初始化大小指定</h1>
<p>容器可以说是我们日常开发中，除了基本对象之外，使用最多的类了，那么平时在使用的时候，是否有主意到良好编程习惯的大佬，在创建容器的时候，一般会设置size；那么他们为什么要这么干呢？是出于什么进行考量的呢？</p>
<p>今天我们将针对最常见的List/Map/Set三种容器类型的初始化值选择，进行说明</p>
<!-- more -->
<h2> 1. 容器初始化</h2>
<h3> 1.1. List</h3>
<p>列表，在我们日常使用过程中，会接触到下面几个</p>
<ul>
<li>ArrayList: 最常见的数组列表</li>
<li>LinkedList: 基于链表的列表</li>
<li>CopyOnWriteArrayList: 线程安全的数组列表</li>
</ul>
<p>接下来逐一进行说明</p>
<h4> 1.1.1 ArrayList</h4>
<p>现在以ArrayList为例，进行源码分析，当我们不指定列表大小，直接创建时</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面是内部实现，其中<code>elementData</code>就是列表中存数据的数组，初始化为默认数组</p>
<p>当我们第一次添加一个元素时，发现数组为默认值，会触发一次数组扩容，新的数组大小为10 （详情看源码）</p>
<p>其次就是数组的库容机制，通过源码/网上分享知识点可以知道，这个扩容的实现如下</p>
<ul>
<li>当新添加的元素，数组放不下时，实现扩容</li>
<li><code>扩容后的大小</code> = <code>扩容前大小</code> + max(<code>添加元素个数</code>, 1/2 * <code>扩容前大小</code>)</li>
</ul>
<p>基于上面的知识点，大致可以得出指定列表长度的好处</p>
<ul>
<li>节省空间（用多少申请多少，避免浪费）</li>
<li>减少扩容带来的拷贝（扩容一次就会带来一次数组拷贝，如果已知列表很大，结果还使用默认的10，这会产生很多可避免的扩容开销）</li>
</ul>
<h4> 1.1.2 LinkedList</h4>
<p>基于链表的列表，不同于上面的数组列表，它没有提供指定大小的构造方法，why?</p>
<p>因为链表本身的数据结构的特点，它就像糖葫芦一样，一个串一个，有数据，才有接上的可能，因此不需要指定大小</p>
<h4> 1.1.3 CopyOnWriteArrayList</h4>
<p>这个又非常有意思，它同样不能指定大小，但是原因与前面不同，主要在于它保证线程安全的实现方式</p>
<ul>
<li>每次新增/修改(加锁，保证单线程访问)，都是在拷贝的数组操作；完成之后，用新的替换旧的</li>
</ul>
<p>所以说，每次变更，都会存在数组拷贝，因此就没有必要提前指定数组大小</p>
<p>那么它的初始化每次都使用默认的么?</p>
<p>并不是这样的，当我们已知这个列表中的值时，推荐使用下面这种方式</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>将初始化值，放在一个普通的列表中，然后利用普通列表来初始化<code>CopyOnWriteArrayList</code></li>
</ul>
<h3> 1.2.Map</h3>
<p>常见的map容器使用，大多是下面几个</p>
<ul>
<li><code>HashMap</code></li>
<li><code>LinkedHashMap</code>: 有序的hashmap</li>
<li><code>TreeMap</code>: 有序的hashmap</li>
<li><code>ConcurrentHashMap</code>: 线程安全的map</li>
</ul>
<h4> 1.2.1 HashMap</h4>
<p>HashMap的底层数据结构是 <code>数组 + 链表/红黑树</code>，关于这个就不细说了</p>
<p>我们在初始化时，若不指定size，则数组的默认长度为8（请注意，Map的数组长度是2的倍数）</p>
<p>与ArrayList的扩容时机不一样的是，默认情况下，Map容量没满就会触发一次扩容</p>
<p>默认是数量达到 <code>size * 0.75</code>(0.75为扩容因子，可以在创建时修改)，就会触发一次扩容</p>
<p>why?</p>
<ul>
<li>主要是为了减少hash冲突</li>
</ul>
<p>同样的为了减少冲突，在初始化时，我们需要指定一个合适大小</p>
<p>比如我们</p>
<ul>
<li>已知map的数量为2，这个时候Map的大小选择因该是4</li>
<li>map数量为6，这个时候Map的大小选择是16</li>
</ul>
<p>有时候让我们自己来计算这个值，就有些麻烦了，这个时候，可以直接使用Guava的工具类来完成这个目的</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4> 1.2.2 LinkedHashMap</h4>
<p>初始化方式同上，略</p>
<h4> 1.2.3 ConcurrentHashMap</h4>
<p>初始化方式同上，略</p>
<h4> 1.2.4 TreeMap</h4>
<p>不同于上面几个的是treeMap，没有提供指定容器大小的构造方法</p>
<p>原因和前面说到的LinkedList有些类似，TreeMap的底层数据结构为Tree，所以新增数据是挂在树的一个节点下面，无需指定容量大小</p>
<h3> 1.3. Set</h3>
<p>集合用的最多应该就是<code>HashSet</code>了，底层结构模型复用，所以初始化大小指定与HashMap一致，也不需要多说</p>
<h2> 2. 小结</h2>
<p>今天这篇博文主要介绍的是三种常见的容器，在创建时，如何指定容量大小</p>
<p>首先明确一点，指定容量大小是为了</p>
<ul>
<li>减少扩容带来的额外开销</li>
<li>指定容量代销，可以减少无效的内存开销</li>
</ul>
<p>初始化值设置的关键点:</p>
<ul>
<li>ArrayList: 数据有多少个，初始化值就是多少</li>
<li>HashMap: 考虑到扩容因子，初始化大小 = <code>(size / 0.75 + 1)</code></li>
</ul>
<hr>
<p>微信搜 <strong>楼仔</strong> 或扫描下方二维码关注楼仔的原创公众号，回复 <strong>110</strong> 即可免费领取 10 本面试必刷八股文。
<img src="https://files.mdnice.com/user/13837/4b47ac79-8256-47cf-ac1a-036729635246.png" alt="" loading="lazy"></p>
<hr>
<h1> 实战9：List.subList使用不当StackOverflowError</h1>
<p>相信每个小伙伴都使用过<code>List.subList</code>来获取子列表，日常使用可能没啥问题，但是，请注意，它的使用，很可能一不小心就可能导致oom</p>
<!-- more -->
<h2> 1.实例说明</h2>
<h3> 1.1. subList</h3>
<p>场景复现，如基于list实现一个小顶堆</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这个执行完毕之后，居然出现栈溢出</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从实现来看，感觉也没啥问题啊， 我们稍微改一下上面的返回</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>再次执行，却没有异常；所以关键点就在与</p>
<ul>
<li>list.subList的使用上</li>
</ul>
<h3> 1.2. StackOverflowError分析</h3>
<p>接下来我们主要看一下<code>list.subList</code>的实现</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面返回的子列表是ArrayList的一个内部类<code>SubList</code>，它拥有一个指向父列表的成员<code>parrent</code></p>
<p>也就是说，从源头的ArryList开始，后面每次调用<code>subList</code>，这个指代关系就深一层</p>
<p>然后它的add方法也很有意思</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>重点看 <code>parent.add(parentOffset + index, e);</code>，添加的数据实际上是加在最源头的ArrayList上的，也就是说，虽然你现在拿到的SubList，只有几个元素，但是它对应的数组，可能超乎你的想象</p>
<p>当然上面这个异常主要是以为调用栈溢出（一直往上找parent）</p>
<p>这里反应的另外一个重要问题则是内存泄漏，就不继续说了</p>
<p>如果需要解决上面这个问题，改造方法如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 2. 小结</h2>
<p>jdk提供的原生方法虽然非常好用，但是在使用的时候，也需要多家注意，一不小心就可能掉进坑里；这也告诉我们多看源码是有必要的</p>
<p>最后一句关键知识点小结：</p>
<ul>
<li><code>ArrayList.subList</code> 返回的是内部类，与原ArrayList公用一个数组，只是限定了这个数组的起始下标和结束下标而已</li>
<li>在使用<code>subList</code>，请注意是否会存在内存泄露和栈溢出的问题</li>
</ul>
<hr>
<p>微信搜 <strong>楼仔</strong> 或扫描下方二维码关注楼仔的原创公众号，回复 <strong>110</strong> 即可免费领取 10 本面试必刷八股文。
<img src="https://files.mdnice.com/user/13837/4b47ac79-8256-47cf-ac1a-036729635246.png" alt="" loading="lazy"></p>
<hr>
<h1> 实战10：不可变容器</h1>
<p>不可变容器，看着好像在实际的业务中不怎么会用到，但实则不然，相信每个小伙伴都用过，或者看到过下面的代码</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>今天我们来介绍一下如何使用不可变容器，以及使用时的注意事项</p>
<!-- more -->
<h2> 1. 不可变容器</h2>
<h3> 1.1. JDK不可变容器</h3>
<p>java原生提供了一些不可变容器，它们最大的特点就是不支持添加、删除、修改容器内的值</p>
<p><code>Collections.emptyXxx</code>空容器</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面三个是最常用的几个了，通常当我们一个方法的返回结果定义为容器类型时，可能为了避免npe，在返回空容器时，会如此使用</p>
<p>除了上面这几个空的不可变容器之外，还有</p>
<ul>
<li><code>UnmodifiableList</code></li>
<li><code>UnmodifiableMap</code></li>
<li><code>UnmodifiableSet</code></li>
</ul>
<p>它们的使用姿势，通常是借助<code>Collections</code>来实现</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>如上面创建的List，就不支持set/remove等修改操作</p>
<p>使用不可变容容器，最大的好处就是基于它的不可修改特性，来实现公用，且不会被污染</p>
<ul>
<li>所以一个自然而然能想到的应用场景就是 <code>全局共享的配置</code></li>
</ul>
<h3> 1.2. Guava不可变容器</h3>
<p>上面是jdk提供的不可变容器，相比较与它们，在实际的项目中，使用Gauva的不可变容器的可能更多</p>
<ul>
<li><code>ImmutableXxx</code>；不可变容器</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面是最常见的三个容器对应的不可变型</p>
<p>从使用角度来看，初始化非常方便（相比较与jdk版而言）</p>
<h2> 2. 注意事项</h2>
<p>不可变容器虽好，但是使用不当也是很坑的；就我个人的一个观点</p>
<ul>
<li>如果是应用内的接口方法，容器传参，返回容器时，尽量不要使用不可变容器；因为你没办法保证别人拿到你的返回容器之后，会对它进行什么操作</li>
<li>如果是对外提供返回结果，特别是null的场景，使用不可变的空容器优于返回null</li>
<li>不可变容器，用于全局公用资源，共享配置参数；多线程的数据传递时，属于比较合适的场景</li>
</ul>
<hr>
<p>微信搜 <strong>楼仔</strong> 或扫描下方二维码关注楼仔的原创公众号，回复 <strong>110</strong> 即可免费领取 10 本面试必刷八股文。
<img src="https://files.mdnice.com/user/13837/4b47ac79-8256-47cf-ac1a-036729635246.png" alt="" loading="lazy"></p>
<hr>
<h1> 实战11：Map转换Map的几种方式</h1>
<p>在日常开发过程中，从一个Map转换为另外一个Map属于基本操作了，那么我们一般怎么去实现这种场景呢？有什么更简洁省事的方法么？</p>
<!-- more -->
<h2> 1.Map互转</h2>
<h3> 1.1 实例场景</h3>
<p>现在我们给一个简单的实例</p>
<p>希望将一个<code>Map&lt;String, Integer&gt;</code> 转换成 <code>Map&lt;String, String&gt;</code>，接下来看一下有哪些实现方式，以及各自的优缺点</p>
<p>首先提供一个创建Map的公共方法</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 1.1.1 基本的for循环转换</h4>
<p>这种方式是最容易想到和实现的，直接for循环来转换即可</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这种方式的优点很明显，实现容易，业务直观；</p>
<p>缺点就是可复用性较差，代码量多（相比于下面的case）</p>
<h4> 1.1.2 容器的流式使用</h4>
<p>在jdk1.8提供了流式操作，同样也可以采用这种方式来实现转换</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用stream的方式，优点就是链式，代码量少；缺点是相较于上面的阅读体验会差一些（当然这个取决于个人，有些小伙伴就更习惯看这种链式的代码）</p>
<h4> 1.1.3 Guava的trasform方式</h4>
<p>从代码层面来看，上面两个都不够直观，如果对guava熟悉的小伙伴对下面的代码可能就很熟悉了</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>核心逻辑就一行 <code>Maps.transformValues(map, String::valueOf)</code>，实现了我们的Map转换的诉求</p>
<p>很明显，这种方式的优点就是间接、直观；当然缺点就是需要引入guava，并且熟悉guava</p>
<h3> 1.2 最后一问，这篇文章目的是啥？</h3>
<p>既然我们的标题是实战小技巧，本文除了给大家介绍可以使用guava的<code>Maps.transformValues</code>来实现map转换之外，更主要的一个目的是如果让我们自己来实现一个工具类，来支持这个场景，应该怎么做？</p>
<p>直接提供一个转换方法？</p>
<p><strong>第一步：一个泛型的转换接口</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>定义上面这个接口之后，自然而然想到的缺点就是差一个value的转换实现</p>
<p><strong>第二步：value转换的定义</strong></p>
<p>这里采用Function接口思想来定义转换类</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>当然到这里我们就需要注意jdk1.8以下是不支持函数编程的，那么我们可以怎么来实现呢？</p>
<p>这个时候再对照一下guava的实现，然后再手撸一个，知识点就到手了</p>
<hr>
<p>微信搜 <strong>楼仔</strong> 或扫描下方二维码关注楼仔的原创公众号，回复 <strong>110</strong> 即可免费领取 10 本面试必刷八股文。
<img src="https://files.mdnice.com/user/13837/4b47ac79-8256-47cf-ac1a-036729635246.png" alt="" loading="lazy"></p>
<hr>
<h1> 实战12：巧用函数方法实现二维数组遍历</h1>
<p>对于数组遍历，基本上每个开发者都写过，遍历本身没什么好说的，但是当我们在遍历的过程中，有一些复杂的业务逻辑时，将会发现代码的层级会逐渐加深</p>
<!-- more -->
<p>如一个简单的case，将一个二维数组中的偶数找出来，保存到一个列表中</p>
<p>二维数组遍历，每个元素判断下是否为偶数，很容易就可以写出来，如</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这个实现没啥问题，但是这个代码的深度很容易就有三层了；当上面这个if中如果再有其他的判定条件，那么这个代码层级很容易增加了；二维数组还好，如果是三维数组，一个遍历就是三层；再加点逻辑，四层、五层不也是分分钟的事情么</p>
<p>那么问题来了，代码层级变多之后会有什么问题呢？</p>
<blockquote>
<p>只要代码能跑，又能有什么问题呢？！</p>
</blockquote>
<h2> 1. 函数方法消减代码层级</h2>
<p>由于多维数组的遍历层级天然就很深，那么有办法进行消减么？</p>
<p>要解决这个问题，关键是要抓住重点，遍历的重点是什么？获取每个元素的坐标！那么我们可以怎么办？</p>
<blockquote>
<p>定义一个函数方法，输入的就是函数坐标，在这个函数体中执行我们的遍历逻辑即可</p>
</blockquote>
<p>基于上面这个思路，相信我们可以很容易写一个二维的数组遍历通用方法</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>主要上面的实现，函数方法直接使用了JDK默认提供的BiConsumer，两个传参，都是int 数组下表；无返回值</p>
<p>那么上面这个怎么用呢？</p>
<p>同样是上面的例子，改一下之后，如</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>相比于前面的，貌似也就少了一层而已，好像也没什么了不起的</p>
<p>但是，当数组变为三维、四维、无维时，这个改动的写法层级都不会变哦</p>
<h2> 2. 遍历中return支持</h2>
<p>前面的实现对于正常的遍历没啥问题；但是当我们在遍历过程中，遇到某个条件直接返回，能支持么？</p>
<p>如一个遍历二维数组，我们希望判断其中是否有偶数，那么可以怎么整？</p>
<p>仔细琢磨一下我们的scan方法，希望可以支持return，主要的问题点就是这个函数方法执行之后，我该怎么知道是继续循环还是直接return呢?</p>
<p>很容易想到的就是执行逻辑中，添加一个额外的返回值，用于标记是否中断循环直接返回</p>
<p>基于此思路，我们可以实现一个简单的demo版本</p>
<p>定义一个函数方法，接受循环的下标 + 返回值</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>循环通用方法就可以相应的改成</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>基于上面这种思路，我们的实际使用姿势如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这个实现可满足我们的需求，唯一有个别扭的地方就是返回，总有点不太优雅；那么除了这种方式之外，还有其他的方式么？</p>
<p>既然考虑了返回值，那么再考虑一下传参呢？通过一个定义的参数来装在是否中断以及返回结果，是否可行呢？</p>
<p>基于这个思路，我们可以先定义一个参数包装类</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们希望通过Ans这个类来记录循环结果，其中tag=true，则表示不用继续循环了，直接返回ans结果吧</p>
<p>与之对应的方法改造及实例如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样看起来就比前面的要好一点了</p>
<p>实际跑一下，看下输出是否和我们预期的一致；</p>
<figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/546a699ae4334df4b6525332da4e5770~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure>
<p>微信搜 <strong>楼仔</strong> 或扫描下方二维码关注楼仔的原创公众号，回复 <strong>110</strong> 即可免费领取 10 本面试必刷八股文。
<img src="https://files.mdnice.com/user/13837/4b47ac79-8256-47cf-ac1a-036729635246.png" alt="" loading="lazy"></p>
<hr>
<h1> 实战13：List转Map List的几种姿势</h1>
<p>今天介绍一个实用的小知识点，如何将List转为<code>Map&lt;Object, List&lt;Object&gt;&gt;</code></p>
<!-- more -->
<h2> 1. 转换方式</h2>
<h3> 1.1. 基本写法</h3>
<p>最开始介绍的当然是最常见、最直观的写法，当然也是任何限制的写法</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对于jdk8+，上面for循环中的内容可以利用<code>Map.computeIfAbsent</code>来替换，具体写法如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当然既然已经是jdk1.8了，借助Stream的流处理，可以将上面的更一步进行简化，如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 1.2. 通用方法</h3>
<p>上面是针对特定的列表，针对业务进行开发转换，那么我们接下来尝试构建一个通用的工具类</p>
<p>这里我们主要借助的知识点就是泛型，一个重要的点就是如何获取Map中的key</p>
<p>对于jdk &lt; 1.8的写法，通过接口来定义实现key的获取姿势</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用demo如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来再看一下jdk1.8之后的写法，结合stream + 函数方法来实现</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其对应的使用方式则如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1.3. 工具类</h3>
<p>上一节介绍了基于泛型 + jdk8 Stream + 函数方法来实现通用转换工具类的实现姿势，接下来我们小结一下，输出一个适用于1.8之后的工具类</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1.4.guava HashMultimap扩展知识点</h3>
<p>最后再介绍一个扩展知识点，Gauva工具包中提供了一个<code>HashMultimap</code>的工具类，他的使用姿势和我们平常的Map并无差别，但是需要在注意的是，它的value是个集合</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>实际输出如下，验证了value实际上是个集合（on只有一个，如果是我们上面的工具类，会输出两个）</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><hr>
<p>微信搜 <strong>楼仔</strong> 或扫描下方二维码关注楼仔的原创公众号，回复 <strong>110</strong> 即可免费领取 10 本面试必刷八股文。
<img src="https://files.mdnice.com/user/13837/4b47ac79-8256-47cf-ac1a-036729635246.png" alt="" loading="lazy"></p>
<hr>
<h1> 实战14：分页遍历得两种实现策略</h1>
<p>在日常开发中，分页遍历迭代的场景可以说非常普遍了，比如扫表，每次捞100条数据，然后遍历这100条数据，依次执行某个业务逻辑；这100条执行完毕之后，再加载下一百条数据，直到扫描完毕</p>
<p>那么要实现上面这种分页迭代遍历的场景，我们可以怎么做呢</p>
<p>本文将介绍两种使用姿势</p>
<ul>
<li>常规的使用方法</li>
<li>借助Iterator的使用姿势</li>
</ul>
<!-- more -->
<h2> 1. 实现方式</h2>
<h3> 1.1. 数据查询模拟</h3>
<p>首先mock一个分页获取数据的逻辑，直接随机生成数据，并且控制最多返回三页</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1.2. 基本实现方式</h3>
<p>针对这种场景，最常见也是最简单直观的实现方式</p>
<ul>
<li>while死循环</li>
<li>内部遍历</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1.3. 迭代器实现方式</h3>
<p>接下来介绍一种更有意思的方式，借助迭代器的遍历特性来实现，首先自定义一个通用分页迭代器</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来借助上面的迭代器可以比较简单的实现我们的需求了</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>那么问题来了，上面这种使用方式比前面的优势体现再哪儿呢？</p>
<ul>
<li>双层循环改为单层循环</li>
</ul>
<p>接下来接入重点了，在jdk1.8引入了函数方法 + lambda之后，又提供了一个更简洁的使用姿势</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在jdk1.8及之后的使用姿势，一行代码即可</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这次对比效果是不是非常显眼了，从此以后分页迭代遍历再也不用冗长的双重迭代了</p>
<hr>
<p>微信搜 <strong>楼仔</strong> 或扫描下方二维码关注楼仔的原创公众号，回复 <strong>110</strong> 即可免费领取 10 本面试必刷八股文。
<img src="https://files.mdnice.com/user/13837/4b47ac79-8256-47cf-ac1a-036729635246.png" alt="" loading="lazy"></p>
<hr>
<h1> 实战15：数组拷贝</h1>
<p>说实话，在实际的业务开发中，基本上很少很少很少...会遇到数组拷贝的场景，甚至是我们一般都不怎么用数组，List它不香嘛，为啥要用数组</p>
<p>现在问题来了，要实现数组拷贝，怎么整？</p>
<!-- more -->
<h2> 1. 实现方式</h2>
<h3> 1.1. 基础写法</h3>
<p>最简单直接的写法，那就是新建一个数组，一个一个拷贝进去，不就完事了么</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1.2. 借用容器中转</h3>
<p>数组用起来有点麻烦，还是用容器舒爽，借助List来实现数组的拷贝，也就几行代码</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1.3. Array.copy</h3>
<p>上面这个有点绕得远了， 直接使用Array.copy</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1.4. System.arraycopy</h3>
<p>除了上面的，还可以使用更基础的用法</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果有看过jdk源码的小伙伴，上面这个用法应该不会陌生，特别是在容器类，这种数组拷贝的方式比比可见</p>
<p>参数说明:</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>src : 原数组</li>
<li>srcPos: 原数组用于拷贝的起始下标</li>
<li>dest: 拷贝后的数组</li>
<li>destPos: 目标数组的小标</li>
<li>length: 原数组中拷贝过去的数组长度</li>
</ul>
<p>从上面的描述也能看出来，这个方法不仅能实现数组拷贝，还可以实现数组内指定片段的拷贝</p>
<hr>
<p>微信搜 <strong>楼仔</strong> 或扫描下方二维码关注楼仔的原创公众号，回复 <strong>110</strong> 即可免费领取 10 本面试必刷八股文。
<img src="https://files.mdnice.com/user/13837/4b47ac79-8256-47cf-ac1a-036729635246.png" alt="" loading="lazy"></p>
<hr>
<h1> 实战16：判断类为基础类型or基础类型的包装类</h1>
<p>判断一个类是否为基础类型属于常规操作了，一般我们遇到这种case，要怎么处理呢？</p>
<p>一个一个的if/else判断? 还是其他的操作姿势？</p>
<!-- more -->
<h2> 1. 基础类型判断</h2>
<p>基础类型可以借助class类的<code>isPrimitive</code>方法来实现判定，使用姿势也简单</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>如果返回true，那么这个对象就是基本类型</p>
<ul>
<li>boolean</li>
<li>char</li>
<li>byte</li>
<li>short</li>
<li>int</li>
<li>long</li>
<li>float</li>
<li>double</li>
<li>void</li>
</ul>
<p>但是请注意，对于封装类型，比如Long，访问isPrimitive返回的是false</p>
<h2> 2. 封装类型判断</h2>
<p>那么封装类型可以怎么判断呢？难道一个一个的判定不成？</p>
<p>首先我们注意到<code>Class#isPrimitive</code>的方法签名，如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的注释中，提到了Boolean#Type之类的静态成员，也就是说包装类型，都有一个TYPE的静态成员</p>
<p>比如boolean的是这个</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>所以我们可以通过这个TYPE来判定，当前对象是否为封装对象</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果Class对象没有TYPE字段，那么就不是封装类，直接抛异常，返回false；当然这种通过异常的方式来判定，并不优雅；但是写法上比我们一个一个的if/else进行对比，要好得多了</p>
<hr>
<p>微信搜 <strong>楼仔</strong> 或扫描下方二维码关注楼仔的原创公众号，回复 <strong>110</strong> 即可免费领取 10 本面试必刷八股文。
<img src="https://files.mdnice.com/user/13837/4b47ac79-8256-47cf-ac1a-036729635246.png" alt="" loading="lazy"></p>
<hr>
<h1> 实战17：Java对象内存地址输出</h1>
<h2> 输出对象地址</h2>
<p>当一个对象没有重写<code>hascode</code>方法时，它返回的内存地址，当覆盖之后，我们有什么办法获取对象的内存地址么?</p>
<ul>
<li>使用 <code>System.identityHashCode()</code> 输出内存地址</li>
</ul>
<!-- more -->
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果如:</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这个有啥用？</p>
<ul>
<li>判断两个对象是否为同一个对象时，可以借用（我是在验证Mybatis的一级缓存的，判断返回的Entity是否确实是同一个的时候以此来判定的）</li>
</ul>
<hr>
<p>微信搜 <strong>楼仔</strong> 或扫描下方二维码关注楼仔的原创公众号，回复 <strong>110</strong> 即可免费领取 10 本面试必刷八股文。
<img src="https://files.mdnice.com/user/13837/4b47ac79-8256-47cf-ac1a-036729635246.png" alt="" loading="lazy"></p>
<hr>
<h1> 实战18：随机数生成怎么选</h1>
<p>随机数生成，java中有一个专门的Random类来实现，除此之外，使用<code>Math.random</code>的也比较多，接下来我们简单学习下，随机数的使用姿势</p>
<!-- more -->
<h2> 1.随机数生成</h2>
<h3> 1.1. Math.random</h3>
<p>jdk提供的基础工具类Math中封装一些常用的基础方法，比如我们今天的主题，生成随机数，使用姿势如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>使用起来比较简单，生成的是[0,1)之间的浮点数，但是不要以为它就真的只能生成0-1之间的随机数，举例如下</p>
<p>如果想利用它，生成一个 <code>[120, 500]</code> 这个区间的随机数，怎么整？</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>为啥上面的可行？</p>
<p>将上面的代码翻译一下，取值区间如</p>
<p><code>Math.random() * 381 + 120</code> 取值范围如下</p>
<ul>
<li>[0, 1) * 381 + 120</li>
<li>[0, 381) + 120</li>
<li>[120, 501)</li>
</ul>
<p>借助<code>Math.ceil</code>只取浮点数中的整数部分，这样我们的取值范围就是 [120, 500]了，和我们的预期一致</p>
<p>最后简单来看下，<code>Math.random()</code>是怎么实现随机数的</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>请注意上面的实现，原来底层依然使用的是<code>Random</code>类来生成随机数，而且上面这种写法属于非常经典的单例模式写法（不同于我们常见的双重判定方式，这种属于内部类的玩法，后面再说为啥可以这么用）</p>
<h3> 1.2. Random</h3>
<p>除了使用上面的Math.random来获取随机数之外，直接使用Random类也是很常见的case；接下来先简单看一下Random的使用姿势</p>
<p><strong>创建Random对象</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>生成随机数</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>伪随机高斯分布双精度数</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>随机类的nextGaussian()方法返回下一个伪随机数，即与随机数生成器序列的平均值为0.0，标准差为1.0的高斯(正态)分布双精度值</p>
<p>这种使用场景可能用在更专业的场景，至少我接触过的业务开发中，没有用过这个😂</p>
<h3> 1.3. Math.random 与 Random如何选</h3>
<p>上面两个都可以用来生成随机数，那么在实际使用的时候，怎么选择呢？</p>
<p>从前面的描述也可以知道，它们两没啥本质区别，底层都是用的Random类，在实际的运用过程中，如果我们希望可以场景复现，比如测试中奖概率的场景下，选择Random类，指定随机种子可能更友好；如果只是简单的随机数生成使用，那么选择<code>Math.random</code>即可，至少使用起来一行代码即可</p>
<hr>
<p>微信搜 <strong>楼仔</strong> 或扫描下方二维码关注楼仔的原创公众号，回复 <strong>110</strong> 即可免费领取 10 本面试必刷八股文。
<img src="https://files.mdnice.com/user/13837/4b47ac79-8256-47cf-ac1a-036729635246.png" alt="" loading="lazy"></p>
<hr>
<h1> 实战19：数字格式化</h1>
<p>数字的格式化场景，更多的是在日志输出、金额计算相关的领域中会用到，平常我们可能更多使用<code>String.format</code>来格式化，但是请注意，数字格式化是有一个<code>DecimalFormat</code>，专门来针对数字进行格式化</p>
<p>今天我们的知识点就是DecimalFormat来实现数字格式化</p>
<!-- more -->
<h2> 1. 格式化</h2>
<h3> 1.1. DecimalFormat使用说明</h3>
<p>对于DecimalFormat的使用比较简单，主要是借助两个占位<code>0</code>与<code>#</code>，区别在于当格式化的占位数，多余实际数的时候，占位<code>0</code>的场景下，会用前缀0来补齐；而<code>#</code>则不需要补齐</p>
<p>上面这个可能不太好理解，举例说明如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面两个都是只输出整数，但是输出结果不同，如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>简单来说，就是<code>0</code>，主要用于定长的输出，对于不足的，前缀补0</p>
<p><strong>整数#小数</strong></p>
<p>除了上面的基本姿势之外，更常见的是设置整数、小数的位数</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>百分比</strong></p>
<p>百分比的输出也属于常见的case，使用DecimalFormat就很简单</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>输出如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>科学计数</strong></p>
<p>非专业场景下，科学技术的可能性比较小</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>金钱样式输出</strong></p>
<p>金融相关的钱输出时，非常有意思的是每三位加一个逗号分隔，如果想实现这个效果，也可以很简单完成</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>嵌入模板输出</strong></p>
<p>格式化模板，除了基础的<code>000, ###</code>之外，还可以直接放在一个字符串中，实现类似<code>String.format</code>的效果</p>
<p>比如显示余额</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><hr>
<p>微信搜 <strong>楼仔</strong> 或扫描下方二维码关注楼仔的原创公众号，回复 <strong>110</strong> 即可免费领取 10 本面试必刷八股文。
<img src="https://files.mdnice.com/user/13837/4b47ac79-8256-47cf-ac1a-036729635246.png" alt="" loading="lazy"></p>
<hr>
<h1> 实战20：进制转换很简单</h1>
<p>进制转换，属于基本技能了，在java中要实现进制转换很简单，可以非常简单的实现，接下来我们来看下它的使用姿势</p>
<!-- more -->
<h2> 1. 进制转换</h2>
<h3> 1.1. toString实现进制转换</h3>
<p>Integer/Long#toString(int i, int radix) 可以将任一进制的整数，转换为其他任意进制的整数</p>
<ul>
<li>第一个参数：待转换的数字</li>
<li>第二个参数：转换后的进制位</li>
</ul>
<p><strong>十六进制转十进制</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>八进制转是十进制</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>八进制转二进制</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 1.2. 十进制转二进制</h3>
<p>除了使用上面的姿势之外，可以直接使用<code>toBinaryString</code>来实现转二进制</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1.3. 十进制转八进制</h3>
<p><code>Integer/Long#toOctalString</code>: 转八进制</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 1.4. 十进制转十六进制</h3>
<p><code>Integer/Long#toHexString</code>: 转十六进制</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><hr>
<p>微信搜 <strong>楼仔</strong> 或扫描下方二维码关注楼仔的原创公众号，回复 <strong>110</strong> 即可免费领取 10 本面试必刷八股文。
<img src="https://files.mdnice.com/user/13837/4b47ac79-8256-47cf-ac1a-036729635246.png" alt="" loading="lazy"></p>
<hr>
<h1> 实战21：Properties配置文件</h1>
<p>properties配置文件，相信各位小伙伴都不会太陌生，常用Spring的可能会经常看到它，虽说现在更推荐的是使用Yaml配置文件，但是properties配置文件的使用频率也不低</p>
<p>在jdk中有一个直接关连的类Properties，接下来我们来看一下它的用法</p>
<!-- more -->
<h2> 1. Properties配置类</h2>
<h3> 1.1. 配置文件</h3>
<p>properties文件的格式比较简单</p>
<ul>
<li><code>key = value</code>: 等号左边的为配置key，右边的为配置value（value值会去除前后的空格）</li>
<li><code>#</code>：以<code>#</code>来区分注释</li>
</ul>
<p>一个基础的配置文件如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1.2. 配置文件加载</h3>
<p>对于Properties配置文件，我们可以非常简单的借助<code>Properties</code>类，来实现配置的加载</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>直接使用<code>Properties#config</code>就可以读取配置文件内容，并赋值到java对象</p>
<p><strong>重点注意：</strong></p>
<p>重点看一下Properties类的继承关系，它的父类是Hashtable, 也就是说它的本质是Map对象</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1.3. Properties对象使用</h3>
<p>因为<code>Properties</code>是继承自Hashtable，而Hashtable是线程安全的Map容器，因此Properties也是线程安全的，同样的，在多线程并发获取配置的时候，它的性能表现也就不咋地了，why?</p>
<p>首先看一下配置获取</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面两个方法的使用频率很高，从签名上也很容易知道使用姿势；接下来需要看一下的为啥说并发效率很低</p>
<p>关键点就在第一个方法的<code>super.get()</code>，它对应的源码正是</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>方法签名上有<code>synchronized</code>，所以为啥说并发环境下的性能表现不会特别好也就知道原因了</p>
<p>除了获取配置之外，另外一个常用的就是更新配置</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 2. 小结</h2>
<p>本文介绍的知识点主要是properties配置文件的处理，使用同名的java类来操作；需要重点注意的是Properties类属于Hashtable的子类，同样属于容器的范畴</p>
<p>最后提一个扩展的问题，在SpringBoot的配置自动装载中，可以将配置内容自动装载到配置类中，简单来讲就是支持配置到java bean的映射，如果现在让我们来实现这个，可以怎么整？</p>
<hr>
<p>微信搜 <strong>楼仔</strong> 或扫描下方二维码关注楼仔的原创公众号，回复 <strong>110</strong> 即可免费领取 10 本面试必刷八股文。
<img src="https://files.mdnice.com/user/13837/4b47ac79-8256-47cf-ac1a-036729635246.png" alt="" loading="lazy"></p>
<hr>
<h1> 实战22：Properties配置文件自动装载JavaBean</h1>
<p>SpringBoot的配置自动装载，使用起来还是很舒爽的，可以非常简单的将properties配置文件的内容，填充到Java bean对象中，如果我们现在是一个脱离于Springboot框架的项目，想实现上面这个功能，可以怎么来做呢？</p>
<!-- more -->
<h2> 1.配置封装</h2>
<h3> 1.1. 配置文件自动装载</h3>
<p>前面介绍了Properties文件的读取以及基本使用姿势，通过上篇博文已知Properties类的本质是一个Map，所以我们需要干的就是将Map容器的值，赋值到JavaBean的成员属性中</p>
<p>要实现这个功能，自然而然会想到的就是利用反射（考虑到我们赋值的通常为标准的java bean，使用内省是个更好的选择）</p>
<p>接下来我们需要实现的也比较清晰了，第一步获取成员属性，两种方式</p>
<ul>
<li>内省: <code>BeanInfo bean = Introspector.getBeanInfo(clz); PropertyDescriptor[] propertyDescriptors = bean.getPropertyDescriptors();</code></li>
<li>反射: <code>Field[] fields = clz.getDeclaredFields();</code></li>
</ul>
<p>第二步遍历成员属性，进行赋值</p>
<ul>
<li>内省：借助前面获取的<code>PropertyDescriptor</code>对象，拿到set方法，进行赋值
<ul>
<li><code>descriptor.getWriteMethod().invoke(obj, value)</code></li>
</ul>
</li>
<li>反射：适应<code>Field.set</code>来赋值
<ul>
<li><code>field.set(obj, value);</code></li>
</ul>
</li>
</ul>
<p><strong>注意</strong></p>
<ul>
<li>上面的两种赋值方式，都要求我们传入的value对象类型与定义类型一直，否则会抛类型转换异常</li>
</ul>
<p>为了避免复杂的类型转换与判定，我们这里介绍下apache的<code>commons-beanutils</code>来实现属性拷贝</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来核心的实现逻辑如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意上面的实现，首先通过内省的方式获取所有的成员，然后进行遍历，借助<code>BeanUtils.setProperty</code>来实现属性值设置</p>
<p>这里面有两个知识点</p>
<ul>
<li><code>BeanUtil</code> 还是 <code>PropertyUtil</code>
<ul>
<li>它们两都有个设置属性的方法，但是BeanUtil支持简单类型的自动转换；而后者不行，要求类型完全一致</li>
</ul>
</li>
<li>非简单类型
<ul>
<li>对于非简单类型，上面采用了递归的调用方式来处理；请注意，这里并不完善，比如BigDecimal, Date, List, Map这些相对基础的类型，是不太适用的哦</li>
</ul>
</li>
</ul>
<h3> 1.2. 功能测试</h3>
<p>最后针对上面的实现功能，简单的测试一下，是否可行</p>
<p>配置文件<code>mail.properties</code></p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>两个Java Bean</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>转换测试类</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果如下：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><hr>
<p>微信搜 <strong>楼仔</strong> 或扫描下方二维码关注楼仔的原创公众号，回复 <strong>110</strong> 即可免费领取 10 本面试必刷八股文。
<img src="https://files.mdnice.com/user/13837/4b47ac79-8256-47cf-ac1a-036729635246.png" alt="" loading="lazy"></p>
<hr>
<h1> 实战23：基于引入包选择具体实现类</h1>
<p>最近遇到一个需求场景，开源的工具包，新增了一个高级特性，会依赖json序列化工具，来做一些特殊操作；但是，这个辅助功能并不是必须的，也就是说对于使用这个工具包的业务方而言，正常使用完全不需要json相关的功能；如果我强引用某个json工具，一是对于不适用高级特性的用户而言没有必要；二则是我引入的json工具极有可能与使用者的不一致，会增加使用者的成本</p>
<p>因此我希望这个工具包对外提供时，并不会引入具体的json工具依赖；也就是说maven依赖中的<code>&lt;scope&gt;</code>设置为<code>provided</code>；具体的json序列化的实现，则取决于调用方自身引入了什么json工具包</p>
<p>那么可以怎么实现上面这个方式呢？</p>
<!-- more -->
<h2> 1.实现方式</h2>
<h3> 1.1. 任务说明</h3>
<p>上面的简单的说了一下我们需要做的事情，接下来我们重点盘一下，我们到底是要干什么</p>
<p>核心诉求相对清晰</p>
<ol>
<li>不强引入某个json工具</li>
<li>若需要使用高级特性，则直接使用当前环境中已集成的json序列化工具；若没有提供，则抛异常，不支持</li>
</ol>
<p>对于上面这个场景，常年使用Spring的我们估计不会陌生，Spring集成了很多的第三方开源组件，根据具体的依赖来选择最终的实现，比如日志，可以是logback，也可以是log4j；比如redis操作，可以是jedis，也可以是lettuce</p>
<p>那么Spring是怎么实现的呢？</p>
<h3> 1.2.具体实现</h3>
<p>在Spring中有个注解名为<code>ConditionalOnClass</code>，表示当某个类存在时，才会干某些事情（如初始化bean对象）</p>
<p>它是怎么是实现的呢？（感兴趣的小伙伴可以搜索一下，或者重点关注下 <code>SpringBootCondition</code> 的实现）</p>
<p>这里且抛开Spring的实现姿势，我们采用传统的实现方式，直接判断是否有加载对应的类，来判断有没有引入相应的工具包</p>
<p>如需要判断是否引入了gson包，则判断ClassLoader是否有加载<code>com.google.gson.Gson</code>类</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这种实现方式就可以达到我们的效果了；接下来我们参考下Spring的ClassUtils实现，做一个简单的封装，以判断是否存在某个类</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>工具类存在之后，我们实现一个简单的json工具类，根据已有的json包来选择具体的实现</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的实现中，根据已有的json序列化工具，选择具体的实现类，我们定义了一个JsonApi接口，然后分别gson,jackson,fastjson给出默认的实现类</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>最后的问题来了，如果调用方并没有使用上面三个序列化工具，而是使用其他的呢，可以支持么？</p>
<p>既然我们定义了一个JsonApi，那么是不是可以由用户自己来实现接口，然后自动选择它呢？</p>
<p>现在的问题就是如何找到用户自定义的接口实现了</p>
<h3> 1.3. 扩展机制</h3>
<p>对于SPI机制比较熟悉的小伙伴可能非常清楚，可以通过在配置目录<code>META-INF/services/</code>下新增接口文件，内容为实现类的全路径名称，然后通过 <code>ServiceLoader.load(JsonApi.class)</code> 的方式来获取所有实现类</p>
<p>除了SPI的实现方式之外，另外一个策略则是上面提到的Spring的实现原理，借助字节码来处理（详情原理后面专文说明）</p>
<p>当然也有更容易想到的策略，扫描包路径下的class文件，遍历判断是否为实现类(额外注意jar包内的实现类场景)</p>
<p>接下来以SPI的方式来介绍下扩展实现方式，首先初始化JsonApi的方式改一下，优先使用用户自定义实现</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对于使用者而言，首先是实现接口</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接着就是实现定义, <code>resources/META-INF/services/</code> 目录下，新建文件名为 <code>com.github.hui.quick.plugin.qrcode.util.json.JsonApi</code></p>
<p>内容如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>然后完工~</p>
<h2> 2. 小结</h2>
<p>主要介绍一个小的知识点，如何根据应用已有的jar包来选择具体的实现类的方式；本文介绍的方案是通过ClassLoader来尝试加载对应的类，若能正常加载，则认为有；否则认为没有；这种实现方式虽然非常简单，但是请注意，它是有缺陷的，至于缺陷是啥...</p>
<p>除此之外，也可以考虑通过字节码的方式来判断是否有某个类，或者获取某个接口的实现；文中最后抛出了一个问题，如何获取接口的所有实现类</p>
<p>常见的方式有下面三类（具体介绍了SPI的实现姿势，其他的两种感兴趣的可以搜索一下）</p>
<ul>
<li>SPI定义方式</li>
<li>扫描包路径</li>
<li>字节码方式(如Spring，如Tomcat的<code>@HandlesTypes</code>)</li>
</ul>
<hr>
<p>微信搜 <strong>楼仔</strong> 或扫描下方二维码关注楼仔的原创公众号，回复 <strong>110</strong> 即可免费领取 10 本面试必刷八股文。
<img src="https://files.mdnice.com/user/13837/4b47ac79-8256-47cf-ac1a-036729635246.png" alt="" loading="lazy"></p>
<hr>
<h1> 实战24： 基于JDK的LRU算法实现</h1>
<h2> 1. LRU算法</h2>
<p>缓存淘汰算法--LRU算法LRU（Least recently used，最近最少使用）算法</p>
<p>根据数据的历史访问记录来进行淘汰数据，其核心思想是"如果数据最近被访问过，那么将来被访问的几率也更高"</p>
<p>再Java中可以非常简单的实现LRU算法，主要利用的是LinkedHashMap容器</p>
<h3> 1.1 LRU算法实现</h3>
<p>inkedHashMap底层就是用的HashMap加双链表实现的，而且本身已经实现了按照访问顺序的存储。此外，LinkedHashMap中本身就实现了一个方法removeEldestEntry用于判断是否需要移除最不常读取的数，方法默认是直接返回false，不会移除元素</p>
<p>因此我们只需要重写这个方法，可以实现当缓存满之后，就移除最不常用的数据</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意上面的访问，当i == 6 时，主动访问了一下 <code>一灰灰blog_2</code>，主要就是不希望淘汰掉它，再看下对应的输出</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>实际输出与我们预期一致</p>
<h3> 1.2 小结</h3>
<p>jdk中蕴含了大量的财富，就看我们能不能识别出来了；通常我非常推荐&lt;3年的小伙伴，有事没事多盘一下jdk的经典实现，比如各种容器的底层结构，并发类的设计思想等</p>
<hr>
<p>微信搜 <strong>楼仔</strong> 或扫描下方二维码关注楼仔的原创公众号，回复 <strong>110</strong> 即可免费领取 10 本面试必刷八股文。
<img src="https://files.mdnice.com/user/13837/4b47ac79-8256-47cf-ac1a-036729635246.png" alt="" loading="lazy"></p>
<hr>
<h1> 实战25： 数字型字面量中的下划线</h1>
<p>不知道有没有小伙伴看过下面这种写法，不用质疑，它没有语法错误；再很多开源的框架中可以看到类似的写法；这种再字面量中添加下划线的方式，是一种小却使用的编程小技巧，推荐给CURD开发者</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><!-- more -->
<h2> 1. Java7新特性之数字中使用下划线</h2>
<p>为了直观性而言，在大数之间，加上下划线用于肉眼区分，下面实例小结下用法</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>简单来说，就是在数中间，插上下划线，用于划分段落</p>
<h2> 2. 小结</h2>
<p>再字面量中添加下划线，主要用于分割大数，方便阅读，重点注意：</p>
<ul>
<li>不能在小数点正前后添加</li>
<li>不要在L/D/F等数据类型标识的正前方添加</li>
<li>不能作为数字开头，也不能作为结尾</li>
<li>不要往进制修饰符中间或后面添加</li>
</ul>
<hr>
<p>微信搜 <strong>楼仔</strong> 或扫描下方二维码关注楼仔的原创公众号，回复 <strong>110</strong> 即可免费领取 10 本面试必刷八股文。
<img src="https://files.mdnice.com/user/13837/4b47ac79-8256-47cf-ac1a-036729635246.png" alt="" loading="lazy"></p>
<hr>
<h1> 实战26：列表遍历删除使用实例</h1>
<p>在实际的业务开发中，容器的遍历可以说是非常非常常见的场景了，遍历删除呢，用的机会也不会少，但你真的会用么？</p>
<!-- more -->
<h2> 1. List遍历删除</h2>
<p>对于列表，这里以ArrayList进行举例说明，下面给出几种经常会遇到的写法</p>
<p>首先初始化一个list数组</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1.1. foreach</h3>
<p>这个属于我们最常见的foreach循环，在循环内部判断满足条件的直接删除</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这种写法导致的问题，很容易可以发现，因为上面代码跑完之后，堆栈就出来了</p>
<figure><img src="https://blog.hhui.top/hexblog/imgs/190521/00.jpg" alt="IMAGE" tabindex="0" loading="lazy"><figcaption>IMAGE</figcaption></figure>
<p>很典型的并发修改错误，在foreach循环中不允许删除,新增</p>
<h3> 1.2. 普通for循环</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这种写法呢？我们希望把列表中，第0，5，10，15位置的元素干掉，正常执行，倒是不会报错，然而输出的结果却和我们的预期不一致</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>for循环中，另外一种写法可能更加常见，为了避免每次都访问 <code>list.size()</code> 方法，我可能提前用一个变量保存数组大小</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这个问题就很明显了，数组越界</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1.3. 迭代方式</h3>
<p>下面这种可以说是标准的迭代删除的写法了，基本上大多都是这么玩</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1.4. jdk8+ 流方式</h3>
<p>jdk8+ 推荐下面这种写法，简洁明了</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2> 2. 小结</h2>
<p>注意不要在for/foreach遍历过程中删除元素，如果有移除元素的需求，使用迭代器；或者使用jdk8的流式写法也行</p>
<hr>
<p>微信搜 <strong>楼仔</strong> 或扫描下方二维码关注楼仔的原创公众号，回复 <strong>110</strong> 即可免费领取 10 本面试必刷八股文。
<img src="https://files.mdnice.com/user/13837/4b47ac79-8256-47cf-ac1a-036729635246.png" alt="" loading="lazy"></p>
<hr>
<h1> 实战27：HashMap遍历删除使用实例</h1>
<p>map的迭代删除，和我们常见的list，set不太一样，不能直接获取Iteraotr对象，提供的删除方法也是单个的，根据key进行删除，如果我们有个需求，将map中满足某些条件的元素删除掉，要怎么做呢？</p>
<!-- more -->
<h2> 1. Map 迭代删除</h2>
<p>迭代删除，在不考虑并发安全的前提下，我们看下可以怎么支持</p>
<h3> 1.1. 非常不优雅版本</h3>
<p>我们知道map并不是继承自Collection接口的，HashMap 也没有提供迭代支持，既然没法直接迭代，那我就老老实的low b版好了</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的实现怎么样？并没有什么毛病</p>
<p>(为啥不直接在遍历中删除？）</p>
<h3> 1.2. 正确姿势版</h3>
<p>虽然Map没有迭代，但是它的entrySet有啊，所以我们可以通过它来实现遍历删除</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这个可能是我们经常使用的操作姿势了，利用迭代器来操作元素</p>
<h3> 1.3. 简洁版</h3>
<p>到jdk8之后，针对容器提供了很多简洁的操作方式，迭代删除这方面可以说更加简单了</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 2. 小结</h2>
<p>和列表删除元素一样，不要在for/foreach迭代过程中删除数据，如有需要，迭代器才是正解；jdk8之后更推荐流式写法</p>
<hr>
<p>微信搜 <strong>楼仔</strong> 或扫描下方二维码关注楼仔的原创公众号，回复 <strong>110</strong> 即可免费领取 10 本面试必刷八股文。
<img src="https://files.mdnice.com/user/13837/4b47ac79-8256-47cf-ac1a-036729635246.png" alt="" loading="lazy"></p>
<hr>
<h1> 实战28：优雅的实现代码耗时统计</h1>
<p>在我们的实际开发中，多多少少会遇到统计一段代码片段的耗时的情况，我们一般的写法如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的写法没有什么毛病，但是看起来就不太美观了，那么有没有什么更优雅的写法呢？</p>
<!-- more -->
<h2> 1. 代理方式</h2>
<p>了解Spring AOP的同学可能立马会想到一个解决方法，如果想要统计某个方法耗时，使用切面可以无侵入的实现，如</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Spring AOP的底层支持原理为代理模式，为目标对象提供增强功能；在Spring的生态体系下，使用aop的方式来统计方法耗时，可以说少侵入且实现简单，但是有以下几个问题</p>
<ul>
<li>统计粒度为方法级别</li>
<li>类内部方法调用无法生效（详情可以参考博文：<a href="http://spring.hhui.top/spring-blog/2019/03/02/190302-SpringBoot%E5%9F%BA%E7%A1%80%E7%AF%87AOP%E4%B9%8B%E9%AB%98%E7%BA%A7%E4%BD%BF%E7%94%A8%E6%8A%80%E8%83%BD/" target="_blank" rel="noopener noreferrer">【SpringBoot 基础系列教程】AOP之高级使用技能</a>）</li>
</ul>
<h2> 2. AutoCloseable</h2>
<p>在JDK1.7引入了一个新的接口<code>AutoCloseable</code>, 通常它的实现类配合<code>try{}</code>使用，可在IO流的使用上，经常可以看到下面这种写法</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意上面的写法中，最值得关注一点是，不需要再主动的写<code>stream.close</code>了，主要原因就是在<code>try(){}</code>执行完毕之后，会调用方法<code>AutoCloseable#close</code>方法；</p>
<p>基于此，我们就会有一个大单的想法，下一个<code>Cost</code>类实现<code>AutoCloseable</code>接口，创建时记录一个时间，close方法中记录一个时间，并输出时间差值；将需要统计耗时的逻辑放入<code>try(){}</code>代码块</p>
<p>下面是一个具体的实现：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>执行后输出如下:</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果代码块抛异常，也会正常输出耗时么？</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>再次输出如下，并没有问题</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 3. 小结</h2>
<p>除了上面介绍的两种方式，还有一种在业务开发中不太常见，但是在中间件、偏基础服务的功能组件中可以看到，利用Java Agent探针技术来实现，比如阿里的arthas就是在JavaAgent的基础上做了各种上天的功能，后续介绍java探针技术时会专门介绍</p>
<p>下面小结一下三种统计耗时的方式</p>
<p><strong>基本写法</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>优点是简单，适用范围广泛；缺点是侵入性强，大量的重复代码</p>
<p><strong>Spring AOP</strong></p>
<p>在Spring生态下，可以借助AOP来拦截目标方法，统计耗时</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>优点：无侵入，适合统一管理（比如测试环境输出统计耗时，生产环境不输出）；缺点是适用范围小，且粒度为方法级别，并受限于AOP的使用范围</p>
<p><strong>AutoCloseable</strong></p>
<p>这种方式可以看做是第一种写法的进阶版</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>优点是：简单，适用范围广泛，且适合统一管理；缺点是依然有代码侵入</p>
<p><strong>说明</strong></p>
<p>上面第二种方法看着属于最优雅的方式，但是限制性强；如果有更灵活的需求，建议考虑第三种写法，在代码的简洁性和统一管理上都要优雅很多，相比较第一种可以减少大量冗余代码</p>
<hr>
<p>微信搜 <strong>楼仔</strong> 或扫描下方二维码关注楼仔的原创公众号，回复 <strong>110</strong> 即可免费领取 10 本面试必刷八股文。
<img src="https://files.mdnice.com/user/13837/4b47ac79-8256-47cf-ac1a-036729635246.png" alt="" loading="lazy"></p>
<hr>
<h1> 实战29：获取类路径的常见方式</h1>
<h2> 1. 资源路径查询</h2>
<p>在Java环境中，如何获取当前类的路径，如何获取项目根路径，可以说是比较常见的需求场景了，下面简单的记录一下</p>
<!-- more -->
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出如下:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 2. 小结</h2>
<ol>
<li><code>new File(this.getClass().getResource("/").getPath())</code>
<ul>
<li>获取类加载的根路径</li>
</ul>
</li>
<li><code>new File(this.getClass().getResource("").getPath())</code>
<ul>
<li>获取当前类的所在工程路径; 如果不加“/”  获取当前类的加载目录</li>
</ul>
</li>
<li><code>new File("").getCanonicalPath()</code>
<ul>
<li>获取项目路径</li>
</ul>
</li>
<li><code>this.getClass().getClassLoader().getResource("")</code></li>
<li><code>System.getProperty("user.dir")</code></li>
<li><code>System.getProperty("java.class.path")</code>
<ul>
<li>获取所有的类路径 包括jar包的路径</li>
</ul>
</li>
</ol>
<hr>
<p>微信搜 <strong>楼仔</strong> 或扫描下方二维码关注楼仔的原创公众号，回复 <strong>110</strong> 即可免费领取 10 本面试必刷八股文。
<img src="https://files.mdnice.com/user/13837/4b47ac79-8256-47cf-ac1a-036729635246.png" alt="" loading="lazy"></p>
<hr>
<h1> 实战30：JDK压缩与解压工具类</h1>
<p>在实际的应用场景中，特别是对外传输数据时，将原始数据压缩之后丢出去，可以说是非常常见的一个case了，平常倒是没有直接使用JDK原生的压缩工具类，使用Protosutff和Kryo的机会较多,正好在实际的工作场景中遇到了，现在简单的看下使用姿势</p>
<!-- more -->
<h2> 1. 压缩与解压工具类</h2>
<h3> 1.1. 基本实现</h3>
<p>主要借助的就是Deflater, Inflater两个工具类，其使用姿势如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>一个简单的测试</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1.2. 注意事项</h3>
<p>上面这个运作的还挺好，但在接入使用时，总是提示<code>java.util.zip.DataFormatException: incorrect header check</code>, 因为接受的是第三方传递过来的压缩数据，比较坑爹的是对方就写了个Deflater压缩，然后什么都没有了，那么这个是啥原因呢？</p>
<p>其实看下Deflater的构造方法，发现还可以传一个boolean值(nowrap), 官方说明是</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>简单来说，就是压缩时，如果nowrap为true，那么解压时也要为true；否则对不上时，就会抛异常</p>
<p>接下来简单对比下两种不同传参的情况，首先更新下工具类</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>测试如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果如下，从大小来看，前者小那么一点点</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 2. 小结</h2>
<p>一般来说，jdk自带的压缩与解压，除了方便之外，可能优势并不是那么的大，这里盗一张网上的对比表格</p>
<p>以下来自: <a href="https://www.cnblogs.com/lonelywolfmoutain/p/5563985.html" target="_blank" rel="noopener noreferrer">[java]序列化框架性能对比（kryo、hessian、java、protostuff）</a></p>
<table>
<thead>
<tr>
<th></th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>kryo</td>
<td>速度快，序列化后体积小</td>
<td>跨语言支持较复杂</td>
</tr>
<tr>
<td>hessian</td>
<td>默认支持跨语言</td>
<td>较慢</td>
</tr>
<tr>
<td>protostuff</td>
<td>速度快，基于protobuf</td>
<td>需静态编译</td>
</tr>
<tr>
<td>Protostuff-Runtime</td>
<td>无需静态编译，但序列化前需预先传入schema</td>
<td>不支持无默认构造函数的类，反序列化时需用户自己初始化序列化后的对象，其只负责将该对象进行赋值</td>
</tr>
<tr>
<td>jdk</td>
<td>使用方便，可序列化所有类</td>
<td>速度慢，占空间</td>
</tr>
</tbody>
</table>
<p>其次，在使用java的压缩与解压时，需要注意下，nowrap这个参数，需要保持一致，否则会报错</p>
<hr>
<p>微信搜 <strong>楼仔</strong> 或扫描下方二维码关注楼仔的原创公众号，回复 <strong>110</strong> 即可免费领取 10 本面试必刷八股文。
<img src="https://files.mdnice.com/user/13837/4b47ac79-8256-47cf-ac1a-036729635246.png" alt="" loading="lazy"></p>
<hr>
<h1> 实战31：深拷贝浅拷贝及对象拷贝的两种方式</h1>
<h2> 1. Java之Clone</h2>
<h3> 1.1 背景</h3>
<p>对象拷贝，是一个非常基础的内容了，为什么会单独的把这个领出来讲解，主要是先前遇到了一个非常有意思的场景</p>
<p>有一个任务，需要解析类xml标记语言，然后生成document对象，之后将会有一系列针对document对象的操作</p>
<p>通过实际的测试，发现生成Document对象是比较耗时的一个操作，再加上这个任务场景中，需要解析的xml文档是固定的几个，那么一个可以优化的思路就是能不能缓存住创建后的Document对象，在实际使用的时候clone一份出来</p>
<!-- more  -->
<h3> 1.2 内容说明</h3>
<p>看到了上面的应用背景，自然而言的就会想到深拷贝了，本篇博文则主要内容如下</p>
<ul>
<li>介绍下两种拷贝方式的区别</li>
<li>深拷贝的辅助工具类</li>
<li>如何自定义实现对象拷贝</li>
</ul>
<h2> 2. 深拷贝和浅拷贝</h2>
<h3> 2.1 定义说明</h3>
<p><strong>深拷贝</strong></p>
<p>相当于创建了一个新的对象，只是这个对象的所有内容，都和被拷贝的对象一模一样而已，即两者的修改是隔离的，相互之间没有影响</p>
<p><strong>浅拷贝</strong></p>
<p>也是创建了一个对象，但是这个对象的某些内容（比如A）依然是被拷贝对象的，即通过这两个对象中任意一个修改A，两个对象的A都会受到影响</p>
<p>看到上面两个简单的说明，那么问题来了</p>
<ul>
<li>浅拷贝中，是所有的内容公用呢？还是某些内容公用？</li>
<li>从隔离来将，都不希望出现浅拷贝这种方式了，太容易出错了，那么两种拷贝方式的应用场景是怎样的？</li>
</ul>
<h3> 2.2 浅拷贝</h3>
<p>一般来说，浅拷贝方式需要实现<code>Cloneable</code>接口，下面结合一个实例，来看下浅拷贝中哪些是独立的，哪些是公用的</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>结果分析：</p>
<ul>
<li>拷贝后获取的是一个独立的对象，和原对象拥有不同的内存地址</li>
<li>基本元素类型，两者是隔离的（虽然上面只给出了int，String）
<ul>
<li>基本元素类型包括:</li>
<li>int, Integer, long, Long, char, Charset, byte,Byte, boolean, Boolean, float,Float, double, Double, String</li>
</ul>
</li>
<li>非基本数据类型（如基本容器，其他对象等），只是拷贝了一份引用出去了，实际指向的依然是同一份</li>
</ul>
<p>其实，浅拷贝有个非常简单的理解方式：</p>
<p><strong>浅拷贝的整个过程就是，创建一个新的对象，然后新对象的每个值都是由原对象的值，通过 <code>=</code> 进行赋值</strong></p>
<p>这个怎么理解呢？</p>
<p>上面的流程拆解就是：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>那么=赋值有什么特点呢？</p>
<p>基本数据类型是值赋值；非基本的就是引用赋值</p>
<h3> 2.3 深拷贝</h3>
<p>深拷贝，就是要创建一个全新的对象，新的对象内部所有的成员也都是全新的，只是初始化的值已经由被拷贝的对象确定了而已</p>
<p>那么上面的实例改成深拷贝应该是怎样的呢？</p>
<p>可以加上这么一个方法</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果为：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>结果分析：</p>
<ul>
<li>深拷贝独立的对象</li>
<li>拷贝后对象的内容，与原对象的内容完全没关系，都是独立的</li>
</ul>
<p>简单来说，深拷贝是需要自己来实现的，对于基本类型可以直接赋值，而对于对象、容器、数组来讲，需要创建一个新的出来，然后重新赋值</p>
<h3> 2.4 应用场景区分</h3>
<p>深拷贝的用途我们很容易可以想见，某个复杂对象创建比较消耗资源的时候，就可以缓存一个蓝本，后续的操作都是针对深clone后的对象，这样就不会出现混乱的情况了</p>
<p>那么浅拷贝呢？感觉留着是一个坑，一个人修改了这个对象的值，结果发现对另一个人造成了影响，真不是坑爹么？</p>
<p>假设又这么一个通知对象长下面这样</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们现在随机挑选了一千个人，同时发送通知消息，所以需要创建一千个上面的对象，这些对象中呢，除了notifyUser不同，其他的都一样</p>
<p>在发送之前，突然发现要临时新增一条通知信息，如果是浅拷贝的话，只用在任意一个通知对象的notifyRules中添加一调消息，那么这一千个对象的通知消息都会变成最新的了；而如果你是用深拷贝，那么苦逼的得遍历这一千个对象，每个都加一条消息了</p>
<hr>
<h2> 3. 对象拷贝工具</h2>
<p>上面说到，浅拷贝，需要实现Clonebale接口，深拷贝一般需要自己来实现，那么我现在拿到一个对象A，它自己没有提供深拷贝接口，我们除了主动一条一条的帮它实现之外，有什么辅助工具可用么？</p>
<p>对象拷贝区别与clone，它可以支持两个不同对象之间实现内容拷贝</p>
<p><strong>Apache的两个版本：（反射机制）</strong></p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>Spring版本：（反射机制）</strong></p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>cglib版本：（使用动态代理，效率高）</strong></p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>从上面的几个有名的工具类来看，提供了两种使用者姿势，一个是反射，一个是动态代理，下面分别来看两种思路</p>
<h3> 3.1 借助反射实现对象拷贝</h3>
<p>通过反射的方式实现对象拷贝的思路还是比较清晰的，先通过反射获取对象的所有属性，然后修改可访问级别，然后赋值；再获取继承的父类的属性，同样利用反射进行赋值</p>
<p>上面的几个开源工具，内部实现封装得比较好，所以直接贴源码可能不太容易一眼就能看出反射方式的原理，所以简单的实现了一个, 仅提供思路</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的实现步骤还是非常清晰的，首先是找同名的属性，然后利用反射获取对应的值</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果找不到，则找getXXX, isXXX来获取</p>
<h3> 3.2 代理的方式实现对象拷贝</h3>
<p>Cglib的BeanCopier就是通过代理的方式实现拷贝，性能优于反射的方式，特别是在大量的数据拷贝时，比较明显</p>
<p>代理，我们知道可以区分为静态代理和动态代理，简单来讲就是你要操作对象A，但是你不直接去操作A，而是找一个中转porxyA, 让它来帮你操作对象A</p>
<p>那么这种技术是如何使用在对象拷贝的呢？</p>
<p>我们知道，效率最高的对象拷贝方式就是Getter/Setter方法了，前面说的代理的含义指我们不直接操作，而是找个中间商来赚差价，那么方案就出来了</p>
<p>将原SourceA拷贝到目标DestB</p>
<ul>
<li>创建一个代理 copyProxy</li>
<li>在代理中，依次调用 SourceA的get方法获取属性值，然后调用DestB的set方法进行赋值</li>
</ul>
<p>实际上BeanCopier的思路大致如上，具体的方案当然就不太一样了, 简单看了一下实现逻辑，挺有意思的一块，先留个坑，后面单独开个博文补上</p>
<p><strong>说明</strong></p>
<p>从实现原理和通过简单的测试，发现BeanCopier是扫描原对象的getXXX方法，然后赋值给同名的 setXXX 方法，也就是说，如果这个对象中某个属性没有get/set方法，那么就无法赋值成功了</p>
<hr>
<h2> 3. 小结</h2>
<h3> 3.1 深拷贝和浅拷贝</h3>
<p><strong>深拷贝</strong></p>
<blockquote>
<p>相当于创建了一个新的对象，只是这个对象的所有内容，都和被拷贝的对象一模一样而已，即两者的修改是隔离的，相互之间没有影响</p>
</blockquote>
<ul>
<li>完全独立</li>
</ul>
<p><strong>浅拷贝</strong></p>
<blockquote>
<p>也是创建了一个对象，但是这个对象的某些内容（比如A）依然是被拷贝对象的，即通过这两个对象中任意一个修改A，两个对象的A都会受到影响</p>
</blockquote>
<ul>
<li>等同与新创建一个对象，然后使用=，将原对象的属性赋值给新对象的属性</li>
<li>需要实现Cloneable接口</li>
</ul>
<h3> 3.2 对象拷贝的两种方法</h3>
<p><strong>通过反射方式实现对象拷贝</strong></p>
<p>主要原理就是通过反射获取所有的属性，然后反射更改属性的内容</p>
<p><strong>通过代理实现对象拷贝</strong></p>
<p>将原SourceA拷贝到目标DestB</p>
<p>创建一个代理 copyProxy
在代理中，依次调用 SourceA的get方法获取属性值，然后调用DestB的set方法进行赋值</p>
<hr>
<p>微信搜 <strong>楼仔</strong> 或扫描下方二维码关注楼仔的原创公众号，回复 <strong>110</strong> 即可免费领取 10 本面试必刷八股文。
<img src="https://files.mdnice.com/user/13837/4b47ac79-8256-47cf-ac1a-036729635246.png" alt="" loading="lazy"></p>
<hr>
<h1> 实战32：Java可以如何实现文件变动的监听</h1>
<p>应用中使用logback作为日志输出组件的话，大部分会去配置 <code>logback.xml</code> 这个文件，而且生产环境下，直接去修改logback.xml文件中的日志级别，不用重启应用就可以生效</p>
<p>那么，这个功能是怎么实现的呢？</p>
<!-- more -->
<h2> 1. 问题描述及分析</h2>
<p>针对上面的这个问题，首先抛出一个实际的case，在我的个人网站 * <a href="https://tool.hhui.top/" target="_blank" rel="noopener noreferrer">神奇工具箱 - 小工具集合</a> 中，所有的小工具都是通过配置文件来动态新增和隐藏的，因为只有一台服务器，所以配置文件就简化的直接放在了服务器的某个目录下</p>
<p>现在的问题时，我需要在这个文件的内容发生变动时，应用可以感知这种变动，并重新加载文件内容，更新应用内部缓存</p>
<p>一个最容易想到的方法，就是轮询，判断文件是否发生修改，如果修改了，则重新加载，并刷新内存，所以主要需要关心的问题如下：</p>
<ul>
<li>如何轮询？</li>
<li>如何判断文件是否修改？</li>
<li>配置异常，会不会导致服务不可用？（即容错，这个与本次主题关联不大，但又比较重要...）</li>
</ul>
<h2> 2. 设计与实现</h2>
<p>问题抽象出来之后，对应的解决方案就比较清晰了</p>
<ul>
<li>如何轮询 ？ --》 定时器 Timer, ScheduledExecutorService 都可以实现</li>
<li>如何判断文件修改？ --》根据 <code>java.io.File#lastModified</code> 获取文件的上次修改时间，比对即可</li>
</ul>
<p>那么一个很简单的实现就比较容易了:</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这个属于一个非常简单，非常基础的实现了，基本上也可以满足我们的需求，那么这个实现有什么问题呢？</p>
<p><strong>定时任务的执行中，如果出现了异常会怎样？</strong></p>
<p>对上面的代码稍作修改</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>实际测试，发现只有首次修改的时候，触发了上面的代码，但是再次修改则没有效果了，即当抛出异常之后，定时任务将不再继续执行了，这个问题的主要原因是因为 <code>ScheduledExecutorService</code> 的原因了</p>
<p>直接查看ScheduledExecutorService的源码注释说明</p>
<blockquote>
<p>If any execution of the task encounters an exception, subsequent executions are suppressed.Otherwise, the task will only terminate via cancellation or termination of the executor.
即如果定时任务执行过程中遇到发生异常，则后面的任务将不再执行。</p>
</blockquote>
<p><strong>所以，使用这种姿势的时候，得确保自己的任务不会抛出异常，否则后面就没法玩了</strong></p>
<p>对应的解决方法也比较简单，整个catch一下就好</p>
<h2> 3. 进阶版</h2>
<p>前面是一个基础的实现版本了，当然在java圈，基本上很多常见的需求，都是可以找到对应的开源工具来使用的，当然这个也不例外，而且应该还是大家比较属性的apache系列</p>
<h3> 3.1 apache版</h3>
<p>首先maven依赖</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>主要是借助这个工具中的 <code>FileAlterationObserver</code>, <code>FileAlterationListener</code>, <code>FileAlterationMonitor</code> 三个类来实现相关的需求场景了，当然使用也算是很简单了，以至于都不太清楚可以再怎么去说明了，直接看下面从我的一个开源项目quick-alarm中拷贝出来的代码</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>针对上面的实现，简单说明几点：</p>
<ul>
<li>这个文件监听，是以目录为根源，然后可以设置过滤器，来实现对应文件变动的监听</li>
<li>如上面<code>registerConfChangeListener</code>方法，传入的file是具体的配置文件，因此构建参数的时候，捞出了目录，捞出了文件名作为过滤</li>
<li>第二参数是jdk8语法，其中为具体的读取配置文件内容，并映射为对应的实体对象</li>
</ul>
<p>一个问题，如果 func方法执行时，也抛出了异常，会怎样？</p>
<p>实际测试表现结果和上面一样，抛出异常之后，依然跪，所以依然得注意，不要跑异常</p>
<p>那么简单来看一下上面的实现逻辑，直接扣出核心模块</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从上面基本上一目了然，整个的实现逻辑了，和我们的第一种定时任务的方法不太一样，这儿直接使用线程，死循环，内部采用sleep的方式来来暂停，因此出现异常时，相当于直接抛出去了，这个线程就跪了</p>
<h3> 3.2 JDK版本</h3>
<p>jdk1.7，提供了一个<code>WatchService</code>，也可以用来实现文件变动的监听，之前也没有接触过，看到说明，然后搜了一下使用相关，发现也挺简单的，同样给出一个简单的示例demo</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 4. 小结</h2>
<p>使用Java来实现配置文件变动的监听，主要涉及到的就是两个点</p>
<ul>
<li>如何轮询：  定时器（Timer, ScheduledExecutorService）, 线程死循环+sleep</li>
<li>文件修改： File#lastModified</li>
</ul>
<p>整体来说，这个实现还是比较简单的，无论是自定义实现，还是依赖 commos-io来做，都没太大的技术成本，但是需要注意的一点是：</p>
<ul>
<li>千万不要在定时任务 or 文件变动的回调方法中抛出异常！！！</li>
</ul>
<p>为了避免上面这个情况，一个可以做的实现是借助EventBus的异步消息通知来实现，当文件变动之后，发送一个消息即可，然后在具体的重新加载文件内容的方法上，添加一个 <code>@Subscribe</code>注解即可，这样既实现了解耦，也避免了异常导致的服务异常 （如果对这个实现有兴趣的可以评论说明）</p>
<hr>
<p>微信搜 <strong>楼仔</strong> 或扫描下方二维码关注楼仔的原创公众号，回复 <strong>110</strong> 即可免费领取 10 本面试必刷八股文。
<img src="https://files.mdnice.com/user/13837/4b47ac79-8256-47cf-ac1a-036729635246.png" alt="" loading="lazy"></p>
<hr>
<h1> 实战33：实用的Map初始化工具类</h1>
<p>虽说java作为编译语言，但是它本身也提供了很多运行时能力，今天介绍一个非常基础的知识点，可变参数传递</p>
<!-- more -->
<p>在日常的开发过程中，创建Map对象还是比较常见的，现在我希望写一个工具类，可以非常简单创建并初始化Map对象</p>
<p>因此我们可以实现一个MapUtil工具类，来支持这个场景</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意一下上面的实现，kv这个参数就是我们要说的可变参数，在方法内部，kv可以看成是一个数组对象（而且是安全的对象，当不传递时，它的取值也不是null）</p>
<p>在使用可变参数时，下面是一些需要注意的点</p>
<p><strong>可变参数注意与数组参数的冲突</strong></p>
<p>注意下面的两个方法，不能同时出现，直接出现编译错误</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>重载的选择</strong></p>
<p>如果只有一个可变参数的方法，<code>newMap("key", "value")</code>不会报错，会直接访问下面这个方法，kv参数为空数组</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>当出现重载时，即如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>上面两个方法的调用，如果传参只有两个时，会调用哪个？</p>
<ul>
<li><code>newMap("key", "value")</code> 调用的下面的方法</li>
<li>`newMap("key", "value", "k", "v") 调用的上面的方法</li>
</ul>
<p><strong>可变参数传数组会怎样</strong></p>
<p>虽说我们在使用的时候，将可变参数当做数组来使用，但是传递时，若传数组，是否可行呢？</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>实际输出如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>从实际测试来看，传数组并没有问题</p>
<hr>
<p>微信搜 <strong>楼仔</strong> 或扫描下方二维码关注楼仔的原创公众号，回复 <strong>110</strong> 即可免费领取 10 本面试必刷八股文。
<img src="https://files.mdnice.com/user/13837/4b47ac79-8256-47cf-ac1a-036729635246.png" alt="" loading="lazy"></p>
<hr>
<h1> 实战34：通用的根据路径获取文件资源的工具类</h1>
<p>通常我们最多的场景是从本地资源中读取文件，这个时候我们经常需要注意的是相对路径、绝对路径问题；</p>
<p>除了从本地获取文件之外，从网络中获取文件资源（如图片）也属于相对常见的场景，接下来我们封装一个工具类，可以支持以上各种类型的数据读取</p>
<!-- more -->
<h2> 1. 工具实现类</h2>
<p>首先定义一个公共方法如下，内部支持四种方式的数据获取</p>
<ul>
<li>相对路径</li>
<li>绝对路径</li>
<li>用户根目录</li>
<li>网络</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>请注意上面的实现，绝对路径与相对路径比较好理解，用户目录，这个处理又是怎样的呢？</p>
<p>关键点在于，用户目录转绝对路径</p>
<ul>
<li>借助<code>System.getProperties</code>系统属性来处理</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来再看如何判断一个路径是否为绝对路径呢？</p>
<p>这里需要格外注意不同操作系统的差异性，比如win，区分C盘，D盘，但是mac/linux则不分这个，上面判断的核心逻辑如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>除了上面的三种本地资源获取之外，还有一个就是网络资源的读取，上面介绍的实现姿势主要是基于JDK原生的URL，在实际使用时，这个并不稳定，不能确定能获取到完整的数据，原则上不推荐使用；如果可以，使用http-client/okhttp都是不错的选择</p>
<p>最后给一个简单的测试</p>
<p>最后一个简单下载图片的case</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0542b4ae409b4336a431fac44c1cef5f~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure>
<hr>
<p>微信搜 <strong>楼仔</strong> 或扫描下方二维码关注楼仔的原创公众号，回复 <strong>110</strong> 即可免费领取 10 本面试必刷八股文。
<img src="https://files.mdnice.com/user/13837/4b47ac79-8256-47cf-ac1a-036729635246.png" alt="" loading="lazy"></p>
<hr>
<h1> 实战35：调用本地程序的几种姿势</h1>
<p>作为一个后端同学，经常被安全的小伙伴盯上，找一找安全漏洞；除了常说的注入之外，还有比较吓人的执行远程命令，唤醒本地应用程序等；然后有意思的问题就来了，写了这么多年的代码，好像还真没有尝试过用java来唤醒本地应用程序的</p>
<p>比如说一个最简单的，打开本地的计算器，应该怎么搞？</p>
<p>接下来本文将介绍一下如何使用java打开本地应用，以及打开mac系统中特殊一点的处理方式（直白来说就是不同操作系统，使用姿势不一样）</p>
<!-- more -->
<h2> 1. Runtime使用方式</h2>
<p>主要是基于<code>Runtime.getRuntime().exec()</code>来执行shell命令，来打开应用</p>
<ul>
<li>传参就是需要打开的应用名</li>
</ul>
<p>比如上面说到的打开计算器</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从上面的传参也可以看出两者的区别，为什么mac会整一个 <code>open -n</code>， 这个其实可以理解为在终端执行命令，打开计算器</p>
<p><strong>注意事项</strong></p>
<p>对于mac系统而言，除了上面这种打开方式之外，还有下面这种姿势</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>在exec中指定计算器的路径，有个很容易采的坑，直接写成下面这种</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面这个直接执行之后会提示<code>权限错误</code>，其主要原因是mac系统的应用和win中的exe作为启动方式不太一样，对于mac而言，可以理解<code>xxx.app</code>为一个目录，真正执行文件是内部的<code>xxx/Contents/MacOS/xxx</code></p>
<h2> 2. ProcessBuilder使用方式</h2>
<p>除了Runtime唤起之外，使用ProcessBuilder也属于非常常见的case</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用上面这种姿势，特别需要注意的是内部传参不能是<code>open -n</code></p>
<h2> 3. 小结</h2>
<p>从上面介绍的方式来看，其实打开应用程序的思路主要就是利用java来执行脚本命令；内容比较简单，隐患却是比较大的；在自己的项目中，最好不要出现这种调用方式</p>
<p>微信搜 <strong>楼仔</strong> 或扫描下方二维码关注楼仔的原创公众号，回复 <strong>110</strong> 即可免费领取 10 本面试必刷八股文。
<img src="https://files.mdnice.com/user/13837/4b47ac79-8256-47cf-ac1a-036729635246.png" alt="" loading="lazy"></p>
<hr>
<h1> 实战36：技术派开源项目</h1>
<p>大家好，足足搞了半年，我们的第一个项目——技术派，终于上线啦！</p>
<p>之前就有很多粉丝催，久等了各位！心急的小伙伴，可以到文末直接看网站域名。</p>
<p>在此之前，我先来介绍（吹一吹）网站。</p>
<h2> 网站内容有什么？</h2>
<p>技术派致力于打造一个完整的社区平台，采用现阶段最流行的技术实现。</p>
<p>网站的内容丰富，又不失整洁，整体以橘色为主色调，颜值很高。</p>
<figure><img src="https://files.mdnice.com/user/13837/180e1ba7-7074-43b7-9250-ac6bc158b1a9.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>什么，卡片的颜色不喜欢？我们还有其它的，<strong>这些色系是根据图片自动识别</strong>，满满的黑科技。</p>
<figure><img src="https://files.mdnice.com/user/13837/0d4b3010-58a1-4279-9268-574981ca81e9.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>再看看文章详情页，整个阅读体验非常不错。</p>
<figure><img src="https://files.mdnice.com/user/13837/9d52c137-5b44-4ffe-a6a8-98df2d40f739.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>除了文章，我们还有配套的教程，目前的教程，都是楼仔的原创系列文章，让你刷得飞起，嘎嘎。。。</p>
<figure><img src="https://files.mdnice.com/user/13837/4492a683-f131-4320-b8fe-e3d5e78a567e.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>下面是个人中心，还是我喜欢的配色，如果你也喜欢写文，欢迎入驻哈，没事一起侃侃大山。</p>
<figure><img src="https://files.mdnice.com/user/13837/5b9617c7-b728-4824-9331-b538933b7e3a.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>那如何登录呢？当然是微信扫码呗，来来，一起扫一扫，公众号内输入验证码，即可登录成功，是不是很方便？</p>
<figure><img src="https://files.mdnice.com/user/13837/8d8b4592-0e64-49e7-8caf-a8386f60cb08.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>告诉你一个秘密，<strong>登录后，还会有惊喜哦</strong>，一般人我不告诉他，嘿嘿。。。</p>
<p>除了前端，我们也有自己的运营后台，文末有登录方式。</p>
<figure><img src="https://files.mdnice.com/user/13837/fbacda81-41a9-4f88-8eac-d3826828df47.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> 技术派能给你提供什么帮助呢？</h2>
<p>可能有粉丝会问 “市面上的技术网站已经很多，你们为啥还要做一个呢？”</p>
<p>其实我们做这个网站的目的，<strong>主要是为了教大家如何从 0 到 1 去构建一个商业化的社区平台</strong>，特别是对于那些缺乏项目经验，或者需要深入学习 Java 的同学。</p>
<p>下面我就给大家讲讲，技术派用到哪些牛逼的框架的技术。</p>
<p>技术派包括前台社区系统和后台管理系统，基于 SpringBoot + MyBatis Plus 实现，采用 Docker 容器化部署。</p>
<p><strong>前台社区系统</strong>包括首页门户、文章浏览、文章编辑、文章搜索、系列教程、登录鉴权、用户评论、点赞收藏、个人中心、消息通知、广告运营、粉丝管理等模块。</p>
<p><strong>后台管理系统</strong>包括数据统计、运营配置、分类管理、标签管理、文章管理、教程配置、教程文章、权限管理等模块。</p>
<p>是不是讲的太泛？给你来一张系统架构图，所有的模块和技术，都能一目了然。</p>
<figure><img src="https://files.mdnice.com/user/13837/6cfb2a84-78cd-45b6-80b3-15ab422997c4.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>再来一张业务架构图，让你对前后台模块更清晰。</p>
<figure><img src="https://files.mdnice.com/user/13837/7720af6c-2ae4-47ea-aad4-593d74347d81.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>有同学会说，楼哥，我想要更详细的模块介绍，好好学学，好嘞，下面就给安排上。</p>
<figure><img src="https://files.mdnice.com/user/13837/ac8f2050-5d19-447e-be3b-19776c11e32a.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>这个是我们的开发进度，核心功能都已完成，后面也会持续迭代。</p>
<figure><img src="https://files.mdnice.com/user/13837/86ee6878-33cf-4bc8-a746-a8648ac5256c.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>最后就是大家最关心的地方，我们的项目源码能下载么，那必须的，我们的项目完全开源！</p>
<p>对，你没有听错，文末有 GitHub 地址，大家可以自行下载。</p>
<p>同时，我们后续也会出配套的项目教程，无论你是小白，还是有一定工作经验的同学，这套教程都会帮你进阶，让你大厂 Offer 拿到手软。</p>
<p>这套教程直接对标大厂，下面是教程目录。</p>
<figure><img src="https://files.mdnice.com/user/13837/f84b0111-4cf3-41e1-a8bd-ada028071b04.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>由于出教程比较花时间，所以前期的教程，会在楼仔的公众号中连载，请大家持续关注哈。</p>
<p>最后告诉大家一个秘密，后面我们也会开通<strong>技术派的知识星球</strong>，更好去帮助大家学习这个项目，有没有亿点小期待呢？</p>
<h2> 网站地址</h2>
<p>好了，楼仔不啰嗦了，大家自己去体验下网站吧。</p>
<ul>
<li>
<p><strong>前台地址</strong>：<a href="https://paicoding.com" target="_blank" rel="noopener noreferrer">https://paicoding.com</a></p>
</li>
<li>
<p><strong>后台地址</strong>：<a href="https://paicoding.com/admin-view" target="_blank" rel="noopener noreferrer">https://paicoding.com/admin-view</a></p>
</li>
</ul>
<p>前台可以直接访问，后台需要扫描/长按下方的二维码关注「楼仔」的公众号后，<strong>回复 “001” 即可获取登录账号和密码。</strong></p>
<figure><img src="https://files.mdnice.com/user/13837/e670d6d3-b4d8-4c17-80c0-fa2dd68000e4.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>大家在体验的过程中，如果发现任何问题，都可以直接在 Github 上提交 PR，我们会定期 fix。</p>
<ul>
<li>
<p>前台社区系统 GitHub：<a href="https://github.com/itwanger/paicoding" target="_blank" rel="noopener noreferrer">https://github.com/itwanger/paicoding</a></p>
</li>
<li>
<p>后台管理系统 GitHub：<a href="https://github.com/itwanger/paicoding-admin" target="_blank" rel="noopener noreferrer">https://github.com/itwanger/paicoding-admin</a></p>
</li>
</ul>
<p>欢迎大家奔走相告，将技术派网站分享给你们的朋友，他们一定很感激你告诉他这么牛逼的学习资源。</p>
<blockquote>
<p>我从清晨走过，也拥抱夜晚的星辰，人生没有捷径，你我皆平凡，你好，陌生人，一起共勉。</p>
</blockquote>
]]></content:encoded>
      <enclosure url="http://cdn.hhui.top/column/java_cover.png" type="image/png"/>
    </item>
    <item>
      <title>关于我</title>
      <link>https://liuyueyi.github.io/tutorial/me/</link>
      <guid>https://liuyueyi.github.io/tutorial/me/</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">关于我</source>
      <description>关于我</description>
      <pubDate>Fri, 17 Feb 2023 14:22:08 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 关于我</h2>
]]></content:encoded>
    </item>
    <item>
      <title>关于我</title>
      <link>https://liuyueyi.github.io/tutorial/me/about-me.html</link>
      <guid>https://liuyueyi.github.io/tutorial/me/about-me.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">关于我</source>
      <description>1. 自我介绍 不习惯分享私人相关的，简单说几个关键点 常用名：一灰，一灰灰，一灰灰blog 性别：男 工作：8+ 履历：一线大厂、千人规模、创业团队、国企都待过 2. 有啥成就 比较惭愧，没有太大的成就，业内也不算出名，甚至是小透明 个人网站： www.hhui.top GitHub： https://github.com/liuyueyi 上架的app： https://play.google.com/store/apps/details?id=com.yhh.zhongdian 活跃网站： https://juejin.cn/user/377887729916126</description>
      <pubDate>Fri, 17 Feb 2023 14:22:08 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 1. 自我介绍</h2>
<p>不习惯分享私人相关的，简单说几个关键点</p>
<ul>
<li>常用名：一灰，一灰灰，一灰灰blog</li>
<li>性别：男</li>
<li>工作：8+</li>
<li>履历：一线大厂、千人规模、创业团队、国企都待过</li>
</ul>
<h2> 2. 有啥成就</h2>
<p>比较惭愧，没有太大的成就，业内也不算出名，甚至是小透明</p>
<ul>
<li>个人网站： <a href="www.hhui.top">www.hhui.top</a></li>
<li>GitHub： <a href="https://github.com/liuyueyi" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi</a></li>
<li>上架的app： <a href="https://play.google.com/store/apps/details?id=com.yhh.zhongdian" target="_blank" rel="noopener noreferrer">https://play.google.com/store/apps/details?id=com.yhh.zhongdian</a></li>
<li>活跃网站： <a href="https://juejin.cn/user/377887729916126" target="_blank" rel="noopener noreferrer">https://juejin.cn/user/377887729916126</a></li>
</ul>
<h2> 3. 什么时候开始的分享</h2>
<p>最早是在16、17年的时候开始在开源中国上分享一些自己的笔记，然后就一直坚持了下来，至今所有的文章加起来应该也有五六百篇了，当然其中有很多比较水；但也有不少文章是注入了心血的</p>
<p>有到我站点逛的小伙伴可能也看到了，有几个分站</p>
<ul>
<li><a href="https://blog.hhui.top" target="_blank" rel="noopener noreferrer">https://blog.hhui.top</a> ： 最早搭建的博客站点，记录的内容多，且零散，检索阅读并不友好，虽然东西很多，但是很多时候我自己都找不到，更何况其他的小伙伴呢</li>
<li><a href="https://spring.hhui.top" target="_blank" rel="noopener noreferrer">https://spring.hhui.tpp</a>： 这个站点相比于上面一个更垂直一点，全是spring相关的博文，每一篇文章都搭配有对应的项目源码，目前也在持续更新迭代中</li>
<li><a href="https://hhui.top" target="_blank" rel="noopener noreferrer">https://hhui.top</a>：主站点，为了解决上面说到的知识点分散的问题，近期我也在做知识汇总，形成一个一个专栏性质的小册，后续也会逐渐整理为pdf，供有离线学习诉求的小伙伴查阅</li>
</ul>
<h2> 4. 最近在干什么</h2>
<p>在22年中开始，和楼仔（强烈推荐关注他的公众号“楼仔”，分享的都是技术干活）凑一起搞事情，目前项目已上线，一个开源的博客论坛系统，将会围绕这个项目，出一版相关的教程，希望能基于此为各位有志于从事编程事业的小伙伴，提供一个极佳的练手项目、学习平台</p>
<ul>
<li>源码地址：<a href="https://github.com/itwanger/paicoding" target="_blank" rel="noopener noreferrer">https://github.com/itwanger/paicoding</a></li>
<li>论坛地址：<a href="https://paicoding.com/" target="_blank" rel="noopener noreferrer">https://paicoding.com/</a></li>
</ul>
<h2> 5. 有公众号么</h2>
<p>我的公众号是："一灰灰blog"， 有兴趣的小伙伴可以关注一波</p>
<figure><img src="https://spring.hhui.top/spring-blog/imgs/info/info.png" alt="一灰灰的公众号" tabindex="0" loading="lazy"><figcaption>一灰灰的公众号</figcaption></figure>
<p>我的小伙伴楼仔的公众号： "楼仔" 同时也推荐各位</p>
<figure><img src="https://files.mdnice.com/user/13837/4b47ac79-8256-47cf-ac1a-036729635246.png" alt="楼仔的公众号" tabindex="0" loading="lazy"><figcaption>楼仔的公众号</figcaption></figure>
<h2> 6. 有什么学习的资料么</h2>
<p>找楼仔，他有很多pdf</p>
<h2> 7. 有什么学习的建议么</h2>
<p>我一般做不来指路明灯，或者导师的角色；一个建议就是跟着大佬后面走</p>
<h2> 8. 怎么联系我</h2>
<ul>
<li>QQ : 3302797840</li>
<li>微信 : liuyueyi25</li>
<li>邮箱 : <a href="mailto:bangzewu@126.com">bangzewu@126.com</a></li>
<li>微博 : 一灰灰blog (基本上不活跃)</li>
</ul>
]]></content:encoded>
      <enclosure url="https://spring.hhui.top/spring-blog/imgs/info/info.png" type="image/png"/>
    </item>
    <item>
      <title>1.字符串占位替换</title>
      <link>https://liuyueyi.github.io/tutorial/java/skill/01.%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8D%A0%E4%BD%8D%E6%9B%BF%E6%8D%A2.html</link>
      <guid>https://liuyueyi.github.io/tutorial/java/skill/01.%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8D%A0%E4%BD%8D%E6%9B%BF%E6%8D%A2.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">1.字符串占位替换</source>
      <description>实战1：字符串占位替换 字符串占位替换，相信没有小伙伴是陌生的，这东西可以说是伴随着我们所有的项目工程，编码过程；别不相信，如 String.format sql参数拼接的占位 log日志输出 接下来我们看一下在我们的日常工作生涯中，经常涉及到的几种占位替换方式</description>
      <category>Java</category>
      <category>编程技巧</category>
      <pubDate>Mon, 09 Aug 2021 08:53:46 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 实战1：字符串占位替换</h1>
<p>字符串占位替换，相信没有小伙伴是陌生的，这东西可以说是伴随着我们所有的项目工程，编码过程；别不相信，如</p>
<ul>
<li>String.format</li>
<li>sql参数拼接的占位</li>
<li>log日志输出</li>
</ul>
<p>接下来我们看一下在我们的日常工作生涯中，经常涉及到的几种占位替换方式</p>
<!-- more -->
<h2> 1. String.format</h2>
<p>这种可以说是最原始最基础的方式了，基本上在最开始学习java这门语言的时候就会涉及到，语法也比较简单</p>
<p>举例如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>使用<code>%</code>来表示占位，后面跟上不同的标识符，用于限定这个占位处的参数类型</p>
<p>这种使用姿势，由jdk原生提供支持，下表为不同的转换符对应的说明</p>
<table>
<thead>
<tr>
<th>转换符</th>
<th>说明</th>
<th>参数实例</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>%s</code></td>
<td>字符串替换</td>
<td>"一灰灰"</td>
</tr>
<tr>
<td><code>%c</code></td>
<td>字符类型</td>
<td>'a'</td>
</tr>
<tr>
<td><code>%b</code></td>
<td>布尔类型</td>
<td>true/false</td>
</tr>
<tr>
<td><code>%d</code></td>
<td>整数，十进制</td>
<td>10</td>
</tr>
<tr>
<td><code>%x</code></td>
<td>整数，十六进制</td>
<td>0x12</td>
</tr>
<tr>
<td><code>%o</code></td>
<td>整数，八进制</td>
<td>012</td>
</tr>
<tr>
<td><code>%f</code></td>
<td>浮点</td>
<td>0.12f</td>
</tr>
<tr>
<td><code>%e</code></td>
<td>指数</td>
<td>2e2</td>
</tr>
<tr>
<td><code>%g</code></td>
<td>通用浮点型</td>
<td></td>
</tr>
<tr>
<td><code>%h</code></td>
<td>散列</td>
<td></td>
</tr>
<tr>
<td><code>%%</code></td>
<td>百分比</td>
<td></td>
</tr>
<tr>
<td><code>%n</code></td>
<td>换行</td>
<td></td>
</tr>
<tr>
<td><code>%tx</code></td>
<td>日期与时间类型（x代表不同的日期与时间转换符</td>
<td></td>
</tr>
</tbody>
</table>
<p>虽然上面表中列出了很多，但实际使用时，<code>%s</code>, <code>%d</code>, <code>%f</code> 这三个就足以应付绝大部分的场景了；使用姿势和上面的实例参不多，第一个参数为字符串模板，后面的可变参数为待替换的值</p>
<p>下面是在实际使用过程中的注意事项</p>
<h3> 1.1 类型不匹配</h3>
<p>上面的表中介绍了不同的转换符，要求的参数类型，如果没有对应上，会怎样</p>
<p><strong><code>%s</code>，传入非字符串类型</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>也就是说，<code>%s</code>的占位标记，传参如果不是String类型，那么实际替换的是 <code>arg.toString()</code> (所以数组输出的是地址，而list输出了内容)</p>
<p><strong><code>%d</code>，传入非整数</strong></p>
<p>与字符串的不一样的是，如果我们定义要求替换的参数类型为整数，那么传参不是整数，就会抛异常</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这两个，一个传入的参数为浮点，一个传入的是字符串，在实际替换的时候，可不会调用<code>Integer.valufOf(String.valueOf(xxx))</code>来强转，而是采用更直接的方式，抛异常</p>
<p>关键的提示信息如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>因此在实际使用这种方式进行替换时，推荐选择 <code>%s</code>，毕竟兼容性更好</p>
<h3> 1.2 参数个数不匹配</h3>
<p>我们会注意到,<code>String.format</code>接收的参数是不定长的，那么就可能存在字符串模板中预留的占位与实际传入的参数个数不匹配的场景，那么出现这种场景时，会怎样</p>
<p><strong>参数缺少</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面的例子中，模板要求两个，实际只传入一个参数，会直接抛异常<code>MissingFormatArgumentException</code></p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>参数过多</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>执行正常，多余的参数不会被替换</p>
<p>因此，我们在使用<code>String.format</code>进行字符串替换时，请确保传参不要少于实际定义的参数个数；多了还好，少了就会抛异常</p>
<h2> 2. MessageFormat</h2>
<p>上面介绍的String.format虽说简单好用，但我们用多之后，自然会遇到，一个参数，需要替换模板中多个占位的场景，针对这种场景，更友好的方式是<code>MessageFormat</code>，这个也是jdk原生提供的</p>
<p>我们来简单看一下它的使用姿势</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>使用<code>{数字}</code>来表示占位，其中数字对应的是传参的下标，因此当一个参数需要复用时，使用MessageFormat就可以比较简单的实现了，上面就是一个实例，替换之后的字符串为</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>接下来说一下它使用时的注意事项</p>
<h3> 2.1 {}成对出现</h3>
<p>如果字符串中，只出现一个<code>{</code>，而没有配套的<code>}</code>，会抛异常</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>注意上面两种case，上面一个是有<code>}</code>而缺少<code>{</code>，这样是没有问题的；而下面那个则会抛异常</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>如果字符串中却是希望输出<code>{</code>，可以使用单引号来处理</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 2.2 单引号</h3>
<p>上面提到需要转移时，可以用单引号进行处理，在字符串模板的定义中，如果有单引号，需要各位注意</p>
<p><strong>只有一个单引号，会导致后面所有占位都不生效</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面这个输出结果可能和我们实际希望的不一致</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>要解决上面这个，就是使用两个单引号</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这样输出的就是我们预期的</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 2.3 序号省略</h3>
<p>上面的定义中，已经明确要求我们在<code>{}</code>中指定参数的序号，如果模板中没有指定会怎样?</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>直接抛异常</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2> 3. 小结</h2>
<p>本文介绍的实战小技巧属于是jdk原生提供的两种实现字符串占位替换的方式，除了这两个之外，我们日常开发中还会遇到其他的占位替换方式</p>
<p>比如sql的<code>?</code>替换，mybatis中sql参数组装使用<code>${paramName}</code>，或者logback日志输出中的<code>{}</code>来表示占位，spring的@Value注解声明的配置注入方式<code>${name:defaultValue}</code>，这些也都属于占位替换的范畴，那么它们又是怎么实现的呢？</p>
]]></content:encoded>
    </item>
    <item>
      <title>2. 数组与list互转</title>
      <link>https://liuyueyi.github.io/tutorial/java/skill/02.%E6%95%B0%E7%BB%84%E4%B8%8Elist%E4%BA%92%E8%BD%AC.html</link>
      <guid>https://liuyueyi.github.io/tutorial/java/skill/02.%E6%95%B0%E7%BB%84%E4%B8%8Elist%E4%BA%92%E8%BD%AC.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">2. 数组与list互转</source>
      <description>实战2：数组与list互转 这个考题比较常见，也比较简单，难道就这也有什么可以说到的门路不成？ 接下来本文好好的说一说它的几种实现姿势，总有一款你喜欢的 1.数组转List 1.1. Array.asList 这个考题太简单了，直接使用Array.asList不就完事了么，比如 @Test public void ary2list() { String[] ary = new String[]{ &amp;quot;1&amp;quot;, &amp;quot;a&amp;quot;}; List&amp;lt;String&amp;gt; list = Arrays.asList((ary); System.out.println(list); }</description>
      <category>Java</category>
      <category>编程技巧</category>
      <pubDate>Tue, 10 Aug 2021 08:42:44 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 实战2：数组与list互转</h1>
<p>这个考题比较常见，也比较简单，难道就这也有什么可以说到的门路不成？</p>
<p>接下来本文好好的说一说它的几种实现姿势，总有一款你喜欢的</p>
<h2> 1.数组转List</h2>
<h3> 1.1. Array.asList</h3>
<p>这个考题太简单了，直接使用<code>Array.asList</code>不就完事了么，比如</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>数组转list，so easy!!!</p>
<p>真的就这么简单么？？？</p>
<p>且看下面这一段代码</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>直接抛出了异常<code>java.lang.UnsupportedOperationException</code></p>
<p>有兴趣的小伙伴可以看一下源码实现方式，通过<code>Arrays.asList</code>创建的List，虽说也命名是<code>ArrayList</code>，但是它的全路径为 <code>java.util.Arrays.ArrayList</code>， 不支持<code>add</code>, <code>remove</code>等操作（所以下次再有面试官问ArrayList的知识点时，就可以反问一句，老哥你指的是哪个ArrayList😝，逼格是不是立马拉起来）</p>
<p><strong>知识点</strong></p>
<ul>
<li>通过<code>Arrays.asList</code>创建的列表，不允许新增，删除元素；但是可以更新列表中元素的值</li>
</ul>
<h3> 1.2. new ArrayList</h3>
<p>上面的数组转list方式虽然是最简单的，但不一定是合适的，特别是当我们可能对转换后的list进行操作时，可能埋坑（而且这种坑还非常隐晦，代码层面上很难发现）</p>
<p>为了减少在代码里面下毒的可能性，不妨使用下面这种方式<code>new ArrayList&lt;&gt;(Arrays.asList(ary))</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过上面这种方式创建的List，就是我们熟知的<code>ArrayList</code>了</p>
<p><strong>避雷预警</strong></p>
<p>看到上面这个使用姿势，就很容易想到一个常见的踩雷点，比如我们的应用中，有一个全局共享的配置列表，张三需要拿id为奇数的配置，李四拿id为偶数的配置，然后他们都是这么做的</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>然后跑了一次之后发现这个全局的列表清空了，这就是典型的没有做好资源隔离的case了，针对这种场景，要么是限制使用方，直接针对全局的资源进行修改，要么就是使用方拿到的是一个隔离的备份</p>
<p><strong>禁止修改：</strong></p>
<ul>
<li>使用不可变的容器，如前面提到的<code>java.util.Arrays.ArrayList</code> ()</li>
<li>使用<code>Collections.unmodifiableList</code>创建</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>列表拷贝</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>（上面这种属于深拷贝的实现，具体可以看一下jdk的源码实现）</p>
<h3> 1.3. Collections.addAll</h3>
<p>第三种方式借助jdk提供的容器工具类<code>Collections</code>来实现</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>原则上是比较推荐这种方式来实现的，至于为啥？看下源码实现</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码的实现是不是非常眼熟，如果让我们自己来写，也差不多会写成这样吧，简单直观高效，完美</p>
<h2> 2. 列表转数组</h2>
<p>不同于数组转列表的几种玩法，列表转数组就简单多了，直接调用<code>List.toArray</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 3. 小结</h2>
<p>今天的博文主题是数组与列表的互转，虽说题目简单，但是实现方式也是多种，需要搞清楚它们之间的本质区别，一不小心就可能采坑，而最简单的地方掉坑里，往往是最难发现和爬出来的</p>
<p>核心知识点小结如下</p>
<p><strong>数组转list：</strong></p>
<ul>
<li><code>Arrays.asList(xxx)</code>：创建的是不可变列表，不能删除和新增元素</li>
<li><code>new ArrayList&lt;&gt;(Arrays.asList(xxx)</code>: 相当于用列表创建列表，属于深拷贝的一种表现，获取到的列表支持新增、删除</li>
<li>推荐写法 <code>Collections.addAll()</code></li>
</ul>
<p><strong>列表转数组</strong></p>
<ul>
<li><code>list.toArray</code>: 如果需要指定数组类型，则传参指定</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>3.字符串与容器互转</title>
      <link>https://liuyueyi.github.io/tutorial/java/skill/03.%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8E%E5%AE%B9%E5%99%A8%E4%BA%92%E8%BD%AC.html</link>
      <guid>https://liuyueyi.github.io/tutorial/java/skill/03.%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8E%E5%AE%B9%E5%99%A8%E4%BA%92%E8%BD%AC.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">3.字符串与容器互转</source>
      <description>实战3：字符串与Collection的互转 将字符串转换为List，这种业务场景可以说非常非常常见了，实现方式也比较简单 public List&amp;lt;String&amp;gt; str2list(String str, String split) { String[] cells = str.split(split); return Arrays.asList(cells); } 那么除了上面这种实现方式之外，还有其他的么？</description>
      <category>Java</category>
      <category>编程技巧</category>
      <pubDate>Wed, 11 Aug 2021 08:32:54 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 实战3：字符串与Collection的互转</h1>
<p>将字符串转换为List，这种业务场景可以说非常非常常见了，实现方式也比较简单</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>那么除了上面这种实现方式之外，还有其他的么？</p>
<!-- more -->
<h2> 1. 字符串转列表</h2>
<p>上面的实现姿势相当于字符串先转数组，然后在通过数组转列表，所以可以沿用前一篇字数组转list的几种方式</p>
<h3> 1.1. jdk支持方式</h3>
<p>借助<code>Collections.addAll</code>来实现</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这种方式适用于输出String的列表，如果我希望转成int列表呢？可以采用下面的方式</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>直接将数组转换为流，然后基于jdk8的特性，来实现转换为int列表</p>
<h3> 1.2. guava方式</h3>
<p>引入依赖</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>除了使用jdk原生的方式之外，借助guava也是非常常见的的case了，主要通过Splitter来实现，写法看起来非常秀</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>简单直接的一行代码搞定，如果我们希望是对输出的列表类型进行指定，也可以如下操作</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1.3. apache-commons</h3>
<p>引入依赖</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面流的方式就很赞了，但是注意它是有jdk版本限制的，虽说现在基本上都是1.8以上的环境进行开发，但也不排除有上古的代码，比如我现在手上的项目，spring还是3...</p>
<p>如果我们不能使用流的方式，那么有什么简单的方式来实现字符串转换为指定类型的列表么？</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这个实现也没有多优雅，不过这里有个编程小技巧可以学习，<code>new Transformer(){}</code>的传参方式，这种实现方式有点像回调的写法，虽然他们有本质的区别，此外就是jdk8之后的函数方法，就充分的体现这种设计思路，比如上面的换成jdk8的写法，直接简化为</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 2. 列表转字符串</h2>
<h3> 2.1. StringBuilder</h3>
<p>最容易想到的，直接使用StringBuilder来实现拼接</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意两点：</p>
<ul>
<li>使用StringBuilder而不是StringBuffer (why?)</li>
<li>注意最后一个拼接符号不要</li>
</ul>
<h3> 2.2. String.join</h3>
<p>一个更简单的实现方式如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当然上面这个的缺点就是列表必须是字符串列表，如果换成int列表，则不行</p>
<h3> 2.3. gauva</h3>
<p>guava也提供了列表转String的方式，同样很简单，而且还没有列表类型的限制</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 3. 小结</h2>
<p>本文的考题也非常常见，列表与字符串的互转，这里介绍了多种实现方式，有jdk原生的case（如果没有什么限制，推荐使用它， <code>String.split</code>除外，原因后面再说），如果有更高级的定制场景，如非String类型类表，则可以考虑guava的Splitter/Joinner来实现</p>
<p>在上面的实现中，也提供了几种有意思的编程方式</p>
<ul>
<li>Stream: 流，jdk8之后非常常见了</li>
<li>函数方法，回调写法case</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>4.优雅的实现字符串拼接</title>
      <link>https://liuyueyi.github.io/tutorial/java/skill/04.%E4%BC%98%E9%9B%85%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5.html</link>
      <guid>https://liuyueyi.github.io/tutorial/java/skill/04.%E4%BC%98%E9%9B%85%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">4.优雅的实现字符串拼接</source>
      <description>实战4：字符串拼接 相信没有小伙伴没有写过这样的代码，比如说现在让我们来实现一个字符串拼接的场景，怎样的实现才算是优雅的呢？</description>
      <category>Java</category>
      <category>编程技巧</category>
      <pubDate>Thu, 12 Aug 2021 07:39:11 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 实战4：字符串拼接</h1>
<p>相信没有小伙伴没有写过这样的代码，比如说现在让我们来实现一个字符串拼接的场景，怎样的实现才算是优雅的呢？</p>
<!-- more -->
<p>以将int数组转为英文逗号分隔的字符串为例进行演示</p>
<h2> 1. 实现</h2>
<h3> 1.1. 普通写法</h3>
<p>直接使用StringBuilder来拼接</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这种写法相信比较常见，相对来说不太顺眼的地方就是最后的toString，需要将最后的一个英文逗号给干掉</p>
<p>当然也可以用下面这种事前判断方式，避免最终的字符串截取</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1.2. StringJoiner</h3>
<p>上面实现中，干掉最后的一个分隔符实在不是很优雅，那么有更好一点的用法么，接下来看一下使用<code>StringJoiner</code>的方式</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>StringJoiner由jdk1.8提供，除了上面的基础玩法之外，结合jdk1.8带来的流操作方式，可以更简洁的实现</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>怎么样，上面这个实现比起前面的代码是不是要简洁多了，一行代码完事</p>
<h3> 1.3. guava joiner</h3>
<p>如果使用的jdk还不是1.8版本，不能使用上面的StringJoiner，没关系，还有guava的Joiner也可以实现</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>注意</strong></p>
<ul>
<li>接收的参数类型为: 数组/Iterable/Iterator/可变参数, 基本上可以覆盖我们日常的业务场景</li>
</ul>
<h2> 2. 小结</h2>
<p>本篇文章的主题是一个非常非常常见的字符串拼接，一般来讲，我们在做字符串拼接时，最麻烦的事情就是分隔符的处理，要么就是分隔符前置添加，每次循环都需要判断是否为开头；要么就是后置，最后取字符串时，干掉最后一个分隔符</p>
<p>本文提供了一个非常使用的方式<code>StringJoiner</code>，完全解决了上面的分隔符问题，它的使用有两种场景</p>
<ul>
<li>简单的容器转String：直接借助Stream的<code>Collectors.joining</code>来实现</li>
<li>for循环 （这种场景一般是for循环内的逻辑不仅仅包括字符串拼接，还包括其他的业务逻辑）： 循环内直接执行<code>stringJoiner.add()</code>添加</li>
</ul>
<p>对于jdk1.8及以上的版本，优先推荐使用上面说的StringJoiner来实现字符串拼接；至于jdk1.8之下，那么Guava就是一个不错的选择了，使用姿势也很很简单</p>
]]></content:encoded>
    </item>
    <item>
      <title>5.驼峰与下划线互转</title>
      <link>https://liuyueyi.github.io/tutorial/java/skill/05.%E9%A9%BC%E5%B3%B0%E4%B8%8E%E4%B8%8B%E5%88%92%E7%BA%BF%E4%BA%92%E8%BD%AC.html</link>
      <guid>https://liuyueyi.github.io/tutorial/java/skill/05.%E9%A9%BC%E5%B3%B0%E4%B8%8E%E4%B8%8B%E5%88%92%E7%BA%BF%E4%BA%92%E8%BD%AC.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">5.驼峰与下划线互转</source>
      <description>实战5：驼峰与下划线划转 这个考题非常实用，特别是对于我们这些号称只需要CURD的后端开发来说，驼峰与下划线互转，这不是属于日常任务么；一般来讲db中的列名，要求是下划线格式（why? 阿里的数据库规范是这么定义的，就我感觉驼峰也没毛病），而java实体命名则是驼峰格式，所以它们之间的互转，就必然存在一个驼峰与下划线的互转 今天我们就来看一下，这两个的互转支持方式</description>
      <category>Java</category>
      <category>编程技巧</category>
      <pubDate>Sat, 14 Aug 2021 11:17:19 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 实战5：驼峰与下划线划转</h1>
<p>这个考题非常实用，特别是对于我们这些号称只需要CURD的后端开发来说，驼峰与下划线互转，这不是属于日常任务么；一般来讲db中的列名，要求是下划线格式（why? 阿里的数据库规范是这么定义的，就我感觉驼峰也没毛病），而java实体命名则是驼峰格式，所以它们之间的互转，就必然存在一个驼峰与下划线的互转</p>
<p>今天我们就来看一下，这两个的互转支持方式</p>
<!-- more -->
<h2> 1.实现</h2>
<h3> 1.1. Gauva</h3>
<p>一般来讲遇到这种普适性的问题，大部分都是有现成的工具类可以来直接使用的；在java生态中，说到好用的工具百宝箱，guava可以说是排列靠前的</p>
<p>接下来我们看一下如何使用Gauva来实现我们的目的</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这里主要使用的是<code>CaseFormat</code>来实现互转，guava的CaseFormat还提供了其他几种方式</p>
<p>上面这个虽然可以实现互转，但是如果我们有一个字符串为 <code>helloWorld_Case</code></p>
<p>将其他转换输出结果如下:</p>
<ul>
<li>下划线：<code>hello_world__case</code></li>
<li>驼峰：<code>helloworldCase</code></li>
</ul>
<p>这种输出，和标准的驼峰/下划线不太一样了（当然原因是由于输入也不标准）</p>
<h3> 1.2. Hutool</h3>
<p>除了上面的guava，hutool的使用也非常广，其中包含很多工具类，其<code>StrUtil</code>也提供了下划线与驼峰的互转支持</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>同样的我们再来看一下特殊的case</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果如下</p>
<ul>
<li>驼峰：<code>helloworldCase</code></li>
<li>下划线: <code>hello_world_case</code></li>
</ul>
<p>相比较上面的guava的场景，下划线这个貌似还行</p>
<h3> 1.3. 自定义实现</h3>
<p>接下来为了满足我们希望转换为标砖的驼峰/下划线输出方式的需求，我们自己来手撸一个</p>
<p><strong>下划线转驼峰:</strong></p>
<ul>
<li>关键点就是找到下划线，然后去掉它，下一个字符转大写续上（如果下一个还是下划线，那继续找下一个）</li>
</ul>
<p>根据上面这个思路来实现，如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>驼峰转下划线</strong></p>
<ul>
<li>关键点：大写的，则前位补一个下划线，当前字符转小写（如果前面已经是一个下划线了，那前面不补，直接转小写即可）</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>再次测试<code>helloWorld_Case</code>，输出如下</p>
<ul>
<li>驼峰：<code>helloWorldCase</code></li>
<li>下划线: <code>hello_world_case</code></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>6.枚举的特殊用法</title>
      <link>https://liuyueyi.github.io/tutorial/java/skill/06.%E6%9E%9A%E4%B8%BE%E7%9A%84%E7%89%B9%E6%AE%8A%E7%94%A8%E6%B3%95.html</link>
      <guid>https://liuyueyi.github.io/tutorial/java/skill/06.%E6%9E%9A%E4%B8%BE%E7%9A%84%E7%89%B9%E6%AE%8A%E7%94%A8%E6%B3%95.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">6.枚举的特殊用法</source>
      <description>实战6：枚举的特殊用法 难道我们日常使用的枚举还有什么特殊的玩法不成？没错，还真有，本文主要介绍枚举的两种不那么常见的使用姿势 利用枚举来实现单例模式 利用枚举来实现策略模式</description>
      <category>Java</category>
      <category>编程技巧</category>
      <pubDate>Mon, 16 Aug 2021 09:54:23 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 实战6：枚举的特殊用法</h1>
<p>难道我们日常使用的枚举还有什么特殊的玩法不成？没错，还真有，本文主要介绍枚举的两种不那么常见的使用姿势</p>
<ul>
<li>利用枚举来实现单例模式</li>
<li>利用枚举来实现策略模式</li>
</ul>
<!-- more -->
<h2> 1. 使用场景</h2>
<h3> 1.1. 单例模式</h3>
<p>单例模式可以说是每个java开发者必须掌握的一个设计模式了，通常我们说它的实现，有饱汉式和饿汉式，也有经常说的双重判断，今天我们介绍另外一种方式，借助枚举来实现</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用枚举来实现单例模式非常非常简单，将类声明为枚举，内部只定义一个值即可</p>
<p>为什么可以这样做？</p>
<ul>
<li>枚举类不能<code>new</code>，因此保证单例</li>
<li>枚举类不能被继承</li>
<li>类不加载时，不会实例化</li>
</ul>
<p>使用枚举类创建的单例有一个好处，就是即使用反射，也无法打破它的单例性质，这是相比较于其他的实现方式的一个优点</p>
<p>那么，为啥在实际的项目中，不太常见这种写法？</p>
<ul>
<li>就我个人的一点认知（不保证准确）：这个与我们对枚举的认知有一定关系，在 《Effect in java》一书中，推荐我们使用这种方式来实现单例，但是在实际的项目开发中，我们更多的将枚举作为常量来使用，很少在枚举类中，添加复杂的业务逻辑</li>
</ul>
<h3> 1.2. 策略模式</h3>
<p>枚举除了很容易就实现上面的单例模式之外，还可以非常简单的实现策略模式</p>
<p>举一个简单的例子，我现在有一个接口，通过接受的参数，来决定最终的数据存在什么地方</p>
<p>如果按照正常的写法，可能就是很多的if/else</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这种写法虽说简单直观，但是当type类型一多了之后，这个if/else的代码行数就会很多很多了，而且看起来也不美观</p>
<p>接下来我们介绍一种利用枚举，基于策略模式的思想来解决上面的if/else问题</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的实现，主要利用的是<code>抽象类 + 枚举</code>来完成不同的策略具体实现</p>
<p>这种实现方式，相比较与前面的单例模式，还是更常见一点，虽然整体看下来没有什么难度，但是仔细看一看，会发现几个知识点</p>
<ul>
<li>抽象方法的使用 （在模板设计模式中，更能体会抽象方法的使用妙处）</li>
<li>利用枚举原生提供的<code>values()</code>，来实现遍历，找到目标</li>
</ul>
<h2> 2. 小结</h2>
<p>枚举虽然说是jdk原生提供的一个基础数据类型，但是它的使用姿势除了我们熟知的常量之外，还可以有效的运用在设计模式中，让我们的代码实现更优雅</p>
<p>比如使用枚举来实现单例模式，就不用再面对让人烦躁的双重判断/内部类的方式了</p>
<p>使用枚举的策略模式，也可以有效解决我们类中大量的if/else</p>
]]></content:encoded>
    </item>
    <item>
      <title>7.排序比较要慎重</title>
      <link>https://liuyueyi.github.io/tutorial/java/skill/07.%E6%8E%92%E5%BA%8F%E6%AF%94%E8%BE%83%E8%A6%81%E6%85%8E%E9%87%8D.html</link>
      <guid>https://liuyueyi.github.io/tutorial/java/skill/07.%E6%8E%92%E5%BA%8F%E6%AF%94%E8%BE%83%E8%A6%81%E6%85%8E%E9%87%8D.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">7.排序比较要慎重</source>
      <description>实战7：排序比较要慎重 今天介绍的又是一个非常非常基本的基本知识点，为啥要单独拎出来？还是因为这个东西虽然非常简单，但是很容易掉坑，我已经遇到几次不严谨的写法了</description>
      <category>Java</category>
      <category>编程技巧</category>
      <pubDate>Tue, 17 Aug 2021 14:22:52 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 实战7：排序比较要慎重</h1>
<p>今天介绍的又是一个非常非常基本的基本知识点，为啥要单独拎出来？还是因为这个东西虽然非常简单，但是很容易掉坑，我已经遇到几次不严谨的写法了</p>
<!-- more -->
<h2> 1.排序</h2>
<h3> 1.1. Comparator 与 Comparable</h3>
<p>输掉排序，这两个接口好像不太容易绕过去，我们简单介绍下它们的区别</p>
<ul>
<li>如果你有一个类，希望支持同类型的自定义比较策略，可以实现接口<code>Compareable</code></li>
<li>如果某个类，没有实现<code>Compareable</code>接口，但是又希望对它进行比较，则可以自自定义一个<code>Comparator</code>，来定义这个类的比较规则</li>
</ul>
<p>通过一个简单的实例进行演示说明</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的实现中，重点关注 Demo类，实现了<code>Comparable</code>接口，因此可以直接调用<code>list.sort(null)</code>来进行比较；</p>
<p>但是如果我们现在需求改变了，希望实现针对demo类的age字段，进行升序排列，那么就可以利用<code>Comparator</code>来实现了</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1.2. 踩坑预告</h3>
<p>再上面的compare方法实现中，我们可以发现里面的实现有点不太美观，我们最终的目的是什么？</p>
<ul>
<li>如果左边的小于右边的，返回 -1</li>
<li>如果左边的大于右边的，返回 0</li>
<li>如果左边的等于右边的，返回 1</li>
</ul>
<p>基于此，经常可以看到的实现如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这个实现虽然简洁了，但是有一个致命的问题，可能溢出!!!</p>
<p>所以请注意，千万千万不要用上面这种写法</p>
<p>那么有没有更优雅的方式呢？</p>
<ul>
<li>有，使用基础类的<code>compare</code>方法</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这一段代码，再jdk1.8中，可以简化为下面一句</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>再扩展一下，如果希望倒排呢？</p>
<ul>
<li>第一种实现方式，调换位置</li>
<li>Jdk1.8方式，使用负数</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 2. 小结</h2>
<p>今天主要介绍的知识点是排序，再我们日常使用中，如果一个类希望支持排序，最好的方式就是让它实现<code>Comparable</code>接口，然后自定义排序方式</p>
<p>这样再容器中，如果需要排序，直接调用 <code>list.sort(null)</code> 或者 <code>CollectionUtils.sort(list)</code></p>
<p>如果目标类没有实现排序接口，或者希望使用另外一种排序方式，则通过自定义的<code>Comparator</code>来实现</p>
<p>最后关于<code>compare</code>方法的实现，设计到两个类的比较，这种最终的落脚地，多半是基础类型的比较</p>
<ul>
<li>o1 与 o2 比较，返回负数，则最终的结果中o1再前面（即升序排列）</li>
<li>不要直接使用 <code>o1-o2</code>会溢出，推荐使用 <code>Integer.compare(o1, o2);</code></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>8.容器的初始化大小指定</title>
      <link>https://liuyueyi.github.io/tutorial/java/skill/08.%E5%AE%B9%E5%99%A8%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%A4%A7%E5%B0%8F%E6%8C%87%E5%AE%9A.html</link>
      <guid>https://liuyueyi.github.io/tutorial/java/skill/08.%E5%AE%B9%E5%99%A8%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%A4%A7%E5%B0%8F%E6%8C%87%E5%AE%9A.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">8.容器的初始化大小指定</source>
      <description>实战8：容器的初始化大小指定 容器可以说是我们日常开发中，除了基本对象之外，使用最多的类了，那么平时在使用的时候，是否有主意到良好编程习惯的大佬，在创建容器的时候，一般会设置size；那么他们为什么要这么干呢？是出于什么进行考量的呢？ 今天我们将针对最常见的List/Map/Set三种容器类型的初始化值选择，进行说明</description>
      <category>Java</category>
      <category>编程技巧</category>
      <pubDate>Wed, 18 Aug 2021 14:11:05 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 实战8：容器的初始化大小指定</h1>
<p>容器可以说是我们日常开发中，除了基本对象之外，使用最多的类了，那么平时在使用的时候，是否有主意到良好编程习惯的大佬，在创建容器的时候，一般会设置size；那么他们为什么要这么干呢？是出于什么进行考量的呢？</p>
<p>今天我们将针对最常见的List/Map/Set三种容器类型的初始化值选择，进行说明</p>
<!-- more -->
<h2> 1. 容器初始化</h2>
<h3> 1.1. List</h3>
<p>列表，在我们日常使用过程中，会接触到下面几个</p>
<ul>
<li>ArrayList: 最常见的数组列表</li>
<li>LinkedList: 基于链表的列表</li>
<li>CopyOnWriteArrayList: 线程安全的数组列表</li>
</ul>
<p>接下来逐一进行说明</p>
<h4> 1.1.1 ArrayList</h4>
<p>现在以ArrayList为例，进行源码分析，当我们不指定列表大小，直接创建时</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面是内部实现，其中<code>elementData</code>就是列表中存数据的数组，初始化为默认数组</p>
<p>当我们第一次添加一个元素时，发现数组为默认值，会触发一次数组扩容，新的数组大小为10 （详情看源码）</p>
<p>其次就是数组的库容机制，通过源码/网上分享知识点可以知道，这个扩容的实现如下</p>
<ul>
<li>当新添加的元素，数组放不下时，实现扩容</li>
<li><code>扩容后的大小</code> = <code>扩容前大小</code> + max(<code>添加元素个数</code>, 1/2 * <code>扩容前大小</code>)</li>
</ul>
<p>基于上面的知识点，大致可以得出指定列表长度的好处</p>
<ul>
<li>节省空间（用多少申请多少，避免浪费）</li>
<li>减少扩容带来的拷贝（扩容一次就会带来一次数组拷贝，如果已知列表很大，结果还使用默认的10，这会产生很多可避免的扩容开销）</li>
</ul>
<h4> 1.1.2 LinkedList</h4>
<p>基于链表的列表，不同于上面的数组列表，它没有提供指定大小的构造方法，why?</p>
<p>因为链表本身的数据结构的特点，它就像糖葫芦一样，一个串一个，有数据，才有接上的可能，因此不需要指定大小</p>
<h4> 1.1.3 CopyOnWriteArrayList</h4>
<p>这个又非常有意思，它同样不能指定大小，但是原因与前面不同，主要在于它保证线程安全的实现方式</p>
<ul>
<li>每次新增/修改(加锁，保证单线程访问)，都是在拷贝的数组操作；完成之后，用新的替换旧的</li>
</ul>
<p>所以说，每次变更，都会存在数组拷贝，因此就没有必要提前指定数组大小</p>
<p>那么它的初始化每次都使用默认的么?</p>
<p>并不是这样的，当我们已知这个列表中的值时，推荐使用下面这种方式</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>将初始化值，放在一个普通的列表中，然后利用普通列表来初始化<code>CopyOnWriteArrayList</code></li>
</ul>
<h3> 1.2.Map</h3>
<p>常见的map容器使用，大多是下面几个</p>
<ul>
<li><code>HashMap</code></li>
<li><code>LinkedHashMap</code>: 有序的hashmap</li>
<li><code>TreeMap</code>: 有序的hashmap</li>
<li><code>ConcurrentHashMap</code>: 线程安全的map</li>
</ul>
<h4> 1.2.1 HashMap</h4>
<p>HashMap的底层数据结构是 <code>数组 + 链表/红黑树</code>，关于这个就不细说了</p>
<p>我们在初始化时，若不指定size，则数组的默认长度为8（请注意，Map的数组长度是2的倍数）</p>
<p>与ArrayList的扩容时机不一样的是，默认情况下，Map容量没满就会触发一次扩容</p>
<p>默认是数量达到 <code>size * 0.75</code>(0.75为扩容因子，可以在创建时修改)，就会触发一次扩容</p>
<p>why?</p>
<ul>
<li>主要是为了减少hash冲突</li>
</ul>
<p>同样的为了减少冲突，在初始化时，我们需要指定一个合适大小</p>
<p>比如我们</p>
<ul>
<li>已知map的数量为2，这个时候Map的大小选择因该是4</li>
<li>map数量为6，这个时候Map的大小选择是16</li>
</ul>
<p>有时候让我们自己来计算这个值，就有些麻烦了，这个时候，可以直接使用Guava的工具类来完成这个目的</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4> 1.2.2 LinkedHashMap</h4>
<p>初始化方式同上，略</p>
<h4> 1.2.3 ConcurrentHashMap</h4>
<p>初始化方式同上，略</p>
<h4> 1.2.4 TreeMap</h4>
<p>不同于上面几个的是treeMap，没有提供指定容器大小的构造方法</p>
<p>原因和前面说到的LinkedList有些类似，TreeMap的底层数据结构为Tree，所以新增数据是挂在树的一个节点下面，无需指定容量大小</p>
<h3> 1.3. Set</h3>
<p>集合用的最多应该就是<code>HashSet</code>了，底层结构模型复用，所以初始化大小指定与HashMap一致，也不需要多说</p>
<h2> 2. 小结</h2>
<p>今天这篇博文主要介绍的是三种常见的容器，在创建时，如何指定容量大小</p>
<p>首先明确一点，指定容量大小是为了</p>
<ul>
<li>减少扩容带来的额外开销</li>
<li>指定容量代销，可以减少无效的内存开销</li>
</ul>
<p>初始化值设置的关键点:</p>
<ul>
<li>ArrayList: 数据有多少个，初始化值就是多少</li>
<li>HashMap: 考虑到扩容因子，初始化大小 = <code>(size / 0.75 + 1)</code></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>9.List.subList使用不当StackOverflowError</title>
      <link>https://liuyueyi.github.io/tutorial/java/skill/09.List-subList%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%BD%93StackOverflowError.html</link>
      <guid>https://liuyueyi.github.io/tutorial/java/skill/09.List-subList%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%BD%93StackOverflowError.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">9.List.subList使用不当StackOverflowError</source>
      <description>实战9：List.subList使用不当StackOverflowError 相信每个小伙伴都使用过List.subList来获取子列表，日常使用可能没啥问题，但是，请注意，它的使用，很可能一不小心就可能导致oom</description>
      <category>Java</category>
      <category>编程技巧</category>
      <pubDate>Thu, 19 Aug 2021 14:13:42 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 实战9：List.subList使用不当StackOverflowError</h1>
<p>相信每个小伙伴都使用过<code>List.subList</code>来获取子列表，日常使用可能没啥问题，但是，请注意，它的使用，很可能一不小心就可能导致oom</p>
<!-- more -->
<h2> 1.实例说明</h2>
<h3> 1.1. subList</h3>
<p>场景复现，如基于list实现一个小顶堆</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这个执行完毕之后，居然出现栈溢出</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从实现来看，感觉也没啥问题啊， 我们稍微改一下上面的返回</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>再次执行，却没有异常；所以关键点就在与</p>
<ul>
<li>list.subList的使用上</li>
</ul>
<h3> 1.2. StackOverflowError分析</h3>
<p>接下来我们主要看一下<code>list.subList</code>的实现</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面返回的子列表是ArrayList的一个内部类<code>SubList</code>，它拥有一个指向父列表的成员<code>parrent</code></p>
<p>也就是说，从源头的ArryList开始，后面每次调用<code>subList</code>，这个指代关系就深一层</p>
<p>然后它的add方法也很有意思</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>重点看 <code>parent.add(parentOffset + index, e);</code>，添加的数据实际上是加在最源头的ArrayList上的，也就是说，虽然你现在拿到的SubList，只有几个元素，但是它对应的数组，可能超乎你的想象</p>
<p>当然上面这个异常主要是以为调用栈溢出（一直往上找parent）</p>
<p>这里反应的另外一个重要问题则是内存泄漏，就不继续说了</p>
<p>如果需要解决上面这个问题，改造方法如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 2. 小结</h2>
<p>jdk提供的原生方法虽然非常好用，但是在使用的时候，也需要多家注意，一不小心就可能掉进坑里；这也告诉我们多看源码是有必要的</p>
<p>最后一句关键知识点小结：</p>
<ul>
<li><code>ArrayList.subList</code> 返回的是内部类，与原ArrayList公用一个数组，只是限定了这个数组的起始下标和结束下标而已</li>
<li>在使用<code>subList</code>，请注意是否会存在内存泄露和栈溢出的问题</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>10.不可变容器</title>
      <link>https://liuyueyi.github.io/tutorial/java/skill/10.%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%AE%B9%E5%99%A8.html</link>
      <guid>https://liuyueyi.github.io/tutorial/java/skill/10.%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%AE%B9%E5%99%A8.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">10.不可变容器</source>
      <description>实战10：不可变容器 不可变容器，看着好像在实际的业务中不怎么会用到，但实则不然，相信每个小伙伴都用过，或者看到过下面的代码 Collections.emptyList(); Collections.emptyMap(); 今天我们来介绍一下如何使用不可变容器，以及使用时的注意事项</description>
      <category>Java</category>
      <category>编程技巧</category>
      <pubDate>Fri, 20 Aug 2021 17:59:24 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 实战10：不可变容器</h1>
<p>不可变容器，看着好像在实际的业务中不怎么会用到，但实则不然，相信每个小伙伴都用过，或者看到过下面的代码</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>今天我们来介绍一下如何使用不可变容器，以及使用时的注意事项</p>
<!-- more -->
<h2> 1. 不可变容器</h2>
<h3> 1.1. JDK不可变容器</h3>
<p>java原生提供了一些不可变容器，它们最大的特点就是不支持添加、删除、修改容器内的值</p>
<p><code>Collections.emptyXxx</code>空容器</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面三个是最常用的几个了，通常当我们一个方法的返回结果定义为容器类型时，可能为了避免npe，在返回空容器时，会如此使用</p>
<p>除了上面这几个空的不可变容器之外，还有</p>
<ul>
<li><code>UnmodifiableList</code></li>
<li><code>UnmodifiableMap</code></li>
<li><code>UnmodifiableSet</code></li>
</ul>
<p>它们的使用姿势，通常是借助<code>Collections</code>来实现</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>如上面创建的List，就不支持set/remove等修改操作</p>
<p>使用不可变容容器，最大的好处就是基于它的不可修改特性，来实现公用，且不会被污染</p>
<ul>
<li>所以一个自然而然能想到的应用场景就是 <code>全局共享的配置</code></li>
</ul>
<h3> 1.2. Guava不可变容器</h3>
<p>上面是jdk提供的不可变容器，相比较与它们，在实际的项目中，使用Gauva的不可变容器的可能更多</p>
<ul>
<li><code>ImmutableXxx</code>；不可变容器</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面是最常见的三个容器对应的不可变型</p>
<p>从使用角度来看，初始化非常方便（相比较与jdk版而言）</p>
<h2> 2. 注意事项</h2>
<p>不可变容器虽好，但是使用不当也是很坑的；就我个人的一个观点</p>
<ul>
<li>如果是应用内的接口方法，容器传参，返回容器时，尽量不要使用不可变容器；因为你没办法保证别人拿到你的返回容器之后，会对它进行什么操作</li>
<li>如果是对外提供返回结果，特别是null的场景，使用不可变的空容器优于返回null</li>
<li>不可变容器，用于全局公用资源，共享配置参数；多线程的数据传递时，属于比较合适的场景</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>11.Map转换的几种方式</title>
      <link>https://liuyueyi.github.io/tutorial/java/skill/11.Map%E8%BD%AC%E6%8D%A2%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F.html</link>
      <guid>https://liuyueyi.github.io/tutorial/java/skill/11.Map%E8%BD%AC%E6%8D%A2%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">11.Map转换的几种方式</source>
      <description>实战11：Map转换Map的几种方式 在日常开发过程中，从一个Map转换为另外一个Map属于基本操作了，那么我们一般怎么去实现这种场景呢？有什么更简洁省事的方法么？</description>
      <category>Java</category>
      <category>编程技巧</category>
      <pubDate>Tue, 02 Nov 2021 19:43:19 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 实战11：Map转换Map的几种方式</h1>
<p>在日常开发过程中，从一个Map转换为另外一个Map属于基本操作了，那么我们一般怎么去实现这种场景呢？有什么更简洁省事的方法么？</p>
<!-- more -->
<h2> 1.Map互转</h2>
<h3> 1.1 实例场景</h3>
<p>现在我们给一个简单的实例</p>
<p>希望将一个<code>Map&lt;String, Integer&gt;</code> 转换成 <code>Map&lt;String, String&gt;</code>，接下来看一下有哪些实现方式，以及各自的优缺点</p>
<p>首先提供一个创建Map的公共方法</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 1.1.1 基本的for循环转换</h4>
<p>这种方式是最容易想到和实现的，直接for循环来转换即可</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这种方式的优点很明显，实现容易，业务直观；</p>
<p>缺点就是可复用性较差，代码量多（相比于下面的case）</p>
<h4> 1.1.2 容器的流式使用</h4>
<p>在jdk1.8提供了流式操作，同样也可以采用这种方式来实现转换</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用stream的方式，优点就是链式，代码量少；缺点是相较于上面的阅读体验会差一些（当然这个取决于个人，有些小伙伴就更习惯看这种链式的代码）</p>
<h4> 1.1.3 Guava的trasform方式</h4>
<p>从代码层面来看，上面两个都不够直观，如果对guava熟悉的小伙伴对下面的代码可能就很熟悉了</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>核心逻辑就一行 <code>Maps.transformValues(map, String::valueOf)</code>，实现了我们的Map转换的诉求</p>
<p>很明显，这种方式的优点就是间接、直观；当然缺点就是需要引入guava，并且熟悉guava</p>
<h3> 1.2 最后一问，这篇文章目的是啥？</h3>
<p>既然我们的标题是实战小技巧，本文除了给大家介绍可以使用guava的<code>Maps.transformValues</code>来实现map转换之外，更主要的一个目的是如果让我们自己来实现一个工具类，来支持这个场景，应该怎么做？</p>
<p>直接提供一个转换方法？</p>
<p><strong>第一步：一个泛型的转换接口</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>定义上面这个接口之后，自然而然想到的缺点就是差一个value的转换实现</p>
<p><strong>第二步：value转换的定义</strong></p>
<p>这里采用Function接口思想来定义转换类</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>当然到这里我们就需要注意jdk1.8以下是不支持函数编程的，那么我们可以怎么来实现呢？</p>
<p>这个时候再对照一下guava的实现，然后再手撸一个，知识点就到手了</p>
]]></content:encoded>
    </item>
    <item>
      <title>12.巧用函数方法实现二维数组遍历</title>
      <link>https://liuyueyi.github.io/tutorial/java/skill/12.%E5%B7%A7%E7%94%A8%E5%87%BD%E6%95%B0%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E9%81%8D%E5%8E%86.html</link>
      <guid>https://liuyueyi.github.io/tutorial/java/skill/12.%E5%B7%A7%E7%94%A8%E5%87%BD%E6%95%B0%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E9%81%8D%E5%8E%86.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">12.巧用函数方法实现二维数组遍历</source>
      <description>实战12：巧用函数方法实现二维数组遍历 对于数组遍历，基本上每个开发者都写过，遍历本身没什么好说的，但是当我们在遍历的过程中，有一些复杂的业务逻辑时，将会发现代码的层级会逐渐加深</description>
      <category>Java</category>
      <category>编程技巧</category>
      <pubDate>Tue, 09 Aug 2022 18:35:40 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 实战12：巧用函数方法实现二维数组遍历</h1>
<p>对于数组遍历，基本上每个开发者都写过，遍历本身没什么好说的，但是当我们在遍历的过程中，有一些复杂的业务逻辑时，将会发现代码的层级会逐渐加深</p>
<!-- more -->
<p>如一个简单的case，将一个二维数组中的偶数找出来，保存到一个列表中</p>
<p>二维数组遍历，每个元素判断下是否为偶数，很容易就可以写出来，如</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这个实现没啥问题，但是这个代码的深度很容易就有三层了；当上面这个if中如果再有其他的判定条件，那么这个代码层级很容易增加了；二维数组还好，如果是三维数组，一个遍历就是三层；再加点逻辑，四层、五层不也是分分钟的事情么</p>
<p>那么问题来了，代码层级变多之后会有什么问题呢？</p>
<blockquote>
<p>只要代码能跑，又能有什么问题呢？！</p>
</blockquote>
<h2> 1. 函数方法消减代码层级</h2>
<p>由于多维数组的遍历层级天然就很深，那么有办法进行消减么？</p>
<p>要解决这个问题，关键是要抓住重点，遍历的重点是什么？获取每个元素的坐标！那么我们可以怎么办？</p>
<blockquote>
<p>定义一个函数方法，输入的就是函数坐标，在这个函数体中执行我们的遍历逻辑即可</p>
</blockquote>
<p>基于上面这个思路，相信我们可以很容易写一个二维的数组遍历通用方法</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>主要上面的实现，函数方法直接使用了JDK默认提供的BiConsumer，两个传参，都是int 数组下表；无返回值</p>
<p>那么上面这个怎么用呢？</p>
<p>同样是上面的例子，改一下之后，如</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>相比于前面的，貌似也就少了一层而已，好像也没什么了不起的</p>
<p>但是，当数组变为三维、四维、无维时，这个改动的写法层级都不会变哦</p>
<h2> 2. 遍历中return支持</h2>
<p>前面的实现对于正常的遍历没啥问题；但是当我们在遍历过程中，遇到某个条件直接返回，能支持么？</p>
<p>如一个遍历二维数组，我们希望判断其中是否有偶数，那么可以怎么整？</p>
<p>仔细琢磨一下我们的scan方法，希望可以支持return，主要的问题点就是这个函数方法执行之后，我该怎么知道是继续循环还是直接return呢?</p>
<p>很容易想到的就是执行逻辑中，添加一个额外的返回值，用于标记是否中断循环直接返回</p>
<p>基于此思路，我们可以实现一个简单的demo版本</p>
<p>定义一个函数方法，接受循环的下标 + 返回值</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>循环通用方法就可以相应的改成</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>基于上面这种思路，我们的实际使用姿势如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这个实现可满足我们的需求，唯一有个别扭的地方就是返回，总有点不太优雅；那么除了这种方式之外，还有其他的方式么？</p>
<p>既然考虑了返回值，那么再考虑一下传参呢？通过一个定义的参数来装在是否中断以及返回结果，是否可行呢？</p>
<p>基于这个思路，我们可以先定义一个参数包装类</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们希望通过Ans这个类来记录循环结果，其中tag=true，则表示不用继续循环了，直接返回ans结果吧</p>
<p>与之对应的方法改造及实例如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样看起来就比前面的要好一点了</p>
<p>实际跑一下，看下输出是否和我们预期的一致；</p>
<figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/546a699ae4334df4b6525332da4e5770~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure>
]]></content:encoded>
      <enclosure url="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/546a699ae4334df4b6525332da4e5770~tplv-k3u1fbpfcp-watermark.image?" type="image/"/>
    </item>
    <item>
      <title>13.List转Map List的几种姿势</title>
      <link>https://liuyueyi.github.io/tutorial/java/skill/13.List%E8%BD%ACMap-List%E7%9A%84%E5%87%A0%E7%A7%8D%E5%A7%BF%E5%8A%BF.html</link>
      <guid>https://liuyueyi.github.io/tutorial/java/skill/13.List%E8%BD%ACMap-List%E7%9A%84%E5%87%A0%E7%A7%8D%E5%A7%BF%E5%8A%BF.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">13.List转Map List的几种姿势</source>
      <description>实战13：List转Map List的几种姿势 今天介绍一个实用的小知识点，如何将List转为Map&amp;lt;Object, List&amp;lt;Object&amp;gt;&amp;gt;</description>
      <category>Java</category>
      <category>编程技巧</category>
      <pubDate>Tue, 17 May 2022 19:44:20 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 实战13：List转Map List的几种姿势</h1>
<p>今天介绍一个实用的小知识点，如何将List转为<code>Map&lt;Object, List&lt;Object&gt;&gt;</code></p>
<!-- more -->
<h2> 1. 转换方式</h2>
<h3> 1.1. 基本写法</h3>
<p>最开始介绍的当然是最常见、最直观的写法，当然也是任何限制的写法</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对于jdk8+，上面for循环中的内容可以利用<code>Map.computeIfAbsent</code>来替换，具体写法如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当然既然已经是jdk1.8了，借助Stream的流处理，可以将上面的更一步进行简化，如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 1.2. 通用方法</h3>
<p>上面是针对特定的列表，针对业务进行开发转换，那么我们接下来尝试构建一个通用的工具类</p>
<p>这里我们主要借助的知识点就是泛型，一个重要的点就是如何获取Map中的key</p>
<p>对于jdk &lt; 1.8的写法，通过接口来定义实现key的获取姿势</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用demo如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来再看一下jdk1.8之后的写法，结合stream + 函数方法来实现</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其对应的使用方式则如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1.3. 工具类</h3>
<p>上一节介绍了基于泛型 + jdk8 Stream + 函数方法来实现通用转换工具类的实现姿势，接下来我们小结一下，输出一个适用于1.8之后的工具类</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1.4.guava HashMultimap扩展知识点</h3>
<p>最后再介绍一个扩展知识点，Gauva工具包中提供了一个<code>HashMultimap</code>的工具类，他的使用姿势和我们平常的Map并无差别，但是需要在注意的是，它的value是个集合</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>实际输出如下，验证了value实际上是个集合（on只有一个，如果是我们上面的工具类，会输出两个）</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>14.分页遍历的两种使用姿势</title>
      <link>https://liuyueyi.github.io/tutorial/java/skill/14.%E5%88%86%E9%A1%B5%E9%81%8D%E5%8E%86%E7%9A%84%E4%B8%A4%E7%A7%8D%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF.html</link>
      <guid>https://liuyueyi.github.io/tutorial/java/skill/14.%E5%88%86%E9%A1%B5%E9%81%8D%E5%8E%86%E7%9A%84%E4%B8%A4%E7%A7%8D%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">14.分页遍历的两种使用姿势</source>
      <description>实战14：分页遍历得两种实现策略 在日常开发中，分页遍历迭代的场景可以说非常普遍了，比如扫表，每次捞100条数据，然后遍历这100条数据，依次执行某个业务逻辑；这100条执行完毕之后，再加载下一百条数据，直到扫描完毕 那么要实现上面这种分页迭代遍历的场景，我们可以怎么做呢 本文将介绍两种使用姿势 常规的使用方法 借助Iterator的使用姿势</description>
      <category>Java</category>
      <category>JDK</category>
      <pubDate>Thu, 25 Feb 2021 08:05:07 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 实战14：分页遍历得两种实现策略</h1>
<p>在日常开发中，分页遍历迭代的场景可以说非常普遍了，比如扫表，每次捞100条数据，然后遍历这100条数据，依次执行某个业务逻辑；这100条执行完毕之后，再加载下一百条数据，直到扫描完毕</p>
<p>那么要实现上面这种分页迭代遍历的场景，我们可以怎么做呢</p>
<p>本文将介绍两种使用姿势</p>
<ul>
<li>常规的使用方法</li>
<li>借助Iterator的使用姿势</li>
</ul>
<!-- more -->
<h2> 1. 实现方式</h2>
<h3> 1.1. 数据查询模拟</h3>
<p>首先mock一个分页获取数据的逻辑，直接随机生成数据，并且控制最多返回三页</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1.2. 基本实现方式</h3>
<p>针对这种场景，最常见也是最简单直观的实现方式</p>
<ul>
<li>while死循环</li>
<li>内部遍历</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1.3. 迭代器实现方式</h3>
<p>接下来介绍一种更有意思的方式，借助迭代器的遍历特性来实现，首先自定义一个通用分页迭代器</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来借助上面的迭代器可以比较简单的实现我们的需求了</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>那么问题来了，上面这种使用方式比前面的优势体现再哪儿呢？</p>
<ul>
<li>双层循环改为单层循环</li>
</ul>
<p>接下来接入重点了，在jdk1.8引入了函数方法 + lambda之后，又提供了一个更简洁的使用姿势</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在jdk1.8及之后的使用姿势，一行代码即可</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这次对比效果是不是非常显眼了，从此以后分页迭代遍历再也不用冗长的双重迭代了</p>
]]></content:encoded>
    </item>
    <item>
      <title>15.数组拷贝</title>
      <link>https://liuyueyi.github.io/tutorial/java/skill/15.%E6%95%B0%E7%BB%84%E6%8B%B7%E8%B4%9D.html</link>
      <guid>https://liuyueyi.github.io/tutorial/java/skill/15.%E6%95%B0%E7%BB%84%E6%8B%B7%E8%B4%9D.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">15.数组拷贝</source>
      <description>实战15：数组拷贝 说实话，在实际的业务开发中，基本上很少很少很少...会遇到数组拷贝的场景，甚至是我们一般都不怎么用数组，List它不香嘛，为啥要用数组 现在问题来了，要实现数组拷贝，怎么整？</description>
      <category>Java</category>
      <category>编程技巧</category>
      <pubDate>Sat, 21 Aug 2021 06:56:34 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 实战15：数组拷贝</h1>
<p>说实话，在实际的业务开发中，基本上很少很少很少...会遇到数组拷贝的场景，甚至是我们一般都不怎么用数组，List它不香嘛，为啥要用数组</p>
<p>现在问题来了，要实现数组拷贝，怎么整？</p>
<!-- more -->
<h2> 1. 实现方式</h2>
<h3> 1.1. 基础写法</h3>
<p>最简单直接的写法，那就是新建一个数组，一个一个拷贝进去，不就完事了么</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1.2. 借用容器中转</h3>
<p>数组用起来有点麻烦，还是用容器舒爽，借助List来实现数组的拷贝，也就几行代码</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1.3. Array.copy</h3>
<p>上面这个有点绕得远了， 直接使用Array.copy</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1.4. System.arraycopy</h3>
<p>除了上面的，还可以使用更基础的用法</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果有看过jdk源码的小伙伴，上面这个用法应该不会陌生，特别是在容器类，这种数组拷贝的方式比比可见</p>
<p>参数说明:</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>src : 原数组</li>
<li>srcPos: 原数组用于拷贝的起始下标</li>
<li>dest: 拷贝后的数组</li>
<li>destPos: 目标数组的小标</li>
<li>length: 原数组中拷贝过去的数组长度</li>
</ul>
<p>从上面的描述也能看出来，这个方法不仅能实现数组拷贝，还可以实现数组内指定片段的拷贝</p>
]]></content:encoded>
    </item>
    <item>
      <title>16.如何判断类为基础类型or基础类型的包装类</title>
      <link>https://liuyueyi.github.io/tutorial/java/skill/16.%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E7%B1%BB%E4%B8%BA%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8Bor%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8C%85%E8%A3%85%E7%B1%BB.html</link>
      <guid>https://liuyueyi.github.io/tutorial/java/skill/16.%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E7%B1%BB%E4%B8%BA%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8Bor%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8C%85%E8%A3%85%E7%B1%BB.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">16.如何判断类为基础类型or基础类型的包装类</source>
      <description>实战16：判断类为基础类型or基础类型的包装类 判断一个类是否为基础类型属于常规操作了，一般我们遇到这种case，要怎么处理呢？ 一个一个的if/else判断? 还是其他的操作姿势？</description>
      <category>Java</category>
      <category>编程技巧</category>
      <pubDate>Fri, 03 Sep 2021 19:36:52 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 实战16：判断类为基础类型or基础类型的包装类</h1>
<p>判断一个类是否为基础类型属于常规操作了，一般我们遇到这种case，要怎么处理呢？</p>
<p>一个一个的if/else判断? 还是其他的操作姿势？</p>
<!-- more -->
<h2> 1. 基础类型判断</h2>
<p>基础类型可以借助class类的<code>isPrimitive</code>方法来实现判定，使用姿势也简单</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>如果返回true，那么这个对象就是基本类型</p>
<ul>
<li>boolean</li>
<li>char</li>
<li>byte</li>
<li>short</li>
<li>int</li>
<li>long</li>
<li>float</li>
<li>double</li>
<li>void</li>
</ul>
<p>但是请注意，对于封装类型，比如Long，访问isPrimitive返回的是false</p>
<h2> 2. 封装类型判断</h2>
<p>那么封装类型可以怎么判断呢？难道一个一个的判定不成？</p>
<p>首先我们注意到<code>Class#isPrimitive</code>的方法签名，如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的注释中，提到了Boolean#Type之类的静态成员，也就是说包装类型，都有一个TYPE的静态成员</p>
<p>比如boolean的是这个</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>所以我们可以通过这个TYPE来判定，当前对象是否为封装对象</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果Class对象没有TYPE字段，那么就不是封装类，直接抛异常，返回false；当然这种通过异常的方式来判定，并不优雅；但是写法上比我们一个一个的if/else进行对比，要好得多了</p>
]]></content:encoded>
    </item>
    <item>
      <title>17.Java对象内存地址输出</title>
      <link>https://liuyueyi.github.io/tutorial/java/skill/17.Java%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80%E8%BE%93%E5%87%BA.html</link>
      <guid>https://liuyueyi.github.io/tutorial/java/skill/17.Java%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80%E8%BE%93%E5%87%BA.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">17.Java对象内存地址输出</source>
      <description>实战17：Java对象内存地址输出 输出对象地址 当一个对象没有重写hascode方法时，它返回的内存地址，当覆盖之后，我们有什么办法获取对象的内存地址么? 使用 System.identityHashCode() 输出内存地址</description>
      <category>Java</category>
      <category>JDK</category>
      <pubDate>Fri, 29 Jan 2021 10:37:36 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 实战17：Java对象内存地址输出</h1>
<h2> 输出对象地址</h2>
<p>当一个对象没有重写<code>hascode</code>方法时，它返回的内存地址，当覆盖之后，我们有什么办法获取对象的内存地址么?</p>
<ul>
<li>使用 <code>System.identityHashCode()</code> 输出内存地址</li>
</ul>
<!-- more -->
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果如:</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这个有啥用？</p>
<ul>
<li>判断两个对象是否为同一个对象时，可以借用（我是在验证Mybatis的一级缓存的，判断返回的Entity是否确实是同一个的时候以此来判定的）</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>18.随机数生成怎么选</title>
      <link>https://liuyueyi.github.io/tutorial/java/skill/18.%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%94%9F%E6%88%90%E6%80%8E%E4%B9%88%E9%80%89.html</link>
      <guid>https://liuyueyi.github.io/tutorial/java/skill/18.%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%94%9F%E6%88%90%E6%80%8E%E4%B9%88%E9%80%89.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">18.随机数生成怎么选</source>
      <description>实战18：随机数生成怎么选 随机数生成，java中有一个专门的Random类来实现，除此之外，使用Math.random的也比较多，接下来我们简单学习下，随机数的使用姿势</description>
      <category>Java</category>
      <category>编程技巧</category>
      <pubDate>Fri, 03 Sep 2021 19:40:13 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 实战18：随机数生成怎么选</h1>
<p>随机数生成，java中有一个专门的Random类来实现，除此之外，使用<code>Math.random</code>的也比较多，接下来我们简单学习下，随机数的使用姿势</p>
<!-- more -->
<h2> 1.随机数生成</h2>
<h3> 1.1. Math.random</h3>
<p>jdk提供的基础工具类Math中封装一些常用的基础方法，比如我们今天的主题，生成随机数，使用姿势如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>使用起来比较简单，生成的是[0,1)之间的浮点数，但是不要以为它就真的只能生成0-1之间的随机数，举例如下</p>
<p>如果想利用它，生成一个 <code>[120, 500]</code> 这个区间的随机数，怎么整？</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>为啥上面的可行？</p>
<p>将上面的代码翻译一下，取值区间如</p>
<p><code>Math.random() * 381 + 120</code> 取值范围如下</p>
<ul>
<li>[0, 1) * 381 + 120</li>
<li>[0, 381) + 120</li>
<li>[120, 501)</li>
</ul>
<p>借助<code>Math.ceil</code>只取浮点数中的整数部分，这样我们的取值范围就是 [120, 500]了，和我们的预期一致</p>
<p>最后简单来看下，<code>Math.random()</code>是怎么实现随机数的</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>请注意上面的实现，原来底层依然使用的是<code>Random</code>类来生成随机数，而且上面这种写法属于非常经典的单例模式写法（不同于我们常见的双重判定方式，这种属于内部类的玩法，后面再说为啥可以这么用）</p>
<h3> 1.2. Random</h3>
<p>除了使用上面的Math.random来获取随机数之外，直接使用Random类也是很常见的case；接下来先简单看一下Random的使用姿势</p>
<p><strong>创建Random对象</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>生成随机数</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>伪随机高斯分布双精度数</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>随机类的nextGaussian()方法返回下一个伪随机数，即与随机数生成器序列的平均值为0.0，标准差为1.0的高斯(正态)分布双精度值</p>
<p>这种使用场景可能用在更专业的场景，至少我接触过的业务开发中，没有用过这个😂</p>
<h3> 1.3. Math.random 与 Random如何选</h3>
<p>上面两个都可以用来生成随机数，那么在实际使用的时候，怎么选择呢？</p>
<p>从前面的描述也可以知道，它们两没啥本质区别，底层都是用的Random类，在实际的运用过程中，如果我们希望可以场景复现，比如测试中奖概率的场景下，选择Random类，指定随机种子可能更友好；如果只是简单的随机数生成使用，那么选择<code>Math.random</code>即可，至少使用起来一行代码即可</p>
]]></content:encoded>
    </item>
    <item>
      <title>19.数字格式化</title>
      <link>https://liuyueyi.github.io/tutorial/java/skill/19.%E6%95%B0%E5%AD%97%E6%A0%BC%E5%BC%8F%E5%8C%96.html</link>
      <guid>https://liuyueyi.github.io/tutorial/java/skill/19.%E6%95%B0%E5%AD%97%E6%A0%BC%E5%BC%8F%E5%8C%96.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">19.数字格式化</source>
      <description>实战19：数字格式化 数字的格式化场景，更多的是在日志输出、金额计算相关的领域中会用到，平常我们可能更多使用String.format来格式化，但是请注意，数字格式化是有一个DecimalFormat，专门来针对数字进行格式化 今天我们的知识点就是DecimalFormat来实现数字格式化</description>
      <category>Java</category>
      <category>编程技巧</category>
      <pubDate>Wed, 25 Aug 2021 19:12:33 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 实战19：数字格式化</h1>
<p>数字的格式化场景，更多的是在日志输出、金额计算相关的领域中会用到，平常我们可能更多使用<code>String.format</code>来格式化，但是请注意，数字格式化是有一个<code>DecimalFormat</code>，专门来针对数字进行格式化</p>
<p>今天我们的知识点就是DecimalFormat来实现数字格式化</p>
<!-- more -->
<h2> 1. 格式化</h2>
<h3> 1.1. DecimalFormat使用说明</h3>
<p>对于DecimalFormat的使用比较简单，主要是借助两个占位<code>0</code>与<code>#</code>，区别在于当格式化的占位数，多余实际数的时候，占位<code>0</code>的场景下，会用前缀0来补齐；而<code>#</code>则不需要补齐</p>
<p>上面这个可能不太好理解，举例说明如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面两个都是只输出整数，但是输出结果不同，如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>简单来说，就是<code>0</code>，主要用于定长的输出，对于不足的，前缀补0</p>
<p><strong>整数#小数</strong></p>
<p>除了上面的基本姿势之外，更常见的是设置整数、小数的位数</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>百分比</strong></p>
<p>百分比的输出也属于常见的case，使用DecimalFormat就很简单</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>输出如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>科学计数</strong></p>
<p>非专业场景下，科学技术的可能性比较小</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>金钱样式输出</strong></p>
<p>金融相关的钱输出时，非常有意思的是每三位加一个逗号分隔，如果想实现这个效果，也可以很简单完成</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>嵌入模板输出</strong></p>
<p>格式化模板，除了基础的<code>000, ###</code>之外，还可以直接放在一个字符串中，实现类似<code>String.format</code>的效果</p>
<p>比如显示余额</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>20.进制转换很简单</title>
      <link>https://liuyueyi.github.io/tutorial/java/skill/20.%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2%E5%BE%88%E7%AE%80%E5%8D%95.html</link>
      <guid>https://liuyueyi.github.io/tutorial/java/skill/20.%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2%E5%BE%88%E7%AE%80%E5%8D%95.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">20.进制转换很简单</source>
      <description>实战20：进制转换很简单 进制转换，属于基本技能了，在java中要实现进制转换很简单，可以非常简单的实现，接下来我们来看下它的使用姿势</description>
      <category>Java</category>
      <category>编程技巧</category>
      <pubDate>Thu, 26 Aug 2021 18:24:38 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 实战20：进制转换很简单</h1>
<p>进制转换，属于基本技能了，在java中要实现进制转换很简单，可以非常简单的实现，接下来我们来看下它的使用姿势</p>
<!-- more -->
<h2> 1. 进制转换</h2>
<h3> 1.1. toString实现进制转换</h3>
<p>Integer/Long#toString(int i, int radix) 可以将任一进制的整数，转换为其他任意进制的整数</p>
<ul>
<li>第一个参数：待转换的数字</li>
<li>第二个参数：转换后的进制位</li>
</ul>
<p><strong>十六进制转十进制</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>八进制转是十进制</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>八进制转二进制</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 1.2. 十进制转二进制</h3>
<p>除了使用上面的姿势之外，可以直接使用<code>toBinaryString</code>来实现转二进制</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1.3. 十进制转八进制</h3>
<p><code>Integer/Long#toOctalString</code>: 转八进制</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 1.4. 十进制转十六进制</h3>
<p><code>Integer/Long#toHexString</code>: 转十六进制</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>21.配置文件Properties</title>
      <link>https://liuyueyi.github.io/tutorial/java/skill/21.%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6Properties.html</link>
      <guid>https://liuyueyi.github.io/tutorial/java/skill/21.%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6Properties.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">21.配置文件Properties</source>
      <description>实战21：Properties配置文件 properties配置文件，相信各位小伙伴都不会太陌生，常用Spring的可能会经常看到它，虽说现在更推荐的是使用Yaml配置文件，但是properties配置文件的使用频率也不低 在jdk中有一个直接关连的类Properties，接下来我们来看一下它的用法</description>
      <category>Java</category>
      <category>编程技巧</category>
      <pubDate>Mon, 30 Aug 2021 09:34:18 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 实战21：Properties配置文件</h1>
<p>properties配置文件，相信各位小伙伴都不会太陌生，常用Spring的可能会经常看到它，虽说现在更推荐的是使用Yaml配置文件，但是properties配置文件的使用频率也不低</p>
<p>在jdk中有一个直接关连的类Properties，接下来我们来看一下它的用法</p>
<!-- more -->
<h2> 1. Properties配置类</h2>
<h3> 1.1. 配置文件</h3>
<p>properties文件的格式比较简单</p>
<ul>
<li><code>key = value</code>: 等号左边的为配置key，右边的为配置value（value值会去除前后的空格）</li>
<li><code>#</code>：以<code>#</code>来区分注释</li>
</ul>
<p>一个基础的配置文件如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1.2. 配置文件加载</h3>
<p>对于Properties配置文件，我们可以非常简单的借助<code>Properties</code>类，来实现配置的加载</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>直接使用<code>Properties#config</code>就可以读取配置文件内容，并赋值到java对象</p>
<p><strong>重点注意：</strong></p>
<p>重点看一下Properties类的继承关系，它的父类是Hashtable, 也就是说它的本质是Map对象</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1.3. Properties对象使用</h3>
<p>因为<code>Properties</code>是继承自Hashtable，而Hashtable是线程安全的Map容器，因此Properties也是线程安全的，同样的，在多线程并发获取配置的时候，它的性能表现也就不咋地了，why?</p>
<p>首先看一下配置获取</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面两个方法的使用频率很高，从签名上也很容易知道使用姿势；接下来需要看一下的为啥说并发效率很低</p>
<p>关键点就在第一个方法的<code>super.get()</code>，它对应的源码正是</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>方法签名上有<code>synchronized</code>，所以为啥说并发环境下的性能表现不会特别好也就知道原因了</p>
<p>除了获取配置之外，另外一个常用的就是更新配置</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 2. 小结</h2>
<p>本文介绍的知识点主要是properties配置文件的处理，使用同名的java类来操作；需要重点注意的是Properties类属于Hashtable的子类，同样属于容器的范畴</p>
<p>最后提一个扩展的问题，在SpringBoot的配置自动装载中，可以将配置内容自动装载到配置类中，简单来讲就是支持配置到java bean的映射，如果现在让我们来实现这个，可以怎么整？</p>
]]></content:encoded>
    </item>
    <item>
      <title>22.Properties配置文件自动装载JavaBean</title>
      <link>https://liuyueyi.github.io/tutorial/java/skill/22.Properties%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%87%AA%E5%8A%A8%E8%A3%85%E8%BD%BDJavaBean.html</link>
      <guid>https://liuyueyi.github.io/tutorial/java/skill/22.Properties%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%87%AA%E5%8A%A8%E8%A3%85%E8%BD%BDJavaBean.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">22.Properties配置文件自动装载JavaBean</source>
      <description>实战22：Properties配置文件自动装载JavaBean SpringBoot的配置自动装载，使用起来还是很舒爽的，可以非常简单的将properties配置文件的内容，填充到Java bean对象中，如果我们现在是一个脱离于Springboot框架的项目，想实现上面这个功能，可以怎么来做呢？</description>
      <category>Java</category>
      <category>编程技巧</category>
      <pubDate>Fri, 03 Sep 2021 19:38:55 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 实战22：Properties配置文件自动装载JavaBean</h1>
<p>SpringBoot的配置自动装载，使用起来还是很舒爽的，可以非常简单的将properties配置文件的内容，填充到Java bean对象中，如果我们现在是一个脱离于Springboot框架的项目，想实现上面这个功能，可以怎么来做呢？</p>
<!-- more -->
<h2> 1.配置封装</h2>
<h3> 1.1. 配置文件自动装载</h3>
<p>前面介绍了Properties文件的读取以及基本使用姿势，通过上篇博文已知Properties类的本质是一个Map，所以我们需要干的就是将Map容器的值，赋值到JavaBean的成员属性中</p>
<p>要实现这个功能，自然而然会想到的就是利用反射（考虑到我们赋值的通常为标准的java bean，使用内省是个更好的选择）</p>
<p>接下来我们需要实现的也比较清晰了，第一步获取成员属性，两种方式</p>
<ul>
<li>内省: <code>BeanInfo bean = Introspector.getBeanInfo(clz); PropertyDescriptor[] propertyDescriptors = bean.getPropertyDescriptors();</code></li>
<li>反射: <code>Field[] fields = clz.getDeclaredFields();</code></li>
</ul>
<p>第二步遍历成员属性，进行赋值</p>
<ul>
<li>内省：借助前面获取的<code>PropertyDescriptor</code>对象，拿到set方法，进行赋值
<ul>
<li><code>descriptor.getWriteMethod().invoke(obj, value)</code></li>
</ul>
</li>
<li>反射：适应<code>Field.set</code>来赋值
<ul>
<li><code>field.set(obj, value);</code></li>
</ul>
</li>
</ul>
<p><strong>注意</strong></p>
<ul>
<li>上面的两种赋值方式，都要求我们传入的value对象类型与定义类型一直，否则会抛类型转换异常</li>
</ul>
<p>为了避免复杂的类型转换与判定，我们这里介绍下apache的<code>commons-beanutils</code>来实现属性拷贝</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来核心的实现逻辑如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意上面的实现，首先通过内省的方式获取所有的成员，然后进行遍历，借助<code>BeanUtils.setProperty</code>来实现属性值设置</p>
<p>这里面有两个知识点</p>
<ul>
<li><code>BeanUtil</code> 还是 <code>PropertyUtil</code>
<ul>
<li>它们两都有个设置属性的方法，但是BeanUtil支持简单类型的自动转换；而后者不行，要求类型完全一致</li>
</ul>
</li>
<li>非简单类型
<ul>
<li>对于非简单类型，上面采用了递归的调用方式来处理；请注意，这里并不完善，比如BigDecimal, Date, List, Map这些相对基础的类型，是不太适用的哦</li>
</ul>
</li>
</ul>
<h3> 1.2. 功能测试</h3>
<p>最后针对上面的实现功能，简单的测试一下，是否可行</p>
<p>配置文件<code>mail.properties</code></p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>两个Java Bean</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>转换测试类</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果如下：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>23.基于引入包选择具体实现类</title>
      <link>https://liuyueyi.github.io/tutorial/java/skill/23.%E5%9F%BA%E4%BA%8E%E5%BC%95%E5%85%A5%E5%8C%85%E9%80%89%E6%8B%A9%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0%E7%B1%BB.html</link>
      <guid>https://liuyueyi.github.io/tutorial/java/skill/23.%E5%9F%BA%E4%BA%8E%E5%BC%95%E5%85%A5%E5%8C%85%E9%80%89%E6%8B%A9%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0%E7%B1%BB.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">23.基于引入包选择具体实现类</source>
      <description>实战23：基于引入包选择具体实现类 最近遇到一个需求场景，开源的工具包，新增了一个高级特性，会依赖json序列化工具，来做一些特殊操作；但是，这个辅助功能并不是必须的，也就是说对于使用这个工具包的业务方而言，正常使用完全不需要json相关的功能；如果我强引用某个json工具，一是对于不适用高级特性的用户而言没有必要；二则是我引入的json工具极有可能与使用者的不一致，会增加使用者的成本 因此我希望这个工具包对外提供时，并不会引入具体的json工具依赖；也就是说maven依赖中的&amp;lt;scope&amp;gt;设置为provided；具体的json序列化的实现，则取决于调用方自身引入了什么json工具包 那么可以怎么实现上面这个方式呢？</description>
      <category>Java</category>
      <category>编程技巧</category>
      <pubDate>Wed, 24 Aug 2022 18:54:08 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 实战23：基于引入包选择具体实现类</h1>
<p>最近遇到一个需求场景，开源的工具包，新增了一个高级特性，会依赖json序列化工具，来做一些特殊操作；但是，这个辅助功能并不是必须的，也就是说对于使用这个工具包的业务方而言，正常使用完全不需要json相关的功能；如果我强引用某个json工具，一是对于不适用高级特性的用户而言没有必要；二则是我引入的json工具极有可能与使用者的不一致，会增加使用者的成本</p>
<p>因此我希望这个工具包对外提供时，并不会引入具体的json工具依赖；也就是说maven依赖中的<code>&lt;scope&gt;</code>设置为<code>provided</code>；具体的json序列化的实现，则取决于调用方自身引入了什么json工具包</p>
<p>那么可以怎么实现上面这个方式呢？</p>
<!-- more -->
<h2> 1.实现方式</h2>
<h3> 1.1. 任务说明</h3>
<p>上面的简单的说了一下我们需要做的事情，接下来我们重点盘一下，我们到底是要干什么</p>
<p>核心诉求相对清晰</p>
<ol>
<li>不强引入某个json工具</li>
<li>若需要使用高级特性，则直接使用当前环境中已集成的json序列化工具；若没有提供，则抛异常，不支持</li>
</ol>
<p>对于上面这个场景，常年使用Spring的我们估计不会陌生，Spring集成了很多的第三方开源组件，根据具体的依赖来选择最终的实现，比如日志，可以是logback，也可以是log4j；比如redis操作，可以是jedis，也可以是lettuce</p>
<p>那么Spring是怎么实现的呢？</p>
<h3> 1.2.具体实现</h3>
<p>在Spring中有个注解名为<code>ConditionalOnClass</code>，表示当某个类存在时，才会干某些事情（如初始化bean对象）</p>
<p>它是怎么是实现的呢？（感兴趣的小伙伴可以搜索一下，或者重点关注下 <code>SpringBootCondition</code> 的实现）</p>
<p>这里且抛开Spring的实现姿势，我们采用传统的实现方式，直接判断是否有加载对应的类，来判断有没有引入相应的工具包</p>
<p>如需要判断是否引入了gson包，则判断ClassLoader是否有加载<code>com.google.gson.Gson</code>类</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这种实现方式就可以达到我们的效果了；接下来我们参考下Spring的ClassUtils实现，做一个简单的封装，以判断是否存在某个类</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>工具类存在之后，我们实现一个简单的json工具类，根据已有的json包来选择具体的实现</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的实现中，根据已有的json序列化工具，选择具体的实现类，我们定义了一个JsonApi接口，然后分别gson,jackson,fastjson给出默认的实现类</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>最后的问题来了，如果调用方并没有使用上面三个序列化工具，而是使用其他的呢，可以支持么？</p>
<p>既然我们定义了一个JsonApi，那么是不是可以由用户自己来实现接口，然后自动选择它呢？</p>
<p>现在的问题就是如何找到用户自定义的接口实现了</p>
<h3> 1.3. 扩展机制</h3>
<p>对于SPI机制比较熟悉的小伙伴可能非常清楚，可以通过在配置目录<code>META-INF/services/</code>下新增接口文件，内容为实现类的全路径名称，然后通过 <code>ServiceLoader.load(JsonApi.class)</code> 的方式来获取所有实现类</p>
<p>除了SPI的实现方式之外，另外一个策略则是上面提到的Spring的实现原理，借助字节码来处理（详情原理后面专文说明）</p>
<p>当然也有更容易想到的策略，扫描包路径下的class文件，遍历判断是否为实现类(额外注意jar包内的实现类场景)</p>
<p>接下来以SPI的方式来介绍下扩展实现方式，首先初始化JsonApi的方式改一下，优先使用用户自定义实现</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对于使用者而言，首先是实现接口</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接着就是实现定义, <code>resources/META-INF/services/</code> 目录下，新建文件名为 <code>com.github.hui.quick.plugin.qrcode.util.json.JsonApi</code></p>
<p>内容如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>然后完工~</p>
<h2> 2. 小结</h2>
<p>主要介绍一个小的知识点，如何根据应用已有的jar包来选择具体的实现类的方式；本文介绍的方案是通过ClassLoader来尝试加载对应的类，若能正常加载，则认为有；否则认为没有；这种实现方式虽然非常简单，但是请注意，它是有缺陷的，至于缺陷是啥...</p>
<p>除此之外，也可以考虑通过字节码的方式来判断是否有某个类，或者获取某个接口的实现；文中最后抛出了一个问题，如何获取接口的所有实现类</p>
<p>常见的方式有下面三类（具体介绍了SPI的实现姿势，其他的两种感兴趣的可以搜索一下）</p>
<ul>
<li>SPI定义方式</li>
<li>扫描包路径</li>
<li>字节码方式(如Spring，如Tomcat的<code>@HandlesTypes</code>)</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>24.基于JDK的LRU算法实现</title>
      <link>https://liuyueyi.github.io/tutorial/java/skill/24.%E5%9F%BA%E4%BA%8EJDK%E7%9A%84LRU%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0.html</link>
      <guid>https://liuyueyi.github.io/tutorial/java/skill/24.%E5%9F%BA%E4%BA%8EJDK%E7%9A%84LRU%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">24.基于JDK的LRU算法实现</source>
      <description>实战24： 基于JDK的LRU算法实现 1. LRU算法 缓存淘汰算法--LRU算法LRU（Least recently used，最近最少使用）算法 根据数据的历史访问记录来进行淘汰数据，其核心思想是&amp;quot;如果数据最近被访问过，那么将来被访问的几率也更高&amp;quot; 再Java中可以非常简单的实现LRU算法，主要利用的是LinkedHashMap容器 1.1 LRU算法实现 inkedHashMap底层就是用的HashMap加双链表实现的，而且本身已经实现了按照访问顺序的存储。此外，LinkedHashMap中本身就实现了一个方法removeEldestEntry用于判断是否需要移除最不常读取的数，方法默认是直接返回false，不会移除元素</description>
      <category>Java</category>
      <category>编程技巧</category>
      <pubDate>Thu, 21 Oct 2021 18:54:08 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 实战24： 基于JDK的LRU算法实现</h1>
<h2> 1. LRU算法</h2>
<p>缓存淘汰算法--LRU算法LRU（Least recently used，最近最少使用）算法</p>
<p>根据数据的历史访问记录来进行淘汰数据，其核心思想是"如果数据最近被访问过，那么将来被访问的几率也更高"</p>
<p>再Java中可以非常简单的实现LRU算法，主要利用的是LinkedHashMap容器</p>
<h3> 1.1 LRU算法实现</h3>
<p>inkedHashMap底层就是用的HashMap加双链表实现的，而且本身已经实现了按照访问顺序的存储。此外，LinkedHashMap中本身就实现了一个方法removeEldestEntry用于判断是否需要移除最不常读取的数，方法默认是直接返回false，不会移除元素</p>
<p>因此我们只需要重写这个方法，可以实现当缓存满之后，就移除最不常用的数据</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意上面的访问，当i == 6 时，主动访问了一下 <code>一灰灰blog_2</code>，主要就是不希望淘汰掉它，再看下对应的输出</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>实际输出与我们预期一致</p>
<h3> 1.2 小结</h3>
<p>jdk中蕴含了大量的财富，就看我们能不能识别出来了；通常我非常推荐&lt;3年的小伙伴，有事没事多盘一下jdk的经典实现，比如各种容器的底层结构，并发类的设计思想等</p>
]]></content:encoded>
    </item>
    <item>
      <title>25.数字型字面量中的下划线</title>
      <link>https://liuyueyi.github.io/tutorial/java/skill/25.%E6%95%B0%E5%AD%97%E5%9E%8B%E5%AD%97%E9%9D%A2%E9%87%8F%E4%B8%AD%E7%9A%84%E4%B8%8B%E5%88%92%E7%BA%BF.html</link>
      <guid>https://liuyueyi.github.io/tutorial/java/skill/25.%E6%95%B0%E5%AD%97%E5%9E%8B%E5%AD%97%E9%9D%A2%E9%87%8F%E4%B8%AD%E7%9A%84%E4%B8%8B%E5%88%92%E7%BA%BF.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">25.数字型字面量中的下划线</source>
      <description>实战25： 数字型字面量中的下划线 不知道有没有小伙伴看过下面这种写法，不用质疑，它没有语法错误；再很多开源的框架中可以看到类似的写法；这种再字面量中添加下划线的方式，是一种小却使用的编程小技巧，推荐给CURD开发者 long price = 1_000_123L;</description>
      <category>Java</category>
      <category>编程技巧</category>
      <pubDate>Wed, 26 Sep 2018 01:13:36 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 实战25： 数字型字面量中的下划线</h1>
<p>不知道有没有小伙伴看过下面这种写法，不用质疑，它没有语法错误；再很多开源的框架中可以看到类似的写法；这种再字面量中添加下划线的方式，是一种小却使用的编程小技巧，推荐给CURD开发者</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><!-- more -->
<h2> 1. Java7新特性之数字中使用下划线</h2>
<p>为了直观性而言，在大数之间，加上下划线用于肉眼区分，下面实例小结下用法</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>简单来说，就是在数中间，插上下划线，用于划分段落</p>
<h2> 2. 小结</h2>
<p>再字面量中添加下划线，主要用于分割大数，方便阅读，重点注意：</p>
<ul>
<li>不能在小数点正前后添加</li>
<li>不要在L/D/F等数据类型标识的正前方添加</li>
<li>不能作为数字开头，也不能作为结尾</li>
<li>不要往进制修饰符中间或后面添加</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>26.列表遍历删除使用实例</title>
      <link>https://liuyueyi.github.io/tutorial/java/skill/26.%E5%88%97%E8%A1%A8%E9%81%8D%E5%8E%86%E5%88%A0%E9%99%A4%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BE%8B.html</link>
      <guid>https://liuyueyi.github.io/tutorial/java/skill/26.%E5%88%97%E8%A1%A8%E9%81%8D%E5%8E%86%E5%88%A0%E9%99%A4%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BE%8B.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">26.列表遍历删除使用实例</source>
      <description>实战26：列表遍历删除使用实例 在实际的业务开发中，容器的遍历可以说是非常非常常见的场景了，遍历删除呢，用的机会也不会少，但你真的会用么？</description>
      <category>Java</category>
      <category>编程技巧</category>
      <pubDate>Tue, 21 May 2019 20:21:35 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 实战26：列表遍历删除使用实例</h1>
<p>在实际的业务开发中，容器的遍历可以说是非常非常常见的场景了，遍历删除呢，用的机会也不会少，但你真的会用么？</p>
<!-- more -->
<h2> 1. List遍历删除</h2>
<p>对于列表，这里以ArrayList进行举例说明，下面给出几种经常会遇到的写法</p>
<p>首先初始化一个list数组</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1.1. foreach</h3>
<p>这个属于我们最常见的foreach循环，在循环内部判断满足条件的直接删除</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这种写法导致的问题，很容易可以发现，因为上面代码跑完之后，堆栈就出来了</p>
<figure><img src="https://blog.hhui.top/hexblog/imgs/190521/00.jpg" alt="IMAGE" tabindex="0" loading="lazy"><figcaption>IMAGE</figcaption></figure>
<p>很典型的并发修改错误，在foreach循环中不允许删除,新增</p>
<h3> 1.2. 普通for循环</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这种写法呢？我们希望把列表中，第0，5，10，15位置的元素干掉，正常执行，倒是不会报错，然而输出的结果却和我们的预期不一致</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>for循环中，另外一种写法可能更加常见，为了避免每次都访问 <code>list.size()</code> 方法，我可能提前用一个变量保存数组大小</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这个问题就很明显了，数组越界</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1.3. 迭代方式</h3>
<p>下面这种可以说是标准的迭代删除的写法了，基本上大多都是这么玩</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1.4. jdk8+ 流方式</h3>
<p>jdk8+ 推荐下面这种写法，简洁明了</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2> 2. 小结</h2>
<p>注意不要在for/foreach遍历过程中删除元素，如果有移除元素的需求，使用迭代器；或者使用jdk8的流式写法也行</p>
]]></content:encoded>
      <enclosure url="https://blog.hhui.top/hexblog/imgs/190521/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>27.HashMap遍历删除使用实例</title>
      <link>https://liuyueyi.github.io/tutorial/java/skill/27.Map%E9%81%8D%E5%8E%86%E5%88%A0%E9%99%A4%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BE%8B.html</link>
      <guid>https://liuyueyi.github.io/tutorial/java/skill/27.Map%E9%81%8D%E5%8E%86%E5%88%A0%E9%99%A4%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BE%8B.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">27.HashMap遍历删除使用实例</source>
      <description>实战27：HashMap遍历删除使用实例 map的迭代删除，和我们常见的list，set不太一样，不能直接获取Iteraotr对象，提供的删除方法也是单个的，根据key进行删除，如果我们有个需求，将map中满足某些条件的元素删除掉，要怎么做呢？</description>
      <category>Java</category>
      <category>编程技巧</category>
      <pubDate>Wed, 29 May 2019 21:38:18 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 实战27：HashMap遍历删除使用实例</h1>
<p>map的迭代删除，和我们常见的list，set不太一样，不能直接获取Iteraotr对象，提供的删除方法也是单个的，根据key进行删除，如果我们有个需求，将map中满足某些条件的元素删除掉，要怎么做呢？</p>
<!-- more -->
<h2> 1. Map 迭代删除</h2>
<p>迭代删除，在不考虑并发安全的前提下，我们看下可以怎么支持</p>
<h3> 1.1. 非常不优雅版本</h3>
<p>我们知道map并不是继承自Collection接口的，HashMap 也没有提供迭代支持，既然没法直接迭代，那我就老老实的low b版好了</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的实现怎么样？并没有什么毛病</p>
<p>(为啥不直接在遍历中删除？）</p>
<h3> 1.2. 正确姿势版</h3>
<p>虽然Map没有迭代，但是它的entrySet有啊，所以我们可以通过它来实现遍历删除</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这个可能是我们经常使用的操作姿势了，利用迭代器来操作元素</p>
<h3> 1.3. 简洁版</h3>
<p>到jdk8之后，针对容器提供了很多简洁的操作方式，迭代删除这方面可以说更加简单了</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 2. 小结</h2>
<p>和列表删除元素一样，不要在for/foreach迭代过程中删除数据，如有需要，迭代器才是正解；jdk8之后更推荐流式写法</p>
]]></content:encoded>
    </item>
    <item>
      <title>28.优雅的代码耗时统计策略</title>
      <link>https://liuyueyi.github.io/tutorial/java/skill/28.%E4%BC%98%E9%9B%85%E7%9A%84%E4%BB%A3%E7%A0%81%E8%80%97%E6%97%B6%E7%BB%9F%E8%AE%A1.html</link>
      <guid>https://liuyueyi.github.io/tutorial/java/skill/28.%E4%BC%98%E9%9B%85%E7%9A%84%E4%BB%A3%E7%A0%81%E8%80%97%E6%97%B6%E7%BB%9F%E8%AE%A1.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">28.优雅的代码耗时统计策略</source>
      <description>实战28：优雅的实现代码耗时统计 在我们的实际开发中，多多少少会遇到统计一段代码片段的耗时的情况，我们一般的写法如下 long start = System.currentTimeMillis(); try { // .... 具体的代码段 } finally { System.out.println(&amp;quot;cost: &amp;quot; + (System.currentTimeMillis() - start)); } 上面的写法没有什么毛病，但是看起来就不太美观了，那么有没有什么更优雅的写法呢？</description>
      <category>Java</category>
      <category>编程技巧</category>
      <pubDate>Tue, 03 Mar 2020 09:58:40 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 实战28：优雅的实现代码耗时统计</h1>
<p>在我们的实际开发中，多多少少会遇到统计一段代码片段的耗时的情况，我们一般的写法如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的写法没有什么毛病，但是看起来就不太美观了，那么有没有什么更优雅的写法呢？</p>
<!-- more -->
<h2> 1. 代理方式</h2>
<p>了解Spring AOP的同学可能立马会想到一个解决方法，如果想要统计某个方法耗时，使用切面可以无侵入的实现，如</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Spring AOP的底层支持原理为代理模式，为目标对象提供增强功能；在Spring的生态体系下，使用aop的方式来统计方法耗时，可以说少侵入且实现简单，但是有以下几个问题</p>
<ul>
<li>统计粒度为方法级别</li>
<li>类内部方法调用无法生效（详情可以参考博文：<a href="http://spring.hhui.top/spring-blog/2019/03/02/190302-SpringBoot%E5%9F%BA%E7%A1%80%E7%AF%87AOP%E4%B9%8B%E9%AB%98%E7%BA%A7%E4%BD%BF%E7%94%A8%E6%8A%80%E8%83%BD/" target="_blank" rel="noopener noreferrer">【SpringBoot 基础系列教程】AOP之高级使用技能</a>）</li>
</ul>
<h2> 2. AutoCloseable</h2>
<p>在JDK1.7引入了一个新的接口<code>AutoCloseable</code>, 通常它的实现类配合<code>try{}</code>使用，可在IO流的使用上，经常可以看到下面这种写法</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意上面的写法中，最值得关注一点是，不需要再主动的写<code>stream.close</code>了，主要原因就是在<code>try(){}</code>执行完毕之后，会调用方法<code>AutoCloseable#close</code>方法；</p>
<p>基于此，我们就会有一个大单的想法，下一个<code>Cost</code>类实现<code>AutoCloseable</code>接口，创建时记录一个时间，close方法中记录一个时间，并输出时间差值；将需要统计耗时的逻辑放入<code>try(){}</code>代码块</p>
<p>下面是一个具体的实现：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>执行后输出如下:</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果代码块抛异常，也会正常输出耗时么？</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>再次输出如下，并没有问题</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 3. 小结</h2>
<p>除了上面介绍的两种方式，还有一种在业务开发中不太常见，但是在中间件、偏基础服务的功能组件中可以看到，利用Java Agent探针技术来实现，比如阿里的arthas就是在JavaAgent的基础上做了各种上天的功能，后续介绍java探针技术时会专门介绍</p>
<p>下面小结一下三种统计耗时的方式</p>
<p><strong>基本写法</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>优点是简单，适用范围广泛；缺点是侵入性强，大量的重复代码</p>
<p><strong>Spring AOP</strong></p>
<p>在Spring生态下，可以借助AOP来拦截目标方法，统计耗时</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>优点：无侵入，适合统一管理（比如测试环境输出统计耗时，生产环境不输出）；缺点是适用范围小，且粒度为方法级别，并受限于AOP的使用范围</p>
<p><strong>AutoCloseable</strong></p>
<p>这种方式可以看做是第一种写法的进阶版</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>优点是：简单，适用范围广泛，且适合统一管理；缺点是依然有代码侵入</p>
<p><strong>说明</strong></p>
<p>上面第二种方法看着属于最优雅的方式，但是限制性强；如果有更灵活的需求，建议考虑第三种写法，在代码的简洁性和统一管理上都要优雅很多，相比较第一种可以减少大量冗余代码</p>
]]></content:encoded>
    </item>
    <item>
      <title>29.获取类路径的常见方式</title>
      <link>https://liuyueyi.github.io/tutorial/java/skill/29.%E8%8E%B7%E5%8F%96%E7%B1%BB%E8%B7%AF%E5%BE%84%E7%9A%84%E5%B8%B8%E8%A7%81%E6%96%B9%E5%BC%8F.html</link>
      <guid>https://liuyueyi.github.io/tutorial/java/skill/29.%E8%8E%B7%E5%8F%96%E7%B1%BB%E8%B7%AF%E5%BE%84%E7%9A%84%E5%B8%B8%E8%A7%81%E6%96%B9%E5%BC%8F.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">29.获取类路径的常见方式</source>
      <description>实战29：获取类路径的常见方式 1. 资源路径查询 在Java环境中，如何获取当前类的路径，如何获取项目根路径，可以说是比较常见的需求场景了，下面简单的记录一下</description>
      <category>Java</category>
      <category>编程技巧</category>
      <pubDate>Mon, 27 Aug 2018 09:58:40 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 实战29：获取类路径的常见方式</h1>
<h2> 1. 资源路径查询</h2>
<p>在Java环境中，如何获取当前类的路径，如何获取项目根路径，可以说是比较常见的需求场景了，下面简单的记录一下</p>
<!-- more -->
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出如下:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 2. 小结</h2>
<ol>
<li><code>new File(this.getClass().getResource("/").getPath())</code>
<ul>
<li>获取类加载的根路径</li>
</ul>
</li>
<li><code>new File(this.getClass().getResource("").getPath())</code>
<ul>
<li>获取当前类的所在工程路径; 如果不加“/”  获取当前类的加载目录</li>
</ul>
</li>
<li><code>new File("").getCanonicalPath()</code>
<ul>
<li>获取项目路径</li>
</ul>
</li>
<li><code>this.getClass().getClassLoader().getResource("")</code></li>
<li><code>System.getProperty("user.dir")</code></li>
<li><code>System.getProperty("java.class.path")</code>
<ul>
<li>获取所有的类路径 包括jar包的路径</li>
</ul>
</li>
</ol>
]]></content:encoded>
    </item>
    <item>
      <title>30.Deflater压缩与Inflater解压</title>
      <link>https://liuyueyi.github.io/tutorial/java/skill/30.Deflater%E5%8E%8B%E7%BC%A9%E4%B8%8EInflater%E8%A7%A3%E5%8E%8B.html</link>
      <guid>https://liuyueyi.github.io/tutorial/java/skill/30.Deflater%E5%8E%8B%E7%BC%A9%E4%B8%8EInflater%E8%A7%A3%E5%8E%8B.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">30.Deflater压缩与Inflater解压</source>
      <description>实战30：JDK压缩与解压工具类 在实际的应用场景中，特别是对外传输数据时，将原始数据压缩之后丢出去，可以说是非常常见的一个case了，平常倒是没有直接使用JDK原生的压缩工具类，使用Protosutff和Kryo的机会较多,正好在实际的工作场景中遇到了，现在简单的看下使用姿势</description>
      <category>Java</category>
      <category>编程技巧</category>
      <pubDate>Mon, 27 Aug 2018 09:58:40 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 实战30：JDK压缩与解压工具类</h1>
<p>在实际的应用场景中，特别是对外传输数据时，将原始数据压缩之后丢出去，可以说是非常常见的一个case了，平常倒是没有直接使用JDK原生的压缩工具类，使用Protosutff和Kryo的机会较多,正好在实际的工作场景中遇到了，现在简单的看下使用姿势</p>
<!-- more -->
<h2> 1. 压缩与解压工具类</h2>
<h3> 1.1. 基本实现</h3>
<p>主要借助的就是Deflater, Inflater两个工具类，其使用姿势如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>一个简单的测试</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1.2. 注意事项</h3>
<p>上面这个运作的还挺好，但在接入使用时，总是提示<code>java.util.zip.DataFormatException: incorrect header check</code>, 因为接受的是第三方传递过来的压缩数据，比较坑爹的是对方就写了个Deflater压缩，然后什么都没有了，那么这个是啥原因呢？</p>
<p>其实看下Deflater的构造方法，发现还可以传一个boolean值(nowrap), 官方说明是</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>简单来说，就是压缩时，如果nowrap为true，那么解压时也要为true；否则对不上时，就会抛异常</p>
<p>接下来简单对比下两种不同传参的情况，首先更新下工具类</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>测试如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果如下，从大小来看，前者小那么一点点</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 2. 小结</h2>
<p>一般来说，jdk自带的压缩与解压，除了方便之外，可能优势并不是那么的大，这里盗一张网上的对比表格</p>
<p>以下来自: <a href="https://www.cnblogs.com/lonelywolfmoutain/p/5563985.html" target="_blank" rel="noopener noreferrer">[java]序列化框架性能对比（kryo、hessian、java、protostuff）</a></p>
<table>
<thead>
<tr>
<th></th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>kryo</td>
<td>速度快，序列化后体积小</td>
<td>跨语言支持较复杂</td>
</tr>
<tr>
<td>hessian</td>
<td>默认支持跨语言</td>
<td>较慢</td>
</tr>
<tr>
<td>protostuff</td>
<td>速度快，基于protobuf</td>
<td>需静态编译</td>
</tr>
<tr>
<td>Protostuff-Runtime</td>
<td>无需静态编译，但序列化前需预先传入schema</td>
<td>不支持无默认构造函数的类，反序列化时需用户自己初始化序列化后的对象，其只负责将该对象进行赋值</td>
</tr>
<tr>
<td>jdk</td>
<td>使用方便，可序列化所有类</td>
<td>速度慢，占空间</td>
</tr>
</tbody>
</table>
<p>其次，在使用java的压缩与解压时，需要注意下，nowrap这个参数，需要保持一致，否则会报错</p>
]]></content:encoded>
    </item>
    <item>
      <title>31.深拷贝浅拷贝及对象拷贝的两种方式</title>
      <link>https://liuyueyi.github.io/tutorial/java/skill/31.%E6%B7%B1%E6%8B%B7%E8%B4%9D%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%8F%8A%E5%AF%B9%E8%B1%A1%E6%8B%B7%E8%B4%9D%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F.html</link>
      <guid>https://liuyueyi.github.io/tutorial/java/skill/31.%E6%B7%B1%E6%8B%B7%E8%B4%9D%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%8F%8A%E5%AF%B9%E8%B1%A1%E6%8B%B7%E8%B4%9D%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">31.深拷贝浅拷贝及对象拷贝的两种方式</source>
      <description>实战31：深拷贝浅拷贝及对象拷贝的两种方式 1. Java之Clone 1.1 背景 对象拷贝，是一个非常基础的内容了，为什么会单独的把这个领出来讲解，主要是先前遇到了一个非常有意思的场景 有一个任务，需要解析类xml标记语言，然后生成document对象，之后将会有一系列针对document对象的操作 通过实际的测试，发现生成Document对象是比较耗时的一个操作，再加上这个任务场景中，需要解析的xml文档是固定的几个，那么一个可以优化的思路就是能不能缓存住创建后的Document对象，在实际使用的时候clone一份出来</description>
      <category>Java</category>
      <category>编程技巧</category>
      <pubDate>Sun, 17 Dec 2017 19:53:51 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 实战31：深拷贝浅拷贝及对象拷贝的两种方式</h1>
<h2> 1. Java之Clone</h2>
<h3> 1.1 背景</h3>
<p>对象拷贝，是一个非常基础的内容了，为什么会单独的把这个领出来讲解，主要是先前遇到了一个非常有意思的场景</p>
<p>有一个任务，需要解析类xml标记语言，然后生成document对象，之后将会有一系列针对document对象的操作</p>
<p>通过实际的测试，发现生成Document对象是比较耗时的一个操作，再加上这个任务场景中，需要解析的xml文档是固定的几个，那么一个可以优化的思路就是能不能缓存住创建后的Document对象，在实际使用的时候clone一份出来</p>
<!-- more  -->
<h3> 1.2 内容说明</h3>
<p>看到了上面的应用背景，自然而言的就会想到深拷贝了，本篇博文则主要内容如下</p>
<ul>
<li>介绍下两种拷贝方式的区别</li>
<li>深拷贝的辅助工具类</li>
<li>如何自定义实现对象拷贝</li>
</ul>
<h2> 2. 深拷贝和浅拷贝</h2>
<h3> 2.1 定义说明</h3>
<p><strong>深拷贝</strong></p>
<p>相当于创建了一个新的对象，只是这个对象的所有内容，都和被拷贝的对象一模一样而已，即两者的修改是隔离的，相互之间没有影响</p>
<p><strong>浅拷贝</strong></p>
<p>也是创建了一个对象，但是这个对象的某些内容（比如A）依然是被拷贝对象的，即通过这两个对象中任意一个修改A，两个对象的A都会受到影响</p>
<p>看到上面两个简单的说明，那么问题来了</p>
<ul>
<li>浅拷贝中，是所有的内容公用呢？还是某些内容公用？</li>
<li>从隔离来将，都不希望出现浅拷贝这种方式了，太容易出错了，那么两种拷贝方式的应用场景是怎样的？</li>
</ul>
<h3> 2.2 浅拷贝</h3>
<p>一般来说，浅拷贝方式需要实现<code>Cloneable</code>接口，下面结合一个实例，来看下浅拷贝中哪些是独立的，哪些是公用的</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>结果分析：</p>
<ul>
<li>拷贝后获取的是一个独立的对象，和原对象拥有不同的内存地址</li>
<li>基本元素类型，两者是隔离的（虽然上面只给出了int，String）
<ul>
<li>基本元素类型包括:</li>
<li>int, Integer, long, Long, char, Charset, byte,Byte, boolean, Boolean, float,Float, double, Double, String</li>
</ul>
</li>
<li>非基本数据类型（如基本容器，其他对象等），只是拷贝了一份引用出去了，实际指向的依然是同一份</li>
</ul>
<p>其实，浅拷贝有个非常简单的理解方式：</p>
<p><strong>浅拷贝的整个过程就是，创建一个新的对象，然后新对象的每个值都是由原对象的值，通过 <code>=</code> 进行赋值</strong></p>
<p>这个怎么理解呢？</p>
<p>上面的流程拆解就是：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>那么=赋值有什么特点呢？</p>
<p>基本数据类型是值赋值；非基本的就是引用赋值</p>
<h3> 2.3 深拷贝</h3>
<p>深拷贝，就是要创建一个全新的对象，新的对象内部所有的成员也都是全新的，只是初始化的值已经由被拷贝的对象确定了而已</p>
<p>那么上面的实例改成深拷贝应该是怎样的呢？</p>
<p>可以加上这么一个方法</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果为：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>结果分析：</p>
<ul>
<li>深拷贝独立的对象</li>
<li>拷贝后对象的内容，与原对象的内容完全没关系，都是独立的</li>
</ul>
<p>简单来说，深拷贝是需要自己来实现的，对于基本类型可以直接赋值，而对于对象、容器、数组来讲，需要创建一个新的出来，然后重新赋值</p>
<h3> 2.4 应用场景区分</h3>
<p>深拷贝的用途我们很容易可以想见，某个复杂对象创建比较消耗资源的时候，就可以缓存一个蓝本，后续的操作都是针对深clone后的对象，这样就不会出现混乱的情况了</p>
<p>那么浅拷贝呢？感觉留着是一个坑，一个人修改了这个对象的值，结果发现对另一个人造成了影响，真不是坑爹么？</p>
<p>假设又这么一个通知对象长下面这样</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们现在随机挑选了一千个人，同时发送通知消息，所以需要创建一千个上面的对象，这些对象中呢，除了notifyUser不同，其他的都一样</p>
<p>在发送之前，突然发现要临时新增一条通知信息，如果是浅拷贝的话，只用在任意一个通知对象的notifyRules中添加一调消息，那么这一千个对象的通知消息都会变成最新的了；而如果你是用深拷贝，那么苦逼的得遍历这一千个对象，每个都加一条消息了</p>
<hr>
<h2> 3. 对象拷贝工具</h2>
<p>上面说到，浅拷贝，需要实现Clonebale接口，深拷贝一般需要自己来实现，那么我现在拿到一个对象A，它自己没有提供深拷贝接口，我们除了主动一条一条的帮它实现之外，有什么辅助工具可用么？</p>
<p>对象拷贝区别与clone，它可以支持两个不同对象之间实现内容拷贝</p>
<p><strong>Apache的两个版本：（反射机制）</strong></p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>Spring版本：（反射机制）</strong></p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>cglib版本：（使用动态代理，效率高）</strong></p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>从上面的几个有名的工具类来看，提供了两种使用者姿势，一个是反射，一个是动态代理，下面分别来看两种思路</p>
<h3> 3.1 借助反射实现对象拷贝</h3>
<p>通过反射的方式实现对象拷贝的思路还是比较清晰的，先通过反射获取对象的所有属性，然后修改可访问级别，然后赋值；再获取继承的父类的属性，同样利用反射进行赋值</p>
<p>上面的几个开源工具，内部实现封装得比较好，所以直接贴源码可能不太容易一眼就能看出反射方式的原理，所以简单的实现了一个, 仅提供思路</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的实现步骤还是非常清晰的，首先是找同名的属性，然后利用反射获取对应的值</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果找不到，则找getXXX, isXXX来获取</p>
<h3> 3.2 代理的方式实现对象拷贝</h3>
<p>Cglib的BeanCopier就是通过代理的方式实现拷贝，性能优于反射的方式，特别是在大量的数据拷贝时，比较明显</p>
<p>代理，我们知道可以区分为静态代理和动态代理，简单来讲就是你要操作对象A，但是你不直接去操作A，而是找一个中转porxyA, 让它来帮你操作对象A</p>
<p>那么这种技术是如何使用在对象拷贝的呢？</p>
<p>我们知道，效率最高的对象拷贝方式就是Getter/Setter方法了，前面说的代理的含义指我们不直接操作，而是找个中间商来赚差价，那么方案就出来了</p>
<p>将原SourceA拷贝到目标DestB</p>
<ul>
<li>创建一个代理 copyProxy</li>
<li>在代理中，依次调用 SourceA的get方法获取属性值，然后调用DestB的set方法进行赋值</li>
</ul>
<p>实际上BeanCopier的思路大致如上，具体的方案当然就不太一样了, 简单看了一下实现逻辑，挺有意思的一块，先留个坑，后面单独开个博文补上</p>
<p><strong>说明</strong></p>
<p>从实现原理和通过简单的测试，发现BeanCopier是扫描原对象的getXXX方法，然后赋值给同名的 setXXX 方法，也就是说，如果这个对象中某个属性没有get/set方法，那么就无法赋值成功了</p>
<hr>
<h2> 3. 小结</h2>
<h3> 3.1 深拷贝和浅拷贝</h3>
<p><strong>深拷贝</strong></p>
<blockquote>
<p>相当于创建了一个新的对象，只是这个对象的所有内容，都和被拷贝的对象一模一样而已，即两者的修改是隔离的，相互之间没有影响</p>
</blockquote>
<ul>
<li>完全独立</li>
</ul>
<p><strong>浅拷贝</strong></p>
<blockquote>
<p>也是创建了一个对象，但是这个对象的某些内容（比如A）依然是被拷贝对象的，即通过这两个对象中任意一个修改A，两个对象的A都会受到影响</p>
</blockquote>
<ul>
<li>等同与新创建一个对象，然后使用=，将原对象的属性赋值给新对象的属性</li>
<li>需要实现Cloneable接口</li>
</ul>
<h3> 3.2 对象拷贝的两种方法</h3>
<p><strong>通过反射方式实现对象拷贝</strong></p>
<p>主要原理就是通过反射获取所有的属性，然后反射更改属性的内容</p>
<p><strong>通过代理实现对象拷贝</strong></p>
<p>将原SourceA拷贝到目标DestB</p>
<p>创建一个代理 copyProxy
在代理中，依次调用 SourceA的get方法获取属性值，然后调用DestB的set方法进行赋值</p>
]]></content:encoded>
    </item>
    <item>
      <title>32.文件变动监听</title>
      <link>https://liuyueyi.github.io/tutorial/java/skill/32.%E6%96%87%E4%BB%B6%E5%8F%98%E5%8A%A8%E7%9B%91%E5%90%AC.html</link>
      <guid>https://liuyueyi.github.io/tutorial/java/skill/32.%E6%96%87%E4%BB%B6%E5%8F%98%E5%8A%A8%E7%9B%91%E5%90%AC.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">32.文件变动监听</source>
      <description>Java可以如何实现文件变动的监听 应用中使用logback作为日志输出组件的话，大部分会去配置 logback.xml 这个文件，而且生产环境下，直接去修改logback.xml文件中的日志级别，不用重启应用就可以生效 那么，这个功能是怎么实现的呢？</description>
      <category>Java</category>
      <category>编程技巧</category>
      <pubDate>Thu, 08 Feb 2018 12:01:58 GMT</pubDate>
      <content:encoded><![CDATA[<h1> Java可以如何实现文件变动的监听</h1>
<p>应用中使用logback作为日志输出组件的话，大部分会去配置 <code>logback.xml</code> 这个文件，而且生产环境下，直接去修改logback.xml文件中的日志级别，不用重启应用就可以生效</p>
<p>那么，这个功能是怎么实现的呢？</p>
<!-- more -->
<h2> 1. 问题描述及分析</h2>
<p>针对上面的这个问题，首先抛出一个实际的case，在我的个人网站 * <a href="https://tool.hhui.top/" target="_blank" rel="noopener noreferrer">神奇工具箱 - 小工具集合</a> 中，所有的小工具都是通过配置文件来动态新增和隐藏的，因为只有一台服务器，所以配置文件就简化的直接放在了服务器的某个目录下</p>
<p>现在的问题时，我需要在这个文件的内容发生变动时，应用可以感知这种变动，并重新加载文件内容，更新应用内部缓存</p>
<p>一个最容易想到的方法，就是轮询，判断文件是否发生修改，如果修改了，则重新加载，并刷新内存，所以主要需要关心的问题如下：</p>
<ul>
<li>如何轮询？</li>
<li>如何判断文件是否修改？</li>
<li>配置异常，会不会导致服务不可用？（即容错，这个与本次主题关联不大，但又比较重要...）</li>
</ul>
<h2> 2. 设计与实现</h2>
<p>问题抽象出来之后，对应的解决方案就比较清晰了</p>
<ul>
<li>如何轮询 ？ --》 定时器 Timer, ScheduledExecutorService 都可以实现</li>
<li>如何判断文件修改？ --》根据 <code>java.io.File#lastModified</code> 获取文件的上次修改时间，比对即可</li>
</ul>
<p>那么一个很简单的实现就比较容易了:</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这个属于一个非常简单，非常基础的实现了，基本上也可以满足我们的需求，那么这个实现有什么问题呢？</p>
<p><strong>定时任务的执行中，如果出现了异常会怎样？</strong></p>
<p>对上面的代码稍作修改</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>实际测试，发现只有首次修改的时候，触发了上面的代码，但是再次修改则没有效果了，即当抛出异常之后，定时任务将不再继续执行了，这个问题的主要原因是因为 <code>ScheduledExecutorService</code> 的原因了</p>
<p>直接查看ScheduledExecutorService的源码注释说明</p>
<blockquote>
<p>If any execution of the task encounters an exception, subsequent executions are suppressed.Otherwise, the task will only terminate via cancellation or termination of the executor.
即如果定时任务执行过程中遇到发生异常，则后面的任务将不再执行。</p>
</blockquote>
<p><strong>所以，使用这种姿势的时候，得确保自己的任务不会抛出异常，否则后面就没法玩了</strong></p>
<p>对应的解决方法也比较简单，整个catch一下就好</p>
<h2> 3. 进阶版</h2>
<p>前面是一个基础的实现版本了，当然在java圈，基本上很多常见的需求，都是可以找到对应的开源工具来使用的，当然这个也不例外，而且应该还是大家比较属性的apache系列</p>
<h3> 3.1 apache版</h3>
<p>首先maven依赖</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>主要是借助这个工具中的 <code>FileAlterationObserver</code>, <code>FileAlterationListener</code>, <code>FileAlterationMonitor</code> 三个类来实现相关的需求场景了，当然使用也算是很简单了，以至于都不太清楚可以再怎么去说明了，直接看下面从我的一个开源项目quick-alarm中拷贝出来的代码</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>针对上面的实现，简单说明几点：</p>
<ul>
<li>这个文件监听，是以目录为根源，然后可以设置过滤器，来实现对应文件变动的监听</li>
<li>如上面<code>registerConfChangeListener</code>方法，传入的file是具体的配置文件，因此构建参数的时候，捞出了目录，捞出了文件名作为过滤</li>
<li>第二参数是jdk8语法，其中为具体的读取配置文件内容，并映射为对应的实体对象</li>
</ul>
<p>一个问题，如果 func方法执行时，也抛出了异常，会怎样？</p>
<p>实际测试表现结果和上面一样，抛出异常之后，依然跪，所以依然得注意，不要跑异常</p>
<p>那么简单来看一下上面的实现逻辑，直接扣出核心模块</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从上面基本上一目了然，整个的实现逻辑了，和我们的第一种定时任务的方法不太一样，这儿直接使用线程，死循环，内部采用sleep的方式来来暂停，因此出现异常时，相当于直接抛出去了，这个线程就跪了</p>
<h3> 3.2 JDK版本</h3>
<p>jdk1.7，提供了一个<code>WatchService</code>，也可以用来实现文件变动的监听，之前也没有接触过，看到说明，然后搜了一下使用相关，发现也挺简单的，同样给出一个简单的示例demo</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 4. 小结</h2>
<p>使用Java来实现配置文件变动的监听，主要涉及到的就是两个点</p>
<ul>
<li>如何轮询：  定时器（Timer, ScheduledExecutorService）, 线程死循环+sleep</li>
<li>文件修改： File#lastModified</li>
</ul>
<p>整体来说，这个实现还是比较简单的，无论是自定义实现，还是依赖 commos-io来做，都没太大的技术成本，但是需要注意的一点是：</p>
<ul>
<li>千万不要在定时任务 or 文件变动的回调方法中抛出异常！！！</li>
</ul>
<p>为了避免上面这个情况，一个可以做的实现是借助EventBus的异步消息通知来实现，当文件变动之后，发送一个消息即可，然后在具体的重新加载文件内容的方法上，添加一个 <code>@Subscribe</code>注解即可，这样既实现了解耦，也避免了异常导致的服务异常 （如果对这个实现有兴趣的可以评论说明）</p>
]]></content:encoded>
    </item>
    <item>
      <title>33.实用的Map初始化工具类</title>
      <link>https://liuyueyi.github.io/tutorial/java/skill/33.%E5%AE%9E%E7%94%A8%E7%9A%84Map%E5%88%9D%E5%A7%8B%E5%8C%96%E5%B7%A5%E5%85%B7%E7%B1%BB.html</link>
      <guid>https://liuyueyi.github.io/tutorial/java/skill/33.%E5%AE%9E%E7%94%A8%E7%9A%84Map%E5%88%9D%E5%A7%8B%E5%8C%96%E5%B7%A5%E5%85%B7%E7%B1%BB.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">33.实用的Map初始化工具类</source>
      <description>实战33：实用的Map初始化工具类 虽说java作为编译语言，但是它本身也提供了很多运行时能力，今天介绍一个非常基础的知识点，可变参数传递</description>
      <category>Java</category>
      <category>编程技巧</category>
      <pubDate>Mon, 11 Oct 2021 20:45:27 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 实战33：实用的Map初始化工具类</h1>
<p>虽说java作为编译语言，但是它本身也提供了很多运行时能力，今天介绍一个非常基础的知识点，可变参数传递</p>
<!-- more -->
<p>在日常的开发过程中，创建Map对象还是比较常见的，现在我希望写一个工具类，可以非常简单创建并初始化Map对象</p>
<p>因此我们可以实现一个MapUtil工具类，来支持这个场景</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意一下上面的实现，kv这个参数就是我们要说的可变参数，在方法内部，kv可以看成是一个数组对象（而且是安全的对象，当不传递时，它的取值也不是null）</p>
<p>在使用可变参数时，下面是一些需要注意的点</p>
<p><strong>可变参数注意与数组参数的冲突</strong></p>
<p>注意下面的两个方法，不能同时出现，直接出现编译错误</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>重载的选择</strong></p>
<p>如果只有一个可变参数的方法，<code>newMap("key", "value")</code>不会报错，会直接访问下面这个方法，kv参数为空数组</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>当出现重载时，即如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>上面两个方法的调用，如果传参只有两个时，会调用哪个？</p>
<ul>
<li><code>newMap("key", "value")</code> 调用的下面的方法</li>
<li>`newMap("key", "value", "k", "v") 调用的上面的方法</li>
</ul>
<p><strong>可变参数传数组会怎样</strong></p>
<p>虽说我们在使用的时候，将可变参数当做数组来使用，但是传递时，若传数组，是否可行呢？</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>实际输出如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>从实际测试来看，传数组并没有问题</p>
]]></content:encoded>
    </item>
    <item>
      <title>34.通用的根据路径获取文件资源的工具类</title>
      <link>https://liuyueyi.github.io/tutorial/java/skill/34.%E9%80%9A%E7%94%A8%E7%9A%84%E6%A0%B9%E6%8D%AE%E8%B7%AF%E5%BE%84%E8%8E%B7%E5%8F%96%E6%96%87%E4%BB%B6%E8%B5%84%E6%BA%90%E7%9A%84%E5%B7%A5%E5%85%B7%E7%B1%BB.html</link>
      <guid>https://liuyueyi.github.io/tutorial/java/skill/34.%E9%80%9A%E7%94%A8%E7%9A%84%E6%A0%B9%E6%8D%AE%E8%B7%AF%E5%BE%84%E8%8E%B7%E5%8F%96%E6%96%87%E4%BB%B6%E8%B5%84%E6%BA%90%E7%9A%84%E5%B7%A5%E5%85%B7%E7%B1%BB.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">34.通用的根据路径获取文件资源的工具类</source>
      <description>实战34：通用的根据路径获取文件资源的工具类 通常我们最多的场景是从本地资源中读取文件，这个时候我们经常需要注意的是相对路径、绝对路径问题； 除了从本地获取文件之外，从网络中获取文件资源（如图片）也属于相对常见的场景，接下来我们封装一个工具类，可以支持以上各种类型的数据读取</description>
      <category>Java</category>
      <category>编程技巧</category>
      <pubDate>Mon, 08 Nov 2021 20:20:59 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 实战34：通用的根据路径获取文件资源的工具类</h1>
<p>通常我们最多的场景是从本地资源中读取文件，这个时候我们经常需要注意的是相对路径、绝对路径问题；</p>
<p>除了从本地获取文件之外，从网络中获取文件资源（如图片）也属于相对常见的场景，接下来我们封装一个工具类，可以支持以上各种类型的数据读取</p>
<!-- more -->
<h2> 1. 工具实现类</h2>
<p>首先定义一个公共方法如下，内部支持四种方式的数据获取</p>
<ul>
<li>相对路径</li>
<li>绝对路径</li>
<li>用户根目录</li>
<li>网络</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>请注意上面的实现，绝对路径与相对路径比较好理解，用户目录，这个处理又是怎样的呢？</p>
<p>关键点在于，用户目录转绝对路径</p>
<ul>
<li>借助<code>System.getProperties</code>系统属性来处理</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来再看如何判断一个路径是否为绝对路径呢？</p>
<p>这里需要格外注意不同操作系统的差异性，比如win，区分C盘，D盘，但是mac/linux则不分这个，上面判断的核心逻辑如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>除了上面的三种本地资源获取之外，还有一个就是网络资源的读取，上面介绍的实现姿势主要是基于JDK原生的URL，在实际使用时，这个并不稳定，不能确定能获取到完整的数据，原则上不推荐使用；如果可以，使用http-client/okhttp都是不错的选择</p>
<p>最后给一个简单的测试</p>
<p>最后一个简单下载图片的case</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0542b4ae409b4336a431fac44c1cef5f~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure>
]]></content:encoded>
      <enclosure url="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0542b4ae409b4336a431fac44c1cef5f~tplv-k3u1fbpfcp-watermark.image?" type="image/"/>
    </item>
    <item>
      <title>35.调用本地程序的几种姿势</title>
      <link>https://liuyueyi.github.io/tutorial/java/skill/35.%E8%B0%83%E7%94%A8%E6%9C%AC%E5%9C%B0%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%87%A0%E7%A7%8D%E5%A7%BF%E5%8A%BF.html</link>
      <guid>https://liuyueyi.github.io/tutorial/java/skill/35.%E8%B0%83%E7%94%A8%E6%9C%AC%E5%9C%B0%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%87%A0%E7%A7%8D%E5%A7%BF%E5%8A%BF.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">35.调用本地程序的几种姿势</source>
      <description>实战35：调用本地程序的几种姿势 作为一个后端同学，经常被安全的小伙伴盯上，找一找安全漏洞；除了常说的注入之外，还有比较吓人的执行远程命令，唤醒本地应用程序等；然后有意思的问题就来了，写了这么多年的代码，好像还真没有尝试过用java来唤醒本地应用程序的 比如说一个最简单的，打开本地的计算器，应该怎么搞？ 接下来本文将介绍一下如何使用java打开本地应用，以及打开mac系统中特殊一点的处理方式（直白来说就是不同操作系统，使用姿势不一样）</description>
      <category>Java</category>
      <category>编程技巧</category>
      <pubDate>Fri, 31 Dec 2021 10:55:56 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 实战35：调用本地程序的几种姿势</h1>
<p>作为一个后端同学，经常被安全的小伙伴盯上，找一找安全漏洞；除了常说的注入之外，还有比较吓人的执行远程命令，唤醒本地应用程序等；然后有意思的问题就来了，写了这么多年的代码，好像还真没有尝试过用java来唤醒本地应用程序的</p>
<p>比如说一个最简单的，打开本地的计算器，应该怎么搞？</p>
<p>接下来本文将介绍一下如何使用java打开本地应用，以及打开mac系统中特殊一点的处理方式（直白来说就是不同操作系统，使用姿势不一样）</p>
<!-- more -->
<h2> 1. Runtime使用方式</h2>
<p>主要是基于<code>Runtime.getRuntime().exec()</code>来执行shell命令，来打开应用</p>
<ul>
<li>传参就是需要打开的应用名</li>
</ul>
<p>比如上面说到的打开计算器</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从上面的传参也可以看出两者的区别，为什么mac会整一个 <code>open -n</code>， 这个其实可以理解为在终端执行命令，打开计算器</p>
<p><strong>注意事项</strong></p>
<p>对于mac系统而言，除了上面这种打开方式之外，还有下面这种姿势</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>在exec中指定计算器的路径，有个很容易采的坑，直接写成下面这种</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面这个直接执行之后会提示<code>权限错误</code>，其主要原因是mac系统的应用和win中的exe作为启动方式不太一样，对于mac而言，可以理解<code>xxx.app</code>为一个目录，真正执行文件是内部的<code>xxx/Contents/MacOS/xxx</code></p>
<h2> 2. ProcessBuilder使用方式</h2>
<p>除了Runtime唤起之外，使用ProcessBuilder也属于非常常见的case</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用上面这种姿势，特别需要注意的是内部传参不能是<code>open -n</code></p>
<h2> 3. 小结</h2>
<p>从上面介绍的方式来看，其实打开应用程序的思路主要就是利用java来执行脚本命令；内容比较简单，隐患却是比较大的；在自己的项目中，最好不要出现这种调用方式</p>
]]></content:encoded>
    </item>
    <item>
      <title>Java系列专栏</title>
      <link>https://liuyueyi.github.io/tutorial/java/</link>
      <guid>https://liuyueyi.github.io/tutorial/java/</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">Java系列专栏</source>
      <description>Java专栏 精选实战系列</description>
      <pubDate>Thu, 16 Feb 2023 06:42:50 GMT</pubDate>
      <content:encoded><![CDATA[<h2> Java专栏</h2>
<ul>
<li><a href="/tutorial/java/skill/" target="blank">精选实战系列</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>实战系列</title>
      <link>https://liuyueyi.github.io/tutorial/java/skill/</link>
      <guid>https://liuyueyi.github.io/tutorial/java/skill/</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">实战系列</source>
      <description>Java实战演练 实战小技巧，可用于实际编码过程中的 code snippets 带你再日常得编码中写得更加顺畅 本专栏中所有内容来自于笔者（一灰灰blog）的日常收集与分享，其中每一个主题都是针对真实的应用场景，通过提供切实可用与项目中的代码片段或者工具类，来给给位小伙伴提供帮助</description>
      <pubDate>Thu, 16 Feb 2023 06:42:50 GMT</pubDate>
      <content:encoded><![CDATA[<h1> Java实战演练</h1>
<blockquote>
<p>实战小技巧，可用于实际编码过程中的 <code>code snippets</code> 带你再日常得编码中写得更加顺畅</p>
</blockquote>
<p>本专栏中所有内容来自于笔者（一灰灰blog）的日常收集与分享，其中每一个主题都是针对真实的应用场景，通过提供切实可用与项目中的代码片段或者工具类，来给给位小伙伴提供帮助</p>
]]></content:encoded>
    </item>
    <item>
      <title>1.Eureka注册中心初体验</title>
      <link>https://liuyueyi.github.io/tutorial/spring/cloud/Eureka/01.200513-SpringCloud%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B9%8BEureka%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E5%88%9D%E4%BD%93%E9%AA%8C.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/cloud/Eureka/01.200513-SpringCloud%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B9%8BEureka%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E5%88%9D%E4%BD%93%E9%AA%8C.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">1.Eureka注册中心初体验</source>
      <description>在SpringCloud微服务体系中，有几个比较重要的组件，如注册中心，配置中心，网关，安全、负载均衡、监控等等，接下来我们将来看一下这些常用的组件有什么用，在微服务架构下的该怎么用。 本文为为第一篇，注册中心Eureka的使用说明</description>
      <category>SpringCloud</category>
      <category>Eureka系列</category>
      <pubDate>Wed, 13 May 2020 09:14:47 GMT</pubDate>
      <content:encoded><![CDATA[<p>在SpringCloud微服务体系中，有几个比较重要的组件，如注册中心，配置中心，网关，安全、负载均衡、监控等等，接下来我们将来看一下这些常用的组件有什么用，在微服务架构下的该怎么用。</p>
<p>本文为为第一篇，注册中心Eureka的使用说明</p>
<!-- more -->
<h2> I. 基本介绍</h2>
<h3> 1. 注册中心</h3>
<p>注册中心，主要的核心点是服务的注册与发现。</p>
<p>简单来讲，就是我们的所有服务都会在注册中心上标识自己，注册中心统一管理所有的服务名与具体的应用之间的映射关系，这样微服务之间的访问，就可以直接通过服务名来相互通信，相比较于直接通过ip端口的访问，这样的好处是当某个服务下线、新增或者换了机器，对调用者而言，只要维持一份注册中心的最新映射表即可，不需要其他任何改动逻辑。</p>
<p>我们通常可用的注册中心有 <code>Eureka</code>, <code>Consul</code>, <code>Zookeeper</code>, <code>nacos</code>等，在我们后续的教程中会逐一进行介绍</p>
<blockquote>
<p>Eureka2.x 闭源，1.x虽然可用，但新项目的话不建议再使用它，比如<code>Consul</code>, <code>nacos</code> 都是不错的选择</p>
<p>如果出于学习的目的，或者由于历史原因（比如我），学习了解一下Eureka知识点也没什么坏处</p>
</blockquote>
<h3> 2. Eureka</h3>
<p>Eureka是Netflix开源的服务发现组件，本身是一个基于REST的服务，通常包含Server和Client端</p>
<p><strong>原理如下图</strong></p>
<figure><img src="/imgs/200513/00.jpg" alt="来源于网络" tabindex="0" loading="lazy"><figcaption>来源于网络</figcaption></figure>
<ul>
<li>server: 提供服务注册，并在服务注册表中存储所有可用服务节点的信息</li>
<li>client: 简化与Server之间的交互，比如封装了发送心跳，获取注册信息表等基本操作</li>
</ul>
<h2> II. 实例演示</h2>
<h3> 1. 版本说明</h3>
<p>后续的演示项目中，我们的环境与版本信息如下</p>
<ul>
<li>开发环境: IDEA + maven</li>
<li>SpringBoot: <code>2.2.1.RELEASE</code></li>
<li>SpringCloud: <code>Hoxton.M2</code></li>
</ul>
<h3> 2. Eureka Server端</h3>
<p>Eureka区分了Server和Client两端，即我们有一个独立的注册中心服务，其他的微服务则作为Client端</p>
<p>Server端核心依赖如下</p>
<div class="language-pom line-numbers-mode" data-ext="pom"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后在配置文件中，添加一些基本信息</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>请注意，上面的<code>registerWithEureka</code>这个配置，设置为false，不像自己注册服务（后续会介绍多个Eureka实例时，可以如何配置）</p>
<p>然后再启动类上，添加注解<code>@EnableEurekaServer</code>来申明Eureka服务</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>到此，一个Eureka服务端已经完成，此时我们可以直接访问<code>http://localhost:8081</code>，会看到一个自带的控制台，会提供一些基本信息</p>
<h3> 3. Eureka 客户端</h3>
<p>我们这里设计两个客户端，一个提供服务，另外一个调用，演示一下Eureka的基本功能</p>
<h4> a. 客户端 eureka-service-provider</h4>
<p>客户端需要在pom文件中，添加下面的关键依赖</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来需要在配置文件中，指定注册中心的地址，以及服务名（请注意，这个服务名是重要线索，后面会用到！！！）</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>同样的需要在启动类上，通过<code>@EnableEurekaClient</code>来标注客户端</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们在这个项目中，写一个基本REST接口，供后面的服务进行调用</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>再看一下上面的实现，你会发现和平时写的Controller没有任何的区别</p>
<p>到这里第一个Eureka客户端已经完成，并提供了一个REST接口，接下来我们开始写第二个Eureka客户端，用来访问上面的REST服务</p>
<h4> b. 客户端 eureka-service-consumer</h4>
<p>基本的流程和上面没有任何区别，只是将配置文件稍微改一下</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>那么在这个服务中，如何访问 <code>eureka-service-provider</code> 提供的服务呢？</p>
<ul>
<li>通过<code>RestTemplate</code>来实现</li>
</ul>
<p>请注意，这个RestTemplate和我们普通的<code>new RestTemplate()</code>创建的不一样哦，我们是通过如下方式获取实例</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>重点关注方法上的<code>@LoadBalanced</code>注解，这个会在后续的Ribbon的章节中深入介绍，在这里只需要知道通过它生成的<code>RestTemplate</code>，在发起访问时，会借助Eureka的注册信息表，将服务名翻译为对应的<code>ip+端口号</code></p>
<p>接下来就是我们的访问环节，写法如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>请着重看一下访问的url: <code>"http://eureka-service-provider/userService/getUserById?userId=" + userId</code>,这里没有域名，没有ip，是直接通过服务名进行访问的</p>
<h3> 4. 测试与小结</h3>
<p>我们依次将上面的Server和两个Client启动，然后访问<code>http://localhost:8081</code>，查看Eureka控制台，可以看到如下界面，两个客户端都已经注册好了</p>
<figure><img src="/imgs/200513/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>然后再测试一下通过consumer访问provider的服务</p>
<figure><img src="/imgs/200513/02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>到此Eureka的核心功能已经演示完毕，当然如果仅仅只是这样，这个学习成本好像很低了，作为一个有思考的小青年，看了上面的流程自然会有几个疑问</p>
<ul>
<li>安全问题
<ul>
<li>注册中心控制台直接访问，这要是暴露出去了...</li>
<li>一个Eureka实例，单点故障怎么解</li>
</ul>
</li>
<li>服务注册多久生效？服务下线多久会从注册信息表中摘除？服务存活判断是怎样的？</li>
<li>通过<code>RestTemplate</code>方式使用，很不优雅啊，有没有类似rmi的通过类调用的方式呢？</li>
</ul>
<h2> II. 其他</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：
<ul>
<li><a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-cloud/eurka-server" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-cloud/eurka-server</a></li>
<li><a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-cloud/eurka-service-consumer" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-cloud/eurka-service-consumer</a></li>
<li><a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-cloud/eurka-service-provider" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-cloud/eurka-service-provider</a></li>
</ul>
</li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/200513/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>Eureka</title>
      <link>https://liuyueyi.github.io/tutorial/spring/cloud/Eureka/</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/cloud/Eureka/</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">Eureka</source>
      <description>注册中心Eureka全知道</description>
      <pubDate>Fri, 10 Feb 2023 04:50:05 GMT</pubDate>
      <content:encoded><![CDATA[<p>注册中心Eureka全知道</p>
]]></content:encoded>
    </item>
    <item>
      <title>1.Feign请求参数包装异常问题定位</title>
      <link>https://liuyueyi.github.io/tutorial/spring/cloud/Feign/01.190306-SpringCloud%E4%B9%8BFeign%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E5%8C%85%E8%A3%85%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/cloud/Feign/01.190306-SpringCloud%E4%B9%8BFeign%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E5%8C%85%E8%A3%85%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">1.Feign请求参数包装异常问题定位</source>
      <description>通过Feign包装rpc的调用姿势，在使用的版本中发现一个奇怪的bug，大部分场景下请求正常，少数情况下请求返回400，记录下原因</description>
      <category>SpringCloud</category>
      <category>Feign系列</category>
      <category>采坑记录</category>
      <pubDate>Wed, 06 Mar 2019 12:43:08 GMT</pubDate>
      <content:encoded><![CDATA[<p>通过Feign包装rpc的调用姿势，在使用的版本中发现一个奇怪的bug，大部分场景下请求正常，少数情况下请求返回400，记录下原因</p>
<!-- more -->
<h2> 场景复现</h2>
<h3> 1. 环境相关版本</h3>
<p>Spring版本如</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>Feign版本</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对应的feign-core版本为</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 服务接口</h3>
<p>接口形如</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用时报400的case</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>简单来说，接口参数为集合的情况下，如果传一个空集合，那么这就会出现400的错误</p>
<p>通过在提供服务的应用中，写一个fitler拦截请求，打印出请求参数</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后发起rpc调用前面的测试用例，通过断点查看请求参数，确实只有两个参数，而我们传入空pairIds集合，直接被吃掉了</p>
<figure><img src="/imgs/190306/00.jpg" alt="filter截图" tabindex="0" loading="lazy"><figcaption>filter截图</figcaption></figure>
<p>再对应到我们的api声明方式，要求三个参数，因此问题就很清晰了，解决办法就是在api中参数的必填设置为false即可</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面只是表层的解决了问题，接下来就需要确定，为什么请求参数会被吃掉，通过浅显的推测，多半原因在feign的请求参数封装上了</p>
<h3> 2. 问题定位</h3>
<p>对于容易复现的问题，最佳的定位方法就是debug了，直接单步进去，找到对应的请求参数封装逻辑，</p>
<p>第一步定位到<code>RequestTemplate</code>的创建</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来深入进去之后，参数解析的位置</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>再进去一步就到了根源点</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>下图是我们最终定位的一个截图，从代码实现来看，feign的设计理念是，如果请求参数为null，空集合，则不会将参数拼接到最终的请求参数中，也就导致最终发起请求时，少了一个参数</p>
<figure><img src="/imgs/190306/01.jpg" alt="debug截图" tabindex="0" loading="lazy"><figcaption>debug截图</figcaption></figure>
<p>问题清晰之后，然后就可以确认下是bug还是就是这么设计的了，最简单的办法就是看最新的代码有没有改掉了，从git上，目前已经更新到10.x；10.x与9.x的差别挺大，底层很多东西重写了，然而官方的<code>Spring-Cloud-openfeing</code>并没有升级到最新，so，只能取看9.7.0版本的实现了，和9.5.2并没有太大的区别；</p>
<p>so，站在feign开发者角度出发，这么设计的理由可能有以下几点</p>
<ul>
<li>既然允许传入空集合、null参数，那么在api的声明时，就有必要加上 <code>require=False</code></li>
<li>对于这种无效的请求参数，也没有太大的必要传过去（虽然从使用者角度来说，你就应该老老实实的把我调用的参数都丢过去）</li>
</ul>
<h3> 3. 小结</h3>
<p>最后小结一下，使用feign作为SpringCloud的rpc封装工具时，请注意，</p>
<ul>
<li>如果api的请求参数允许为null，请在注解中显示声明；</li>
<li>此外请求方传入的null、空集合最终不会拼装的请求参数中，即对于接受者而言，就像没有这个参数一样，对于出现400错误的场景，可以考虑下是否是这种问题导致的</li>
<li>对于复杂的请求参数，推荐使用DTO来替代多参数的类型（因为这样接口的复用性是最佳的，如新增和修改条件时，往往不需要新增api)</li>
</ul>
<h2> II. 其他</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">spring-boot-demo</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/190306/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>Feign</title>
      <link>https://liuyueyi.github.io/tutorial/spring/cloud/Feign/</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/cloud/Feign/</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">Feign</source>
      <description>基于Feign实现微服务访问</description>
      <pubDate>Fri, 10 Feb 2023 04:50:05 GMT</pubDate>
      <content:encoded><![CDATA[<p>基于Feign实现微服务访问</p>
]]></content:encoded>
    </item>
  </channel>
</rss>