<?xml version="1.0" encoding="utf-8"?><?xml-stylesheet type="text/xsl" href="https://liuyueyi.github.io/tutorial/rss.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <atom:link href="https://liuyueyi.github.io/tutorial/rss.xml" rel="self" type="application/rss+xml"/>
    <title>一灰灰的站点</title>
    <link>https://liuyueyi.github.io/tutorial/</link>
    <description>一灰灰的全网知识站点</description>
    <language>zh-CN</language>
    <pubDate>Fri, 24 Feb 2023 08:23:34 GMT</pubDate>
    <lastBuildDate>Fri, 24 Feb 2023 08:23:34 GMT</lastBuildDate>
    <generator>vuepress-plugin-feed2</generator>
    <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
    <copyright>Copyright by 一灰灰blog</copyright>
    <image>
      <title>一灰灰的站点</title>
      <url>https://liuyueyi.github.io/tutorial/logo.svg</url>
      <link>https://liuyueyi.github.io/tutorial/</link>
    </image>
    <category>DB</category>
    <category>Mongo</category>
    <category>Java</category>
    <category>编程技巧</category>
    <category>JDK</category>
    <category>SpringCloud</category>
    <category>Eureka系列</category>
    <category>Feign系列</category>
    <category>采坑记录</category>
    <category>SpringBoot</category>
    <category>运维系列</category>
    <category>Docker</category>
    <category>中间件</category>
    <category>Email</category>
    <category>Prometheus</category>
    <category>ZooKeeper</category>
    <category>MQ系列</category>
    <category>RabbitMq</category>
    <category>搜索系列</category>
    <category>ElasticSearch</category>
    <category>Solr</category>
    <category>SpringSecurity</category>
    <item>
      <title>MongoDB之Collection导入导出</title>
      <link>https://liuyueyi.github.io/tutorial/db/mongodb/basic/01.MongoDB%E4%B9%8BCollection%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA.html</link>
      <guid>https://liuyueyi.github.io/tutorial/db/mongodb/basic/01.MongoDB%E4%B9%8BCollection%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">MongoDB之Collection导入导出</source>
      <description>mongodb中集合的导入导出，在robot3t工具中没有找到对应的方法，记录下控制台的操作流程 主要利用： mongoexport 与 mongoimport</description>
      <category>DB</category>
      <category>Mongo</category>
      <pubDate>Sat, 16 Feb 2019 10:25:19 GMT</pubDate>
      <content:encoded><![CDATA[<p>mongodb中集合的导入导出，在robot3t工具中没有找到对应的方法，记录下控制台的操作流程</p>
<p>主要利用： <code>mongoexport</code> 与 <code>mongoimport</code></p>
<!-- more -->
<h3> 1. 集合导出</h3>
<p>直接使用 <code>mognoexport</code> 即可，通过<code>mongoexport --help</code>查看对应的使用说明</p>
<p>将库<code>database</code>中的集合<code>collection</code>导出到json文件<code>out.json</code></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 2. 集合导入</h3>
<p>使用 <code>mongoimport</code> 实现导入，同样可以输入<code>--help</code>查看使用说明</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>零：环境安装与初始化</title>
      <link>https://liuyueyi.github.io/tutorial/db/mongodb/basic/02.MongoDb%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E9%9B%B6-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96.html</link>
      <guid>https://liuyueyi.github.io/tutorial/db/mongodb/basic/02.MongoDb%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E9%9B%B6-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">零：环境安装与初始化</source>
      <description>MongoDB 是一个基于分布式文件存储的数据库。由 C++ 语言编写。旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。 MongoDB 是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。 本篇为mongodb系列教程第一篇，环境安装与连接设置</description>
      <category>DB</category>
      <category>Mongo</category>
      <pubDate>Thu, 19 Mar 2020 20:13:29 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>MongoDB 是一个基于分布式文件存储的数据库。由 C++ 语言编写。旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。</p>
</blockquote>
<p>MongoDB 是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。</p>
<p>本篇为mongodb系列教程第一篇，环境安装与连接设置</p>
<!-- more -->
<h3> 1. docker安装</h3>
<p>首先介绍最简单的安装方式，docker安装，请先保证docker环境存在（没有安装的推荐查看: <a href="https://blog.hhui.top/2019/12/06/191206-Centos%E5%AE%89%E8%A3%85docker%E4%B8%8E%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/" target="_blank" rel="noopener noreferrer">Centos安装docker与使用说明</a>）</p>
<p>安装命令如下:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. centos安装</h3>
<p>直接借助yum进行安装，命令如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. 用户配置</h3>
<p>直接通过mongodb提供的终端命令进行设置，</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4. 终端控制台</h3>
<p>mongodb集成了终端控制台，通过<code>mongo</code>进入；</p>
<p>但是当我们设置了登录认证时，有下面两种使用姿势</p>
<p><strong>case1</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/200319/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p><strong>case2</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/200319/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 5. 可视化操作工具</h3>
<p>终端虽好，使用起来终究不太顺手，可视化工具推荐使用<code>ROBO 3T</code>操作mongodb，官网下载地址: <a href="https://robomongo.org/" target="_blank" rel="noopener noreferrer">https://robomongo.org/</a></p>
<p>然后配置mongodb连接信息（支持ssh验证方式哦），下面是一个简单的配置</p>
<figure><img src="/imgs/200319/02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>然后就可以通过它来操作mongodb了</p>
<figure><img src="/imgs/200319/03.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/200319/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>一：基本概念</title>
      <link>https://liuyueyi.github.io/tutorial/db/mongodb/basic/03.MongoDb%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B8%80-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5.html</link>
      <guid>https://liuyueyi.github.io/tutorial/db/mongodb/basic/03.MongoDb%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B8%80-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">一：基本概念</source>
      <description>mongodb和我们通常使用的关系型数据库如mysql，在一些基本概念上有相同之处，但也有一些区别，在进行mongodb的语言介绍之前，有必要先了解一些基础概念 本文将对比sql对一些基础概念进行解释说明</description>
      <category>DB</category>
      <category>Mongo</category>
      <pubDate>Sat, 21 Mar 2020 19:40:22 GMT</pubDate>
      <content:encoded><![CDATA[<p>mongodb和我们通常使用的关系型数据库如mysql，在一些基本概念上有相同之处，但也有一些区别，在进行mongodb的语言介绍之前，有必要先了解一些基础概念</p>
<p>本文将对比sql对一些基础概念进行解释说明</p>
<!-- more -->
<h2> I. 基本概念</h2>
<blockquote>
<p><a href="https://www.runoob.com/mongodb/mongodb-databases-documents-collections.html" target="_blank" rel="noopener noreferrer">MongoDB 概念解析</a></p>
</blockquote>
<p>在sql中，会区分database, table, row, column, index, primaryId；在mongodb中也有对应的概念</p>
<table>
<thead>
<tr>
<th>sql</th>
<th>mongodb</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>database</td>
<td>db</td>
<td>数据库</td>
</tr>
<tr>
<td>table</td>
<td>collection</td>
<td>表/集合</td>
</tr>
<tr>
<td>row</td>
<td>document</td>
<td>行/文档</td>
</tr>
<tr>
<td>column</td>
<td>field</td>
<td>字段</td>
</tr>
<tr>
<td>index</td>
<td>index</td>
<td>索引</td>
</tr>
<tr>
<td>primaryId</td>
<td>_id</td>
<td>主键</td>
</tr>
<tr>
<td>lock</td>
<td>lock</td>
<td>锁</td>
</tr>
</tbody>
</table>
<p>下面对以上基本概念进行简单说明，详情的后续博文会补上</p>
<h3> 1. 数据库</h3>
<p>数据库可以理解为collection的聚集体，每个mongodb实例可以有多个database，每个database可以有多个collection</p>
<p>常见的几个命令如下：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 集合</h3>
<p>document的集合，与table最大的区别是它的结构不是固定的，不需要事先定义字段、类型</p>
<p>首次新增document时，集合被创建；</p>
<h3> 3. document</h3>
<p>文档，也就是具体的数据；bson结构，kv方式</p>
<p>最大的特点是不要求所有的document的结构一致，相同的field的数据类型可以不一致</p>
<h3> 4. index</h3>
<p>索引，同样是用来提高查询效率，避免全盘扫描</p>
<h3> 5. lock</h3>
<p>支持读写锁，document加读锁时，其他读操作ok，写操作禁止；加写锁时，其他读写操作禁止</p>
<h3> 6. 事务</h3>
<blockquote>
<p><a href="https://yq.aliyun.com/articles/610159" target="_blank" rel="noopener noreferrer">MongoDB 4.0 事务实现解析</a></p>
</blockquote>
<p>版本<code>&gt;= 4.0</code>，支持事务，支持多文档ACID，后续详细说明</p>
]]></content:encoded>
    </item>
    <item>
      <title>二：连接</title>
      <link>https://liuyueyi.github.io/tutorial/db/mongodb/basic/04.MongoDb%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%BA%8C-%E8%BF%9E%E6%8E%A5.html</link>
      <guid>https://liuyueyi.github.io/tutorial/db/mongodb/basic/04.MongoDb%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%BA%8C-%E8%BF%9E%E6%8E%A5.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">二：连接</source>
      <description>后续的所有文章的基础，都是需要先连上mongodb，然后才能执行各种命令操作； 本文将介绍一下如何连接一个已经启动的mongodb服务器</description>
      <category>DB</category>
      <category>Mongo</category>
      <pubDate>Sun, 22 Mar 2020 22:11:09 GMT</pubDate>
      <content:encoded><![CDATA[<p>后续的所有文章的基础，都是需要先连上mongodb，然后才能执行各种命令操作；</p>
<p>本文将介绍一下如何连接一个已经启动的mongodb服务器</p>
<!-- more -->
<h3> 1. 连接语法</h3>
<p>标准URI连接语法：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul>
<li><code>mongodb://</code> 固定前缀</li>
<li><code>username:password@</code>: 如果开启了用户登录验证，需要指定用户名密码</li>
<li><code>host1:port1</code>: mongodb服务器的ip/域名 + 端口(不填时，默认为27017)</li>
<li><code>database</code>: 如果指定<code>username:password@</code>，连接并验证登陆指定数据库。若不指定，默认打开 test 数据库</li>
<li><code>?options</code>: 是连接选项。如果不使用/database，则前面需要加上</li>
</ul>
<h3> 2. 实例</h3>
<p>直接连接方式如下，注意这种方式会保留用户名和密码，会有一定的安全风险</p>
<p><strong>连接目标服务器</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>连接多台服务器</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>连接 replica set 三台服务器, 写入操作应用在主服务器 并且分布查询到从服务器</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>三：基本工具介绍</title>
      <link>https://liuyueyi.github.io/tutorial/db/mongodb/basic/05.MongoDb%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B8%89-%E5%9F%BA%E6%9C%AC%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D.html</link>
      <guid>https://liuyueyi.github.io/tutorial/db/mongodb/basic/05.MongoDb%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B8%89-%E5%9F%BA%E6%9C%AC%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">三：基本工具介绍</source>
      <description>mongodb服务器安装完毕之后，提供了一些配套的操作工具，接下来我们有必要认识一下它们，并了解基本用法</description>
      <category>DB</category>
      <category>Mongo</category>
      <pubDate>Wed, 25 Mar 2020 21:32:39 GMT</pubDate>
      <content:encoded><![CDATA[<p>mongodb服务器安装完毕之后，提供了一些配套的操作工具，接下来我们有必要认识一下它们，并了解基本用法</p>
<!-- more -->
<h3> 0. mongod</h3>
<p>启动mongodb实例的主要命令，常见的使用姿势如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 1. mongo 命令行使用</h3>
<p>mongodb安装完毕之后，会自带一个终端命令行工具，通过它可以连接mongodb，并执行相关命令</p>
<h4> a. 连接</h4>
<p>介绍三种连接mongodb的姿势</p>
<p><strong>case1</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>case2</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>case3</strong></p>
<p>上面两种姿势虽然简单，但是用户名密码有暴露的风险，推荐使用下面这种方式</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> b. 操作</h4>
<p>连接上mongodb服务器之后，就可以执行mongo命令，查看数据库，管理文档，比如下面给几个常见的操作</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/200325/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 2. mongoimport/mongoexport</h3>
<p>用于导入导出数据，如</p>
<p>将库<code>database</code>中的集合<code>collection</code>导出到json文件<code>out.json</code></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>从json文件导入到目标集合<code>new_collection</code></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 3. mongodump/mongorestore</h3>
<p>使用mongodump命令来备份MongoDB数据, 将数据库<code>basic</code>的所有集合备份到目录 <code>/tmp/outDir</code>下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>使用mongorestore恢复，如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4. mongostate</h3>
<p>mongostat是mongodb自带的状态检测工具，在命令行下使用。它会间隔固定时间获取mongodb的当前运行状态，并输出。如果你发现数据库突然变慢或者有其他问题的话，你第一手的操作就考虑采用mongostat来查看mongo的状态。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="/imgs/200325/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 5. mongotop</h3>
<p>mongotop提供每个集合的水平的统计数据，默认每s输出一次</p>
<figure><img src="/imgs/200325/02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/200325/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>四：数据库 Database</title>
      <link>https://liuyueyi.github.io/tutorial/db/mongodb/basic/06.MongoDb%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E5%9B%9B-%E6%95%B0%E6%8D%AE%E5%BA%93-Database.html</link>
      <guid>https://liuyueyi.github.io/tutorial/db/mongodb/basic/06.MongoDb%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E5%9B%9B-%E6%95%B0%E6%8D%AE%E5%BA%93-Database.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">四：数据库 Database</source>
      <description>我们通常把mongodb叫文档型数据库，mysql叫关系型数据库，influxdb叫时序数据库，如果熟悉这三个的话，会发现他们都有一个database，它是collection/table/measurement的上一级，可以简单的把它理解为更高层级的集合，方便统一管理/权限划分/业务拆分 下面简单介绍一下database的基础操作</description>
      <category>DB</category>
      <category>Mongo</category>
      <pubDate>Thu, 26 Mar 2020 16:49:32 GMT</pubDate>
      <content:encoded><![CDATA[<p>我们通常把mongodb叫文档型数据库，mysql叫关系型数据库，influxdb叫时序数据库，如果熟悉这三个的话，会发现他们都有一个<code>database</code>，它是<code>collection/table/measurement</code>的上一级，可以简单的把它理解为更高层级的集合，方便统一管理/权限划分/业务拆分</p>
<p>下面简单介绍一下database的基础操作</p>
<!-- more -->
<h3> 1. 创建数据库</h3>
<p>当数据库不存在时，通过<code>use + 数据库</code>命令可以用来创建数据库；当数据库存在时，表示选中</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 2. 查看数据库</h3>
<p>通过 <code>db</code>查看当前的数据库</p>
<p>通过 <code>show dbs</code> 查看当前的数据库列表</p>
<p>请注意，新创建一个数据库时，直接使用<code>show dbs</code>命令，并不会显示出来，如下</p>
<figure><img src="/imgs/200326/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>为了显示这个数据库，需要插入一个文档</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="/imgs/200326/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 3. 删除数据库</h3>
<p>对于数据库而言，任何删除命令都需要慎重处理，一不小心就得跑路了。。。</p>
<p>命令如下: <code>db.dropDatabase()</code></p>
<p>实例说明：</p>
<p>一般来说我们需要删除时，两步走</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/200326/02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 4. 潜规则</h3>
<p>需要注意，有三个数据库属于预留的，有特殊的作用，不能新建同名的数据</p>
<ul>
<li>admin: 将一个用户添加到这个数据库，这个用户自动继承所有数据库的权限; 一些特定的服务器端命令也只能从这个数据库运行，比如列出所有的数据库或者关闭服务器。</li>
<li>local: 这个数据永远不会被复制，可以用来存储限于本地单台服务器的任意集合</li>
<li>config: 当Mongo用于分片设置时，config数据库在内部使用，用于保存分片的相关信息。</li>
</ul>
<p>命名规则：</p>
<ul>
<li>不能是空字符串</li>
<li>不能含有特殊字符（如<code> </code>，<code>.</code>，<code>$</code>, <code>\</code>, <code>/</code>, <code>\0</code></li>
<li>小写</li>
<li>最多64字节</li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/200326/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>五：集合 Collection</title>
      <link>https://liuyueyi.github.io/tutorial/db/mongodb/basic/07.MongoDb%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%BA%94-%E9%9B%86%E5%90%88-Collection.html</link>
      <guid>https://liuyueyi.github.io/tutorial/db/mongodb/basic/07.MongoDb%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%BA%94-%E9%9B%86%E5%90%88-Collection.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">五：集合 Collection</source>
      <description>集合，相当于关系型数据库中的table，在mongodb中，集合的概念非常贴切，属于文档(Document)的集合 其最大的特点是： 没有固定的结构</description>
      <category>DB</category>
      <category>Mongo</category>
      <pubDate>Thu, 26 Mar 2020 16:52:20 GMT</pubDate>
      <content:encoded><![CDATA[<p>集合，相当于关系型数据库中的table，在mongodb中，集合的概念非常贴切，属于文档(Document)的集合</p>
<p>其最大的特点是：</p>
<ul>
<li>没有固定的结构</li>
</ul>
<!-- more -->
<h3> 1. 创建集合</h3>
<p>创建命令如: <code>db.createCollection(name, options)</code></p>
<p>重点看一下参数<code>options</code>的可选项</p>
<ul>
<li>capped: true，表示创建固定大小的集合，需要指定size；超过数量之后，覆盖最早的文档</li>
<li>size: 固定集合时配套使用，KB为单位</li>
<li>autoIndexId: 自动为<code>_id</code>添加索引，默认true</li>
<li>max: 固定集合时，文档的最大数量</li>
</ul>
<p>一个简单的实例</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>除此之外，新插入一个文档时，集合若不存在，也会创建对应的集合，如</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 查看集合</h3>
<p>通过 <code>show collections</code> 查看数据库下的集合列表</p>
<figure><img src="/imgs/200326/03.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 3. 删除集合</h3>
<p>通过命令 <code>db.col.drop()</code>来删除</p>
<figure><img src="/imgs/200326/04.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 4. 命名规则</h3>
<ul>
<li>不能全是空白字符</li>
<li>不应包含特殊字符</li>
<li>不要以<code>system.</code>开头</li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/200326/03.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>六：文档 Document 插入姿势</title>
      <link>https://liuyueyi.github.io/tutorial/db/mongodb/basic/08.MongoDb%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E5%85%AD-%E6%96%87%E6%A1%A3-Document-%E6%8F%92%E5%85%A5%E5%A7%BF%E5%8A%BF.html</link>
      <guid>https://liuyueyi.github.io/tutorial/db/mongodb/basic/08.MongoDb%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E5%85%AD-%E6%96%87%E6%A1%A3-Document-%E6%8F%92%E5%85%A5%E5%A7%BF%E5%8A%BF.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">六：文档 Document 插入姿势</source>
      <description>文档相当于关系数据库中数据行，也是我们最关心的数据本身；以BSON格式存储（和json区别不大） 我们通常所说业务开发者的CURD四大技能，在mongodb中，就是针对Document而言，接下来我们先看一下文档的新增使用姿势</description>
      <category>DB</category>
      <category>Mongo</category>
      <pubDate>Thu, 26 Mar 2020 17:04:06 GMT</pubDate>
      <content:encoded><![CDATA[<p>文档相当于关系数据库中数据行，也是我们最关心的数据本身；以BSON格式存储（和json区别不大）</p>
<p>我们通常所说业务开发者的CURD四大技能，在mongodb中，就是针对Document而言，接下来我们先看一下文档的新增使用姿势</p>
<!-- more -->
<h3> 1. 基本语法</h3>
<p>插入语法： <code>db.collection.insert()</code></p>
<p>因为集合不要求定义数据结构，所以插入的文档格式理论上可以完全不一样，可以拥有完全不同的数据结构，相同的字段拥有不同的数据类型</p>
<h3> 2. 实例演示</h3>
<p>下面给出几个实例进行说明</p>
<p><strong>基本数据类型插入</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>数组类型插入</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>Object类型插入</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="/imgs/200326/05.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 3. 数据类型</h3>
<p>mongodb支持的基本数据类型，除了我们常见的string,int,float,boolean之外，还有一些其他的;</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>String</td>
<td>字符串， UTF8编码</td>
</tr>
<tr>
<td>Integer</td>
<td>整型，32/64位</td>
</tr>
<tr>
<td>Boolean</td>
<td>布尔</td>
</tr>
<tr>
<td>Double</td>
<td>浮点</td>
</tr>
<tr>
<td>Min/Max keys</td>
<td>将一个值与 BSON（二进制的 JSON）元素的最低值和最高值相对比</td>
</tr>
<tr>
<td>Array</td>
<td>数组</td>
</tr>
<tr>
<td>Timestamp</td>
<td>时间戳，记录文档修改或添加的具体时间</td>
</tr>
<tr>
<td>Object</td>
<td>内嵌文档</td>
</tr>
<tr>
<td>Null</td>
<td>创建空值</td>
</tr>
<tr>
<td>Symbol</td>
<td>符号。该数据类型基本上等同于字符串类型，但不同的是，它一般用于采用特殊符号类型的语言。</td>
</tr>
<tr>
<td>Date</td>
<td>日期，用 UNIX 时间格式来存储当前日期或时间。你可以指定自己的日期时间：创建 Date 对象，传入年月日信息。</td>
</tr>
<tr>
<td>ObjectID</td>
<td>对象ID</td>
</tr>
<tr>
<td>Binary Data</td>
<td>二进制</td>
</tr>
<tr>
<td>code</td>
<td>代码类型。用于在文档中存储 JavaScript 代码。</td>
</tr>
<tr>
<td>Regular expression</td>
<td>正则表达式类型。用于存储正则表达式。</td>
</tr>
</tbody>
</table>
<p><strong>ObjectId 类似唯一主键</strong>，可以很快的去生成和排序，包含 12 bytes，含义是：</p>
<ul>
<li>前 4 个字节表示创建 unix 时间戳,格林尼治时间 UTC 时间，比北京时间晚了 8 个小时</li>
<li>接下来的 3 个字节是机器标识码</li>
<li>紧接的两个字节由进程 id 组成 PID</li>
<li>最后三个字节是随机数</li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/200326/05.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>七：文档 Document 删除姿势</title>
      <link>https://liuyueyi.github.io/tutorial/db/mongodb/basic/09.MongoDb%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B8%83-%E6%96%87%E6%A1%A3-Document-%E5%88%A0%E9%99%A4%E5%A7%BF%E5%8A%BF.html</link>
      <guid>https://liuyueyi.github.io/tutorial/db/mongodb/basic/09.MongoDb%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B8%83-%E6%96%87%E6%A1%A3-Document-%E5%88%A0%E9%99%A4%E5%A7%BF%E5%8A%BF.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">七：文档 Document 删除姿势</source>
      <description>前面一篇介绍了插入文档的使用姿势，这一篇则主要介绍删除的使用case</description>
      <category>DB</category>
      <category>Mongo</category>
      <pubDate>Thu, 26 Mar 2020 18:02:03 GMT</pubDate>
      <content:encoded><![CDATA[<p>前面一篇介绍了插入文档的使用姿势，这一篇则主要介绍删除的使用case</p>
<!-- more -->
<h3> 1. 基本语法</h3>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>第一个为需要删除的匹配条件；第二个表示是否只删除一个，默认是false，删除所有满足条件的文档</p>
<p><strong>注意</strong></p>
<ul>
<li>当query为空时，表示删除所有文档，高危操作，谨慎执行</li>
</ul>
<h3> 2. 实例演示</h3>
<p>借用给我们上一篇插入的文档来进行演示，当前存在的文档为</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>根据id进行删除</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>根据name删除第一个满足条件的记录</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>再次查看剩下的内容如下：</p>
<figure><img src="/imgs/200326/06.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/200326/06.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>八：文档 Document 更新姿势</title>
      <link>https://liuyueyi.github.io/tutorial/db/mongodb/basic/10.MongoDb%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E5%85%AB-%E6%96%87%E6%A1%A3-Document-%E6%9B%B4%E6%96%B0%E5%A7%BF%E5%8A%BF.html</link>
      <guid>https://liuyueyi.github.io/tutorial/db/mongodb/basic/10.MongoDb%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E5%85%AB-%E6%96%87%E6%A1%A3-Document-%E6%9B%B4%E6%96%B0%E5%A7%BF%E5%8A%BF.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">八：文档 Document 更新姿势</source>
      <description>本篇介绍update/save两种方法提供的更新姿势</description>
      <category>DB</category>
      <category>Mongo</category>
      <pubDate>Fri, 27 Mar 2020 11:04:36 GMT</pubDate>
      <content:encoded><![CDATA[<p>本篇介绍update/save两种方法提供的更新姿势</p>
<!-- more -->
<h3> 1. update</h3>
<p>用于更新已经存在的文档，语法如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>query: 查询条件</li>
<li>update: 更新语句</li>
<li>upsert: （可选）true, 不存在update的记录时插入；默认是false，不插入</li>
<li>multi: (可选) true，表示更新所有满足条件的记录；默认false，只更新第一条</li>
<li>writeConcern: (可选)，抛出异常的级别</li>
</ul>
<p>插入两条用于测试的数据</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>下面给出几个更新的实例</p>
<p><strong>更新age</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/200327/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p><strong>更新所有age为20的文档，新增一个tag成员</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="/imgs/200327/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p><strong>更新一个不存在的文档</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="/imgs/200327/02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 2. save</h3>
<p>save最大的特点是覆盖，用新的文档完全覆盖旧的文档；而update，则是更新指定的field</p>
<p>语法如下：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>举例如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="/imgs/200327/03.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>那么问题来了，<strong>怎样判定是新增一条记录，还是覆盖已经存在的记录呢？</strong></p>
<ul>
<li>有唯一键来判定</li>
<li>即：如果save的文档中，某个field有唯一性要求，那么当数据库中存在这个field文档文档时，执行覆盖操作；否则执行插入</li>
</ul>
<p>举例如下, 指定ObjectId</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="/imgs/200327/04.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/200327/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>九：文档 Document 查询基础篇</title>
      <link>https://liuyueyi.github.io/tutorial/db/mongodb/basic/11.MongoDb%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B9%9D-%E6%96%87%E6%A1%A3-Document-%E6%9F%A5%E8%AF%A2%E5%9F%BA%E7%A1%80%E7%AF%87.html</link>
      <guid>https://liuyueyi.github.io/tutorial/db/mongodb/basic/11.MongoDb%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B9%9D-%E6%96%87%E6%A1%A3-Document-%E6%9F%A5%E8%AF%A2%E5%9F%BA%E7%A1%80%E7%AF%87.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">九：文档 Document 查询基础篇</source>
      <description>MongoDb文档查询，主要借助find方法来完成，在实际的业务开发中，为了满足各种复杂的业务场景，查询的姿势也是各种各样，本篇则主要介绍基本的使用姿势，不涉及到聚合、排序、分页相关内容</description>
      <category>DB</category>
      <category>Mongo</category>
      <pubDate>Sat, 28 Mar 2020 19:27:12 GMT</pubDate>
      <content:encoded><![CDATA[<p>MongoDb文档查询，主要借助find方法来完成，在实际的业务开发中，为了满足各种复杂的业务场景，查询的姿势也是各种各样，本篇则主要介绍基本的使用姿势，不涉及到聚合、排序、分页相关内容</p>
<!-- more -->
<h3> 1. 查询语法</h3>
<p>查询语法定义比较简单，复杂的是查询条件的组合；语法定义如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul>
<li>query: 查询条件，如果不填，则表示查询所有文档</li>
<li>projection: 查询需要返回的field，如果不填则返回所有的数据</li>
</ul>
<p>此外为了mongo-cli的返回结果更加友好，可以在最后添加<code>.pretty()</code>，使输出更友好</p>
<h3> 2. 查询所有</h3>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="/imgs/200328/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 3. 根据条件精准查询</h3>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="/imgs/200328/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 4. 数字比较查询</h3>
<p>对于数字类型的field，可以借助符号<code>$gt</code>(&gt;), <code>$get</code>(&gt;=), <code>$lt</code>(&lt;), <code>$lte</code>(&lt;=), <code>$ne</code>(!=) 来表示具体的操作</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/200328/02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 5. 模糊查询</h3>
<p>在mysql中有一个like用于模糊查询，在mongodb中，同样支持基于正则的模糊查询</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/200328/03.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 6. and条件</h3>
<p>多个查询条件需要满足时，并不需要什么特殊的操作，只需要在查询bson中，加上多个条件即可</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/200328/04.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 7. or条件</h3>
<p>和and不需要额外的操作不同，or条件需要借助 <code>$or</code> 来实现，语法如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>实例如下：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/200328/05.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 8. 限制返回成员</h3>
<p>有些时候我们只需要获取文档中的部分成员，可以在第二个参数中进行指定，规则如下</p>
<ul>
<li><code>成员名: 1</code>： 表示这个成员需要返回</li>
<li><code>成员名: 0</code>： 表示这个成员不返回</li>
</ul>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/200328/06.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>请注意，一般在使用了 <code>成员名: 1</code> 来指定返回field时，会自动返回<code>_id</code>，如果不需要，请显示加上 <code>_id: 0</code></p>
<h3> 9. field类型查询</h3>
<p>根据field的成员类型来作为查询条件，一般有两种方式，这里只介绍更优雅的，语法如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>举例说明</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="/imgs/200328/07.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 10. 存在查询</h3>
<p>mongodb的一个特点就是集合的结构不固定，所以某个成员可能存在也可能不存在，所以当我们的查询条件中需要加一个是否存在的判断时，可以如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/200328/08.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/200328/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>十：文档 Document 查询高级篇</title>
      <link>https://liuyueyi.github.io/tutorial/db/mongodb/basic/12.MongoDb%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E5%8D%81-%E6%96%87%E6%A1%A3-Document-%E6%9F%A5%E8%AF%A2%E9%AB%98%E7%BA%A7%E7%AF%87.html</link>
      <guid>https://liuyueyi.github.io/tutorial/db/mongodb/basic/12.MongoDb%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E5%8D%81-%E6%96%87%E6%A1%A3-Document-%E6%9F%A5%E8%AF%A2%E9%AB%98%E7%BA%A7%E7%AF%87.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">十：文档 Document 查询高级篇</source>
      <description>上一篇的mongodb查询，主要介绍的是一些基本操作，当然有基本就高阶操作； 本文将带来更多的查询姿势 排序 分页 聚合</description>
      <category>DB</category>
      <category>Mongo</category>
      <pubDate>Tue, 31 Mar 2020 21:50:13 GMT</pubDate>
      <content:encoded><![CDATA[<p>上一篇的mongodb查询，主要介绍的是一些基本操作，当然有基本就高阶操作；</p>
<p>本文将带来更多的查询姿势</p>
<ul>
<li>排序</li>
<li>分页</li>
<li>聚合</li>
</ul>
<!-- more -->
<h3> 1. 排序</h3>
<p>在mongodb中，使用sort方法进行排序，语法如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>请注意，sort内部是一个对象，key为field，value为1或者-1，其中1表示升序，-1表示降序</p>
<p>实例说明，根据age进行排序</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>输出如下:</p>
<figure><img src="/imgs/200331/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>上面的演示属于常规的操作，但是针对mongodb的特点，自然会有一些疑问</p>
<p><strong>q1: 如果某个文档没有包含这个field，排序是怎样的？</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="/imgs/200331/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>从输出来看，升序时，不包含这个field的文档，在最前面；降序时，不包含这个field的文档，在最后面</p>
<p><strong>q2: 支持多个field排序吗？</strong></p>
<p>原则上一般不建议多个field的排序（比较影响性能），但对于数据库而言，你得支持吧</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/200331/02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>请注意上的输出，在涉及到多个field排序时，优先根据第一个进行排序，当文档的field相同时，再根据后面的进行排序</p>
<h3> 2. 分页</h3>
<p>当文档很多时，我们不可能把所有的文档一次返回，所以就有了常见的分页，在sql中我们一般使用<code>limit</code> <code>offset</code>来实现分页，在mongodb中也差不多</p>
<p><strong>limit()</strong></p>
<p>限制返回的文档数</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="/imgs/200331/03.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p><strong>skip()</strong></p>
<p>使用limit进行返回条数限制，使用skip进行分页，表示跳过前面的n条数据</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/200331/04.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 3. 聚合</h3>
<p>使用<code>aggregate()</code>来实现聚合，用于处理求和、平均值，最大值，分组等</p>
<p>数据准备:</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>分组查询</strong></p>
<p>根据name进行分组统计</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/200331/05.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>请注意，分组的条件中</p>
<ul>
<li><code>_id</code>: 表示根据哪个字段进行分组</li>
<li><code>size: {}</code>: 表示聚合条件指定，将结果输出到名为size的field中</li>
<li><code>filed</code>名前加<code>$</code>进行指定</li>
</ul>
<p>当前mongodb支持的聚合表达式包括:</p>
<table>
<thead>
<tr>
<th>表达式</th>
<th>说明</th>
<th>举例说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>sum</td>
<td>求和</td>
<td><code>db.doc_demo.aggregate([{$group: {_id: "$name", size: {$sum: '$age'}}}])</code></td>
</tr>
<tr>
<td>avg</td>
<td>平均值</td>
<td><code>db.doc_demo.aggregate([{$group: {_id: "$name", size: {$avg: '$age'}}}])</code></td>
</tr>
<tr>
<td>min</td>
<td>取最小</td>
<td><code>db.doc_demo.aggregate([{$group: {_id: "$name", age: {$min: '$age'}}}])</code></td>
</tr>
<tr>
<td>max</td>
<td>取最大</td>
<td><code>db.doc_demo.aggregate([{$group: {_id: "$name", age: {$max: '$age'}}}])</code></td>
</tr>
<tr>
<td>push</td>
<td>结果插入到一个数组中</td>
<td><code>db.doc_demo.aggregate([{$group: {_id: "$name", age: {$push: '$age'}}}])</code></td>
</tr>
<tr>
<td>addToSet</td>
<td>结果插入集合，过滤重复</td>
<td><code>db.doc_demo.aggregate([{$group: {_id: "$name", age: {$addToSet: '$age'}}}])</code></td>
</tr>
<tr>
<td>first</td>
<td>第一个</td>
<td><code>db.doc_demo.aggregate([{$group: {_id: "$name", age: {$first: '$age'}}}])</code></td>
</tr>
<tr>
<td>last</td>
<td>最后一个</td>
<td><code>db.doc_demo.aggregate([{$group: {_id: "$name", age: {$last: '$age'}}}])</code></td>
</tr>
</tbody>
</table>
<figure><img src="/imgs/200331/06.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>上面虽然介绍了分组支持的一些表达式，但是没有查询条件，难道只能针对所有的文档进行分组统计么？</p>
<p><strong>分组过滤</strong></p>
<p>借助<code>$match</code>来实现过滤统计，如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/200331/07.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>请注意，$match的语法规则和find的查询条件一样，会将满足条件的数据传递给后面的分组计算</p>
<p>这种方式和liux中的管道特别相似，aggregate方法的参数数组中，前面的执行完毕之后，将结果传递给后面的继续执行，除了<code>$match</code>和<code>$group</code>之外，还有一些其他的操作</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>$project</td>
<td>修改输入文档的结构。可以用来重命名、增加或删除域，也可以用于创建计算结果以及嵌套文档。</td>
</tr>
<tr>
<td>$match</td>
<td>用于过滤数据，只输出符合条件的文档。$match使用MongoDB的标准查询操作。</td>
</tr>
<tr>
<td>$limit</td>
<td>用来限制MongoDB聚合管道返回的文档数。</td>
</tr>
<tr>
<td>$skip</td>
<td>在聚合管道中跳过指定数量的文档，并返回余下的文档。</td>
</tr>
<tr>
<td>$unwind</td>
<td>将文档中的某一个数组类型字段拆分成多条，每条包含数组中的一个值。</td>
</tr>
<tr>
<td>$group</td>
<td>将集合中的文档分组，可用于统计结果。</td>
</tr>
<tr>
<td>$sort</td>
<td>将输入文档排序后输出。</td>
</tr>
<tr>
<td>$geoNear</td>
<td>输出接近某一地理位置的有序文档。</td>
</tr>
</tbody>
</table>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/200331/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>十一：文档 Document 查询非典型篇</title>
      <link>https://liuyueyi.github.io/tutorial/db/mongodb/basic/13.MongoDb%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E5%8D%81%E4%B8%80-%E6%96%87%E6%A1%A3-Document-%E6%9F%A5%E8%AF%A2%E9%9D%9E%E5%85%B8%E5%9E%8B%E7%AF%87.html</link>
      <guid>https://liuyueyi.github.io/tutorial/db/mongodb/basic/13.MongoDb%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E5%8D%81%E4%B8%80-%E6%96%87%E6%A1%A3-Document-%E6%9F%A5%E8%AF%A2%E9%9D%9E%E5%85%B8%E5%9E%8B%E7%AF%87.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">十一：文档 Document 查询非典型篇</source>
      <description>前面介绍的查询可以说是常见的典型case，但是mongodb中有两个比价特殊的数据类型，数组 + 对象，自然的也会有一些非典型的查询case，下面主要针对这两种数据类型的查询姿势，给出实例讲解</description>
      <category>DB</category>
      <category>Mongo</category>
      <pubDate>Wed, 08 Apr 2020 21:12:29 GMT</pubDate>
      <content:encoded><![CDATA[<p>前面介绍的查询可以说是常见的典型case，但是mongodb中有两个比价特殊的数据类型，数组 + 对象，自然的也会有一些非典型的查询case，下面主要针对这两种数据类型的查询姿势，给出实例讲解</p>
<!-- more -->
<h3> 1. 数组</h3>
<p>首先准备一些供数组操作的文档如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>长度查询</strong></p>
<p>根据数组长度进行查询，借助<code>$size</code>来统计数组长度</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>长度范围查询</strong></p>
<p>请注意，不支持长度的比较查询，如下，会报语法错误</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="/imgs/200408/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>要实现范围查询，可以借助<code>$where</code>来实现(<code>$where</code>比较强大，后面单独说明)</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/200408/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p><strong>数组内容查询</strong></p>
<p>根据数组内容进行查询，常见的有两种方式，一个是直接根据数组定位比较如</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这种实用性可能并不大，另外一个常见的case就是查询数组中包含某个元素的文档，这时可以借助<code>$elemMatch</code>来实现</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/200408/02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>说明，当数组的元素是Object类型时，还可以用右边这种姿势：<code>db.doc_demo.find({'skill': {$elemMatch: {'subField': 'xxx'}}})</code></p>
<h3> 2. Object</h3>
<p>因为mongodb支持内嵌文档，所以根据内嵌文档进行查询的场景也是不少的</p>
<p>首先准备三个用于后续查询测试的文档</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>根据内嵌文档字段查询</strong></p>
<p>查询姿势和field查询相似，只是需要注意一下key的语法为: <code>field.subField</code>, 实例如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="/imgs/200408/03.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p><strong>存在性查询</strong></p>
<p>查询嵌入文档包含某个field的case，和普通的查询姿势也一样</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>排序</strong></p>
<p>根据Object的成员进行排序，操作姿势也基本一样</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="/imgs/200408/04.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/200408/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>十二：文档更新删除之非典型篇</title>
      <link>https://liuyueyi.github.io/tutorial/db/mongodb/basic/14.MongoDB%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E5%8D%81%E4%BA%8C-%E6%96%87%E6%A1%A3%E6%9B%B4%E6%96%B0%E5%88%A0%E9%99%A4%E4%B9%8B%E9%9D%9E%E5%85%B8%E5%9E%8B%E7%AF%87.html</link>
      <guid>https://liuyueyi.github.io/tutorial/db/mongodb/basic/14.MongoDB%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E5%8D%81%E4%BA%8C-%E6%96%87%E6%A1%A3%E6%9B%B4%E6%96%B0%E5%88%A0%E9%99%A4%E4%B9%8B%E9%9D%9E%E5%85%B8%E5%9E%8B%E7%AF%87.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">十二：文档更新删除之非典型篇</source>
      <description>前面介绍document的新增、删除、更新都处于相对常见和基础的说明，但是考虑到mongodb非结构化的特点，它的一些特性是我们的mysql不会遇到的，本文将针对这些特殊场景给出示例说明 在现有文档中，增加一个field 删除文档中的某个field 重命名文档的field 在文档的数组orObject中，添加/删除/更新数据</description>
      <category>DB</category>
      <category>Mongo</category>
      <pubDate>Fri, 10 Apr 2020 09:13:52 GMT</pubDate>
      <content:encoded><![CDATA[<p>前面介绍document的新增、删除、更新都处于相对常见和基础的说明，但是考虑到mongodb非结构化的特点，它的一些特性是我们的mysql不会遇到的，本文将针对这些特殊场景给出示例说明</p>
<ul>
<li>在现有文档中，增加一个field</li>
<li>删除文档中的某个field</li>
<li>重命名文档的field</li>
<li>在文档的数组orObject中，添加/删除/更新数据</li>
</ul>
<!-- more -->
<h3> 1. 增加field</h3>
<p>我们知道修改文档的命令格式如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当我们更新一个文档中，不存在的field，会怎样</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/200410/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 2. 重命名field</h3>
<p>同样是借助update方法，但是我们用到的关键字为 <code>$rename</code></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="/imgs/200410/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p><strong>请注意，当文档中不存在这个field，则不会有任何影响</strong></p>
<h3> 3. 删除field</h3>
<p>既然<code>$set</code>可以新增一个不存在的field，那么是不是就可以用<code>$unset</code>来删除一个已存在的field呢</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="/imgs/200410/02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 4. 数组元素修改</h3>
<blockquote>
<p>数组元素的修改删除增加，可以参考官方教程: <a href="https://www.mongodb.org.cn/manual/update-array/" target="_blank" rel="noopener noreferrer">MongoDB update-array Method</a></p>
</blockquote>
<p>如果我们希望直接修改数组中的某个元素，可以借助之前查询的case</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/200410/03.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p><strong>请注意，使用<code>$</code>占位符的前途是，前面的查询条件可以限定数组元素</strong></p>
<h3> 5. 数组元素新增</h3>
<p>元素添加支持两种方式，一是<code>addToSet</code>，一是<code>push</code></p>
<p><strong><code>$addToSet</code></strong></p>
<ul>
<li>确保没有重复的项添加到数组集合，对于已经存在的重复元素不受影响；</li>
<li>不能保证添加时元素的顺序</li>
<li>如果值是数组，则作为一个元素添加进去</li>
<li>可以通过 <code>$each</code> 实现添加多个元素到数组中</li>
</ul>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/200410/04.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p><strong><code>$push</code></strong></p>
<ul>
<li>如果被更新的文档该数组不存在，那么$push将添加数组字段和值</li>
<li>如果字段不是数组，失败</li>
<li>如果值是数组，那么整个数组作为一个单个元素添加到数组</li>
</ul>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/200410/05.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 6. 数组元素删除</h3>
<p><strong><code>$pop</code></strong> 删除第一个or最后一个</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/200410/06.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p><strong><code>$pull</code></strong> 删除满足条件的数组元素</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/200410/07.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>注意，<code>$pull</code>后面跟上的可以理解为限定条件，查询教程篇的一些操作也是支持的（如比较查询等）</p>
<h3> 7. 内嵌文档操作</h3>
<p>对于内嵌文档的操作，实际上普通的field的操作姿势没有什么区别，只是对于key加了一个<code>xx.xx</code>的限定而已</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/200410/08.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/200410/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>十三：索引</title>
      <link>https://liuyueyi.github.io/tutorial/db/mongodb/basic/15.MongoDb%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E5%8D%81%E4%B8%89-%E7%B4%A2%E5%BC%95.html</link>
      <guid>https://liuyueyi.github.io/tutorial/db/mongodb/basic/15.MongoDb%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E5%8D%81%E4%B8%89-%E7%B4%A2%E5%BC%95.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">十三：索引</source>
      <description>索引一般用来提高查询效率，避免全集合搜索，那么在mongodb中，支持索引么？如果支持，如何定义索引，如何使用索引，如何确定一个sql是否走索引？</description>
      <category>DB</category>
      <category>Mongo</category>
      <pubDate>Sat, 18 Apr 2020 08:55:17 GMT</pubDate>
      <content:encoded><![CDATA[<p>索引一般用来提高查询效率，避免全集合搜索，那么在mongodb中，支持索引么？如果支持，如何定义索引，如何使用索引，如何确定一个sql是否走索引？</p>
<!-- more -->
<h3> 1. 创建索引</h3>
<p><strong>语法定义:</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>请注意，在3.0之前的版本中，也可以使用<code>ensureIndex</code>来创建索引</p>
<p><strong>参数说明:</strong></p>
<ul>
<li>keys：kv结构，key为fieldName, value为1 表示升序创建索引；-1 表示降序创建索引；支持多字段索引</li>
<li>options：可选参数</li>
</ul>
<p>常见参数说明如下表:</p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>background</code></td>
<td>true，则后台方式创建索引，不阻塞其他操作；默认为false</td>
</tr>
<tr>
<td><code>unique</code></td>
<td>true，则表示唯一约束索引，比如<code>_id</code>就有唯一约束；默认为false</td>
</tr>
<tr>
<td><code>name</code></td>
<td>索引名，不指定时，根据field + 方向生成索引名</td>
</tr>
<tr>
<td><code>sparse</code></td>
<td>true, 则不包含这个字段的不创建索引，且索引查询时查不到不包含这个字段的文档；默认false</td>
</tr>
<tr>
<td><code>expireAfterSeconds</code></td>
<td>设置文档在集合的生存时间，s为单位</td>
</tr>
<tr>
<td><code>v</code></td>
<td>版本号</td>
</tr>
<tr>
<td><code>weight</code></td>
<td>索引权重值，数值在 1 到 99,999 之间，表示该索引相对于其他索引字段的得分权重</td>
</tr>
<tr>
<td><code>default_language</code></td>
<td>对于文本索引，该参数决定了停用词及词干和词器的规则的列表。 默认为英语</td>
</tr>
<tr>
<td><code>language_override</code></td>
<td>对于文本索引，该参数指定了包含在文档中的字段名，语言覆盖默认的language，默认值为 language</td>
</tr>
</tbody>
</table>
<p>实例如下：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 2. 索引查询</h3>
<p>查看一个集合定义了哪些索引，借助<code>getIndexes()</code>方法即可，如</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="/imgs/200418/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 3. 索引分析</h3>
<p>虽然我们创建了索引，但是我们的查询语句却并不一定会走索引，在mysql中我们知道有一个<code>explain</code>语句来分析索引情况，在mongodb中也存在类似的方法</p>
<p>集合数据如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当前集合上除了默认的<code>_id</code>索引之外，针对<code>name</code>也创建了升序索引</p>
<p>如需要判断一个查询语句的情况，可以在后面加上<code>explain()</code>方法，如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>输出如下</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>关于是否走索引，主要看stage，通常会有以下几种状态</p>
<table>
<thead>
<tr>
<th>stage</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>COLLSCAN</td>
<td>全表扫描</td>
</tr>
<tr>
<td>IXSCAN</td>
<td>扫描索引</td>
</tr>
<tr>
<td>FETCH</td>
<td>根据索引去检索指定document</td>
</tr>
<tr>
<td>SHARD_MERGE</td>
<td>将各个分片返回数据进行merge</td>
</tr>
<tr>
<td>SORT</td>
<td>表明在内存中进行了排序</td>
</tr>
<tr>
<td>LIMIT</td>
<td>使用limit限制返回数</td>
</tr>
<tr>
<td>SKIP</td>
<td>使用skip进行跳过</td>
</tr>
<tr>
<td>IDHACK</td>
<td>针对_id进行查询</td>
</tr>
<tr>
<td>SHARDING_FILTER</td>
<td>通过mongos对分片数据进行查询</td>
</tr>
<tr>
<td>COUNT</td>
<td>利用db.coll.explain().count()之类进行count运算</td>
</tr>
<tr>
<td>COUNTSCAN</td>
<td>count不使用Index进行count时的stage返回</td>
</tr>
<tr>
<td>COUNT_SCAN</td>
<td>count使用了Index进行count时的stage返回</td>
</tr>
<tr>
<td>SUBPLA</td>
<td>未使用到索引的$or查询的stage返回</td>
</tr>
<tr>
<td>TEXT</td>
<td>使用全文索引进行查询时候的stage返回</td>
</tr>
<tr>
<td>PROJECTION</td>
<td>限定返回字段时候stage的返回</td>
</tr>
</tbody>
</table>
<p>上面的具体查询，对应的stage组合是<code>Fetch+ixscan</code>，也就是说会根据索引查询</p>
<p>虽然mongodb会根据查询来选择索引，但并不能保证都能选到最优的索引；这种时候我们可以通过<code>hint</code>来强制指定索引，举例如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 4. 删除索引</h3>
<p>一般有下面两种删除方式，全量删除和指定索引删除</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>请注意，指定索引名删除时，如果不确定索引名是啥，可以通过<code>getIndexes()</code>来查看</p>
<h3> 5. 文档自动删除</h3>
<p>在创建索引的时候，其中有一个参数比较有意思，有必要单独拿出来说明一下，<code>expireAfterSeconds</code> 设置文档的生存时间</p>
<p>使用它有几个潜规则：</p>
<ul>
<li>索引字段为Date类型</li>
<li>单字段索引，不支持混合索引</li>
<li>非立即执行</li>
</ul>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后过一段时间（并不一定10:55分的时候会删除）再去查询，会发现插入的文档被删除了</p>
<p>利用这种特性，在mongodb中存一些需要定时删除的数据，相比较我们常用的mysql而言，还是有很大优势的</p>
<h3> 6. 覆盖索引</h3>
<p>覆盖索引的概念有些类似mysql中的不回表查询的case，直接查询索引，就可以返回所需要的字段了</p>
<p>比如在前面的case中，我只查询name字段，可以走覆盖索引；但是返回除了name，还有<code>_id</code>，那么就不能了</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>注意：所有索引字段是一个数组时，不能使用覆盖索引</strong></p>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/200418/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>MongoDB基础教程</title>
      <link>https://liuyueyi.github.io/tutorial/db/mongodb/basic/</link>
      <guid>https://liuyueyi.github.io/tutorial/db/mongodb/basic/</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">MongoDB基础教程</source>
      <description>文档数据库MongoDB的基本使用姿势教程，手把手教你学会MongoDB的CURD</description>
      <pubDate>Fri, 24 Feb 2023 08:19:09 GMT</pubDate>
      <content:encoded><![CDATA[<p>文档数据库MongoDB的基本使用姿势教程，手把手教你学会MongoDB的CURD</p>
]]></content:encoded>
    </item>
    <item>
      <title>SpringBoot整合MongoDB</title>
      <link>https://liuyueyi.github.io/tutorial/db/mongodb/spring/</link>
      <guid>https://liuyueyi.github.io/tutorial/db/mongodb/spring/</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">SpringBoot整合MongoDB</source>
      <description>SpringBoot 整合 MongoDB SpringBoot + MongoDB SpringBoot生态下，掌握MongoDB的CURD</description>
      <pubDate>Fri, 24 Feb 2023 08:19:09 GMT</pubDate>
      <content:encoded><![CDATA[<p><a href="/spring/db/MongoDB/" target="_blank" rel="noopener noreferrer">SpringBoot 整合 MongoDB</a></p>
<div class="hint-container info">
<p class="hint-container-title">SpringBoot + MongoDB</p>
<p>SpringBoot生态下，掌握MongoDB的CURD</p>
</div>
]]></content:encoded>
    </item>
    <item>
      <title>数据库</title>
      <link>https://liuyueyi.github.io/tutorial/db/</link>
      <guid>https://liuyueyi.github.io/tutorial/db/</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">数据库</source>
      <description>数据库 ❤️ MySql 📝 MongoDB ⌛ InfluxDB 🪧 ClickHouse 🫶 Redis 🔍 ES</description>
      <pubDate>Fri, 24 Feb 2023 02:18:35 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 数据库</h1>
<h2> ❤️ MySql</h2>
<h2> 📝 MongoDB</h2>
<h2> ⌛ InfluxDB</h2>
<h2> 🪧 ClickHouse</h2>
<h2> 🫶 Redis</h2>
<h2> 🔍 ES</h2>
]]></content:encoded>
    </item>
    <item>
      <title>ClickHouse系列教程</title>
      <link>https://liuyueyi.github.io/tutorial/db/clickhouse/</link>
      <guid>https://liuyueyi.github.io/tutorial/db/clickhouse/</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">ClickHouse系列教程</source>
      <description>列式数据库ClickHouse</description>
      <pubDate>Fri, 24 Feb 2023 02:18:35 GMT</pubDate>
      <content:encoded><![CDATA[<p>列式数据库ClickHouse</p>
]]></content:encoded>
    </item>
    <item>
      <title>ES系列教程</title>
      <link>https://liuyueyi.github.io/tutorial/db/es/</link>
      <guid>https://liuyueyi.github.io/tutorial/db/es/</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">ES系列教程</source>
      <description>近实时搜索引擎ElasticSearch</description>
      <pubDate>Fri, 24 Feb 2023 02:18:35 GMT</pubDate>
      <content:encoded><![CDATA[<p>近实时搜索引擎ElasticSearch</p>
]]></content:encoded>
    </item>
    <item>
      <title>InfluxDB系列教程</title>
      <link>https://liuyueyi.github.io/tutorial/db/influxdb/</link>
      <guid>https://liuyueyi.github.io/tutorial/db/influxdb/</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">InfluxDB系列教程</source>
      <description>时序数据库Influxdb</description>
      <pubDate>Fri, 24 Feb 2023 02:18:35 GMT</pubDate>
      <content:encoded><![CDATA[<p>时序数据库Influxdb</p>
]]></content:encoded>
    </item>
    <item>
      <title>MongoDB系列教程</title>
      <link>https://liuyueyi.github.io/tutorial/db/mongodb/</link>
      <guid>https://liuyueyi.github.io/tutorial/db/mongodb/</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">MongoDB系列教程</source>
      <description>专栏说明 文档数据库MongoDB的基本使用姿势教程，手把手教你学会MongoDB的CURD MongoDB 0基础入门 mongodb 基础知识 原生的mongodb知识点，如基础概念，CURD等</description>
      <pubDate>Fri, 24 Feb 2023 02:18:35 GMT</pubDate>
      <content:encoded><![CDATA[<div class="hint-container tip">
<p class="hint-container-title">专栏说明</p>
<p>文档数据库MongoDB的基本使用姿势教程，手把手教你学会MongoDB的CURD</p>
</div>
<ul>
<li><a href="./basic">MongoDB 0基础入门</a></li>
</ul>
<div class="hint-container info">
<p class="hint-container-title">mongodb 基础知识</p>
<p>原生的mongodb知识点，如基础概念，CURD等</p>
</div>
<ul>
<li><a href="/spring/db/MongoDB/" target="_blank" rel="noopener noreferrer">SpringBoot 整合 MongoDB</a></li>
</ul>
<div class="hint-container info">
<p class="hint-container-title">SpringBoot + MongoDB</p>
<p>SpringBoot生态下，掌握MongoDB的CURD</p>
</div>
]]></content:encoded>
    </item>
    <item>
      <title>mongodb零基础入门</title>
      <link>https://liuyueyi.github.io/tutorial/db/mongodb/merge.html</link>
      <guid>https://liuyueyi.github.io/tutorial/db/mongodb/merge.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">mongodb零基础入门</source>
      <description>MongoDB零基础入门 MongoDB 是一个基于分布式文件存储的数据库，本片文档主要面向0基础的小伙伴，如何迅速的学会MongoDB的基本知识点以及掌握基础的CURD，实现业务支撑 第一卷：MongoDB原生知识点 环境安装与初始化 MongoDB 是一个基于分布式文件存储的数据库。由 C++ 语言编写。旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。 MongoDB 是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。 本篇为mongodb系列教程第一篇，环境安装与连接设置</description>
      <pubDate>Fri, 24 Feb 2023 02:18:35 GMT</pubDate>
      <content:encoded><![CDATA[<figure><img src="http://cdn.hhui.top/column/mongo_cover.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> MongoDB零基础入门</h2>
<p>MongoDB 是一个基于分布式文件存储的数据库，本片文档主要面向0基础的小伙伴，如何迅速的学会MongoDB的基本知识点以及掌握基础的CURD，实现业务支撑</p>
<h1> 第一卷：MongoDB原生知识点</h1>
<h2> 环境安装与初始化</h2>
<blockquote>
<p>MongoDB 是一个基于分布式文件存储的数据库。由 C++ 语言编写。旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。</p>
</blockquote>
<p>MongoDB 是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。</p>
<p>本篇为mongodb系列教程第一篇，环境安装与连接设置</p>
<!-- more -->
<h3> 1. docker安装</h3>
<p>首先介绍最简单的安装方式，docker安装，请先保证docker环境存在（没有安装的推荐查看: <a href="https://blog.hhui.top/2019/12/06/191206-Centos%E5%AE%89%E8%A3%85docker%E4%B8%8E%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/" target="_blank" rel="noopener noreferrer">Centos安装docker与使用说明</a>）</p>
<p>安装命令如下:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. centos安装</h3>
<p>直接借助yum进行安装，命令如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. 用户配置</h3>
<p>直接通过mongodb提供的终端命令进行设置，</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4. 终端控制台</h3>
<p>mongodb集成了终端控制台，通过<code>mongo</code>进入；</p>
<p>但是当我们设置了登录认证时，有下面两种使用姿势</p>
<p><strong>case1</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://hhui.top/imgs/200319/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p><strong>case2</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://hhui.top/imgs/200319/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 5. 可视化操作工具</h3>
<p>终端虽好，使用起来终究不太顺手，可视化工具推荐使用<code>ROBO 3T</code>操作mongodb，官网下载地址: <a href="https://robomongo.org/" target="_blank" rel="noopener noreferrer">https://robomongo.org/</a></p>
<p>然后配置mongodb连接信息（支持ssh验证方式哦），下面是一个简单的配置</p>
<figure><img src="https://hhui.top/imgs/200319/02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>然后就可以通过它来操作mongodb了</p>
<figure><img src="https://hhui.top/imgs/200319/03.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> 基本概念</h2>
<p>mongodb和我们通常使用的关系型数据库如mysql，在一些基本概念上有相同之处，但也有一些区别，在进行mongodb的语言介绍之前，有必要先了解一些基础概念</p>
<p>本文将对比sql对一些基础概念进行解释说明</p>
<!-- more -->
<blockquote>
<p><a href="https://www.runoob.com/mongodb/mongodb-databases-documents-collections.html" target="_blank" rel="noopener noreferrer">MongoDB 概念解析</a></p>
</blockquote>
<p>在sql中，会区分database, table, row, column, index, primaryId；在mongodb中也有对应的概念</p>
<table>
<thead>
<tr>
<th>sql</th>
<th>mongodb</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>database</td>
<td>db</td>
<td>数据库</td>
</tr>
<tr>
<td>table</td>
<td>collection</td>
<td>表/集合</td>
</tr>
<tr>
<td>row</td>
<td>document</td>
<td>行/文档</td>
</tr>
<tr>
<td>column</td>
<td>field</td>
<td>字段</td>
</tr>
<tr>
<td>index</td>
<td>index</td>
<td>索引</td>
</tr>
<tr>
<td>primaryId</td>
<td>_id</td>
<td>主键</td>
</tr>
<tr>
<td>lock</td>
<td>lock</td>
<td>锁</td>
</tr>
</tbody>
</table>
<p>下面对以上基本概念进行简单说明，详情的后续博文会补上</p>
<h3> 1. 数据库</h3>
<p>数据库可以理解为collection的聚集体，每个mongodb实例可以有多个database，每个database可以有多个collection</p>
<p>常见的几个命令如下：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 集合</h3>
<p>document的集合，与table最大的区别是它的结构不是固定的，不需要事先定义字段、类型</p>
<p>首次新增document时，集合被创建；</p>
<h3> 3. document</h3>
<p>文档，也就是具体的数据；bson结构，kv方式</p>
<p>最大的特点是不要求所有的document的结构一致，相同的field的数据类型可以不一致</p>
<h3> 4. index</h3>
<p>索引，同样是用来提高查询效率，避免全盘扫描</p>
<h3> 5. lock</h3>
<p>支持读写锁，document加读锁时，其他读操作ok，写操作禁止；加写锁时，其他读写操作禁止</p>
<h3> 6. 事务</h3>
<blockquote>
<p><a href="https://yq.aliyun.com/articles/610159" target="_blank" rel="noopener noreferrer">MongoDB 4.0 事务实现解析</a></p>
</blockquote>
<p>版本<code>&gt;= 4.0</code>，支持事务，支持多文档ACID，后续详细说明</p>
<hr>
<p>微信搜 <strong>楼仔</strong> 或扫描下方二维码关注楼仔的原创公众号，回复 <strong>110</strong> 即可免费领取 10 本面试必刷八股文。
<img src="https://files.mdnice.com/user/13837/4b47ac79-8256-47cf-ac1a-036729635246.png" alt="" loading="lazy"></p>
<hr>
<h2> 连接</h2>
<p>后续的所有文章的基础，都是需要先连上mongodb，然后才能执行各种命令操作；</p>
<p>本文将介绍一下如何连接一个已经启动的mongodb服务器</p>
<!-- more -->
<h3> 1. 连接语法</h3>
<p>标准URI连接语法：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul>
<li><code>mongodb://</code> 固定前缀</li>
<li><code>username:password@</code>: 如果开启了用户登录验证，需要指定用户名密码</li>
<li><code>host1:port1</code>: mongodb服务器的ip/域名 + 端口(不填时，默认为27017)</li>
<li><code>database</code>: 如果指定<code>username:password@</code>，连接并验证登陆指定数据库。若不指定，默认打开 test 数据库</li>
<li><code>?options</code>: 是连接选项。如果不使用/database，则前面需要加上</li>
</ul>
<h3> 2. 实例</h3>
<p>直接连接方式如下，注意这种方式会保留用户名和密码，会有一定的安全风险</p>
<p><strong>连接目标服务器</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>连接多台服务器</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>连接 replica set 三台服务器, 写入操作应用在主服务器 并且分布查询到从服务器</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2> 基本工具介绍</h2>
<p>mongodb服务器安装完毕之后，提供了一些配套的操作工具，接下来我们有必要认识一下它们，并了解基本用法</p>
<!-- more -->
<h3> 0. mongod</h3>
<p>启动mongodb实例的主要命令，常见的使用姿势如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 1. mongo 命令行使用</h3>
<p>mongodb安装完毕之后，会自带一个终端命令行工具，通过它可以连接mongodb，并执行相关命令</p>
<h4> a. 连接</h4>
<p>介绍三种连接mongodb的姿势</p>
<p><strong>case1</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>case2</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>case3</strong></p>
<p>上面两种姿势虽然简单，但是用户名密码有暴露的风险，推荐使用下面这种方式</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> b. 操作</h4>
<p>连接上mongodb服务器之后，就可以执行mongo命令，查看数据库，管理文档，比如下面给几个常见的操作</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://hhui.top/imgs/200325/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 2. mongoimport/mongoexport</h3>
<p>用于导入导出数据，如</p>
<p>将库<code>database</code>中的集合<code>collection</code>导出到json文件<code>out.json</code></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>从json文件导入到目标集合<code>new_collection</code></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 3. mongodump/mongorestore</h3>
<p>使用mongodump命令来备份MongoDB数据, 将数据库<code>basic</code>的所有集合备份到目录 <code>/tmp/outDir</code>下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>使用mongorestore恢复，如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4. mongostate</h3>
<p>mongostat是mongodb自带的状态检测工具，在命令行下使用。它会间隔固定时间获取mongodb的当前运行状态，并输出。如果你发现数据库突然变慢或者有其他问题的话，你第一手的操作就考虑采用mongostat来查看mongo的状态。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="https://hhui.top/imgs/200325/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 5. mongotop</h3>
<p>mongotop提供每个集合的水平的统计数据，默认每s输出一次</p>
<figure><img src="https://hhui.top/imgs/200325/02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> 数据库 Database</h2>
<p>我们通常把mongodb叫文档型数据库，mysql叫关系型数据库，influxdb叫时序数据库，如果熟悉这三个的话，会发现他们都有一个<code>database</code>，它是<code>collection/table/measurement</code>的上一级，可以简单的把它理解为更高层级的集合，方便统一管理/权限划分/业务拆分</p>
<p>下面简单介绍一下database的基础操作</p>
<!-- more -->
<h3> 1. 创建数据库</h3>
<p>当数据库不存在时，通过<code>use + 数据库</code>命令可以用来创建数据库；当数据库存在时，表示选中</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 2. 查看数据库</h3>
<p>通过 <code>db</code>查看当前的数据库</p>
<p>通过 <code>show dbs</code> 查看当前的数据库列表</p>
<p>请注意，新创建一个数据库时，直接使用<code>show dbs</code>命令，并不会显示出来，如下</p>
<figure><img src="https://hhui.top/imgs/200326/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>为了显示这个数据库，需要插入一个文档</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="https://hhui.top/imgs/200326/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 3. 删除数据库</h3>
<p>对于数据库而言，任何删除命令都需要慎重处理，一不小心就得跑路了。。。</p>
<p>命令如下: <code>db.dropDatabase()</code></p>
<p>实例说明：</p>
<p>一般来说我们需要删除时，两步走</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://hhui.top/imgs/200326/02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 4. 潜规则</h3>
<p>需要注意，有三个数据库属于预留的，有特殊的作用，不能新建同名的数据</p>
<ul>
<li>admin: 将一个用户添加到这个数据库，这个用户自动继承所有数据库的权限; 一些特定的服务器端命令也只能从这个数据库运行，比如列出所有的数据库或者关闭服务器。</li>
<li>local: 这个数据永远不会被复制，可以用来存储限于本地单台服务器的任意集合</li>
<li>config: 当Mongo用于分片设置时，config数据库在内部使用，用于保存分片的相关信息。</li>
</ul>
<p>命名规则：</p>
<ul>
<li>不能是空字符串</li>
<li>不能含有特殊字符（如<code> </code>，<code>.</code>，<code>$</code>, <code>\</code>, <code>/</code>, <code>\0</code></li>
<li>小写</li>
<li>最多64字节</li>
</ul>
<h2> 集合 Collection</h2>
<p>集合，相当于关系型数据库中的table，在mongodb中，集合的概念非常贴切，属于文档(Document)的集合</p>
<p>其最大的特点是：</p>
<ul>
<li>没有固定的结构</li>
</ul>
<!-- more -->
<h3> 1. 创建集合</h3>
<p>创建命令如: <code>db.createCollection(name, options)</code></p>
<p>重点看一下参数<code>options</code>的可选项</p>
<ul>
<li>capped: true，表示创建固定大小的集合，需要指定size；超过数量之后，覆盖最早的文档</li>
<li>size: 固定集合时配套使用，KB为单位</li>
<li>autoIndexId: 自动为<code>_id</code>添加索引，默认true</li>
<li>max: 固定集合时，文档的最大数量</li>
</ul>
<p>一个简单的实例</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>除此之外，新插入一个文档时，集合若不存在，也会创建对应的集合，如</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 查看集合</h3>
<p>通过 <code>show collections</code> 查看数据库下的集合列表</p>
<figure><img src="https://hhui.top/imgs/200326/03.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 3. 删除集合</h3>
<p>通过命令 <code>db.col.drop()</code>来删除</p>
<figure><img src="https://hhui.top/imgs/200326/04.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 4. 命名规则</h3>
<ul>
<li>不能全是空白字符</li>
<li>不应包含特殊字符</li>
<li>不要以<code>system.</code>开头</li>
</ul>
<hr>
<p>微信搜 <strong>楼仔</strong> 或扫描下方二维码关注楼仔的原创公众号，回复 <strong>110</strong> 即可免费领取 10 本面试必刷八股文。 <img src="https://files.mdnice.com/user/13837/4b47ac79-8256-47cf-ac1a-036729635246.png" alt="" loading="lazy"></p>
<hr>
<h2> 文档 Document 插入姿势</h2>
<p>文档相当于关系数据库中数据行，也是我们最关心的数据本身；以BSON格式存储（和json区别不大）</p>
<p>我们通常所说业务开发者的CURD四大技能，在mongodb中，就是针对Document而言，接下来我们先看一下文档的新增使用姿势</p>
<!-- more -->
<h3> 1. 基本语法</h3>
<p>插入语法： <code>db.collection.insert()</code></p>
<p>因为集合不要求定义数据结构，所以插入的文档格式理论上可以完全不一样，可以拥有完全不同的数据结构，相同的字段拥有不同的数据类型</p>
<h3> 2. 实例演示</h3>
<p>下面给出几个实例进行说明</p>
<p><strong>基本数据类型插入</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>数组类型插入</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>Object类型插入</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="https://hhui.top/imgs/200326/05.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 3. 数据类型</h3>
<p>mongodb支持的基本数据类型，除了我们常见的string,int,float,boolean之外，还有一些其他的;</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>String</td>
<td>字符串， UTF8编码</td>
</tr>
<tr>
<td>Integer</td>
<td>整型，32/64位</td>
</tr>
<tr>
<td>Boolean</td>
<td>布尔</td>
</tr>
<tr>
<td>Double</td>
<td>浮点</td>
</tr>
<tr>
<td>Min/Max keys</td>
<td>将一个值与 BSON（二进制的 JSON）元素的最低值和最高值相对比</td>
</tr>
<tr>
<td>Array</td>
<td>数组</td>
</tr>
<tr>
<td>Timestamp</td>
<td>时间戳，记录文档修改或添加的具体时间</td>
</tr>
<tr>
<td>Object</td>
<td>内嵌文档</td>
</tr>
<tr>
<td>Null</td>
<td>创建空值</td>
</tr>
<tr>
<td>Symbol</td>
<td>符号。该数据类型基本上等同于字符串类型，但不同的是，它一般用于采用特殊符号类型的语言。</td>
</tr>
<tr>
<td>Date</td>
<td>日期，用 UNIX 时间格式来存储当前日期或时间。你可以指定自己的日期时间：创建 Date 对象，传入年月日信息。</td>
</tr>
<tr>
<td>ObjectID</td>
<td>对象ID</td>
</tr>
<tr>
<td>Binary Data</td>
<td>二进制</td>
</tr>
<tr>
<td>code</td>
<td>代码类型。用于在文档中存储 JavaScript 代码。</td>
</tr>
<tr>
<td>Regular expression</td>
<td>正则表达式类型。用于存储正则表达式。</td>
</tr>
</tbody>
</table>
<p><strong>ObjectId 类似唯一主键</strong>，可以很快的去生成和排序，包含 12 bytes，含义是：</p>
<ul>
<li>前 4 个字节表示创建 unix 时间戳,格林尼治时间 UTC 时间，比北京时间晚了 8 个小时</li>
<li>接下来的 3 个字节是机器标识码</li>
<li>紧接的两个字节由进程 id 组成 PID</li>
<li>最后三个字节是随机数</li>
</ul>
<h2> 文档 Document 删除姿势</h2>
<p>前面一篇介绍了插入文档的使用姿势，这一篇则主要介绍删除的使用case</p>
<!-- more -->
<h3> 1. 基本语法</h3>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>第一个为需要删除的匹配条件；第二个表示是否只删除一个，默认是false，删除所有满足条件的文档</p>
<p><strong>注意</strong></p>
<ul>
<li>当query为空时，表示删除所有文档，高危操作，谨慎执行</li>
</ul>
<h3> 2. 实例演示</h3>
<p>借用给我们上一篇插入的文档来进行演示，当前存在的文档为</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>根据id进行删除</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>根据name删除第一个满足条件的记录</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>再次查看剩下的内容如下：</p>
<figure><img src="https://hhui.top/imgs/200326/06.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> 文档 Document 更新姿势</h2>
<p>本篇介绍update/save两种方法提供的更新姿势</p>
<!-- more -->
<h3> 1. update</h3>
<p>用于更新已经存在的文档，语法如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>query: 查询条件</li>
<li>update: 更新语句</li>
<li>upsert: （可选）true, 不存在update的记录时插入；默认是false，不插入</li>
<li>multi: (可选) true，表示更新所有满足条件的记录；默认false，只更新第一条</li>
<li>writeConcern: (可选)，抛出异常的级别</li>
</ul>
<p>插入两条用于测试的数据</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>下面给出几个更新的实例</p>
<p><strong>更新age</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://hhui.top/imgs/200327/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p><strong>更新所有age为20的文档，新增一个tag成员</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="https://hhui.top/imgs/200327/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p><strong>更新一个不存在的文档</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="https://hhui.top/imgs/200327/02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 2. save</h3>
<p>save最大的特点是覆盖，用新的文档完全覆盖旧的文档；而update，则是更新指定的field</p>
<p>语法如下：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>举例如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="https://hhui.top/imgs/200327/03.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>那么问题来了，<strong>怎样判定是新增一条记录，还是覆盖已经存在的记录呢？</strong></p>
<ul>
<li>有唯一键来判定</li>
<li>即：如果save的文档中，某个field有唯一性要求，那么当数据库中存在这个field文档文档时，执行覆盖操作；否则执行插入</li>
</ul>
<p>举例如下, 指定ObjectId</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="https://hhui.top/imgs/200327/04.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<hr>
<p>微信搜 <strong>楼仔</strong> 或扫描下方二维码关注楼仔的原创公众号，回复 <strong>110</strong> 即可免费领取 10 本面试必刷八股文。 <img src="https://files.mdnice.com/user/13837/4b47ac79-8256-47cf-ac1a-036729635246.png" alt="" loading="lazy"></p>
<hr>
<h2> 文档 Document 查询基础篇</h2>
<p>MongoDb文档查询，主要借助find方法来完成，在实际的业务开发中，为了满足各种复杂的业务场景，查询的姿势也是各种各样，本篇则主要介绍基本的使用姿势，不涉及到聚合、排序、分页相关内容</p>
<!-- more -->
<h3> 1. 查询语法</h3>
<p>查询语法定义比较简单，复杂的是查询条件的组合；语法定义如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul>
<li>query: 查询条件，如果不填，则表示查询所有文档</li>
<li>projection: 查询需要返回的field，如果不填则返回所有的数据</li>
</ul>
<p>此外为了mongo-cli的返回结果更加友好，可以在最后添加<code>.pretty()</code>，使输出更友好</p>
<h3> 2. 查询所有</h3>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="https://hhui.top/imgs/200328/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 3. 根据条件精准查询</h3>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="https://hhui.top/imgs/200328/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 4. 数字比较查询</h3>
<p>对于数字类型的field，可以借助符号<code>$gt</code>(&gt;), <code>$get</code>(&gt;=), <code>$lt</code>(&lt;), <code>$lte</code>(&lt;=), <code>$ne</code>(!=) 来表示具体的操作</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://hhui.top/imgs/200328/02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 5. 模糊查询</h3>
<p>在mysql中有一个like用于模糊查询，在mongodb中，同样支持基于正则的模糊查询</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://hhui.top/imgs/200328/03.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 6. and条件</h3>
<p>多个查询条件需要满足时，并不需要什么特殊的操作，只需要在查询bson中，加上多个条件即可</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://hhui.top/imgs/200328/04.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 7. or条件</h3>
<p>和and不需要额外的操作不同，or条件需要借助 <code>$or</code> 来实现，语法如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>实例如下：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://hhui.top/imgs/200328/05.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 8. 限制返回成员</h3>
<p>有些时候我们只需要获取文档中的部分成员，可以在第二个参数中进行指定，规则如下</p>
<ul>
<li><code>成员名: 1</code>： 表示这个成员需要返回</li>
<li><code>成员名: 0</code>： 表示这个成员不返回</li>
</ul>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://hhui.top/imgs/200328/06.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>请注意，一般在使用了 <code>成员名: 1</code> 来指定返回field时，会自动返回<code>_id</code>，如果不需要，请显示加上 <code>_id: 0</code></p>
<h3> 9. field类型查询</h3>
<p>根据field的成员类型来作为查询条件，一般有两种方式，这里只介绍更优雅的，语法如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>举例说明</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="https://hhui.top/imgs/200328/07.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 10. 存在查询</h3>
<p>mongodb的一个特点就是集合的结构不固定，所以某个成员可能存在也可能不存在，所以当我们的查询条件中需要加一个是否存在的判断时，可以如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://hhui.top/imgs/200328/08.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> 文档 Document 查询高级篇</h2>
<p>上一篇的mongodb查询，主要介绍的是一些基本操作，当然有基本就高阶操作；</p>
<p>本文将带来更多的查询姿势</p>
<ul>
<li>排序</li>
<li>分页</li>
<li>聚合</li>
</ul>
<!-- more -->
<h3> 1. 排序</h3>
<p>在mongodb中，使用sort方法进行排序，语法如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>请注意，sort内部是一个对象，key为field，value为1或者-1，其中1表示升序，-1表示降序</p>
<p>实例说明，根据age进行排序</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>输出如下:</p>
<figure><img src="https://hhui.top/imgs/200331/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>上面的演示属于常规的操作，但是针对mongodb的特点，自然会有一些疑问</p>
<p><strong>q1: 如果某个文档没有包含这个field，排序是怎样的？</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="https://hhui.top/imgs/200331/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>从输出来看，升序时，不包含这个field的文档，在最前面；降序时，不包含这个field的文档，在最后面</p>
<p><strong>q2: 支持多个field排序吗？</strong></p>
<p>原则上一般不建议多个field的排序（比较影响性能），但对于数据库而言，你得支持吧</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://hhui.top/imgs/200331/02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>请注意上的输出，在涉及到多个field排序时，优先根据第一个进行排序，当文档的field相同时，再根据后面的进行排序</p>
<h3> 2. 分页</h3>
<p>当文档很多时，我们不可能把所有的文档一次返回，所以就有了常见的分页，在sql中我们一般使用<code>limit</code> <code>offset</code>来实现分页，在mongodb中也差不多</p>
<p><strong>limit()</strong></p>
<p>限制返回的文档数</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="https://hhui.top/imgs/200331/03.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p><strong>skip()</strong></p>
<p>使用limit进行返回条数限制，使用skip进行分页，表示跳过前面的n条数据</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://hhui.top/imgs/200331/04.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 3. 聚合</h3>
<p>使用<code>aggregate()</code>来实现聚合，用于处理求和、平均值，最大值，分组等</p>
<p>数据准备:</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>分组查询</strong></p>
<p>根据name进行分组统计</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://hhui.top/imgs/200331/05.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>请注意，分组的条件中</p>
<ul>
<li><code>_id</code>: 表示根据哪个字段进行分组</li>
<li><code>size: {}</code>: 表示聚合条件指定，将结果输出到名为size的field中</li>
<li><code>filed</code>名前加<code>$</code>进行指定</li>
</ul>
<p>当前mongodb支持的聚合表达式包括:</p>
<table>
<thead>
<tr>
<th>表达式</th>
<th>说明</th>
<th>举例说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>sum</td>
<td>求和</td>
<td><code>db.doc_demo.aggregate([{$group: {_id: "$name", size: {$sum: '$age'}}}])</code></td>
</tr>
<tr>
<td>avg</td>
<td>平均值</td>
<td><code>db.doc_demo.aggregate([{$group: {_id: "$name", size: {$avg: '$age'}}}])</code></td>
</tr>
<tr>
<td>min</td>
<td>取最小</td>
<td><code>db.doc_demo.aggregate([{$group: {_id: "$name", age: {$min: '$age'}}}])</code></td>
</tr>
<tr>
<td>max</td>
<td>取最大</td>
<td><code>db.doc_demo.aggregate([{$group: {_id: "$name", age: {$max: '$age'}}}])</code></td>
</tr>
<tr>
<td>push</td>
<td>结果插入到一个数组中</td>
<td><code>db.doc_demo.aggregate([{$group: {_id: "$name", age: {$push: '$age'}}}])</code></td>
</tr>
<tr>
<td>addToSet</td>
<td>结果插入集合，过滤重复</td>
<td><code>db.doc_demo.aggregate([{$group: {_id: "$name", age: {$addToSet: '$age'}}}])</code></td>
</tr>
<tr>
<td>first</td>
<td>第一个</td>
<td><code>db.doc_demo.aggregate([{$group: {_id: "$name", age: {$first: '$age'}}}])</code></td>
</tr>
<tr>
<td>last</td>
<td>最后一个</td>
<td><code>db.doc_demo.aggregate([{$group: {_id: "$name", age: {$last: '$age'}}}])</code></td>
</tr>
</tbody>
</table>
<figure><img src="https://hhui.top/imgs/200331/06.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>上面虽然介绍了分组支持的一些表达式，但是没有查询条件，难道只能针对所有的文档进行分组统计么？</p>
<p><strong>分组过滤</strong></p>
<p>借助<code>$match</code>来实现过滤统计，如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://hhui.top/imgs/200331/07.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>请注意，$match的语法规则和find的查询条件一样，会将满足条件的数据传递给后面的分组计算</p>
<p>这种方式和liux中的管道特别相似，aggregate方法的参数数组中，前面的执行完毕之后，将结果传递给后面的继续执行，除了<code>$match</code>和<code>$group</code>之外，还有一些其他的操作</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>$project</td>
<td>修改输入文档的结构。可以用来重命名、增加或删除域，也可以用于创建计算结果以及嵌套文档。</td>
</tr>
<tr>
<td>$match</td>
<td>用于过滤数据，只输出符合条件的文档。$match使用MongoDB的标准查询操作。</td>
</tr>
<tr>
<td>$limit</td>
<td>用来限制MongoDB聚合管道返回的文档数。</td>
</tr>
<tr>
<td>$skip</td>
<td>在聚合管道中跳过指定数量的文档，并返回余下的文档。</td>
</tr>
<tr>
<td>$unwind</td>
<td>将文档中的某一个数组类型字段拆分成多条，每条包含数组中的一个值。</td>
</tr>
<tr>
<td>$group</td>
<td>将集合中的文档分组，可用于统计结果。</td>
</tr>
<tr>
<td>$sort</td>
<td>将输入文档排序后输出。</td>
</tr>
<tr>
<td>$geoNear</td>
<td>输出接近某一地理位置的有序文档。</td>
</tr>
</tbody>
</table>
<h2> 文档 Document 查询非典型篇</h2>
<p>前面介绍的查询可以说是常见的典型case，但是mongodb中有两个比价特殊的数据类型，数组 + 对象，自然的也会有一些非典型的查询case，下面主要针对这两种数据类型的查询姿势，给出实例讲解</p>
<!-- more -->
<h3> 1. 数组</h3>
<p>首先准备一些供数组操作的文档如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>长度查询</strong></p>
<p>根据数组长度进行查询，借助<code>$size</code>来统计数组长度</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>长度范围查询</strong></p>
<p>请注意，不支持长度的比较查询，如下，会报语法错误</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="https://hhui.top/imgs/200408/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>要实现范围查询，可以借助<code>$where</code>来实现(<code>$where</code>比较强大，后面单独说明)</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://hhui.top/imgs/200408/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p><strong>数组内容查询</strong></p>
<p>根据数组内容进行查询，常见的有两种方式，一个是直接根据数组定位比较如</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这种实用性可能并不大，另外一个常见的case就是查询数组中包含某个元素的文档，这时可以借助<code>$elemMatch</code>来实现</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://hhui.top/imgs/200408/02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>说明，当数组的元素是Object类型时，还可以用右边这种姿势：<code>db.doc_demo.find({'skill': {$elemMatch: {'subField': 'xxx'}}})</code></p>
<h3> 2. Object</h3>
<p>因为mongodb支持内嵌文档，所以根据内嵌文档进行查询的场景也是不少的</p>
<p>首先准备三个用于后续查询测试的文档</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>根据内嵌文档字段查询</strong></p>
<p>查询姿势和field查询相似，只是需要注意一下key的语法为: <code>field.subField</code>, 实例如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="https://hhui.top/imgs/200408/03.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p><strong>存在性查询</strong></p>
<p>查询嵌入文档包含某个field的case，和普通的查询姿势也一样</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>排序</strong></p>
<p>根据Object的成员进行排序，操作姿势也基本一样</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="https://hhui.top/imgs/200408/04.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> 文档更新删除之非典型篇</h2>
<p>前面介绍document的新增、删除、更新都处于相对常见和基础的说明，但是考虑到mongodb非结构化的特点，它的一些特性是我们的mysql不会遇到的，本文将针对这些特殊场景给出示例说明</p>
<ul>
<li>在现有文档中，增加一个field</li>
<li>删除文档中的某个field</li>
<li>重命名文档的field</li>
<li>在文档的数组orObject中，添加/删除/更新数据</li>
</ul>
<!-- more -->
<h3> 1. 增加field</h3>
<p>我们知道修改文档的命令格式如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当我们更新一个文档中，不存在的field，会怎样</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://hhui.top/imgs/200410/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 2. 重命名field</h3>
<p>同样是借助update方法，但是我们用到的关键字为 <code>$rename</code></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="https://hhui.top/imgs/200410/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p><strong>请注意，当文档中不存在这个field，则不会有任何影响</strong></p>
<h3> 3. 删除field</h3>
<p>既然<code>$set</code>可以新增一个不存在的field，那么是不是就可以用<code>$unset</code>来删除一个已存在的field呢</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="https://hhui.top/imgs/200410/02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 4. 数组元素修改</h3>
<blockquote>
<p>数组元素的修改删除增加，可以参考官方教程: <a href="https://www.mongodb.org.cn/manual/update-array/" target="_blank" rel="noopener noreferrer">MongoDB update-array Method</a></p>
</blockquote>
<p>如果我们希望直接修改数组中的某个元素，可以借助之前查询的case</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://hhui.top/imgs/200410/03.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p><strong>请注意，使用<code>$</code>占位符的前途是，前面的查询条件可以限定数组元素</strong></p>
<h3> 5. 数组元素新增</h3>
<p>元素添加支持两种方式，一是<code>addToSet</code>，一是<code>push</code></p>
<p><strong><code>$addToSet</code></strong></p>
<ul>
<li>确保没有重复的项添加到数组集合，对于已经存在的重复元素不受影响；</li>
<li>不能保证添加时元素的顺序</li>
<li>如果值是数组，则作为一个元素添加进去</li>
<li>可以通过 <code>$each</code> 实现添加多个元素到数组中</li>
</ul>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://hhui.top/imgs/200410/04.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p><strong><code>$push</code></strong></p>
<ul>
<li>如果被更新的文档该数组不存在，那么$push将添加数组字段和值</li>
<li>如果字段不是数组，失败</li>
<li>如果值是数组，那么整个数组作为一个单个元素添加到数组</li>
</ul>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://hhui.top/imgs/200410/05.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 6. 数组元素删除</h3>
<p><strong><code>$pop</code></strong> 删除第一个or最后一个</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://hhui.top/imgs/200410/06.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p><strong><code>$pull</code></strong> 删除满足条件的数组元素</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://hhui.top/imgs/200410/07.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>注意，<code>$pull</code>后面跟上的可以理解为限定条件，查询教程篇的一些操作也是支持的（如比较查询等）</p>
<h3> 7. 内嵌文档操作</h3>
<p>对于内嵌文档的操作，实际上普通的field的操作姿势没有什么区别，只是对于key加了一个<code>xx.xx</code>的限定而已</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://hhui.top/imgs/200410/08.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> 索引</h2>
<p>索引一般用来提高查询效率，避免全集合搜索，那么在mongodb中，支持索引么？如果支持，如何定义索引，如何使用索引，如何确定一个sql是否走索引？</p>
<!-- more -->
<h3> 1. 创建索引</h3>
<p><strong>语法定义:</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>请注意，在3.0之前的版本中，也可以使用<code>ensureIndex</code>来创建索引</p>
<p><strong>参数说明:</strong></p>
<ul>
<li>keys：kv结构，key为fieldName, value为1 表示升序创建索引；-1 表示降序创建索引；支持多字段索引</li>
<li>options：可选参数</li>
</ul>
<p>常见参数说明如下表:</p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>background</code></td>
<td>true，则后台方式创建索引，不阻塞其他操作；默认为false</td>
</tr>
<tr>
<td><code>unique</code></td>
<td>true，则表示唯一约束索引，比如<code>_id</code>就有唯一约束；默认为false</td>
</tr>
<tr>
<td><code>name</code></td>
<td>索引名，不指定时，根据field + 方向生成索引名</td>
</tr>
<tr>
<td><code>sparse</code></td>
<td>true, 则不包含这个字段的不创建索引，且索引查询时查不到不包含这个字段的文档；默认false</td>
</tr>
<tr>
<td><code>expireAfterSeconds</code></td>
<td>设置文档在集合的生存时间，s为单位</td>
</tr>
<tr>
<td><code>v</code></td>
<td>版本号</td>
</tr>
<tr>
<td><code>weight</code></td>
<td>索引权重值，数值在 1 到 99,999 之间，表示该索引相对于其他索引字段的得分权重</td>
</tr>
<tr>
<td><code>default_language</code></td>
<td>对于文本索引，该参数决定了停用词及词干和词器的规则的列表。 默认为英语</td>
</tr>
<tr>
<td><code>language_override</code></td>
<td>对于文本索引，该参数指定了包含在文档中的字段名，语言覆盖默认的language，默认值为 language</td>
</tr>
</tbody>
</table>
<p>实例如下：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 2. 索引查询</h3>
<p>查看一个集合定义了哪些索引，借助<code>getIndexes()</code>方法即可，如</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="https://hhui.top/imgs/200418/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 3. 索引分析</h3>
<p>虽然我们创建了索引，但是我们的查询语句却并不一定会走索引，在mysql中我们知道有一个<code>explain</code>语句来分析索引情况，在mongodb中也存在类似的方法</p>
<p>集合数据如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当前集合上除了默认的<code>_id</code>索引之外，针对<code>name</code>也创建了升序索引</p>
<p>如需要判断一个查询语句的情况，可以在后面加上<code>explain()</code>方法，如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>输出如下</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>关于是否走索引，主要看stage，通常会有以下几种状态</p>
<table>
<thead>
<tr>
<th>stage</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>COLLSCAN</td>
<td>全表扫描</td>
</tr>
<tr>
<td>IXSCAN</td>
<td>扫描索引</td>
</tr>
<tr>
<td>FETCH</td>
<td>根据索引去检索指定document</td>
</tr>
<tr>
<td>SHARD_MERGE</td>
<td>将各个分片返回数据进行merge</td>
</tr>
<tr>
<td>SORT</td>
<td>表明在内存中进行了排序</td>
</tr>
<tr>
<td>LIMIT</td>
<td>使用limit限制返回数</td>
</tr>
<tr>
<td>SKIP</td>
<td>使用skip进行跳过</td>
</tr>
<tr>
<td>IDHACK</td>
<td>针对_id进行查询</td>
</tr>
<tr>
<td>SHARDING_FILTER</td>
<td>通过mongos对分片数据进行查询</td>
</tr>
<tr>
<td>COUNT</td>
<td>利用db.coll.explain().count()之类进行count运算</td>
</tr>
<tr>
<td>COUNTSCAN</td>
<td>count不使用Index进行count时的stage返回</td>
</tr>
<tr>
<td>COUNT_SCAN</td>
<td>count使用了Index进行count时的stage返回</td>
</tr>
<tr>
<td>SUBPLA</td>
<td>未使用到索引的$or查询的stage返回</td>
</tr>
<tr>
<td>TEXT</td>
<td>使用全文索引进行查询时候的stage返回</td>
</tr>
<tr>
<td>PROJECTION</td>
<td>限定返回字段时候stage的返回</td>
</tr>
</tbody>
</table>
<p>上面的具体查询，对应的stage组合是<code>Fetch+ixscan</code>，也就是说会根据索引查询</p>
<p>虽然mongodb会根据查询来选择索引，但并不能保证都能选到最优的索引；这种时候我们可以通过<code>hint</code>来强制指定索引，举例如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 4. 删除索引</h3>
<p>一般有下面两种删除方式，全量删除和指定索引删除</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>请注意，指定索引名删除时，如果不确定索引名是啥，可以通过<code>getIndexes()</code>来查看</p>
<h3> 5. 文档自动删除</h3>
<p>在创建索引的时候，其中有一个参数比较有意思，有必要单独拿出来说明一下，<code>expireAfterSeconds</code> 设置文档的生存时间</p>
<p>使用它有几个潜规则：</p>
<ul>
<li>索引字段为Date类型</li>
<li>单字段索引，不支持混合索引</li>
<li>非立即执行</li>
</ul>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后过一段时间（并不一定10:55分的时候会删除）再去查询，会发现插入的文档被删除了</p>
<p>利用这种特性，在mongodb中存一些需要定时删除的数据，相比较我们常用的mysql而言，还是有很大优势的</p>
<h3> 6. 覆盖索引</h3>
<p>覆盖索引的概念有些类似mysql中的不回表查询的case，直接查询索引，就可以返回所需要的字段了</p>
<p>比如在前面的case中，我只查询name字段，可以走覆盖索引；但是返回除了name，还有<code>_id</code>，那么就不能了</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>注意：所有索引字段是一个数组时，不能使用覆盖索引</strong></p>
<hr>
<p>微信搜 <strong>楼仔</strong> 或扫描下方二维码关注楼仔的原创公众号，回复 <strong>110</strong> 即可免费领取 10 本面试必刷八股文。 <img src="https://files.mdnice.com/user/13837/4b47ac79-8256-47cf-ac1a-036729635246.png" alt="" loading="lazy"></p>
<hr>
<h1> 第二卷：Spring整合MongoDB</h1>
<p>文档数据库SpringBoot的系列教程，彻底扫平阻碍我们CURD的路障，适用于对Mongodb不了解或了解不够的小伙伴</p>
<h2> 基本环境搭建与使用</h2>
<p>SpringBoot结合mongodb进行业务开发，也属于比较基本的需求了，本文为mongo系列的基本篇，主要就是环境搭建、工程的配置设置相关</p>
<!-- more -->
<h3> 1. 环境搭建</h3>
<p>正式开始之前，第一步就是需要安装Mongo的环境了，因为环境的安装和我们spring的主题没有太大的关系，因此我们选择最简单的使用姿势：直接用docker来安装mongo来使用</p>
<p>下面的安装过程都是mac环境，其他操作系统可以直接安装mongodb，移步相关教程</p>
<h4> 1.1 docker 安装</h4>
<p>可以直接到官网进行下载安装，但是对系统版本有要求，所以需要使用<code>Docker ToolBox</code>，实际试过之后，感觉不太好用，实际上是将docker安装到虚拟机中了，下面直接使用<code>brew</code>命令进行安装</p>
<p><strong>安装命令</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>执行完毕之后，会多一个应用名为 <code>docker</code>， 双击运行，输入密码等即可</p>
<h4> 1.2 mongo 安装使用</h4>
<p>直接使用官方的mongo镜像即可，然后绑定端口映射，就可以在宿主机中使用mongo</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面完毕之后，可以在宿主机进行连接测试，判断是否安装成功</p>
<h3> 2. SpringBoot工程配置</h3>
<h4> 2.1 pom依赖</h4>
<p>整个框架选择的是spring-boot，所有spring这一套相关的pom配置少不了，我们主要需要注意的包就是<code>spring-boot-starter-data-mongodb</code></p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 2.2 配置文件</h4>
<p>配置文件如下，主要就是连接mongo的url</p>
<div class="language-properties line-numbers-mode" data-ext="properties"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>通过上面的实例，也知道格式如下:</p>
<p><code>mongodb://用户名:密码@host:port/dbNmae?参数</code></p>
<ul>
<li>当没有用户名和密码时，可以省略掉中间的 <code>root:root@</code>；</li>
<li>当需要认证时，请格外注意
<ul>
<li>mongodb新版的验证方式改成了<code>SCRAM-SHA-1</code>，所以参数中一定一定一定得加上
<ul>
<li><code>?authSource=admin&amp;authMechanism=SCRAM-SHA-1</code></li>
</ul>
</li>
<li>如果将mongodb的验证方式改成了<code>MONGODB-CR</code>, 则上面的可以不需要</li>
</ul>
</li>
</ul>
<h4> 2.3 测试使用</h4>
<p>写一个简单的测试类，看下mongodb是否连接成功，是否可以正常操作</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面提供了两个方法，新增和查询，简单的使用姿势如</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后开始执行，查看输出，结果演示如下</p>
<figure><img src="https://hhui.top/imgs/181213/00.gif" alt="gif.gif" tabindex="0" loading="lazy"><figcaption>gif.gif</figcaption></figure>
<h4> 2.4 说明</h4>
<p>最后针对认证的问题，需要额外提一句，开始测试的时候，使用的配置如下</p>
<div class="language-properties line-numbers-mode" data-ext="properties"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然而因为mongo采用的是SHA-1加密方式，所以始终验证不通过；然后查了一下，各种让改mongo的验证版本，改回去用CR的方式；但明显这种并不是一种好的解决方式，既然新的版本选择了新的加密方式，总有他的理由，所以应该改的还是spring的使用姿势；目前还没找到匹配上面这种配置方式的解决方案；</p>
<p>本文选择的是用url的方式指定加密方式来解决这个问题，当然研究下后面这种方式内部实现，应该就能知道前面的可以怎么解决，这点记下来，后续再开坑填</p>
<h3> 3. 其他</h3>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">spring-boot-demo</a></li>
<li>module: <a href="https://github.com/liuyueyi/spring-boot-demo/blob/master/spring-boot/110-mongo-basic/README.md" target="_blank" rel="noopener noreferrer">110-mongo-basic</a></li>
</ul>
<hr>
<p>微信搜 <strong>楼仔</strong> 或扫描下方二维码关注楼仔的原创公众号，回复 <strong>110</strong> 即可免费领取 10 本面试必刷八股文。 <img src="https://files.mdnice.com/user/13837/4b47ac79-8256-47cf-ac1a-036729635246.png" alt="" loading="lazy"></p>
<hr>
<h2> 查询基本使用姿势</h2>
<p>学习一个新的数据库，一般怎么下手呢？基本的CURD没跑了，当可以熟练的增、删、改、查一个数据库时，可以说对这个数据库算是入门了，如果需要更进一步的话，就需要了解下数据库的特性，比如索引、事物、锁、分布式支持等</p>
<p>本篇博文为mongodb的入门篇，将介绍一下基本的查询操作，在Spring中可以怎么玩</p>
<!-- more -->
<h3> 1. 基本使用</h3>
<h4> 1.0. 环境准备</h4>
<p>在正式开始之前，先准备好环境，搭建好工程，对于这一步的详细信息，可以参考博文: <a href="http://spring.hhui.top/spring-blog/2018/12/13/181213-SpringBoot%E9%AB%98%E7%BA%A7%E7%AF%87MongoDB%E4%B9%8B%E5%9F%BA%E6%9C%AC%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8/" target="_blank" rel="noopener noreferrer">181213-SpringBoot高级篇MongoDB之基本环境搭建与使用</a></p>
<p>接下来，在一个集合中，准备一下数据如下，我们的基本查询范围就是这些数据</p>
<figure><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy9kWVY5Y0FXNjVrYTJnZHpOWjZKaWFpYmljOHhaNGliRHJVS1V1N3oxc1FoaWFKeHBieTRwMk1uSmtpY2ljVDIyOVVpYXNMZWlid3FmaWJTZHlKTnprWVdhUE1iTmtvQkEvNjQwP3d4X2ZtdD1qcGVn?x-oss-process=image/format,png" alt="data" tabindex="0" loading="lazy"><figcaption>data</figcaption></figure>
<h4> 1.1. 根据字段进行查询</h4>
<p>最常见的查询场景，比如我们根据查询<code>user=一灰灰blog</code>的数据，这里主要会使用<code>Query</code> + <code>Criteria</code> 来完成</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面是一个实际的case，从中可以知道一般的查询方式为:</p>
<ul>
<li><code>Criteria.where(xxx).is(xxx)</code>来指定具体的查询条件</li>
<li>封装Query对象 <code>new Query(criteria)</code></li>
<li>借助<code>mongoTemplate</code>执行查询 <code>mongoTemplate.findOne(query, resultType, collectionName)</code></li>
</ul>
<p>其中findOne表示只获取一条满足条件的数据；find则会将所有满足条件的返回；上面执行之后，输出结果如</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h4> 1.2. and多条件查询</h4>
<p>前面是只有一个条件满足，现在如果是要求同时满足多个条件，则利用<code>org.springframework.data.mongodb.core.query.Criteria#and</code>来斜街多个查询条件</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4> 1.3. or或查询</h4>
<p>and对应的就是or，多个条件中只要一个满足即可，这个与and的使用有些区别, 借助<code>org.springframework.data.mongodb.core.query.Criteria#orOperator</code>来实现，传参为多个<code>Criteria</code>对象，其中每一个表示一种查询条件</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>执行后输出结果为</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h4> 1.4. in查询</h4>
<p>标准的in查询case</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4> 1.5. 数值比较</h4>
<p>数值的比较大小，主要使用的是 <code>get</code>, <code>gt</code>, <code>lt</code>, <code>let</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 1.6. 正则查询</h4>
<p>牛逼高大上的功能</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4> 1.7. 查询总数</h4>
<p>统计常用，这个主要利用的是<code>mongoTemplate.count</code>方法</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4> 1.8. 分组查询</h4>
<p>这个对应的是mysql中的group查询，但是在mongodb中，更多的是通过聚合查询，可以完成很多类似的操作，下面借助聚合，来看一下分组计算总数怎么玩</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意下，这里用<code>Aggregation</code>而不是前面的<code>Query</code>和<code>Criteria</code>，输出如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4> 1.9. 排序</h4>
<p>sort，比较常见的了，在mongodb中有个有意思的地方在于某个字段，document中并不一定存在，这是会怎样呢？</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果如下，对于没有这个字段的document也被查出来了</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4> 1.10. 分页</h4>
<p>数据量多的时候，分页查询比较常见，用得多就是limit和skip了</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果表明，limit用来限制查询多少条数据，skip则表示跳过前面多少条数据</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h4> 1.11. 小结</h4>
<p>上面给出的一些常见的查询姿势，当然并不全面，比如我们如果需要查询document中的部分字段怎么办？比如document内部结果比较复杂，有内嵌的对象或者数组时，嵌套查询可以怎么玩？索引什么的又可以怎么利用起来，从而优化查询效率？如何通过传说中自动生成的<code>_id</code>来获取文档创建的时间戳？</p>
<p>先留着这些疑问，后面再补上</p>
<h3> 2. 其他</h3>
<h3> 2.0. 项目</h3>
<ul>
<li>
<p>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">spring-boot-demo</a></p>
</li>
<li>
<p>module: <a href="https://github.com/liuyueyi/spring-boot-demo/blob/master/spring-boot/111-mongo-template" target="_blank" rel="noopener noreferrer">mongo-template</a></p>
</li>
<li>
<p>相关博文: <a href="http://spring.hhui.top/spring-blog/2018/12/13/181213-SpringBoot%E9%AB%98%E7%BA%A7%E7%AF%87MongoDB%E4%B9%8B%E5%9F%BA%E6%9C%AC%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8/" target="_blank" rel="noopener noreferrer">181213-SpringBoot高级篇MongoDB之基本环境搭建与使用</a></p>
</li>
</ul>
<h2> 新增文档使用姿势</h2>
<p>本篇博文为mongodb的curd中一篇，前面介绍简单的查询使用，这一篇重点则放在插入数据;</p>
<!-- more -->
<h3> 1. 基本使用</h3>
<p>首先是准备好基本环境，可以参考博文</p>
<ul>
<li><a href="http://spring.hhui.top/spring-blog/2018/12/13/181213-SpringBoot%E9%AB%98%E7%BA%A7%E7%AF%87MongoDB%E4%B9%8B%E5%9F%BA%E6%9C%AC%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8/" target="_blank" rel="noopener noreferrer">181213-SpringBoot高级篇MongoDB之基本环境搭建与使用</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2019/01/13/190113-SpringBoot%E9%AB%98%E7%BA%A7%E7%AF%87MongoDB%E4%B9%8B%E6%9F%A5%E8%AF%A2%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF/" target="_blank" rel="noopener noreferrer">190113-SpringBoot高级篇MongoDB之查询基本使用姿势</a></li>
</ul>
<h4> 1.1. 新增一条数据</h4>
<p>MongoDB一个基本数据称为document，和mysql不一样，没有强制约束哪些字段，可以随意的插入，下面是一个简单的插入演示</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用的关键地方为一行: <code>mongoTemplate.insert(object, COLLECTION_NAME);</code></p>
<ul>
<li>第一个参数为待插入的document</li>
<li>第二个参数为collection name （相当于mysql的table)</li>
</ul>
<p>执行后输出结果为如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4> 1.2. 批量插入</h4>
<p>一次插入多条记录，传集合进去即可</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>返回结果如下:</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4> 1.3. upsert，不存在才插入</h4>
<p>我们希望在插入之前，判断数据是否存在，如果不存在则插入；如果存在则更新；此时就可以采用upsert来使用，一般三个参数</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>第一个为查询条件，第二个为需要更新的字段，最后一个指定对应的collection，一个简单的实例如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果如下:</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 1.4. upsert，存在则更新</h4>
<p>前面的demo是演示不存在，那么存在数据呢?</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果如下，注意下面的输出数据的 <code>_id</code>，正视前面插入的那条数据，两个数据唯一的不同，就是age被修改了</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h4> 1.5. upsert，多条满足时</h4>
<p>如果query条件命中多条数据，怎么办？会修改几条数据呢？</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>根据实际输出进行查看，发现只有一条数据被修改；另外一条保持不变，结果如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 其他</h3>
<h4> 2.0. 项目</h4>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">spring-boot-demo</a></li>
<li>module: <a href="https://github.com/liuyueyi/spring-boot-demo/blob/master/spring-boot/111-mongo-template" target="_blank" rel="noopener noreferrer">mongo-template</a></li>
</ul>
<p><strong>相关博文</strong></p>
<ul>
<li><a href="http://spring.hhui.top/spring-blog/2018/12/13/181213-SpringBoot%E9%AB%98%E7%BA%A7%E7%AF%87MongoDB%E4%B9%8B%E5%9F%BA%E6%9C%AC%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8/" target="_blank" rel="noopener noreferrer">181213-SpringBoot高级篇MongoDB之基本环境搭建与使用</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2019/01/13/190113-SpringBoot%E9%AB%98%E7%BA%A7%E7%AF%87MongoDB%E4%B9%8B%E6%9F%A5%E8%AF%A2%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF/" target="_blank" rel="noopener noreferrer">190113-SpringBoot高级篇MongoDB之查询基本使用姿势</a></li>
</ul>
<hr>
<p>微信搜 <strong>楼仔</strong> 或扫描下方二维码关注楼仔的原创公众号，回复 <strong>110</strong> 即可免费领取 10 本面试必刷八股文。 <img src="https://files.mdnice.com/user/13837/4b47ac79-8256-47cf-ac1a-036729635246.png" alt="" loading="lazy"></p>
<hr>
<h2> 修改基本使用姿势</h2>
<p>本篇依然是MongoDB curd中的一篇，主要介绍document的更新，主要内容如下</p>
<ul>
<li>常见类型成员的修改</li>
<li>数组类型成员的增删改</li>
<li>document类型成员的增删改</li>
</ul>
<!-- more -->
<h3> 1. 基本使用</h3>
<p>首先是准备好基本环境，可以参考博文</p>
<ul>
<li><a href="http://spring.hhui.top/spring-blog/2018/12/13/181213-SpringBoot%E9%AB%98%E7%BA%A7%E7%AF%87MongoDB%E4%B9%8B%E5%9F%BA%E6%9C%AC%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8/" target="_blank" rel="noopener noreferrer">181213-SpringBoot高级篇MongoDB之基本环境搭建与使用</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2019/01/13/190113-SpringBoot%E9%AB%98%E7%BA%A7%E7%AF%87MongoDB%E4%B9%8B%E6%9F%A5%E8%AF%A2%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF/" target="_blank" rel="noopener noreferrer">190113-SpringBoot高级篇MongoDB之查询基本使用姿势</a></li>
</ul>
<p>在开始之前，先封装一个输出方法，用于打印修改后的record对象</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 1.1. 基本类型修改</h4>
<p>mongodb支持我们常见的各种基本类型，而MongoTemplate也封装了不少对应的修改方法，最基础的修改，主要是借助<code>Update</code>来实现</p>
<p>常见的使用姿势如:</p>
<h5> a. 基本使用姿势</h5>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果为：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5> b. 数字增加/减少</h5>
<p>数字类型修改，使用 <code>org.springframework.data.mongodb.core.query.Update#inc</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果为:</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5> c. 数字比较修改</h5>
<p>数字简单比较之后修改，如<code>org.springframework.data.mongodb.core.query.Update#max</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5> d. 乘法</h5>
<p>乘法运算, 主要使用 <code>org.springframework.data.mongodb.core.query.Update#multiply</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5> e. 日期修改</h5>
<p>日期修改, 如 <code>org.springframework.data.mongodb.core.query.Update#currentDate</code></p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 1.2. field修改</h4>
<p>不同于mysql的列表是固定的,mongodb的field可以增加、删除和重命名，下面分别看下三种case如何使用</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5> a. 重命名</h5>
<p>利用<code>org.springframework.data.mongodb.core.query.Update#rename</code>来实现重命名，需要注意的是，当修改的docuemnt没有这个成员时，相当于没有任务操作</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果如下，后面一个语句相当于没有执行</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5> b. 新增成员</h5>
<p>新增也是直接利用的<code>Update#set</code>方法，当存在时，修改；不存在时，添加</p>
<ul>
<li>另外提一下<code>setOnInsert</code>, 如果要更新的文档存在那么$setOnInsert操作符不做任何处理；</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果如下：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5> c. 删除成员</h5>
<p>删除document中的某个成员，借助<code>org.springframework.data.mongodb.core.query.Update#unset</code>， 正好与添加对上</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 1.3. 数组操作</h4>
<p>在MongoDB的document中，有两个有意思的类型，一个是数组，一个是document（即可以嵌套），这里则主要介绍下如何操作数组中的成员</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5> a. 添加到数组中</h5>
<p>在数组中新增一个数据，提供了两种方式，一个是<code>org.springframework.data.mongodb.core.query.Update#addToSet(java.lang.String, java.lang.Object)</code>，一个是<code>org.springframework.data.mongodb.core.query.Update#push(java.lang.String, java.lang.Object)</code>；两个的区别在于前者不能插入重复数据，后者可以</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5> b. 批量添加</h5>
<p>一次添加多个，借助<code>addToSet</code>的<code>each</code>来实现</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果:</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5> c. 删除</h5>
<p>借助pull来精确删除某个值</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出如下，注意对比，<code>2</code>没有了</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5> d. 修改</h5>
<p>修改，首先的问题是要定位，确定删除数组中某个下标的元素，这里借助了一个有意思的站位</p>
<ul>
<li>定位删除的数组元素方法： <code>arrayKey.index</code>
<ul>
<li><code>arrayKey</code> 是数组在docment中的名</li>
<li><code>index</code> 表示要删除的索引</li>
</ul>
</li>
</ul>
<p>一个实例如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果，注意后面的，如果数组个数小于待更新的索引位置，则前面补null</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 1.4. document操作</h4>
<p>内嵌文档，可以所是MongoDB的一个特色了，我们则来看下如何进行操作</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5> a. 添加</h5>
<p>借助前面的站位思想，就很好实现了，定位元素的方式采用</p>
<ul>
<li>docName.fieldName
<ul>
<li>docName 为内嵌文档在docunent中的fieldName</li>
<li>fieldName 为内嵌文档内部需要修改的fieldName</li>
</ul>
</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5> c. 修改</h5>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5> d. 删除</h5>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 其他</h3>
<h4> 2.0. 项目</h4>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">spring-boot-demo</a></li>
<li>子module：<a href="https://github.com/liuyueyi/spring-boot-demo/blob/master/spring-boot/111-mongo-template/README.md" target="_blank" rel="noopener noreferrer">111-mongo-template</a></li>
</ul>
<hr>
<p>微信搜 <strong>楼仔</strong> 或扫描下方二维码关注楼仔的原创公众号，回复 <strong>110</strong> 即可免费领取 10 本面试必刷八股文。 <img src="https://files.mdnice.com/user/13837/4b47ac79-8256-47cf-ac1a-036729635246.png" alt="" loading="lazy"></p>
<hr>
]]></content:encoded>
      <enclosure url="http://cdn.hhui.top/column/mongo_cover.png" type="image/png"/>
    </item>
    <item>
      <title>MySql系列教程</title>
      <link>https://liuyueyi.github.io/tutorial/db/mysql/</link>
      <guid>https://liuyueyi.github.io/tutorial/db/mysql/</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">MySql系列教程</source>
      <description>关系数据库MySql系列教程</description>
      <pubDate>Fri, 24 Feb 2023 02:18:35 GMT</pubDate>
      <content:encoded><![CDATA[<p>关系数据库MySql系列教程</p>
]]></content:encoded>
    </item>
    <item>
      <title>redis系列教程</title>
      <link>https://liuyueyi.github.io/tutorial/db/redis/</link>
      <guid>https://liuyueyi.github.io/tutorial/db/redis/</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">redis系列教程</source>
      <description>KV数据库Redis系列教程</description>
      <pubDate>Fri, 24 Feb 2023 02:18:35 GMT</pubDate>
      <content:encoded><![CDATA[<p>KV数据库Redis系列教程</p>
]]></content:encoded>
    </item>
    <item>
      <title>Java实战系列</title>
      <link>https://liuyueyi.github.io/tutorial/java/skill/Java%E5%AE%9E%E6%88%9836%E8%AE%B2.html</link>
      <guid>https://liuyueyi.github.io/tutorial/java/skill/Java%E5%AE%9E%E6%88%9836%E8%AE%B2.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">Java实战系列</source>
      <description>Java实战演练 实战小技巧，可用于实际编码过程中的 code snippets 带你再日常得编码中写得更加顺畅 本专栏中所有内容来自于笔者（一灰灰blog）的日常收集与分享，其中每一个主题都是针对真实的应用场景，通过提供切实可用与项目中的代码片段或者工具类，来给给位小伙伴提供帮助 实战1：字符串占位替换 字符串占位替换，相信没有小伙伴是陌生的，这东西可以说是伴随着我们所有的项目工程，编码过程；别不相信，如 String.format sql参数拼接的占位 log日志输出 接下来我们看一下在我们的日常工作生涯中，经常涉及到的几种占位替换方式</description>
      <pubDate>Fri, 24 Feb 2023 02:18:35 GMT</pubDate>
      <content:encoded><![CDATA[<figure><img src="http://cdn.hhui.top/column/java_cover.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h1> Java实战演练</h1>
<blockquote>
<p>实战小技巧，可用于实际编码过程中的 <code>code snippets</code> 带你再日常得编码中写得更加顺畅</p>
</blockquote>
<p>本专栏中所有内容来自于笔者（一灰灰blog）的日常收集与分享，其中每一个主题都是针对真实的应用场景，通过提供切实可用与项目中的代码片段或者工具类，来给给位小伙伴提供帮助</p>
<hr>
<h1> 实战1：字符串占位替换</h1>
<p>字符串占位替换，相信没有小伙伴是陌生的，这东西可以说是伴随着我们所有的项目工程，编码过程；别不相信，如</p>
<ul>
<li>String.format</li>
<li>sql参数拼接的占位</li>
<li>log日志输出</li>
</ul>
<p>接下来我们看一下在我们的日常工作生涯中，经常涉及到的几种占位替换方式</p>
<!-- more -->
<h2> 1. String.format</h2>
<p>这种可以说是最原始最基础的方式了，基本上在最开始学习java这门语言的时候就会涉及到，语法也比较简单</p>
<p>举例如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>使用<code>%</code>来表示占位，后面跟上不同的标识符，用于限定这个占位处的参数类型</p>
<p>这种使用姿势，由jdk原生提供支持，下表为不同的转换符对应的说明</p>
<table>
<thead>
<tr>
<th>转换符</th>
<th>说明</th>
<th>参数实例</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>%s</code></td>
<td>字符串替换</td>
<td>"一灰灰"</td>
</tr>
<tr>
<td><code>%c</code></td>
<td>字符类型</td>
<td>'a'</td>
</tr>
<tr>
<td><code>%b</code></td>
<td>布尔类型</td>
<td>true/false</td>
</tr>
<tr>
<td><code>%d</code></td>
<td>整数，十进制</td>
<td>10</td>
</tr>
<tr>
<td><code>%x</code></td>
<td>整数，十六进制</td>
<td>0x12</td>
</tr>
<tr>
<td><code>%o</code></td>
<td>整数，八进制</td>
<td>012</td>
</tr>
<tr>
<td><code>%f</code></td>
<td>浮点</td>
<td>0.12f</td>
</tr>
<tr>
<td><code>%e</code></td>
<td>指数</td>
<td>2e2</td>
</tr>
<tr>
<td><code>%g</code></td>
<td>通用浮点型</td>
<td></td>
</tr>
<tr>
<td><code>%h</code></td>
<td>散列</td>
<td></td>
</tr>
<tr>
<td><code>%%</code></td>
<td>百分比</td>
<td></td>
</tr>
<tr>
<td><code>%n</code></td>
<td>换行</td>
<td></td>
</tr>
<tr>
<td><code>%tx</code></td>
<td>日期与时间类型（x代表不同的日期与时间转换符</td>
<td></td>
</tr>
</tbody>
</table>
<p>虽然上面表中列出了很多，但实际使用时，<code>%s</code>, <code>%d</code>, <code>%f</code> 这三个就足以应付绝大部分的场景了；使用姿势和上面的实例参不多，第一个参数为字符串模板，后面的可变参数为待替换的值</p>
<p>下面是在实际使用过程中的注意事项</p>
<h3> 1.1 类型不匹配</h3>
<p>上面的表中介绍了不同的转换符，要求的参数类型，如果没有对应上，会怎样</p>
<p><strong><code>%s</code>，传入非字符串类型</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>也就是说，<code>%s</code>的占位标记，传参如果不是String类型，那么实际替换的是 <code>arg.toString()</code> (所以数组输出的是地址，而list输出了内容)</p>
<p><strong><code>%d</code>，传入非整数</strong></p>
<p>与字符串的不一样的是，如果我们定义要求替换的参数类型为整数，那么传参不是整数，就会抛异常</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这两个，一个传入的参数为浮点，一个传入的是字符串，在实际替换的时候，可不会调用<code>Integer.valufOf(String.valueOf(xxx))</code>来强转，而是采用更直接的方式，抛异常</p>
<p>关键的提示信息如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>因此在实际使用这种方式进行替换时，推荐选择 <code>%s</code>，毕竟兼容性更好</p>
<h3> 1.2 参数个数不匹配</h3>
<p>我们会注意到,<code>String.format</code>接收的参数是不定长的，那么就可能存在字符串模板中预留的占位与实际传入的参数个数不匹配的场景，那么出现这种场景时，会怎样</p>
<p><strong>参数缺少</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面的例子中，模板要求两个，实际只传入一个参数，会直接抛异常<code>MissingFormatArgumentException</code></p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>参数过多</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>执行正常，多余的参数不会被替换</p>
<p>因此，我们在使用<code>String.format</code>进行字符串替换时，请确保传参不要少于实际定义的参数个数；多了还好，少了就会抛异常</p>
<h2> 2. MessageFormat</h2>
<p>上面介绍的String.format虽说简单好用，但我们用多之后，自然会遇到，一个参数，需要替换模板中多个占位的场景，针对这种场景，更友好的方式是<code>MessageFormat</code>，这个也是jdk原生提供的</p>
<p>我们来简单看一下它的使用姿势</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>使用<code>{数字}</code>来表示占位，其中数字对应的是传参的下标，因此当一个参数需要复用时，使用MessageFormat就可以比较简单的实现了，上面就是一个实例，替换之后的字符串为</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>接下来说一下它使用时的注意事项</p>
<h3> 2.1 {}成对出现</h3>
<p>如果字符串中，只出现一个<code>{</code>，而没有配套的<code>}</code>，会抛异常</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>注意上面两种case，上面一个是有<code>}</code>而缺少<code>{</code>，这样是没有问题的；而下面那个则会抛异常</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>如果字符串中却是希望输出<code>{</code>，可以使用单引号来处理</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 2.2 单引号</h3>
<p>上面提到需要转移时，可以用单引号进行处理，在字符串模板的定义中，如果有单引号，需要各位注意</p>
<p><strong>只有一个单引号，会导致后面所有占位都不生效</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面这个输出结果可能和我们实际希望的不一致</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>要解决上面这个，就是使用两个单引号</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这样输出的就是我们预期的</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 2.3 序号省略</h3>
<p>上面的定义中，已经明确要求我们在<code>{}</code>中指定参数的序号，如果模板中没有指定会怎样?</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>直接抛异常</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2> 3. 小结</h2>
<p>本文介绍的实战小技巧属于是jdk原生提供的两种实现字符串占位替换的方式，除了这两个之外，我们日常开发中还会遇到其他的占位替换方式</p>
<p>比如sql的<code>?</code>替换，mybatis中sql参数组装使用<code>${paramName}</code>，或者logback日志输出中的<code>{}</code>来表示占位，spring的@Value注解声明的配置注入方式<code>${name:defaultValue}</code>，这些也都属于占位替换的范畴，那么它们又是怎么实现的呢？</p>
<p>微信搜 <strong>楼仔</strong> 或扫描下方二维码关注楼仔的原创公众号，回复 <strong>110</strong> 即可免费领取 10 本面试必刷八股文。
<img src="https://files.mdnice.com/user/13837/4b47ac79-8256-47cf-ac1a-036729635246.png" alt="" loading="lazy"></p>
<hr>
<h1> 实战2：数组与list互转</h1>
<p>这个考题比较常见，也比较简单，难道就这也有什么可以说到的门路不成？</p>
<p>接下来本文好好的说一说它的几种实现姿势，总有一款你喜欢的</p>
<h2> 1.数组转List</h2>
<h3> 1.1. Array.asList</h3>
<p>这个考题太简单了，直接使用<code>Array.asList</code>不就完事了么，比如</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>数组转list，so easy!!!</p>
<p>真的就这么简单么？？？</p>
<p>且看下面这一段代码</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>直接抛出了异常<code>java.lang.UnsupportedOperationException</code></p>
<p>有兴趣的小伙伴可以看一下源码实现方式，通过<code>Arrays.asList</code>创建的List，虽说也命名是<code>ArrayList</code>，但是它的全路径为 <code>java.util.Arrays.ArrayList</code>， 不支持<code>add</code>, <code>remove</code>等操作（所以下次再有面试官问ArrayList的知识点时，就可以反问一句，老哥你指的是哪个ArrayList😝，逼格是不是立马拉起来）</p>
<p><strong>知识点</strong></p>
<ul>
<li>通过<code>Arrays.asList</code>创建的列表，不允许新增，删除元素；但是可以更新列表中元素的值</li>
</ul>
<h3> 1.2. new ArrayList</h3>
<p>上面的数组转list方式虽然是最简单的，但不一定是合适的，特别是当我们可能对转换后的list进行操作时，可能埋坑（而且这种坑还非常隐晦，代码层面上很难发现）</p>
<p>为了减少在代码里面下毒的可能性，不妨使用下面这种方式<code>new ArrayList&lt;&gt;(Arrays.asList(ary))</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过上面这种方式创建的List，就是我们熟知的<code>ArrayList</code>了</p>
<p><strong>避雷预警</strong></p>
<p>看到上面这个使用姿势，就很容易想到一个常见的踩雷点，比如我们的应用中，有一个全局共享的配置列表，张三需要拿id为奇数的配置，李四拿id为偶数的配置，然后他们都是这么做的</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>然后跑了一次之后发现这个全局的列表清空了，这就是典型的没有做好资源隔离的case了，针对这种场景，要么是限制使用方，直接针对全局的资源进行修改，要么就是使用方拿到的是一个隔离的备份</p>
<p><strong>禁止修改：</strong></p>
<ul>
<li>使用不可变的容器，如前面提到的<code>java.util.Arrays.ArrayList</code> ()</li>
<li>使用<code>Collections.unmodifiableList</code>创建</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>列表拷贝</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>（上面这种属于深拷贝的实现，具体可以看一下jdk的源码实现）</p>
<h3> 1.3. Collections.addAll</h3>
<p>第三种方式借助jdk提供的容器工具类<code>Collections</code>来实现</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>原则上是比较推荐这种方式来实现的，至于为啥？看下源码实现</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码的实现是不是非常眼熟，如果让我们自己来写，也差不多会写成这样吧，简单直观高效，完美</p>
<h2> 2. 列表转数组</h2>
<p>不同于数组转列表的几种玩法，列表转数组就简单多了，直接调用<code>List.toArray</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 3. 小结</h2>
<p>今天的博文主题是数组与列表的互转，虽说题目简单，但是实现方式也是多种，需要搞清楚它们之间的本质区别，一不小心就可能采坑，而最简单的地方掉坑里，往往是最难发现和爬出来的</p>
<p>核心知识点小结如下</p>
<p><strong>数组转list：</strong></p>
<ul>
<li><code>Arrays.asList(xxx)</code>：创建的是不可变列表，不能删除和新增元素</li>
<li><code>new ArrayList&lt;&gt;(Arrays.asList(xxx)</code>: 相当于用列表创建列表，属于深拷贝的一种表现，获取到的列表支持新增、删除</li>
<li>推荐写法 <code>Collections.addAll()</code></li>
</ul>
<p><strong>列表转数组</strong></p>
<ul>
<li><code>list.toArray</code>: 如果需要指定数组类型，则传参指定</li>
</ul>
<hr>
<p>微信搜 <strong>楼仔</strong> 或扫描下方二维码关注楼仔的原创公众号，回复 <strong>110</strong> 即可免费领取 10 本面试必刷八股文。
<img src="https://files.mdnice.com/user/13837/4b47ac79-8256-47cf-ac1a-036729635246.png" alt="" loading="lazy"></p>
<hr>
<h1> 实战3：字符串与Collection的互转</h1>
<p>将字符串转换为List，这种业务场景可以说非常非常常见了，实现方式也比较简单</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>那么除了上面这种实现方式之外，还有其他的么？</p>
<!-- more -->
<h2> 1. 字符串转列表</h2>
<p>上面的实现姿势相当于字符串先转数组，然后在通过数组转列表，所以可以沿用前一篇字数组转list的几种方式</p>
<h3> 1.1. jdk支持方式</h3>
<p>借助<code>Collections.addAll</code>来实现</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这种方式适用于输出String的列表，如果我希望转成int列表呢？可以采用下面的方式</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>直接将数组转换为流，然后基于jdk8的特性，来实现转换为int列表</p>
<h3> 1.2. guava方式</h3>
<p>引入依赖</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>除了使用jdk原生的方式之外，借助guava也是非常常见的的case了，主要通过Splitter来实现，写法看起来非常秀</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>简单直接的一行代码搞定，如果我们希望是对输出的列表类型进行指定，也可以如下操作</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1.3. apache-commons</h3>
<p>引入依赖</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面流的方式就很赞了，但是注意它是有jdk版本限制的，虽说现在基本上都是1.8以上的环境进行开发，但也不排除有上古的代码，比如我现在手上的项目，spring还是3...</p>
<p>如果我们不能使用流的方式，那么有什么简单的方式来实现字符串转换为指定类型的列表么？</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这个实现也没有多优雅，不过这里有个编程小技巧可以学习，<code>new Transformer(){}</code>的传参方式，这种实现方式有点像回调的写法，虽然他们有本质的区别，此外就是jdk8之后的函数方法，就充分的体现这种设计思路，比如上面的换成jdk8的写法，直接简化为</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 2. 列表转字符串</h2>
<h3> 2.1. StringBuilder</h3>
<p>最容易想到的，直接使用StringBuilder来实现拼接</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意两点：</p>
<ul>
<li>使用StringBuilder而不是StringBuffer (why?)</li>
<li>注意最后一个拼接符号不要</li>
</ul>
<h3> 2.2. String.join</h3>
<p>一个更简单的实现方式如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当然上面这个的缺点就是列表必须是字符串列表，如果换成int列表，则不行</p>
<h3> 2.3. gauva</h3>
<p>guava也提供了列表转String的方式，同样很简单，而且还没有列表类型的限制</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 3. 小结</h2>
<p>本文的考题也非常常见，列表与字符串的互转，这里介绍了多种实现方式，有jdk原生的case（如果没有什么限制，推荐使用它， <code>String.split</code>除外，原因后面再说），如果有更高级的定制场景，如非String类型类表，则可以考虑guava的Splitter/Joinner来实现</p>
<p>在上面的实现中，也提供了几种有意思的编程方式</p>
<ul>
<li>Stream: 流，jdk8之后非常常见了</li>
<li>函数方法，回调写法case</li>
</ul>
<hr>
<p>微信搜 <strong>楼仔</strong> 或扫描下方二维码关注楼仔的原创公众号，回复 <strong>110</strong> 即可免费领取 10 本面试必刷八股文。
<img src="https://files.mdnice.com/user/13837/4b47ac79-8256-47cf-ac1a-036729635246.png" alt="" loading="lazy"></p>
<hr>
<h1> 实战4：字符串拼接</h1>
<p>相信没有小伙伴没有写过这样的代码，比如说现在让我们来实现一个字符串拼接的场景，怎样的实现才算是优雅的呢？</p>
<!-- more -->
<p>以将int数组转为英文逗号分隔的字符串为例进行演示</p>
<h2> 1. 实现</h2>
<h3> 1.1. 普通写法</h3>
<p>直接使用StringBuilder来拼接</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这种写法相信比较常见，相对来说不太顺眼的地方就是最后的toString，需要将最后的一个英文逗号给干掉</p>
<p>当然也可以用下面这种事前判断方式，避免最终的字符串截取</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1.2. StringJoiner</h3>
<p>上面实现中，干掉最后的一个分隔符实在不是很优雅，那么有更好一点的用法么，接下来看一下使用<code>StringJoiner</code>的方式</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>StringJoiner由jdk1.8提供，除了上面的基础玩法之外，结合jdk1.8带来的流操作方式，可以更简洁的实现</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>怎么样，上面这个实现比起前面的代码是不是要简洁多了，一行代码完事</p>
<h3> 1.3. guava joiner</h3>
<p>如果使用的jdk还不是1.8版本，不能使用上面的StringJoiner，没关系，还有guava的Joiner也可以实现</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>注意</strong></p>
<ul>
<li>接收的参数类型为: 数组/Iterable/Iterator/可变参数, 基本上可以覆盖我们日常的业务场景</li>
</ul>
<h2> 2. 小结</h2>
<p>本篇文章的主题是一个非常非常常见的字符串拼接，一般来讲，我们在做字符串拼接时，最麻烦的事情就是分隔符的处理，要么就是分隔符前置添加，每次循环都需要判断是否为开头；要么就是后置，最后取字符串时，干掉最后一个分隔符</p>
<p>本文提供了一个非常使用的方式<code>StringJoiner</code>，完全解决了上面的分隔符问题，它的使用有两种场景</p>
<ul>
<li>简单的容器转String：直接借助Stream的<code>Collectors.joining</code>来实现</li>
<li>for循环 （这种场景一般是for循环内的逻辑不仅仅包括字符串拼接，还包括其他的业务逻辑）： 循环内直接执行<code>stringJoiner.add()</code>添加</li>
</ul>
<p>对于jdk1.8及以上的版本，优先推荐使用上面说的StringJoiner来实现字符串拼接；至于jdk1.8之下，那么Guava就是一个不错的选择了，使用姿势也很很简单</p>
<hr>
<p>微信搜 <strong>楼仔</strong> 或扫描下方二维码关注楼仔的原创公众号，回复 <strong>110</strong> 即可免费领取 10 本面试必刷八股文。
<img src="https://files.mdnice.com/user/13837/4b47ac79-8256-47cf-ac1a-036729635246.png" alt="" loading="lazy"></p>
<hr>
<h1> 实战5：驼峰与下划线划转</h1>
<p>这个考题非常实用，特别是对于我们这些号称只需要CURD的后端开发来说，驼峰与下划线互转，这不是属于日常任务么；一般来讲db中的列名，要求是下划线格式（why? 阿里的数据库规范是这么定义的，就我感觉驼峰也没毛病），而java实体命名则是驼峰格式，所以它们之间的互转，就必然存在一个驼峰与下划线的互转</p>
<p>今天我们就来看一下，这两个的互转支持方式</p>
<!-- more -->
<h2> 1.实现</h2>
<h3> 1.1. Gauva</h3>
<p>一般来讲遇到这种普适性的问题，大部分都是有现成的工具类可以来直接使用的；在java生态中，说到好用的工具百宝箱，guava可以说是排列靠前的</p>
<p>接下来我们看一下如何使用Gauva来实现我们的目的</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这里主要使用的是<code>CaseFormat</code>来实现互转，guava的CaseFormat还提供了其他几种方式</p>
<p>上面这个虽然可以实现互转，但是如果我们有一个字符串为 <code>helloWorld_Case</code></p>
<p>将其他转换输出结果如下:</p>
<ul>
<li>下划线：<code>hello_world__case</code></li>
<li>驼峰：<code>helloworldCase</code></li>
</ul>
<p>这种输出，和标准的驼峰/下划线不太一样了（当然原因是由于输入也不标准）</p>
<h3> 1.2. Hutool</h3>
<p>除了上面的guava，hutool的使用也非常广，其中包含很多工具类，其<code>StrUtil</code>也提供了下划线与驼峰的互转支持</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>同样的我们再来看一下特殊的case</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果如下</p>
<ul>
<li>驼峰：<code>helloworldCase</code></li>
<li>下划线: <code>hello_world_case</code></li>
</ul>
<p>相比较上面的guava的场景，下划线这个貌似还行</p>
<h3> 1.3. 自定义实现</h3>
<p>接下来为了满足我们希望转换为标砖的驼峰/下划线输出方式的需求，我们自己来手撸一个</p>
<p><strong>下划线转驼峰:</strong></p>
<ul>
<li>关键点就是找到下划线，然后去掉它，下一个字符转大写续上（如果下一个还是下划线，那继续找下一个）</li>
</ul>
<p>根据上面这个思路来实现，如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>驼峰转下划线</strong></p>
<ul>
<li>关键点：大写的，则前位补一个下划线，当前字符转小写（如果前面已经是一个下划线了，那前面不补，直接转小写即可）</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>再次测试<code>helloWorld_Case</code>，输出如下</p>
<ul>
<li>驼峰：<code>helloWorldCase</code></li>
<li>下划线: <code>hello_world_case</code></li>
</ul>
<hr>
<p>微信搜 <strong>楼仔</strong> 或扫描下方二维码关注楼仔的原创公众号，回复 <strong>110</strong> 即可免费领取 10 本面试必刷八股文。
<img src="https://files.mdnice.com/user/13837/4b47ac79-8256-47cf-ac1a-036729635246.png" alt="" loading="lazy"></p>
<hr>
<h1> 实战6：枚举的特殊用法</h1>
<p>难道我们日常使用的枚举还有什么特殊的玩法不成？没错，还真有，本文主要介绍枚举的两种不那么常见的使用姿势</p>
<ul>
<li>利用枚举来实现单例模式</li>
<li>利用枚举来实现策略模式</li>
</ul>
<!-- more -->
<h2> 1. 使用场景</h2>
<h3> 1.1. 单例模式</h3>
<p>单例模式可以说是每个java开发者必须掌握的一个设计模式了，通常我们说它的实现，有饱汉式和饿汉式，也有经常说的双重判断，今天我们介绍另外一种方式，借助枚举来实现</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用枚举来实现单例模式非常非常简单，将类声明为枚举，内部只定义一个值即可</p>
<p>为什么可以这样做？</p>
<ul>
<li>枚举类不能<code>new</code>，因此保证单例</li>
<li>枚举类不能被继承</li>
<li>类不加载时，不会实例化</li>
</ul>
<p>使用枚举类创建的单例有一个好处，就是即使用反射，也无法打破它的单例性质，这是相比较于其他的实现方式的一个优点</p>
<p>那么，为啥在实际的项目中，不太常见这种写法？</p>
<ul>
<li>就我个人的一点认知（不保证准确）：这个与我们对枚举的认知有一定关系，在 《Effect in java》一书中，推荐我们使用这种方式来实现单例，但是在实际的项目开发中，我们更多的将枚举作为常量来使用，很少在枚举类中，添加复杂的业务逻辑</li>
</ul>
<h3> 1.2. 策略模式</h3>
<p>枚举除了很容易就实现上面的单例模式之外，还可以非常简单的实现策略模式</p>
<p>举一个简单的例子，我现在有一个接口，通过接受的参数，来决定最终的数据存在什么地方</p>
<p>如果按照正常的写法，可能就是很多的if/else</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这种写法虽说简单直观，但是当type类型一多了之后，这个if/else的代码行数就会很多很多了，而且看起来也不美观</p>
<p>接下来我们介绍一种利用枚举，基于策略模式的思想来解决上面的if/else问题</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的实现，主要利用的是<code>抽象类 + 枚举</code>来完成不同的策略具体实现</p>
<p>这种实现方式，相比较与前面的单例模式，还是更常见一点，虽然整体看下来没有什么难度，但是仔细看一看，会发现几个知识点</p>
<ul>
<li>抽象方法的使用 （在模板设计模式中，更能体会抽象方法的使用妙处）</li>
<li>利用枚举原生提供的<code>values()</code>，来实现遍历，找到目标</li>
</ul>
<h2> 2. 小结</h2>
<p>枚举虽然说是jdk原生提供的一个基础数据类型，但是它的使用姿势除了我们熟知的常量之外，还可以有效的运用在设计模式中，让我们的代码实现更优雅</p>
<p>比如使用枚举来实现单例模式，就不用再面对让人烦躁的双重判断/内部类的方式了</p>
<p>使用枚举的策略模式，也可以有效解决我们类中大量的if/else</p>
<hr>
<p>微信搜 <strong>楼仔</strong> 或扫描下方二维码关注楼仔的原创公众号，回复 <strong>110</strong> 即可免费领取 10 本面试必刷八股文。
<img src="https://files.mdnice.com/user/13837/4b47ac79-8256-47cf-ac1a-036729635246.png" alt="" loading="lazy"></p>
<hr>
<h1> 实战7：排序比较要慎重</h1>
<p>今天介绍的又是一个非常非常基本的基本知识点，为啥要单独拎出来？还是因为这个东西虽然非常简单，但是很容易掉坑，我已经遇到几次不严谨的写法了</p>
<!-- more -->
<h2> 1.排序</h2>
<h3> 1.1. Comparator 与 Comparable</h3>
<p>输掉排序，这两个接口好像不太容易绕过去，我们简单介绍下它们的区别</p>
<ul>
<li>如果你有一个类，希望支持同类型的自定义比较策略，可以实现接口<code>Compareable</code></li>
<li>如果某个类，没有实现<code>Compareable</code>接口，但是又希望对它进行比较，则可以自自定义一个<code>Comparator</code>，来定义这个类的比较规则</li>
</ul>
<p>通过一个简单的实例进行演示说明</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的实现中，重点关注 Demo类，实现了<code>Comparable</code>接口，因此可以直接调用<code>list.sort(null)</code>来进行比较；</p>
<p>但是如果我们现在需求改变了，希望实现针对demo类的age字段，进行升序排列，那么就可以利用<code>Comparator</code>来实现了</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1.2. 踩坑预告</h3>
<p>再上面的compare方法实现中，我们可以发现里面的实现有点不太美观，我们最终的目的是什么？</p>
<ul>
<li>如果左边的小于右边的，返回 -1</li>
<li>如果左边的大于右边的，返回 0</li>
<li>如果左边的等于右边的，返回 1</li>
</ul>
<p>基于此，经常可以看到的实现如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这个实现虽然简洁了，但是有一个致命的问题，可能溢出!!!</p>
<p>所以请注意，千万千万不要用上面这种写法</p>
<p>那么有没有更优雅的方式呢？</p>
<ul>
<li>有，使用基础类的<code>compare</code>方法</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这一段代码，再jdk1.8中，可以简化为下面一句</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>再扩展一下，如果希望倒排呢？</p>
<ul>
<li>第一种实现方式，调换位置</li>
<li>Jdk1.8方式，使用负数</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 2. 小结</h2>
<p>今天主要介绍的知识点是排序，再我们日常使用中，如果一个类希望支持排序，最好的方式就是让它实现<code>Comparable</code>接口，然后自定义排序方式</p>
<p>这样再容器中，如果需要排序，直接调用 <code>list.sort(null)</code> 或者 <code>CollectionUtils.sort(list)</code></p>
<p>如果目标类没有实现排序接口，或者希望使用另外一种排序方式，则通过自定义的<code>Comparator</code>来实现</p>
<p>最后关于<code>compare</code>方法的实现，设计到两个类的比较，这种最终的落脚地，多半是基础类型的比较</p>
<ul>
<li>o1 与 o2 比较，返回负数，则最终的结果中o1再前面（即升序排列）</li>
<li>不要直接使用 <code>o1-o2</code>会溢出，推荐使用 <code>Integer.compare(o1, o2);</code></li>
</ul>
<hr>
<p>微信搜 <strong>楼仔</strong> 或扫描下方二维码关注楼仔的原创公众号，回复 <strong>110</strong> 即可免费领取 10 本面试必刷八股文。
<img src="https://files.mdnice.com/user/13837/4b47ac79-8256-47cf-ac1a-036729635246.png" alt="" loading="lazy"></p>
<hr>
<h1> 实战8：容器的初始化大小指定</h1>
<p>容器可以说是我们日常开发中，除了基本对象之外，使用最多的类了，那么平时在使用的时候，是否有主意到良好编程习惯的大佬，在创建容器的时候，一般会设置size；那么他们为什么要这么干呢？是出于什么进行考量的呢？</p>
<p>今天我们将针对最常见的List/Map/Set三种容器类型的初始化值选择，进行说明</p>
<!-- more -->
<h2> 1. 容器初始化</h2>
<h3> 1.1. List</h3>
<p>列表，在我们日常使用过程中，会接触到下面几个</p>
<ul>
<li>ArrayList: 最常见的数组列表</li>
<li>LinkedList: 基于链表的列表</li>
<li>CopyOnWriteArrayList: 线程安全的数组列表</li>
</ul>
<p>接下来逐一进行说明</p>
<h4> 1.1.1 ArrayList</h4>
<p>现在以ArrayList为例，进行源码分析，当我们不指定列表大小，直接创建时</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面是内部实现，其中<code>elementData</code>就是列表中存数据的数组，初始化为默认数组</p>
<p>当我们第一次添加一个元素时，发现数组为默认值，会触发一次数组扩容，新的数组大小为10 （详情看源码）</p>
<p>其次就是数组的库容机制，通过源码/网上分享知识点可以知道，这个扩容的实现如下</p>
<ul>
<li>当新添加的元素，数组放不下时，实现扩容</li>
<li><code>扩容后的大小</code> = <code>扩容前大小</code> + max(<code>添加元素个数</code>, 1/2 * <code>扩容前大小</code>)</li>
</ul>
<p>基于上面的知识点，大致可以得出指定列表长度的好处</p>
<ul>
<li>节省空间（用多少申请多少，避免浪费）</li>
<li>减少扩容带来的拷贝（扩容一次就会带来一次数组拷贝，如果已知列表很大，结果还使用默认的10，这会产生很多可避免的扩容开销）</li>
</ul>
<h4> 1.1.2 LinkedList</h4>
<p>基于链表的列表，不同于上面的数组列表，它没有提供指定大小的构造方法，why?</p>
<p>因为链表本身的数据结构的特点，它就像糖葫芦一样，一个串一个，有数据，才有接上的可能，因此不需要指定大小</p>
<h4> 1.1.3 CopyOnWriteArrayList</h4>
<p>这个又非常有意思，它同样不能指定大小，但是原因与前面不同，主要在于它保证线程安全的实现方式</p>
<ul>
<li>每次新增/修改(加锁，保证单线程访问)，都是在拷贝的数组操作；完成之后，用新的替换旧的</li>
</ul>
<p>所以说，每次变更，都会存在数组拷贝，因此就没有必要提前指定数组大小</p>
<p>那么它的初始化每次都使用默认的么?</p>
<p>并不是这样的，当我们已知这个列表中的值时，推荐使用下面这种方式</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>将初始化值，放在一个普通的列表中，然后利用普通列表来初始化<code>CopyOnWriteArrayList</code></li>
</ul>
<h3> 1.2.Map</h3>
<p>常见的map容器使用，大多是下面几个</p>
<ul>
<li><code>HashMap</code></li>
<li><code>LinkedHashMap</code>: 有序的hashmap</li>
<li><code>TreeMap</code>: 有序的hashmap</li>
<li><code>ConcurrentHashMap</code>: 线程安全的map</li>
</ul>
<h4> 1.2.1 HashMap</h4>
<p>HashMap的底层数据结构是 <code>数组 + 链表/红黑树</code>，关于这个就不细说了</p>
<p>我们在初始化时，若不指定size，则数组的默认长度为8（请注意，Map的数组长度是2的倍数）</p>
<p>与ArrayList的扩容时机不一样的是，默认情况下，Map容量没满就会触发一次扩容</p>
<p>默认是数量达到 <code>size * 0.75</code>(0.75为扩容因子，可以在创建时修改)，就会触发一次扩容</p>
<p>why?</p>
<ul>
<li>主要是为了减少hash冲突</li>
</ul>
<p>同样的为了减少冲突，在初始化时，我们需要指定一个合适大小</p>
<p>比如我们</p>
<ul>
<li>已知map的数量为2，这个时候Map的大小选择因该是4</li>
<li>map数量为6，这个时候Map的大小选择是16</li>
</ul>
<p>有时候让我们自己来计算这个值，就有些麻烦了，这个时候，可以直接使用Guava的工具类来完成这个目的</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4> 1.2.2 LinkedHashMap</h4>
<p>初始化方式同上，略</p>
<h4> 1.2.3 ConcurrentHashMap</h4>
<p>初始化方式同上，略</p>
<h4> 1.2.4 TreeMap</h4>
<p>不同于上面几个的是treeMap，没有提供指定容器大小的构造方法</p>
<p>原因和前面说到的LinkedList有些类似，TreeMap的底层数据结构为Tree，所以新增数据是挂在树的一个节点下面，无需指定容量大小</p>
<h3> 1.3. Set</h3>
<p>集合用的最多应该就是<code>HashSet</code>了，底层结构模型复用，所以初始化大小指定与HashMap一致，也不需要多说</p>
<h2> 2. 小结</h2>
<p>今天这篇博文主要介绍的是三种常见的容器，在创建时，如何指定容量大小</p>
<p>首先明确一点，指定容量大小是为了</p>
<ul>
<li>减少扩容带来的额外开销</li>
<li>指定容量代销，可以减少无效的内存开销</li>
</ul>
<p>初始化值设置的关键点:</p>
<ul>
<li>ArrayList: 数据有多少个，初始化值就是多少</li>
<li>HashMap: 考虑到扩容因子，初始化大小 = <code>(size / 0.75 + 1)</code></li>
</ul>
<hr>
<p>微信搜 <strong>楼仔</strong> 或扫描下方二维码关注楼仔的原创公众号，回复 <strong>110</strong> 即可免费领取 10 本面试必刷八股文。
<img src="https://files.mdnice.com/user/13837/4b47ac79-8256-47cf-ac1a-036729635246.png" alt="" loading="lazy"></p>
<hr>
<h1> 实战9：List.subList使用不当StackOverflowError</h1>
<p>相信每个小伙伴都使用过<code>List.subList</code>来获取子列表，日常使用可能没啥问题，但是，请注意，它的使用，很可能一不小心就可能导致oom</p>
<!-- more -->
<h2> 1.实例说明</h2>
<h3> 1.1. subList</h3>
<p>场景复现，如基于list实现一个小顶堆</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这个执行完毕之后，居然出现栈溢出</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从实现来看，感觉也没啥问题啊， 我们稍微改一下上面的返回</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>再次执行，却没有异常；所以关键点就在与</p>
<ul>
<li>list.subList的使用上</li>
</ul>
<h3> 1.2. StackOverflowError分析</h3>
<p>接下来我们主要看一下<code>list.subList</code>的实现</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面返回的子列表是ArrayList的一个内部类<code>SubList</code>，它拥有一个指向父列表的成员<code>parrent</code></p>
<p>也就是说，从源头的ArryList开始，后面每次调用<code>subList</code>，这个指代关系就深一层</p>
<p>然后它的add方法也很有意思</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>重点看 <code>parent.add(parentOffset + index, e);</code>，添加的数据实际上是加在最源头的ArrayList上的，也就是说，虽然你现在拿到的SubList，只有几个元素，但是它对应的数组，可能超乎你的想象</p>
<p>当然上面这个异常主要是以为调用栈溢出（一直往上找parent）</p>
<p>这里反应的另外一个重要问题则是内存泄漏，就不继续说了</p>
<p>如果需要解决上面这个问题，改造方法如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 2. 小结</h2>
<p>jdk提供的原生方法虽然非常好用，但是在使用的时候，也需要多家注意，一不小心就可能掉进坑里；这也告诉我们多看源码是有必要的</p>
<p>最后一句关键知识点小结：</p>
<ul>
<li><code>ArrayList.subList</code> 返回的是内部类，与原ArrayList公用一个数组，只是限定了这个数组的起始下标和结束下标而已</li>
<li>在使用<code>subList</code>，请注意是否会存在内存泄露和栈溢出的问题</li>
</ul>
<hr>
<p>微信搜 <strong>楼仔</strong> 或扫描下方二维码关注楼仔的原创公众号，回复 <strong>110</strong> 即可免费领取 10 本面试必刷八股文。
<img src="https://files.mdnice.com/user/13837/4b47ac79-8256-47cf-ac1a-036729635246.png" alt="" loading="lazy"></p>
<hr>
<h1> 实战10：不可变容器</h1>
<p>不可变容器，看着好像在实际的业务中不怎么会用到，但实则不然，相信每个小伙伴都用过，或者看到过下面的代码</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>今天我们来介绍一下如何使用不可变容器，以及使用时的注意事项</p>
<!-- more -->
<h2> 1. 不可变容器</h2>
<h3> 1.1. JDK不可变容器</h3>
<p>java原生提供了一些不可变容器，它们最大的特点就是不支持添加、删除、修改容器内的值</p>
<p><code>Collections.emptyXxx</code>空容器</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面三个是最常用的几个了，通常当我们一个方法的返回结果定义为容器类型时，可能为了避免npe，在返回空容器时，会如此使用</p>
<p>除了上面这几个空的不可变容器之外，还有</p>
<ul>
<li><code>UnmodifiableList</code></li>
<li><code>UnmodifiableMap</code></li>
<li><code>UnmodifiableSet</code></li>
</ul>
<p>它们的使用姿势，通常是借助<code>Collections</code>来实现</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>如上面创建的List，就不支持set/remove等修改操作</p>
<p>使用不可变容容器，最大的好处就是基于它的不可修改特性，来实现公用，且不会被污染</p>
<ul>
<li>所以一个自然而然能想到的应用场景就是 <code>全局共享的配置</code></li>
</ul>
<h3> 1.2. Guava不可变容器</h3>
<p>上面是jdk提供的不可变容器，相比较与它们，在实际的项目中，使用Gauva的不可变容器的可能更多</p>
<ul>
<li><code>ImmutableXxx</code>；不可变容器</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面是最常见的三个容器对应的不可变型</p>
<p>从使用角度来看，初始化非常方便（相比较与jdk版而言）</p>
<h2> 2. 注意事项</h2>
<p>不可变容器虽好，但是使用不当也是很坑的；就我个人的一个观点</p>
<ul>
<li>如果是应用内的接口方法，容器传参，返回容器时，尽量不要使用不可变容器；因为你没办法保证别人拿到你的返回容器之后，会对它进行什么操作</li>
<li>如果是对外提供返回结果，特别是null的场景，使用不可变的空容器优于返回null</li>
<li>不可变容器，用于全局公用资源，共享配置参数；多线程的数据传递时，属于比较合适的场景</li>
</ul>
<hr>
<p>微信搜 <strong>楼仔</strong> 或扫描下方二维码关注楼仔的原创公众号，回复 <strong>110</strong> 即可免费领取 10 本面试必刷八股文。
<img src="https://files.mdnice.com/user/13837/4b47ac79-8256-47cf-ac1a-036729635246.png" alt="" loading="lazy"></p>
<hr>
<h1> 实战11：Map转换Map的几种方式</h1>
<p>在日常开发过程中，从一个Map转换为另外一个Map属于基本操作了，那么我们一般怎么去实现这种场景呢？有什么更简洁省事的方法么？</p>
<!-- more -->
<h2> 1.Map互转</h2>
<h3> 1.1 实例场景</h3>
<p>现在我们给一个简单的实例</p>
<p>希望将一个<code>Map&lt;String, Integer&gt;</code> 转换成 <code>Map&lt;String, String&gt;</code>，接下来看一下有哪些实现方式，以及各自的优缺点</p>
<p>首先提供一个创建Map的公共方法</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 1.1.1 基本的for循环转换</h4>
<p>这种方式是最容易想到和实现的，直接for循环来转换即可</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这种方式的优点很明显，实现容易，业务直观；</p>
<p>缺点就是可复用性较差，代码量多（相比于下面的case）</p>
<h4> 1.1.2 容器的流式使用</h4>
<p>在jdk1.8提供了流式操作，同样也可以采用这种方式来实现转换</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用stream的方式，优点就是链式，代码量少；缺点是相较于上面的阅读体验会差一些（当然这个取决于个人，有些小伙伴就更习惯看这种链式的代码）</p>
<h4> 1.1.3 Guava的trasform方式</h4>
<p>从代码层面来看，上面两个都不够直观，如果对guava熟悉的小伙伴对下面的代码可能就很熟悉了</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>核心逻辑就一行 <code>Maps.transformValues(map, String::valueOf)</code>，实现了我们的Map转换的诉求</p>
<p>很明显，这种方式的优点就是间接、直观；当然缺点就是需要引入guava，并且熟悉guava</p>
<h3> 1.2 最后一问，这篇文章目的是啥？</h3>
<p>既然我们的标题是实战小技巧，本文除了给大家介绍可以使用guava的<code>Maps.transformValues</code>来实现map转换之外，更主要的一个目的是如果让我们自己来实现一个工具类，来支持这个场景，应该怎么做？</p>
<p>直接提供一个转换方法？</p>
<p><strong>第一步：一个泛型的转换接口</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>定义上面这个接口之后，自然而然想到的缺点就是差一个value的转换实现</p>
<p><strong>第二步：value转换的定义</strong></p>
<p>这里采用Function接口思想来定义转换类</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>当然到这里我们就需要注意jdk1.8以下是不支持函数编程的，那么我们可以怎么来实现呢？</p>
<p>这个时候再对照一下guava的实现，然后再手撸一个，知识点就到手了</p>
<hr>
<p>微信搜 <strong>楼仔</strong> 或扫描下方二维码关注楼仔的原创公众号，回复 <strong>110</strong> 即可免费领取 10 本面试必刷八股文。
<img src="https://files.mdnice.com/user/13837/4b47ac79-8256-47cf-ac1a-036729635246.png" alt="" loading="lazy"></p>
<hr>
<h1> 实战12：巧用函数方法实现二维数组遍历</h1>
<p>对于数组遍历，基本上每个开发者都写过，遍历本身没什么好说的，但是当我们在遍历的过程中，有一些复杂的业务逻辑时，将会发现代码的层级会逐渐加深</p>
<!-- more -->
<p>如一个简单的case，将一个二维数组中的偶数找出来，保存到一个列表中</p>
<p>二维数组遍历，每个元素判断下是否为偶数，很容易就可以写出来，如</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这个实现没啥问题，但是这个代码的深度很容易就有三层了；当上面这个if中如果再有其他的判定条件，那么这个代码层级很容易增加了；二维数组还好，如果是三维数组，一个遍历就是三层；再加点逻辑，四层、五层不也是分分钟的事情么</p>
<p>那么问题来了，代码层级变多之后会有什么问题呢？</p>
<blockquote>
<p>只要代码能跑，又能有什么问题呢？！</p>
</blockquote>
<h2> 1. 函数方法消减代码层级</h2>
<p>由于多维数组的遍历层级天然就很深，那么有办法进行消减么？</p>
<p>要解决这个问题，关键是要抓住重点，遍历的重点是什么？获取每个元素的坐标！那么我们可以怎么办？</p>
<blockquote>
<p>定义一个函数方法，输入的就是函数坐标，在这个函数体中执行我们的遍历逻辑即可</p>
</blockquote>
<p>基于上面这个思路，相信我们可以很容易写一个二维的数组遍历通用方法</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>主要上面的实现，函数方法直接使用了JDK默认提供的BiConsumer，两个传参，都是int 数组下表；无返回值</p>
<p>那么上面这个怎么用呢？</p>
<p>同样是上面的例子，改一下之后，如</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>相比于前面的，貌似也就少了一层而已，好像也没什么了不起的</p>
<p>但是，当数组变为三维、四维、无维时，这个改动的写法层级都不会变哦</p>
<h2> 2. 遍历中return支持</h2>
<p>前面的实现对于正常的遍历没啥问题；但是当我们在遍历过程中，遇到某个条件直接返回，能支持么？</p>
<p>如一个遍历二维数组，我们希望判断其中是否有偶数，那么可以怎么整？</p>
<p>仔细琢磨一下我们的scan方法，希望可以支持return，主要的问题点就是这个函数方法执行之后，我该怎么知道是继续循环还是直接return呢?</p>
<p>很容易想到的就是执行逻辑中，添加一个额外的返回值，用于标记是否中断循环直接返回</p>
<p>基于此思路，我们可以实现一个简单的demo版本</p>
<p>定义一个函数方法，接受循环的下标 + 返回值</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>循环通用方法就可以相应的改成</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>基于上面这种思路，我们的实际使用姿势如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这个实现可满足我们的需求，唯一有个别扭的地方就是返回，总有点不太优雅；那么除了这种方式之外，还有其他的方式么？</p>
<p>既然考虑了返回值，那么再考虑一下传参呢？通过一个定义的参数来装在是否中断以及返回结果，是否可行呢？</p>
<p>基于这个思路，我们可以先定义一个参数包装类</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们希望通过Ans这个类来记录循环结果，其中tag=true，则表示不用继续循环了，直接返回ans结果吧</p>
<p>与之对应的方法改造及实例如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样看起来就比前面的要好一点了</p>
<p>实际跑一下，看下输出是否和我们预期的一致；</p>
<figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/546a699ae4334df4b6525332da4e5770~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure>
<p>微信搜 <strong>楼仔</strong> 或扫描下方二维码关注楼仔的原创公众号，回复 <strong>110</strong> 即可免费领取 10 本面试必刷八股文。
<img src="https://files.mdnice.com/user/13837/4b47ac79-8256-47cf-ac1a-036729635246.png" alt="" loading="lazy"></p>
<hr>
<h1> 实战13：List转Map List的几种姿势</h1>
<p>今天介绍一个实用的小知识点，如何将List转为<code>Map&lt;Object, List&lt;Object&gt;&gt;</code></p>
<!-- more -->
<h2> 1. 转换方式</h2>
<h3> 1.1. 基本写法</h3>
<p>最开始介绍的当然是最常见、最直观的写法，当然也是任何限制的写法</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对于jdk8+，上面for循环中的内容可以利用<code>Map.computeIfAbsent</code>来替换，具体写法如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当然既然已经是jdk1.8了，借助Stream的流处理，可以将上面的更一步进行简化，如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 1.2. 通用方法</h3>
<p>上面是针对特定的列表，针对业务进行开发转换，那么我们接下来尝试构建一个通用的工具类</p>
<p>这里我们主要借助的知识点就是泛型，一个重要的点就是如何获取Map中的key</p>
<p>对于jdk &lt; 1.8的写法，通过接口来定义实现key的获取姿势</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用demo如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来再看一下jdk1.8之后的写法，结合stream + 函数方法来实现</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其对应的使用方式则如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1.3. 工具类</h3>
<p>上一节介绍了基于泛型 + jdk8 Stream + 函数方法来实现通用转换工具类的实现姿势，接下来我们小结一下，输出一个适用于1.8之后的工具类</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1.4.guava HashMultimap扩展知识点</h3>
<p>最后再介绍一个扩展知识点，Gauva工具包中提供了一个<code>HashMultimap</code>的工具类，他的使用姿势和我们平常的Map并无差别，但是需要在注意的是，它的value是个集合</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>实际输出如下，验证了value实际上是个集合（on只有一个，如果是我们上面的工具类，会输出两个）</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><hr>
<p>微信搜 <strong>楼仔</strong> 或扫描下方二维码关注楼仔的原创公众号，回复 <strong>110</strong> 即可免费领取 10 本面试必刷八股文。
<img src="https://files.mdnice.com/user/13837/4b47ac79-8256-47cf-ac1a-036729635246.png" alt="" loading="lazy"></p>
<hr>
<h1> 实战14：分页遍历得两种实现策略</h1>
<p>在日常开发中，分页遍历迭代的场景可以说非常普遍了，比如扫表，每次捞100条数据，然后遍历这100条数据，依次执行某个业务逻辑；这100条执行完毕之后，再加载下一百条数据，直到扫描完毕</p>
<p>那么要实现上面这种分页迭代遍历的场景，我们可以怎么做呢</p>
<p>本文将介绍两种使用姿势</p>
<ul>
<li>常规的使用方法</li>
<li>借助Iterator的使用姿势</li>
</ul>
<!-- more -->
<h2> 1. 实现方式</h2>
<h3> 1.1. 数据查询模拟</h3>
<p>首先mock一个分页获取数据的逻辑，直接随机生成数据，并且控制最多返回三页</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1.2. 基本实现方式</h3>
<p>针对这种场景，最常见也是最简单直观的实现方式</p>
<ul>
<li>while死循环</li>
<li>内部遍历</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1.3. 迭代器实现方式</h3>
<p>接下来介绍一种更有意思的方式，借助迭代器的遍历特性来实现，首先自定义一个通用分页迭代器</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来借助上面的迭代器可以比较简单的实现我们的需求了</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>那么问题来了，上面这种使用方式比前面的优势体现再哪儿呢？</p>
<ul>
<li>双层循环改为单层循环</li>
</ul>
<p>接下来接入重点了，在jdk1.8引入了函数方法 + lambda之后，又提供了一个更简洁的使用姿势</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在jdk1.8及之后的使用姿势，一行代码即可</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这次对比效果是不是非常显眼了，从此以后分页迭代遍历再也不用冗长的双重迭代了</p>
<hr>
<p>微信搜 <strong>楼仔</strong> 或扫描下方二维码关注楼仔的原创公众号，回复 <strong>110</strong> 即可免费领取 10 本面试必刷八股文。
<img src="https://files.mdnice.com/user/13837/4b47ac79-8256-47cf-ac1a-036729635246.png" alt="" loading="lazy"></p>
<hr>
<h1> 实战15：数组拷贝</h1>
<p>说实话，在实际的业务开发中，基本上很少很少很少...会遇到数组拷贝的场景，甚至是我们一般都不怎么用数组，List它不香嘛，为啥要用数组</p>
<p>现在问题来了，要实现数组拷贝，怎么整？</p>
<!-- more -->
<h2> 1. 实现方式</h2>
<h3> 1.1. 基础写法</h3>
<p>最简单直接的写法，那就是新建一个数组，一个一个拷贝进去，不就完事了么</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1.2. 借用容器中转</h3>
<p>数组用起来有点麻烦，还是用容器舒爽，借助List来实现数组的拷贝，也就几行代码</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1.3. Array.copy</h3>
<p>上面这个有点绕得远了， 直接使用Array.copy</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1.4. System.arraycopy</h3>
<p>除了上面的，还可以使用更基础的用法</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果有看过jdk源码的小伙伴，上面这个用法应该不会陌生，特别是在容器类，这种数组拷贝的方式比比可见</p>
<p>参数说明:</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>src : 原数组</li>
<li>srcPos: 原数组用于拷贝的起始下标</li>
<li>dest: 拷贝后的数组</li>
<li>destPos: 目标数组的小标</li>
<li>length: 原数组中拷贝过去的数组长度</li>
</ul>
<p>从上面的描述也能看出来，这个方法不仅能实现数组拷贝，还可以实现数组内指定片段的拷贝</p>
<hr>
<p>微信搜 <strong>楼仔</strong> 或扫描下方二维码关注楼仔的原创公众号，回复 <strong>110</strong> 即可免费领取 10 本面试必刷八股文。
<img src="https://files.mdnice.com/user/13837/4b47ac79-8256-47cf-ac1a-036729635246.png" alt="" loading="lazy"></p>
<hr>
<h1> 实战16：判断类为基础类型or基础类型的包装类</h1>
<p>判断一个类是否为基础类型属于常规操作了，一般我们遇到这种case，要怎么处理呢？</p>
<p>一个一个的if/else判断? 还是其他的操作姿势？</p>
<!-- more -->
<h2> 1. 基础类型判断</h2>
<p>基础类型可以借助class类的<code>isPrimitive</code>方法来实现判定，使用姿势也简单</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>如果返回true，那么这个对象就是基本类型</p>
<ul>
<li>boolean</li>
<li>char</li>
<li>byte</li>
<li>short</li>
<li>int</li>
<li>long</li>
<li>float</li>
<li>double</li>
<li>void</li>
</ul>
<p>但是请注意，对于封装类型，比如Long，访问isPrimitive返回的是false</p>
<h2> 2. 封装类型判断</h2>
<p>那么封装类型可以怎么判断呢？难道一个一个的判定不成？</p>
<p>首先我们注意到<code>Class#isPrimitive</code>的方法签名，如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的注释中，提到了Boolean#Type之类的静态成员，也就是说包装类型，都有一个TYPE的静态成员</p>
<p>比如boolean的是这个</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>所以我们可以通过这个TYPE来判定，当前对象是否为封装对象</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果Class对象没有TYPE字段，那么就不是封装类，直接抛异常，返回false；当然这种通过异常的方式来判定，并不优雅；但是写法上比我们一个一个的if/else进行对比，要好得多了</p>
<hr>
<p>微信搜 <strong>楼仔</strong> 或扫描下方二维码关注楼仔的原创公众号，回复 <strong>110</strong> 即可免费领取 10 本面试必刷八股文。
<img src="https://files.mdnice.com/user/13837/4b47ac79-8256-47cf-ac1a-036729635246.png" alt="" loading="lazy"></p>
<hr>
<h1> 实战17：Java对象内存地址输出</h1>
<h2> 输出对象地址</h2>
<p>当一个对象没有重写<code>hascode</code>方法时，它返回的内存地址，当覆盖之后，我们有什么办法获取对象的内存地址么?</p>
<ul>
<li>使用 <code>System.identityHashCode()</code> 输出内存地址</li>
</ul>
<!-- more -->
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果如:</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这个有啥用？</p>
<ul>
<li>判断两个对象是否为同一个对象时，可以借用（我是在验证Mybatis的一级缓存的，判断返回的Entity是否确实是同一个的时候以此来判定的）</li>
</ul>
<hr>
<p>微信搜 <strong>楼仔</strong> 或扫描下方二维码关注楼仔的原创公众号，回复 <strong>110</strong> 即可免费领取 10 本面试必刷八股文。
<img src="https://files.mdnice.com/user/13837/4b47ac79-8256-47cf-ac1a-036729635246.png" alt="" loading="lazy"></p>
<hr>
<h1> 实战18：随机数生成怎么选</h1>
<p>随机数生成，java中有一个专门的Random类来实现，除此之外，使用<code>Math.random</code>的也比较多，接下来我们简单学习下，随机数的使用姿势</p>
<!-- more -->
<h2> 1.随机数生成</h2>
<h3> 1.1. Math.random</h3>
<p>jdk提供的基础工具类Math中封装一些常用的基础方法，比如我们今天的主题，生成随机数，使用姿势如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>使用起来比较简单，生成的是[0,1)之间的浮点数，但是不要以为它就真的只能生成0-1之间的随机数，举例如下</p>
<p>如果想利用它，生成一个 <code>[120, 500]</code> 这个区间的随机数，怎么整？</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>为啥上面的可行？</p>
<p>将上面的代码翻译一下，取值区间如</p>
<p><code>Math.random() * 381 + 120</code> 取值范围如下</p>
<ul>
<li>[0, 1) * 381 + 120</li>
<li>[0, 381) + 120</li>
<li>[120, 501)</li>
</ul>
<p>借助<code>Math.ceil</code>只取浮点数中的整数部分，这样我们的取值范围就是 [120, 500]了，和我们的预期一致</p>
<p>最后简单来看下，<code>Math.random()</code>是怎么实现随机数的</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>请注意上面的实现，原来底层依然使用的是<code>Random</code>类来生成随机数，而且上面这种写法属于非常经典的单例模式写法（不同于我们常见的双重判定方式，这种属于内部类的玩法，后面再说为啥可以这么用）</p>
<h3> 1.2. Random</h3>
<p>除了使用上面的Math.random来获取随机数之外，直接使用Random类也是很常见的case；接下来先简单看一下Random的使用姿势</p>
<p><strong>创建Random对象</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>生成随机数</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>伪随机高斯分布双精度数</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>随机类的nextGaussian()方法返回下一个伪随机数，即与随机数生成器序列的平均值为0.0，标准差为1.0的高斯(正态)分布双精度值</p>
<p>这种使用场景可能用在更专业的场景，至少我接触过的业务开发中，没有用过这个😂</p>
<h3> 1.3. Math.random 与 Random如何选</h3>
<p>上面两个都可以用来生成随机数，那么在实际使用的时候，怎么选择呢？</p>
<p>从前面的描述也可以知道，它们两没啥本质区别，底层都是用的Random类，在实际的运用过程中，如果我们希望可以场景复现，比如测试中奖概率的场景下，选择Random类，指定随机种子可能更友好；如果只是简单的随机数生成使用，那么选择<code>Math.random</code>即可，至少使用起来一行代码即可</p>
<hr>
<p>微信搜 <strong>楼仔</strong> 或扫描下方二维码关注楼仔的原创公众号，回复 <strong>110</strong> 即可免费领取 10 本面试必刷八股文。
<img src="https://files.mdnice.com/user/13837/4b47ac79-8256-47cf-ac1a-036729635246.png" alt="" loading="lazy"></p>
<hr>
<h1> 实战19：数字格式化</h1>
<p>数字的格式化场景，更多的是在日志输出、金额计算相关的领域中会用到，平常我们可能更多使用<code>String.format</code>来格式化，但是请注意，数字格式化是有一个<code>DecimalFormat</code>，专门来针对数字进行格式化</p>
<p>今天我们的知识点就是DecimalFormat来实现数字格式化</p>
<!-- more -->
<h2> 1. 格式化</h2>
<h3> 1.1. DecimalFormat使用说明</h3>
<p>对于DecimalFormat的使用比较简单，主要是借助两个占位<code>0</code>与<code>#</code>，区别在于当格式化的占位数，多余实际数的时候，占位<code>0</code>的场景下，会用前缀0来补齐；而<code>#</code>则不需要补齐</p>
<p>上面这个可能不太好理解，举例说明如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面两个都是只输出整数，但是输出结果不同，如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>简单来说，就是<code>0</code>，主要用于定长的输出，对于不足的，前缀补0</p>
<p><strong>整数#小数</strong></p>
<p>除了上面的基本姿势之外，更常见的是设置整数、小数的位数</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>百分比</strong></p>
<p>百分比的输出也属于常见的case，使用DecimalFormat就很简单</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>输出如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>科学计数</strong></p>
<p>非专业场景下，科学技术的可能性比较小</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>金钱样式输出</strong></p>
<p>金融相关的钱输出时，非常有意思的是每三位加一个逗号分隔，如果想实现这个效果，也可以很简单完成</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>嵌入模板输出</strong></p>
<p>格式化模板，除了基础的<code>000, ###</code>之外，还可以直接放在一个字符串中，实现类似<code>String.format</code>的效果</p>
<p>比如显示余额</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><hr>
<p>微信搜 <strong>楼仔</strong> 或扫描下方二维码关注楼仔的原创公众号，回复 <strong>110</strong> 即可免费领取 10 本面试必刷八股文。
<img src="https://files.mdnice.com/user/13837/4b47ac79-8256-47cf-ac1a-036729635246.png" alt="" loading="lazy"></p>
<hr>
<h1> 实战20：进制转换很简单</h1>
<p>进制转换，属于基本技能了，在java中要实现进制转换很简单，可以非常简单的实现，接下来我们来看下它的使用姿势</p>
<!-- more -->
<h2> 1. 进制转换</h2>
<h3> 1.1. toString实现进制转换</h3>
<p>Integer/Long#toString(int i, int radix) 可以将任一进制的整数，转换为其他任意进制的整数</p>
<ul>
<li>第一个参数：待转换的数字</li>
<li>第二个参数：转换后的进制位</li>
</ul>
<p><strong>十六进制转十进制</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>八进制转是十进制</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>八进制转二进制</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 1.2. 十进制转二进制</h3>
<p>除了使用上面的姿势之外，可以直接使用<code>toBinaryString</code>来实现转二进制</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1.3. 十进制转八进制</h3>
<p><code>Integer/Long#toOctalString</code>: 转八进制</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 1.4. 十进制转十六进制</h3>
<p><code>Integer/Long#toHexString</code>: 转十六进制</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><hr>
<p>微信搜 <strong>楼仔</strong> 或扫描下方二维码关注楼仔的原创公众号，回复 <strong>110</strong> 即可免费领取 10 本面试必刷八股文。
<img src="https://files.mdnice.com/user/13837/4b47ac79-8256-47cf-ac1a-036729635246.png" alt="" loading="lazy"></p>
<hr>
<h1> 实战21：Properties配置文件</h1>
<p>properties配置文件，相信各位小伙伴都不会太陌生，常用Spring的可能会经常看到它，虽说现在更推荐的是使用Yaml配置文件，但是properties配置文件的使用频率也不低</p>
<p>在jdk中有一个直接关连的类Properties，接下来我们来看一下它的用法</p>
<!-- more -->
<h2> 1. Properties配置类</h2>
<h3> 1.1. 配置文件</h3>
<p>properties文件的格式比较简单</p>
<ul>
<li><code>key = value</code>: 等号左边的为配置key，右边的为配置value（value值会去除前后的空格）</li>
<li><code>#</code>：以<code>#</code>来区分注释</li>
</ul>
<p>一个基础的配置文件如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1.2. 配置文件加载</h3>
<p>对于Properties配置文件，我们可以非常简单的借助<code>Properties</code>类，来实现配置的加载</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>直接使用<code>Properties#config</code>就可以读取配置文件内容，并赋值到java对象</p>
<p><strong>重点注意：</strong></p>
<p>重点看一下Properties类的继承关系，它的父类是Hashtable, 也就是说它的本质是Map对象</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1.3. Properties对象使用</h3>
<p>因为<code>Properties</code>是继承自Hashtable，而Hashtable是线程安全的Map容器，因此Properties也是线程安全的，同样的，在多线程并发获取配置的时候，它的性能表现也就不咋地了，why?</p>
<p>首先看一下配置获取</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面两个方法的使用频率很高，从签名上也很容易知道使用姿势；接下来需要看一下的为啥说并发效率很低</p>
<p>关键点就在第一个方法的<code>super.get()</code>，它对应的源码正是</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>方法签名上有<code>synchronized</code>，所以为啥说并发环境下的性能表现不会特别好也就知道原因了</p>
<p>除了获取配置之外，另外一个常用的就是更新配置</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 2. 小结</h2>
<p>本文介绍的知识点主要是properties配置文件的处理，使用同名的java类来操作；需要重点注意的是Properties类属于Hashtable的子类，同样属于容器的范畴</p>
<p>最后提一个扩展的问题，在SpringBoot的配置自动装载中，可以将配置内容自动装载到配置类中，简单来讲就是支持配置到java bean的映射，如果现在让我们来实现这个，可以怎么整？</p>
<hr>
<p>微信搜 <strong>楼仔</strong> 或扫描下方二维码关注楼仔的原创公众号，回复 <strong>110</strong> 即可免费领取 10 本面试必刷八股文。
<img src="https://files.mdnice.com/user/13837/4b47ac79-8256-47cf-ac1a-036729635246.png" alt="" loading="lazy"></p>
<hr>
<h1> 实战22：Properties配置文件自动装载JavaBean</h1>
<p>SpringBoot的配置自动装载，使用起来还是很舒爽的，可以非常简单的将properties配置文件的内容，填充到Java bean对象中，如果我们现在是一个脱离于Springboot框架的项目，想实现上面这个功能，可以怎么来做呢？</p>
<!-- more -->
<h2> 1.配置封装</h2>
<h3> 1.1. 配置文件自动装载</h3>
<p>前面介绍了Properties文件的读取以及基本使用姿势，通过上篇博文已知Properties类的本质是一个Map，所以我们需要干的就是将Map容器的值，赋值到JavaBean的成员属性中</p>
<p>要实现这个功能，自然而然会想到的就是利用反射（考虑到我们赋值的通常为标准的java bean，使用内省是个更好的选择）</p>
<p>接下来我们需要实现的也比较清晰了，第一步获取成员属性，两种方式</p>
<ul>
<li>内省: <code>BeanInfo bean = Introspector.getBeanInfo(clz); PropertyDescriptor[] propertyDescriptors = bean.getPropertyDescriptors();</code></li>
<li>反射: <code>Field[] fields = clz.getDeclaredFields();</code></li>
</ul>
<p>第二步遍历成员属性，进行赋值</p>
<ul>
<li>内省：借助前面获取的<code>PropertyDescriptor</code>对象，拿到set方法，进行赋值
<ul>
<li><code>descriptor.getWriteMethod().invoke(obj, value)</code></li>
</ul>
</li>
<li>反射：适应<code>Field.set</code>来赋值
<ul>
<li><code>field.set(obj, value);</code></li>
</ul>
</li>
</ul>
<p><strong>注意</strong></p>
<ul>
<li>上面的两种赋值方式，都要求我们传入的value对象类型与定义类型一直，否则会抛类型转换异常</li>
</ul>
<p>为了避免复杂的类型转换与判定，我们这里介绍下apache的<code>commons-beanutils</code>来实现属性拷贝</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来核心的实现逻辑如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意上面的实现，首先通过内省的方式获取所有的成员，然后进行遍历，借助<code>BeanUtils.setProperty</code>来实现属性值设置</p>
<p>这里面有两个知识点</p>
<ul>
<li><code>BeanUtil</code> 还是 <code>PropertyUtil</code>
<ul>
<li>它们两都有个设置属性的方法，但是BeanUtil支持简单类型的自动转换；而后者不行，要求类型完全一致</li>
</ul>
</li>
<li>非简单类型
<ul>
<li>对于非简单类型，上面采用了递归的调用方式来处理；请注意，这里并不完善，比如BigDecimal, Date, List, Map这些相对基础的类型，是不太适用的哦</li>
</ul>
</li>
</ul>
<h3> 1.2. 功能测试</h3>
<p>最后针对上面的实现功能，简单的测试一下，是否可行</p>
<p>配置文件<code>mail.properties</code></p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>两个Java Bean</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>转换测试类</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果如下：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><hr>
<p>微信搜 <strong>楼仔</strong> 或扫描下方二维码关注楼仔的原创公众号，回复 <strong>110</strong> 即可免费领取 10 本面试必刷八股文。
<img src="https://files.mdnice.com/user/13837/4b47ac79-8256-47cf-ac1a-036729635246.png" alt="" loading="lazy"></p>
<hr>
<h1> 实战23：基于引入包选择具体实现类</h1>
<p>最近遇到一个需求场景，开源的工具包，新增了一个高级特性，会依赖json序列化工具，来做一些特殊操作；但是，这个辅助功能并不是必须的，也就是说对于使用这个工具包的业务方而言，正常使用完全不需要json相关的功能；如果我强引用某个json工具，一是对于不适用高级特性的用户而言没有必要；二则是我引入的json工具极有可能与使用者的不一致，会增加使用者的成本</p>
<p>因此我希望这个工具包对外提供时，并不会引入具体的json工具依赖；也就是说maven依赖中的<code>&lt;scope&gt;</code>设置为<code>provided</code>；具体的json序列化的实现，则取决于调用方自身引入了什么json工具包</p>
<p>那么可以怎么实现上面这个方式呢？</p>
<!-- more -->
<h2> 1.实现方式</h2>
<h3> 1.1. 任务说明</h3>
<p>上面的简单的说了一下我们需要做的事情，接下来我们重点盘一下，我们到底是要干什么</p>
<p>核心诉求相对清晰</p>
<ol>
<li>不强引入某个json工具</li>
<li>若需要使用高级特性，则直接使用当前环境中已集成的json序列化工具；若没有提供，则抛异常，不支持</li>
</ol>
<p>对于上面这个场景，常年使用Spring的我们估计不会陌生，Spring集成了很多的第三方开源组件，根据具体的依赖来选择最终的实现，比如日志，可以是logback，也可以是log4j；比如redis操作，可以是jedis，也可以是lettuce</p>
<p>那么Spring是怎么实现的呢？</p>
<h3> 1.2.具体实现</h3>
<p>在Spring中有个注解名为<code>ConditionalOnClass</code>，表示当某个类存在时，才会干某些事情（如初始化bean对象）</p>
<p>它是怎么是实现的呢？（感兴趣的小伙伴可以搜索一下，或者重点关注下 <code>SpringBootCondition</code> 的实现）</p>
<p>这里且抛开Spring的实现姿势，我们采用传统的实现方式，直接判断是否有加载对应的类，来判断有没有引入相应的工具包</p>
<p>如需要判断是否引入了gson包，则判断ClassLoader是否有加载<code>com.google.gson.Gson</code>类</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这种实现方式就可以达到我们的效果了；接下来我们参考下Spring的ClassUtils实现，做一个简单的封装，以判断是否存在某个类</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>工具类存在之后，我们实现一个简单的json工具类，根据已有的json包来选择具体的实现</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的实现中，根据已有的json序列化工具，选择具体的实现类，我们定义了一个JsonApi接口，然后分别gson,jackson,fastjson给出默认的实现类</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>最后的问题来了，如果调用方并没有使用上面三个序列化工具，而是使用其他的呢，可以支持么？</p>
<p>既然我们定义了一个JsonApi，那么是不是可以由用户自己来实现接口，然后自动选择它呢？</p>
<p>现在的问题就是如何找到用户自定义的接口实现了</p>
<h3> 1.3. 扩展机制</h3>
<p>对于SPI机制比较熟悉的小伙伴可能非常清楚，可以通过在配置目录<code>META-INF/services/</code>下新增接口文件，内容为实现类的全路径名称，然后通过 <code>ServiceLoader.load(JsonApi.class)</code> 的方式来获取所有实现类</p>
<p>除了SPI的实现方式之外，另外一个策略则是上面提到的Spring的实现原理，借助字节码来处理（详情原理后面专文说明）</p>
<p>当然也有更容易想到的策略，扫描包路径下的class文件，遍历判断是否为实现类(额外注意jar包内的实现类场景)</p>
<p>接下来以SPI的方式来介绍下扩展实现方式，首先初始化JsonApi的方式改一下，优先使用用户自定义实现</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对于使用者而言，首先是实现接口</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接着就是实现定义, <code>resources/META-INF/services/</code> 目录下，新建文件名为 <code>com.github.hui.quick.plugin.qrcode.util.json.JsonApi</code></p>
<p>内容如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>然后完工~</p>
<h2> 2. 小结</h2>
<p>主要介绍一个小的知识点，如何根据应用已有的jar包来选择具体的实现类的方式；本文介绍的方案是通过ClassLoader来尝试加载对应的类，若能正常加载，则认为有；否则认为没有；这种实现方式虽然非常简单，但是请注意，它是有缺陷的，至于缺陷是啥...</p>
<p>除此之外，也可以考虑通过字节码的方式来判断是否有某个类，或者获取某个接口的实现；文中最后抛出了一个问题，如何获取接口的所有实现类</p>
<p>常见的方式有下面三类（具体介绍了SPI的实现姿势，其他的两种感兴趣的可以搜索一下）</p>
<ul>
<li>SPI定义方式</li>
<li>扫描包路径</li>
<li>字节码方式(如Spring，如Tomcat的<code>@HandlesTypes</code>)</li>
</ul>
<hr>
<p>微信搜 <strong>楼仔</strong> 或扫描下方二维码关注楼仔的原创公众号，回复 <strong>110</strong> 即可免费领取 10 本面试必刷八股文。
<img src="https://files.mdnice.com/user/13837/4b47ac79-8256-47cf-ac1a-036729635246.png" alt="" loading="lazy"></p>
<hr>
<h1> 实战24： 基于JDK的LRU算法实现</h1>
<h2> 1. LRU算法</h2>
<p>缓存淘汰算法--LRU算法LRU（Least recently used，最近最少使用）算法</p>
<p>根据数据的历史访问记录来进行淘汰数据，其核心思想是"如果数据最近被访问过，那么将来被访问的几率也更高"</p>
<p>再Java中可以非常简单的实现LRU算法，主要利用的是LinkedHashMap容器</p>
<h3> 1.1 LRU算法实现</h3>
<p>inkedHashMap底层就是用的HashMap加双链表实现的，而且本身已经实现了按照访问顺序的存储。此外，LinkedHashMap中本身就实现了一个方法removeEldestEntry用于判断是否需要移除最不常读取的数，方法默认是直接返回false，不会移除元素</p>
<p>因此我们只需要重写这个方法，可以实现当缓存满之后，就移除最不常用的数据</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意上面的访问，当i == 6 时，主动访问了一下 <code>一灰灰blog_2</code>，主要就是不希望淘汰掉它，再看下对应的输出</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>实际输出与我们预期一致</p>
<h3> 1.2 小结</h3>
<p>jdk中蕴含了大量的财富，就看我们能不能识别出来了；通常我非常推荐&lt;3年的小伙伴，有事没事多盘一下jdk的经典实现，比如各种容器的底层结构，并发类的设计思想等</p>
<hr>
<p>微信搜 <strong>楼仔</strong> 或扫描下方二维码关注楼仔的原创公众号，回复 <strong>110</strong> 即可免费领取 10 本面试必刷八股文。
<img src="https://files.mdnice.com/user/13837/4b47ac79-8256-47cf-ac1a-036729635246.png" alt="" loading="lazy"></p>
<hr>
<h1> 实战25： 数字型字面量中的下划线</h1>
<p>不知道有没有小伙伴看过下面这种写法，不用质疑，它没有语法错误；再很多开源的框架中可以看到类似的写法；这种再字面量中添加下划线的方式，是一种小却使用的编程小技巧，推荐给CURD开发者</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><!-- more -->
<h2> 1. Java7新特性之数字中使用下划线</h2>
<p>为了直观性而言，在大数之间，加上下划线用于肉眼区分，下面实例小结下用法</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>简单来说，就是在数中间，插上下划线，用于划分段落</p>
<h2> 2. 小结</h2>
<p>再字面量中添加下划线，主要用于分割大数，方便阅读，重点注意：</p>
<ul>
<li>不能在小数点正前后添加</li>
<li>不要在L/D/F等数据类型标识的正前方添加</li>
<li>不能作为数字开头，也不能作为结尾</li>
<li>不要往进制修饰符中间或后面添加</li>
</ul>
<hr>
<p>微信搜 <strong>楼仔</strong> 或扫描下方二维码关注楼仔的原创公众号，回复 <strong>110</strong> 即可免费领取 10 本面试必刷八股文。
<img src="https://files.mdnice.com/user/13837/4b47ac79-8256-47cf-ac1a-036729635246.png" alt="" loading="lazy"></p>
<hr>
<h1> 实战26：列表遍历删除使用实例</h1>
<p>在实际的业务开发中，容器的遍历可以说是非常非常常见的场景了，遍历删除呢，用的机会也不会少，但你真的会用么？</p>
<!-- more -->
<h2> 1. List遍历删除</h2>
<p>对于列表，这里以ArrayList进行举例说明，下面给出几种经常会遇到的写法</p>
<p>首先初始化一个list数组</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1.1. foreach</h3>
<p>这个属于我们最常见的foreach循环，在循环内部判断满足条件的直接删除</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这种写法导致的问题，很容易可以发现，因为上面代码跑完之后，堆栈就出来了</p>
<figure><img src="https://blog.hhui.top/hexblog/imgs/190521/00.jpg" alt="IMAGE" tabindex="0" loading="lazy"><figcaption>IMAGE</figcaption></figure>
<p>很典型的并发修改错误，在foreach循环中不允许删除,新增</p>
<h3> 1.2. 普通for循环</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这种写法呢？我们希望把列表中，第0，5，10，15位置的元素干掉，正常执行，倒是不会报错，然而输出的结果却和我们的预期不一致</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>for循环中，另外一种写法可能更加常见，为了避免每次都访问 <code>list.size()</code> 方法，我可能提前用一个变量保存数组大小</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这个问题就很明显了，数组越界</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1.3. 迭代方式</h3>
<p>下面这种可以说是标准的迭代删除的写法了，基本上大多都是这么玩</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1.4. jdk8+ 流方式</h3>
<p>jdk8+ 推荐下面这种写法，简洁明了</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2> 2. 小结</h2>
<p>注意不要在for/foreach遍历过程中删除元素，如果有移除元素的需求，使用迭代器；或者使用jdk8的流式写法也行</p>
<hr>
<p>微信搜 <strong>楼仔</strong> 或扫描下方二维码关注楼仔的原创公众号，回复 <strong>110</strong> 即可免费领取 10 本面试必刷八股文。
<img src="https://files.mdnice.com/user/13837/4b47ac79-8256-47cf-ac1a-036729635246.png" alt="" loading="lazy"></p>
<hr>
<h1> 实战27：HashMap遍历删除使用实例</h1>
<p>map的迭代删除，和我们常见的list，set不太一样，不能直接获取Iteraotr对象，提供的删除方法也是单个的，根据key进行删除，如果我们有个需求，将map中满足某些条件的元素删除掉，要怎么做呢？</p>
<!-- more -->
<h2> 1. Map 迭代删除</h2>
<p>迭代删除，在不考虑并发安全的前提下，我们看下可以怎么支持</p>
<h3> 1.1. 非常不优雅版本</h3>
<p>我们知道map并不是继承自Collection接口的，HashMap 也没有提供迭代支持，既然没法直接迭代，那我就老老实的low b版好了</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的实现怎么样？并没有什么毛病</p>
<p>(为啥不直接在遍历中删除？）</p>
<h3> 1.2. 正确姿势版</h3>
<p>虽然Map没有迭代，但是它的entrySet有啊，所以我们可以通过它来实现遍历删除</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这个可能是我们经常使用的操作姿势了，利用迭代器来操作元素</p>
<h3> 1.3. 简洁版</h3>
<p>到jdk8之后，针对容器提供了很多简洁的操作方式，迭代删除这方面可以说更加简单了</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 2. 小结</h2>
<p>和列表删除元素一样，不要在for/foreach迭代过程中删除数据，如有需要，迭代器才是正解；jdk8之后更推荐流式写法</p>
<hr>
<p>微信搜 <strong>楼仔</strong> 或扫描下方二维码关注楼仔的原创公众号，回复 <strong>110</strong> 即可免费领取 10 本面试必刷八股文。
<img src="https://files.mdnice.com/user/13837/4b47ac79-8256-47cf-ac1a-036729635246.png" alt="" loading="lazy"></p>
<hr>
<h1> 实战28：优雅的实现代码耗时统计</h1>
<p>在我们的实际开发中，多多少少会遇到统计一段代码片段的耗时的情况，我们一般的写法如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的写法没有什么毛病，但是看起来就不太美观了，那么有没有什么更优雅的写法呢？</p>
<!-- more -->
<h2> 1. 代理方式</h2>
<p>了解Spring AOP的同学可能立马会想到一个解决方法，如果想要统计某个方法耗时，使用切面可以无侵入的实现，如</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Spring AOP的底层支持原理为代理模式，为目标对象提供增强功能；在Spring的生态体系下，使用aop的方式来统计方法耗时，可以说少侵入且实现简单，但是有以下几个问题</p>
<ul>
<li>统计粒度为方法级别</li>
<li>类内部方法调用无法生效（详情可以参考博文：<a href="http://spring.hhui.top/spring-blog/2019/03/02/190302-SpringBoot%E5%9F%BA%E7%A1%80%E7%AF%87AOP%E4%B9%8B%E9%AB%98%E7%BA%A7%E4%BD%BF%E7%94%A8%E6%8A%80%E8%83%BD/" target="_blank" rel="noopener noreferrer">【SpringBoot 基础系列教程】AOP之高级使用技能</a>）</li>
</ul>
<h2> 2. AutoCloseable</h2>
<p>在JDK1.7引入了一个新的接口<code>AutoCloseable</code>, 通常它的实现类配合<code>try{}</code>使用，可在IO流的使用上，经常可以看到下面这种写法</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意上面的写法中，最值得关注一点是，不需要再主动的写<code>stream.close</code>了，主要原因就是在<code>try(){}</code>执行完毕之后，会调用方法<code>AutoCloseable#close</code>方法；</p>
<p>基于此，我们就会有一个大单的想法，下一个<code>Cost</code>类实现<code>AutoCloseable</code>接口，创建时记录一个时间，close方法中记录一个时间，并输出时间差值；将需要统计耗时的逻辑放入<code>try(){}</code>代码块</p>
<p>下面是一个具体的实现：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>执行后输出如下:</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果代码块抛异常，也会正常输出耗时么？</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>再次输出如下，并没有问题</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 3. 小结</h2>
<p>除了上面介绍的两种方式，还有一种在业务开发中不太常见，但是在中间件、偏基础服务的功能组件中可以看到，利用Java Agent探针技术来实现，比如阿里的arthas就是在JavaAgent的基础上做了各种上天的功能，后续介绍java探针技术时会专门介绍</p>
<p>下面小结一下三种统计耗时的方式</p>
<p><strong>基本写法</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>优点是简单，适用范围广泛；缺点是侵入性强，大量的重复代码</p>
<p><strong>Spring AOP</strong></p>
<p>在Spring生态下，可以借助AOP来拦截目标方法，统计耗时</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>优点：无侵入，适合统一管理（比如测试环境输出统计耗时，生产环境不输出）；缺点是适用范围小，且粒度为方法级别，并受限于AOP的使用范围</p>
<p><strong>AutoCloseable</strong></p>
<p>这种方式可以看做是第一种写法的进阶版</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>优点是：简单，适用范围广泛，且适合统一管理；缺点是依然有代码侵入</p>
<p><strong>说明</strong></p>
<p>上面第二种方法看着属于最优雅的方式，但是限制性强；如果有更灵活的需求，建议考虑第三种写法，在代码的简洁性和统一管理上都要优雅很多，相比较第一种可以减少大量冗余代码</p>
<hr>
<p>微信搜 <strong>楼仔</strong> 或扫描下方二维码关注楼仔的原创公众号，回复 <strong>110</strong> 即可免费领取 10 本面试必刷八股文。
<img src="https://files.mdnice.com/user/13837/4b47ac79-8256-47cf-ac1a-036729635246.png" alt="" loading="lazy"></p>
<hr>
<h1> 实战29：获取类路径的常见方式</h1>
<h2> 1. 资源路径查询</h2>
<p>在Java环境中，如何获取当前类的路径，如何获取项目根路径，可以说是比较常见的需求场景了，下面简单的记录一下</p>
<!-- more -->
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出如下:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 2. 小结</h2>
<ol>
<li><code>new File(this.getClass().getResource("/").getPath())</code>
<ul>
<li>获取类加载的根路径</li>
</ul>
</li>
<li><code>new File(this.getClass().getResource("").getPath())</code>
<ul>
<li>获取当前类的所在工程路径; 如果不加“/”  获取当前类的加载目录</li>
</ul>
</li>
<li><code>new File("").getCanonicalPath()</code>
<ul>
<li>获取项目路径</li>
</ul>
</li>
<li><code>this.getClass().getClassLoader().getResource("")</code></li>
<li><code>System.getProperty("user.dir")</code></li>
<li><code>System.getProperty("java.class.path")</code>
<ul>
<li>获取所有的类路径 包括jar包的路径</li>
</ul>
</li>
</ol>
<hr>
<p>微信搜 <strong>楼仔</strong> 或扫描下方二维码关注楼仔的原创公众号，回复 <strong>110</strong> 即可免费领取 10 本面试必刷八股文。
<img src="https://files.mdnice.com/user/13837/4b47ac79-8256-47cf-ac1a-036729635246.png" alt="" loading="lazy"></p>
<hr>
<h1> 实战30：JDK压缩与解压工具类</h1>
<p>在实际的应用场景中，特别是对外传输数据时，将原始数据压缩之后丢出去，可以说是非常常见的一个case了，平常倒是没有直接使用JDK原生的压缩工具类，使用Protosutff和Kryo的机会较多,正好在实际的工作场景中遇到了，现在简单的看下使用姿势</p>
<!-- more -->
<h2> 1. 压缩与解压工具类</h2>
<h3> 1.1. 基本实现</h3>
<p>主要借助的就是Deflater, Inflater两个工具类，其使用姿势如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>一个简单的测试</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1.2. 注意事项</h3>
<p>上面这个运作的还挺好，但在接入使用时，总是提示<code>java.util.zip.DataFormatException: incorrect header check</code>, 因为接受的是第三方传递过来的压缩数据，比较坑爹的是对方就写了个Deflater压缩，然后什么都没有了，那么这个是啥原因呢？</p>
<p>其实看下Deflater的构造方法，发现还可以传一个boolean值(nowrap), 官方说明是</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>简单来说，就是压缩时，如果nowrap为true，那么解压时也要为true；否则对不上时，就会抛异常</p>
<p>接下来简单对比下两种不同传参的情况，首先更新下工具类</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>测试如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果如下，从大小来看，前者小那么一点点</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 2. 小结</h2>
<p>一般来说，jdk自带的压缩与解压，除了方便之外，可能优势并不是那么的大，这里盗一张网上的对比表格</p>
<p>以下来自: <a href="https://www.cnblogs.com/lonelywolfmoutain/p/5563985.html" target="_blank" rel="noopener noreferrer">[java]序列化框架性能对比（kryo、hessian、java、protostuff）</a></p>
<table>
<thead>
<tr>
<th></th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>kryo</td>
<td>速度快，序列化后体积小</td>
<td>跨语言支持较复杂</td>
</tr>
<tr>
<td>hessian</td>
<td>默认支持跨语言</td>
<td>较慢</td>
</tr>
<tr>
<td>protostuff</td>
<td>速度快，基于protobuf</td>
<td>需静态编译</td>
</tr>
<tr>
<td>Protostuff-Runtime</td>
<td>无需静态编译，但序列化前需预先传入schema</td>
<td>不支持无默认构造函数的类，反序列化时需用户自己初始化序列化后的对象，其只负责将该对象进行赋值</td>
</tr>
<tr>
<td>jdk</td>
<td>使用方便，可序列化所有类</td>
<td>速度慢，占空间</td>
</tr>
</tbody>
</table>
<p>其次，在使用java的压缩与解压时，需要注意下，nowrap这个参数，需要保持一致，否则会报错</p>
<hr>
<p>微信搜 <strong>楼仔</strong> 或扫描下方二维码关注楼仔的原创公众号，回复 <strong>110</strong> 即可免费领取 10 本面试必刷八股文。
<img src="https://files.mdnice.com/user/13837/4b47ac79-8256-47cf-ac1a-036729635246.png" alt="" loading="lazy"></p>
<hr>
<h1> 实战31：深拷贝浅拷贝及对象拷贝的两种方式</h1>
<h2> 1. Java之Clone</h2>
<h3> 1.1 背景</h3>
<p>对象拷贝，是一个非常基础的内容了，为什么会单独的把这个领出来讲解，主要是先前遇到了一个非常有意思的场景</p>
<p>有一个任务，需要解析类xml标记语言，然后生成document对象，之后将会有一系列针对document对象的操作</p>
<p>通过实际的测试，发现生成Document对象是比较耗时的一个操作，再加上这个任务场景中，需要解析的xml文档是固定的几个，那么一个可以优化的思路就是能不能缓存住创建后的Document对象，在实际使用的时候clone一份出来</p>
<!-- more  -->
<h3> 1.2 内容说明</h3>
<p>看到了上面的应用背景，自然而言的就会想到深拷贝了，本篇博文则主要内容如下</p>
<ul>
<li>介绍下两种拷贝方式的区别</li>
<li>深拷贝的辅助工具类</li>
<li>如何自定义实现对象拷贝</li>
</ul>
<h2> 2. 深拷贝和浅拷贝</h2>
<h3> 2.1 定义说明</h3>
<p><strong>深拷贝</strong></p>
<p>相当于创建了一个新的对象，只是这个对象的所有内容，都和被拷贝的对象一模一样而已，即两者的修改是隔离的，相互之间没有影响</p>
<p><strong>浅拷贝</strong></p>
<p>也是创建了一个对象，但是这个对象的某些内容（比如A）依然是被拷贝对象的，即通过这两个对象中任意一个修改A，两个对象的A都会受到影响</p>
<p>看到上面两个简单的说明，那么问题来了</p>
<ul>
<li>浅拷贝中，是所有的内容公用呢？还是某些内容公用？</li>
<li>从隔离来将，都不希望出现浅拷贝这种方式了，太容易出错了，那么两种拷贝方式的应用场景是怎样的？</li>
</ul>
<h3> 2.2 浅拷贝</h3>
<p>一般来说，浅拷贝方式需要实现<code>Cloneable</code>接口，下面结合一个实例，来看下浅拷贝中哪些是独立的，哪些是公用的</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>结果分析：</p>
<ul>
<li>拷贝后获取的是一个独立的对象，和原对象拥有不同的内存地址</li>
<li>基本元素类型，两者是隔离的（虽然上面只给出了int，String）
<ul>
<li>基本元素类型包括:</li>
<li>int, Integer, long, Long, char, Charset, byte,Byte, boolean, Boolean, float,Float, double, Double, String</li>
</ul>
</li>
<li>非基本数据类型（如基本容器，其他对象等），只是拷贝了一份引用出去了，实际指向的依然是同一份</li>
</ul>
<p>其实，浅拷贝有个非常简单的理解方式：</p>
<p><strong>浅拷贝的整个过程就是，创建一个新的对象，然后新对象的每个值都是由原对象的值，通过 <code>=</code> 进行赋值</strong></p>
<p>这个怎么理解呢？</p>
<p>上面的流程拆解就是：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>那么=赋值有什么特点呢？</p>
<p>基本数据类型是值赋值；非基本的就是引用赋值</p>
<h3> 2.3 深拷贝</h3>
<p>深拷贝，就是要创建一个全新的对象，新的对象内部所有的成员也都是全新的，只是初始化的值已经由被拷贝的对象确定了而已</p>
<p>那么上面的实例改成深拷贝应该是怎样的呢？</p>
<p>可以加上这么一个方法</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果为：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>结果分析：</p>
<ul>
<li>深拷贝独立的对象</li>
<li>拷贝后对象的内容，与原对象的内容完全没关系，都是独立的</li>
</ul>
<p>简单来说，深拷贝是需要自己来实现的，对于基本类型可以直接赋值，而对于对象、容器、数组来讲，需要创建一个新的出来，然后重新赋值</p>
<h3> 2.4 应用场景区分</h3>
<p>深拷贝的用途我们很容易可以想见，某个复杂对象创建比较消耗资源的时候，就可以缓存一个蓝本，后续的操作都是针对深clone后的对象，这样就不会出现混乱的情况了</p>
<p>那么浅拷贝呢？感觉留着是一个坑，一个人修改了这个对象的值，结果发现对另一个人造成了影响，真不是坑爹么？</p>
<p>假设又这么一个通知对象长下面这样</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们现在随机挑选了一千个人，同时发送通知消息，所以需要创建一千个上面的对象，这些对象中呢，除了notifyUser不同，其他的都一样</p>
<p>在发送之前，突然发现要临时新增一条通知信息，如果是浅拷贝的话，只用在任意一个通知对象的notifyRules中添加一调消息，那么这一千个对象的通知消息都会变成最新的了；而如果你是用深拷贝，那么苦逼的得遍历这一千个对象，每个都加一条消息了</p>
<hr>
<h2> 3. 对象拷贝工具</h2>
<p>上面说到，浅拷贝，需要实现Clonebale接口，深拷贝一般需要自己来实现，那么我现在拿到一个对象A，它自己没有提供深拷贝接口，我们除了主动一条一条的帮它实现之外，有什么辅助工具可用么？</p>
<p>对象拷贝区别与clone，它可以支持两个不同对象之间实现内容拷贝</p>
<p><strong>Apache的两个版本：（反射机制）</strong></p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>Spring版本：（反射机制）</strong></p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>cglib版本：（使用动态代理，效率高）</strong></p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>从上面的几个有名的工具类来看，提供了两种使用者姿势，一个是反射，一个是动态代理，下面分别来看两种思路</p>
<h3> 3.1 借助反射实现对象拷贝</h3>
<p>通过反射的方式实现对象拷贝的思路还是比较清晰的，先通过反射获取对象的所有属性，然后修改可访问级别，然后赋值；再获取继承的父类的属性，同样利用反射进行赋值</p>
<p>上面的几个开源工具，内部实现封装得比较好，所以直接贴源码可能不太容易一眼就能看出反射方式的原理，所以简单的实现了一个, 仅提供思路</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的实现步骤还是非常清晰的，首先是找同名的属性，然后利用反射获取对应的值</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果找不到，则找getXXX, isXXX来获取</p>
<h3> 3.2 代理的方式实现对象拷贝</h3>
<p>Cglib的BeanCopier就是通过代理的方式实现拷贝，性能优于反射的方式，特别是在大量的数据拷贝时，比较明显</p>
<p>代理，我们知道可以区分为静态代理和动态代理，简单来讲就是你要操作对象A，但是你不直接去操作A，而是找一个中转porxyA, 让它来帮你操作对象A</p>
<p>那么这种技术是如何使用在对象拷贝的呢？</p>
<p>我们知道，效率最高的对象拷贝方式就是Getter/Setter方法了，前面说的代理的含义指我们不直接操作，而是找个中间商来赚差价，那么方案就出来了</p>
<p>将原SourceA拷贝到目标DestB</p>
<ul>
<li>创建一个代理 copyProxy</li>
<li>在代理中，依次调用 SourceA的get方法获取属性值，然后调用DestB的set方法进行赋值</li>
</ul>
<p>实际上BeanCopier的思路大致如上，具体的方案当然就不太一样了, 简单看了一下实现逻辑，挺有意思的一块，先留个坑，后面单独开个博文补上</p>
<p><strong>说明</strong></p>
<p>从实现原理和通过简单的测试，发现BeanCopier是扫描原对象的getXXX方法，然后赋值给同名的 setXXX 方法，也就是说，如果这个对象中某个属性没有get/set方法，那么就无法赋值成功了</p>
<hr>
<h2> 3. 小结</h2>
<h3> 3.1 深拷贝和浅拷贝</h3>
<p><strong>深拷贝</strong></p>
<blockquote>
<p>相当于创建了一个新的对象，只是这个对象的所有内容，都和被拷贝的对象一模一样而已，即两者的修改是隔离的，相互之间没有影响</p>
</blockquote>
<ul>
<li>完全独立</li>
</ul>
<p><strong>浅拷贝</strong></p>
<blockquote>
<p>也是创建了一个对象，但是这个对象的某些内容（比如A）依然是被拷贝对象的，即通过这两个对象中任意一个修改A，两个对象的A都会受到影响</p>
</blockquote>
<ul>
<li>等同与新创建一个对象，然后使用=，将原对象的属性赋值给新对象的属性</li>
<li>需要实现Cloneable接口</li>
</ul>
<h3> 3.2 对象拷贝的两种方法</h3>
<p><strong>通过反射方式实现对象拷贝</strong></p>
<p>主要原理就是通过反射获取所有的属性，然后反射更改属性的内容</p>
<p><strong>通过代理实现对象拷贝</strong></p>
<p>将原SourceA拷贝到目标DestB</p>
<p>创建一个代理 copyProxy
在代理中，依次调用 SourceA的get方法获取属性值，然后调用DestB的set方法进行赋值</p>
<hr>
<p>微信搜 <strong>楼仔</strong> 或扫描下方二维码关注楼仔的原创公众号，回复 <strong>110</strong> 即可免费领取 10 本面试必刷八股文。
<img src="https://files.mdnice.com/user/13837/4b47ac79-8256-47cf-ac1a-036729635246.png" alt="" loading="lazy"></p>
<hr>
<h1> 实战32：Java可以如何实现文件变动的监听</h1>
<p>应用中使用logback作为日志输出组件的话，大部分会去配置 <code>logback.xml</code> 这个文件，而且生产环境下，直接去修改logback.xml文件中的日志级别，不用重启应用就可以生效</p>
<p>那么，这个功能是怎么实现的呢？</p>
<!-- more -->
<h2> 1. 问题描述及分析</h2>
<p>针对上面的这个问题，首先抛出一个实际的case，在我的个人网站 * <a href="https://tool.hhui.top/" target="_blank" rel="noopener noreferrer">神奇工具箱 - 小工具集合</a> 中，所有的小工具都是通过配置文件来动态新增和隐藏的，因为只有一台服务器，所以配置文件就简化的直接放在了服务器的某个目录下</p>
<p>现在的问题时，我需要在这个文件的内容发生变动时，应用可以感知这种变动，并重新加载文件内容，更新应用内部缓存</p>
<p>一个最容易想到的方法，就是轮询，判断文件是否发生修改，如果修改了，则重新加载，并刷新内存，所以主要需要关心的问题如下：</p>
<ul>
<li>如何轮询？</li>
<li>如何判断文件是否修改？</li>
<li>配置异常，会不会导致服务不可用？（即容错，这个与本次主题关联不大，但又比较重要...）</li>
</ul>
<h2> 2. 设计与实现</h2>
<p>问题抽象出来之后，对应的解决方案就比较清晰了</p>
<ul>
<li>如何轮询 ？ --》 定时器 Timer, ScheduledExecutorService 都可以实现</li>
<li>如何判断文件修改？ --》根据 <code>java.io.File#lastModified</code> 获取文件的上次修改时间，比对即可</li>
</ul>
<p>那么一个很简单的实现就比较容易了:</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这个属于一个非常简单，非常基础的实现了，基本上也可以满足我们的需求，那么这个实现有什么问题呢？</p>
<p><strong>定时任务的执行中，如果出现了异常会怎样？</strong></p>
<p>对上面的代码稍作修改</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>实际测试，发现只有首次修改的时候，触发了上面的代码，但是再次修改则没有效果了，即当抛出异常之后，定时任务将不再继续执行了，这个问题的主要原因是因为 <code>ScheduledExecutorService</code> 的原因了</p>
<p>直接查看ScheduledExecutorService的源码注释说明</p>
<blockquote>
<p>If any execution of the task encounters an exception, subsequent executions are suppressed.Otherwise, the task will only terminate via cancellation or termination of the executor.
即如果定时任务执行过程中遇到发生异常，则后面的任务将不再执行。</p>
</blockquote>
<p><strong>所以，使用这种姿势的时候，得确保自己的任务不会抛出异常，否则后面就没法玩了</strong></p>
<p>对应的解决方法也比较简单，整个catch一下就好</p>
<h2> 3. 进阶版</h2>
<p>前面是一个基础的实现版本了，当然在java圈，基本上很多常见的需求，都是可以找到对应的开源工具来使用的，当然这个也不例外，而且应该还是大家比较属性的apache系列</p>
<h3> 3.1 apache版</h3>
<p>首先maven依赖</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>主要是借助这个工具中的 <code>FileAlterationObserver</code>, <code>FileAlterationListener</code>, <code>FileAlterationMonitor</code> 三个类来实现相关的需求场景了，当然使用也算是很简单了，以至于都不太清楚可以再怎么去说明了，直接看下面从我的一个开源项目quick-alarm中拷贝出来的代码</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>针对上面的实现，简单说明几点：</p>
<ul>
<li>这个文件监听，是以目录为根源，然后可以设置过滤器，来实现对应文件变动的监听</li>
<li>如上面<code>registerConfChangeListener</code>方法，传入的file是具体的配置文件，因此构建参数的时候，捞出了目录，捞出了文件名作为过滤</li>
<li>第二参数是jdk8语法，其中为具体的读取配置文件内容，并映射为对应的实体对象</li>
</ul>
<p>一个问题，如果 func方法执行时，也抛出了异常，会怎样？</p>
<p>实际测试表现结果和上面一样，抛出异常之后，依然跪，所以依然得注意，不要跑异常</p>
<p>那么简单来看一下上面的实现逻辑，直接扣出核心模块</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从上面基本上一目了然，整个的实现逻辑了，和我们的第一种定时任务的方法不太一样，这儿直接使用线程，死循环，内部采用sleep的方式来来暂停，因此出现异常时，相当于直接抛出去了，这个线程就跪了</p>
<h3> 3.2 JDK版本</h3>
<p>jdk1.7，提供了一个<code>WatchService</code>，也可以用来实现文件变动的监听，之前也没有接触过，看到说明，然后搜了一下使用相关，发现也挺简单的，同样给出一个简单的示例demo</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 4. 小结</h2>
<p>使用Java来实现配置文件变动的监听，主要涉及到的就是两个点</p>
<ul>
<li>如何轮询：  定时器（Timer, ScheduledExecutorService）, 线程死循环+sleep</li>
<li>文件修改： File#lastModified</li>
</ul>
<p>整体来说，这个实现还是比较简单的，无论是自定义实现，还是依赖 commos-io来做，都没太大的技术成本，但是需要注意的一点是：</p>
<ul>
<li>千万不要在定时任务 or 文件变动的回调方法中抛出异常！！！</li>
</ul>
<p>为了避免上面这个情况，一个可以做的实现是借助EventBus的异步消息通知来实现，当文件变动之后，发送一个消息即可，然后在具体的重新加载文件内容的方法上，添加一个 <code>@Subscribe</code>注解即可，这样既实现了解耦，也避免了异常导致的服务异常 （如果对这个实现有兴趣的可以评论说明）</p>
<hr>
<p>微信搜 <strong>楼仔</strong> 或扫描下方二维码关注楼仔的原创公众号，回复 <strong>110</strong> 即可免费领取 10 本面试必刷八股文。
<img src="https://files.mdnice.com/user/13837/4b47ac79-8256-47cf-ac1a-036729635246.png" alt="" loading="lazy"></p>
<hr>
<h1> 实战33：实用的Map初始化工具类</h1>
<p>虽说java作为编译语言，但是它本身也提供了很多运行时能力，今天介绍一个非常基础的知识点，可变参数传递</p>
<!-- more -->
<p>在日常的开发过程中，创建Map对象还是比较常见的，现在我希望写一个工具类，可以非常简单创建并初始化Map对象</p>
<p>因此我们可以实现一个MapUtil工具类，来支持这个场景</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意一下上面的实现，kv这个参数就是我们要说的可变参数，在方法内部，kv可以看成是一个数组对象（而且是安全的对象，当不传递时，它的取值也不是null）</p>
<p>在使用可变参数时，下面是一些需要注意的点</p>
<p><strong>可变参数注意与数组参数的冲突</strong></p>
<p>注意下面的两个方法，不能同时出现，直接出现编译错误</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>重载的选择</strong></p>
<p>如果只有一个可变参数的方法，<code>newMap("key", "value")</code>不会报错，会直接访问下面这个方法，kv参数为空数组</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>当出现重载时，即如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>上面两个方法的调用，如果传参只有两个时，会调用哪个？</p>
<ul>
<li><code>newMap("key", "value")</code> 调用的下面的方法</li>
<li>`newMap("key", "value", "k", "v") 调用的上面的方法</li>
</ul>
<p><strong>可变参数传数组会怎样</strong></p>
<p>虽说我们在使用的时候，将可变参数当做数组来使用，但是传递时，若传数组，是否可行呢？</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>实际输出如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>从实际测试来看，传数组并没有问题</p>
<hr>
<p>微信搜 <strong>楼仔</strong> 或扫描下方二维码关注楼仔的原创公众号，回复 <strong>110</strong> 即可免费领取 10 本面试必刷八股文。
<img src="https://files.mdnice.com/user/13837/4b47ac79-8256-47cf-ac1a-036729635246.png" alt="" loading="lazy"></p>
<hr>
<h1> 实战34：通用的根据路径获取文件资源的工具类</h1>
<p>通常我们最多的场景是从本地资源中读取文件，这个时候我们经常需要注意的是相对路径、绝对路径问题；</p>
<p>除了从本地获取文件之外，从网络中获取文件资源（如图片）也属于相对常见的场景，接下来我们封装一个工具类，可以支持以上各种类型的数据读取</p>
<!-- more -->
<h2> 1. 工具实现类</h2>
<p>首先定义一个公共方法如下，内部支持四种方式的数据获取</p>
<ul>
<li>相对路径</li>
<li>绝对路径</li>
<li>用户根目录</li>
<li>网络</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>请注意上面的实现，绝对路径与相对路径比较好理解，用户目录，这个处理又是怎样的呢？</p>
<p>关键点在于，用户目录转绝对路径</p>
<ul>
<li>借助<code>System.getProperties</code>系统属性来处理</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来再看如何判断一个路径是否为绝对路径呢？</p>
<p>这里需要格外注意不同操作系统的差异性，比如win，区分C盘，D盘，但是mac/linux则不分这个，上面判断的核心逻辑如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>除了上面的三种本地资源获取之外，还有一个就是网络资源的读取，上面介绍的实现姿势主要是基于JDK原生的URL，在实际使用时，这个并不稳定，不能确定能获取到完整的数据，原则上不推荐使用；如果可以，使用http-client/okhttp都是不错的选择</p>
<p>最后给一个简单的测试</p>
<p>最后一个简单下载图片的case</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0542b4ae409b4336a431fac44c1cef5f~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure>
<hr>
<p>微信搜 <strong>楼仔</strong> 或扫描下方二维码关注楼仔的原创公众号，回复 <strong>110</strong> 即可免费领取 10 本面试必刷八股文。
<img src="https://files.mdnice.com/user/13837/4b47ac79-8256-47cf-ac1a-036729635246.png" alt="" loading="lazy"></p>
<hr>
<h1> 实战35：调用本地程序的几种姿势</h1>
<p>作为一个后端同学，经常被安全的小伙伴盯上，找一找安全漏洞；除了常说的注入之外，还有比较吓人的执行远程命令，唤醒本地应用程序等；然后有意思的问题就来了，写了这么多年的代码，好像还真没有尝试过用java来唤醒本地应用程序的</p>
<p>比如说一个最简单的，打开本地的计算器，应该怎么搞？</p>
<p>接下来本文将介绍一下如何使用java打开本地应用，以及打开mac系统中特殊一点的处理方式（直白来说就是不同操作系统，使用姿势不一样）</p>
<!-- more -->
<h2> 1. Runtime使用方式</h2>
<p>主要是基于<code>Runtime.getRuntime().exec()</code>来执行shell命令，来打开应用</p>
<ul>
<li>传参就是需要打开的应用名</li>
</ul>
<p>比如上面说到的打开计算器</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从上面的传参也可以看出两者的区别，为什么mac会整一个 <code>open -n</code>， 这个其实可以理解为在终端执行命令，打开计算器</p>
<p><strong>注意事项</strong></p>
<p>对于mac系统而言，除了上面这种打开方式之外，还有下面这种姿势</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>在exec中指定计算器的路径，有个很容易采的坑，直接写成下面这种</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面这个直接执行之后会提示<code>权限错误</code>，其主要原因是mac系统的应用和win中的exe作为启动方式不太一样，对于mac而言，可以理解<code>xxx.app</code>为一个目录，真正执行文件是内部的<code>xxx/Contents/MacOS/xxx</code></p>
<h2> 2. ProcessBuilder使用方式</h2>
<p>除了Runtime唤起之外，使用ProcessBuilder也属于非常常见的case</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用上面这种姿势，特别需要注意的是内部传参不能是<code>open -n</code></p>
<h2> 3. 小结</h2>
<p>从上面介绍的方式来看，其实打开应用程序的思路主要就是利用java来执行脚本命令；内容比较简单，隐患却是比较大的；在自己的项目中，最好不要出现这种调用方式</p>
<p>微信搜 <strong>楼仔</strong> 或扫描下方二维码关注楼仔的原创公众号，回复 <strong>110</strong> 即可免费领取 10 本面试必刷八股文。
<img src="https://files.mdnice.com/user/13837/4b47ac79-8256-47cf-ac1a-036729635246.png" alt="" loading="lazy"></p>
<hr>
<h1> 实战36：技术派开源项目</h1>
<p>大家好，足足搞了半年，我们的第一个项目——技术派，终于上线啦！</p>
<p>之前就有很多粉丝催，久等了各位！心急的小伙伴，可以到文末直接看网站域名。</p>
<p>在此之前，我先来介绍（吹一吹）网站。</p>
<h2> 网站内容有什么？</h2>
<p>技术派致力于打造一个完整的社区平台，采用现阶段最流行的技术实现。</p>
<p>网站的内容丰富，又不失整洁，整体以橘色为主色调，颜值很高。</p>
<figure><img src="https://files.mdnice.com/user/13837/180e1ba7-7074-43b7-9250-ac6bc158b1a9.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>什么，卡片的颜色不喜欢？我们还有其它的，<strong>这些色系是根据图片自动识别</strong>，满满的黑科技。</p>
<figure><img src="https://files.mdnice.com/user/13837/0d4b3010-58a1-4279-9268-574981ca81e9.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>再看看文章详情页，整个阅读体验非常不错。</p>
<figure><img src="https://files.mdnice.com/user/13837/9d52c137-5b44-4ffe-a6a8-98df2d40f739.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>除了文章，我们还有配套的教程，目前的教程，都是楼仔的原创系列文章，让你刷得飞起，嘎嘎。。。</p>
<figure><img src="https://files.mdnice.com/user/13837/4492a683-f131-4320-b8fe-e3d5e78a567e.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>下面是个人中心，还是我喜欢的配色，如果你也喜欢写文，欢迎入驻哈，没事一起侃侃大山。</p>
<figure><img src="https://files.mdnice.com/user/13837/5b9617c7-b728-4824-9331-b538933b7e3a.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>那如何登录呢？当然是微信扫码呗，来来，一起扫一扫，公众号内输入验证码，即可登录成功，是不是很方便？</p>
<figure><img src="https://files.mdnice.com/user/13837/8d8b4592-0e64-49e7-8caf-a8386f60cb08.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>告诉你一个秘密，<strong>登录后，还会有惊喜哦</strong>，一般人我不告诉他，嘿嘿。。。</p>
<p>除了前端，我们也有自己的运营后台，文末有登录方式。</p>
<figure><img src="https://files.mdnice.com/user/13837/fbacda81-41a9-4f88-8eac-d3826828df47.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> 技术派能给你提供什么帮助呢？</h2>
<p>可能有粉丝会问 “市面上的技术网站已经很多，你们为啥还要做一个呢？”</p>
<p>其实我们做这个网站的目的，<strong>主要是为了教大家如何从 0 到 1 去构建一个商业化的社区平台</strong>，特别是对于那些缺乏项目经验，或者需要深入学习 Java 的同学。</p>
<p>下面我就给大家讲讲，技术派用到哪些牛逼的框架的技术。</p>
<p>技术派包括前台社区系统和后台管理系统，基于 SpringBoot + MyBatis Plus 实现，采用 Docker 容器化部署。</p>
<p><strong>前台社区系统</strong>包括首页门户、文章浏览、文章编辑、文章搜索、系列教程、登录鉴权、用户评论、点赞收藏、个人中心、消息通知、广告运营、粉丝管理等模块。</p>
<p><strong>后台管理系统</strong>包括数据统计、运营配置、分类管理、标签管理、文章管理、教程配置、教程文章、权限管理等模块。</p>
<p>是不是讲的太泛？给你来一张系统架构图，所有的模块和技术，都能一目了然。</p>
<figure><img src="https://files.mdnice.com/user/13837/6cfb2a84-78cd-45b6-80b3-15ab422997c4.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>再来一张业务架构图，让你对前后台模块更清晰。</p>
<figure><img src="https://files.mdnice.com/user/13837/7720af6c-2ae4-47ea-aad4-593d74347d81.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>有同学会说，楼哥，我想要更详细的模块介绍，好好学学，好嘞，下面就给安排上。</p>
<figure><img src="https://files.mdnice.com/user/13837/ac8f2050-5d19-447e-be3b-19776c11e32a.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>这个是我们的开发进度，核心功能都已完成，后面也会持续迭代。</p>
<figure><img src="https://files.mdnice.com/user/13837/86ee6878-33cf-4bc8-a746-a8648ac5256c.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>最后就是大家最关心的地方，我们的项目源码能下载么，那必须的，我们的项目完全开源！</p>
<p>对，你没有听错，文末有 GitHub 地址，大家可以自行下载。</p>
<p>同时，我们后续也会出配套的项目教程，无论你是小白，还是有一定工作经验的同学，这套教程都会帮你进阶，让你大厂 Offer 拿到手软。</p>
<p>这套教程直接对标大厂，下面是教程目录。</p>
<figure><img src="https://files.mdnice.com/user/13837/f84b0111-4cf3-41e1-a8bd-ada028071b04.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>由于出教程比较花时间，所以前期的教程，会在楼仔的公众号中连载，请大家持续关注哈。</p>
<p>最后告诉大家一个秘密，后面我们也会开通<strong>技术派的知识星球</strong>，更好去帮助大家学习这个项目，有没有亿点小期待呢？</p>
<h2> 网站地址</h2>
<p>好了，楼仔不啰嗦了，大家自己去体验下网站吧。</p>
<ul>
<li>
<p><strong>前台地址</strong>：<a href="https://paicoding.com" target="_blank" rel="noopener noreferrer">https://paicoding.com</a></p>
</li>
<li>
<p><strong>后台地址</strong>：<a href="https://paicoding.com/admin-view" target="_blank" rel="noopener noreferrer">https://paicoding.com/admin-view</a></p>
</li>
</ul>
<p>前台可以直接访问，后台需要扫描/长按下方的二维码关注「楼仔」的公众号后，<strong>回复 “001” 即可获取登录账号和密码。</strong></p>
<figure><img src="https://files.mdnice.com/user/13837/e670d6d3-b4d8-4c17-80c0-fa2dd68000e4.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>大家在体验的过程中，如果发现任何问题，都可以直接在 Github 上提交 PR，我们会定期 fix。</p>
<ul>
<li>
<p>前台社区系统 GitHub：<a href="https://github.com/itwanger/paicoding" target="_blank" rel="noopener noreferrer">https://github.com/itwanger/paicoding</a></p>
</li>
<li>
<p>后台管理系统 GitHub：<a href="https://github.com/itwanger/paicoding-admin" target="_blank" rel="noopener noreferrer">https://github.com/itwanger/paicoding-admin</a></p>
</li>
</ul>
<p>欢迎大家奔走相告，将技术派网站分享给你们的朋友，他们一定很感激你告诉他这么牛逼的学习资源。</p>
<blockquote>
<p>我从清晨走过，也拥抱夜晚的星辰，人生没有捷径，你我皆平凡，你好，陌生人，一起共勉。</p>
</blockquote>
]]></content:encoded>
      <enclosure url="http://cdn.hhui.top/column/java_cover.png" type="image/png"/>
    </item>
    <item>
      <title>关于我</title>
      <link>https://liuyueyi.github.io/tutorial/me/</link>
      <guid>https://liuyueyi.github.io/tutorial/me/</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">关于我</source>
      <description>关于我</description>
      <pubDate>Fri, 17 Feb 2023 14:22:08 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 关于我</h2>
]]></content:encoded>
    </item>
    <item>
      <title>关于我</title>
      <link>https://liuyueyi.github.io/tutorial/me/about-me.html</link>
      <guid>https://liuyueyi.github.io/tutorial/me/about-me.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">关于我</source>
      <description>1. 自我介绍 不习惯分享私人相关的，简单说几个关键点 常用名：一灰，一灰灰，一灰灰blog 性别：男 工作：8+ 履历：一线大厂、千人规模、创业团队、国企都待过 2. 有啥成就 比较惭愧，没有太大的成就，业内也不算出名，甚至是小透明 个人网站： www.hhui.top GitHub： https://github.com/liuyueyi 上架的app： https://play.google.com/store/apps/details?id=com.yhh.zhongdian 活跃网站： https://juejin.cn/user/377887729916126</description>
      <pubDate>Fri, 17 Feb 2023 14:22:08 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 1. 自我介绍</h2>
<p>不习惯分享私人相关的，简单说几个关键点</p>
<ul>
<li>常用名：一灰，一灰灰，一灰灰blog</li>
<li>性别：男</li>
<li>工作：8+</li>
<li>履历：一线大厂、千人规模、创业团队、国企都待过</li>
</ul>
<h2> 2. 有啥成就</h2>
<p>比较惭愧，没有太大的成就，业内也不算出名，甚至是小透明</p>
<ul>
<li>个人网站： <a href="www.hhui.top">www.hhui.top</a></li>
<li>GitHub： <a href="https://github.com/liuyueyi" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi</a></li>
<li>上架的app： <a href="https://play.google.com/store/apps/details?id=com.yhh.zhongdian" target="_blank" rel="noopener noreferrer">https://play.google.com/store/apps/details?id=com.yhh.zhongdian</a></li>
<li>活跃网站： <a href="https://juejin.cn/user/377887729916126" target="_blank" rel="noopener noreferrer">https://juejin.cn/user/377887729916126</a></li>
</ul>
<h2> 3. 什么时候开始的分享</h2>
<p>最早是在16、17年的时候开始在开源中国上分享一些自己的笔记，然后就一直坚持了下来，至今所有的文章加起来应该也有五六百篇了，当然其中有很多比较水；但也有不少文章是注入了心血的</p>
<p>有到我站点逛的小伙伴可能也看到了，有几个分站</p>
<ul>
<li><a href="https://blog.hhui.top" target="_blank" rel="noopener noreferrer">https://blog.hhui.top</a> ： 最早搭建的博客站点，记录的内容多，且零散，检索阅读并不友好，虽然东西很多，但是很多时候我自己都找不到，更何况其他的小伙伴呢</li>
<li><a href="https://spring.hhui.top" target="_blank" rel="noopener noreferrer">https://spring.hhui.tpp</a>： 这个站点相比于上面一个更垂直一点，全是spring相关的博文，每一篇文章都搭配有对应的项目源码，目前也在持续更新迭代中</li>
<li><a href="https://hhui.top" target="_blank" rel="noopener noreferrer">https://hhui.top</a>：主站点，为了解决上面说到的知识点分散的问题，近期我也在做知识汇总，形成一个一个专栏性质的小册，后续也会逐渐整理为pdf，供有离线学习诉求的小伙伴查阅</li>
</ul>
<h2> 4. 最近在干什么</h2>
<p>在22年中开始，和楼仔（强烈推荐关注他的公众号“楼仔”，分享的都是技术干活）凑一起搞事情，目前项目已上线，一个开源的博客论坛系统，将会围绕这个项目，出一版相关的教程，希望能基于此为各位有志于从事编程事业的小伙伴，提供一个极佳的练手项目、学习平台</p>
<ul>
<li>源码地址：<a href="https://github.com/itwanger/paicoding" target="_blank" rel="noopener noreferrer">https://github.com/itwanger/paicoding</a></li>
<li>论坛地址：<a href="https://paicoding.com/" target="_blank" rel="noopener noreferrer">https://paicoding.com/</a></li>
</ul>
<h2> 5. 有公众号么</h2>
<p>我的公众号是："一灰灰blog"， 有兴趣的小伙伴可以关注一波</p>
<figure><img src="https://spring.hhui.top/spring-blog/imgs/info/info.png" alt="一灰灰的公众号" tabindex="0" loading="lazy"><figcaption>一灰灰的公众号</figcaption></figure>
<p>我的小伙伴楼仔的公众号： "楼仔" 同时也推荐各位</p>
<figure><img src="https://files.mdnice.com/user/13837/4b47ac79-8256-47cf-ac1a-036729635246.png" alt="楼仔的公众号" tabindex="0" loading="lazy"><figcaption>楼仔的公众号</figcaption></figure>
<h2> 6. 有什么学习的资料么</h2>
<p>找楼仔，他有很多pdf</p>
<h2> 7. 有什么学习的建议么</h2>
<p>我一般做不来指路明灯，或者导师的角色；一个建议就是跟着大佬后面走</p>
<h2> 8. 怎么联系我</h2>
<ul>
<li>QQ : 3302797840</li>
<li>微信 : liuyueyi25</li>
<li>邮箱 : <a href="mailto:bangzewu@126.com">bangzewu@126.com</a></li>
<li>微博 : 一灰灰blog (基本上不活跃)</li>
</ul>
]]></content:encoded>
      <enclosure url="https://spring.hhui.top/spring-blog/imgs/info/info.png" type="image/png"/>
    </item>
    <item>
      <title>1.字符串占位替换</title>
      <link>https://liuyueyi.github.io/tutorial/java/skill/01.%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8D%A0%E4%BD%8D%E6%9B%BF%E6%8D%A2.html</link>
      <guid>https://liuyueyi.github.io/tutorial/java/skill/01.%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8D%A0%E4%BD%8D%E6%9B%BF%E6%8D%A2.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">1.字符串占位替换</source>
      <description>实战1：字符串占位替换 字符串占位替换，相信没有小伙伴是陌生的，这东西可以说是伴随着我们所有的项目工程，编码过程；别不相信，如 String.format sql参数拼接的占位 log日志输出 接下来我们看一下在我们的日常工作生涯中，经常涉及到的几种占位替换方式</description>
      <category>Java</category>
      <category>编程技巧</category>
      <pubDate>Mon, 09 Aug 2021 08:53:46 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 实战1：字符串占位替换</h1>
<p>字符串占位替换，相信没有小伙伴是陌生的，这东西可以说是伴随着我们所有的项目工程，编码过程；别不相信，如</p>
<ul>
<li>String.format</li>
<li>sql参数拼接的占位</li>
<li>log日志输出</li>
</ul>
<p>接下来我们看一下在我们的日常工作生涯中，经常涉及到的几种占位替换方式</p>
<!-- more -->
<h2> 1. String.format</h2>
<p>这种可以说是最原始最基础的方式了，基本上在最开始学习java这门语言的时候就会涉及到，语法也比较简单</p>
<p>举例如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>使用<code>%</code>来表示占位，后面跟上不同的标识符，用于限定这个占位处的参数类型</p>
<p>这种使用姿势，由jdk原生提供支持，下表为不同的转换符对应的说明</p>
<table>
<thead>
<tr>
<th>转换符</th>
<th>说明</th>
<th>参数实例</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>%s</code></td>
<td>字符串替换</td>
<td>"一灰灰"</td>
</tr>
<tr>
<td><code>%c</code></td>
<td>字符类型</td>
<td>'a'</td>
</tr>
<tr>
<td><code>%b</code></td>
<td>布尔类型</td>
<td>true/false</td>
</tr>
<tr>
<td><code>%d</code></td>
<td>整数，十进制</td>
<td>10</td>
</tr>
<tr>
<td><code>%x</code></td>
<td>整数，十六进制</td>
<td>0x12</td>
</tr>
<tr>
<td><code>%o</code></td>
<td>整数，八进制</td>
<td>012</td>
</tr>
<tr>
<td><code>%f</code></td>
<td>浮点</td>
<td>0.12f</td>
</tr>
<tr>
<td><code>%e</code></td>
<td>指数</td>
<td>2e2</td>
</tr>
<tr>
<td><code>%g</code></td>
<td>通用浮点型</td>
<td></td>
</tr>
<tr>
<td><code>%h</code></td>
<td>散列</td>
<td></td>
</tr>
<tr>
<td><code>%%</code></td>
<td>百分比</td>
<td></td>
</tr>
<tr>
<td><code>%n</code></td>
<td>换行</td>
<td></td>
</tr>
<tr>
<td><code>%tx</code></td>
<td>日期与时间类型（x代表不同的日期与时间转换符</td>
<td></td>
</tr>
</tbody>
</table>
<p>虽然上面表中列出了很多，但实际使用时，<code>%s</code>, <code>%d</code>, <code>%f</code> 这三个就足以应付绝大部分的场景了；使用姿势和上面的实例参不多，第一个参数为字符串模板，后面的可变参数为待替换的值</p>
<p>下面是在实际使用过程中的注意事项</p>
<h3> 1.1 类型不匹配</h3>
<p>上面的表中介绍了不同的转换符，要求的参数类型，如果没有对应上，会怎样</p>
<p><strong><code>%s</code>，传入非字符串类型</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>也就是说，<code>%s</code>的占位标记，传参如果不是String类型，那么实际替换的是 <code>arg.toString()</code> (所以数组输出的是地址，而list输出了内容)</p>
<p><strong><code>%d</code>，传入非整数</strong></p>
<p>与字符串的不一样的是，如果我们定义要求替换的参数类型为整数，那么传参不是整数，就会抛异常</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这两个，一个传入的参数为浮点，一个传入的是字符串，在实际替换的时候，可不会调用<code>Integer.valufOf(String.valueOf(xxx))</code>来强转，而是采用更直接的方式，抛异常</p>
<p>关键的提示信息如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>因此在实际使用这种方式进行替换时，推荐选择 <code>%s</code>，毕竟兼容性更好</p>
<h3> 1.2 参数个数不匹配</h3>
<p>我们会注意到,<code>String.format</code>接收的参数是不定长的，那么就可能存在字符串模板中预留的占位与实际传入的参数个数不匹配的场景，那么出现这种场景时，会怎样</p>
<p><strong>参数缺少</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面的例子中，模板要求两个，实际只传入一个参数，会直接抛异常<code>MissingFormatArgumentException</code></p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>参数过多</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>执行正常，多余的参数不会被替换</p>
<p>因此，我们在使用<code>String.format</code>进行字符串替换时，请确保传参不要少于实际定义的参数个数；多了还好，少了就会抛异常</p>
<h2> 2. MessageFormat</h2>
<p>上面介绍的String.format虽说简单好用，但我们用多之后，自然会遇到，一个参数，需要替换模板中多个占位的场景，针对这种场景，更友好的方式是<code>MessageFormat</code>，这个也是jdk原生提供的</p>
<p>我们来简单看一下它的使用姿势</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>使用<code>{数字}</code>来表示占位，其中数字对应的是传参的下标，因此当一个参数需要复用时，使用MessageFormat就可以比较简单的实现了，上面就是一个实例，替换之后的字符串为</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>接下来说一下它使用时的注意事项</p>
<h3> 2.1 {}成对出现</h3>
<p>如果字符串中，只出现一个<code>{</code>，而没有配套的<code>}</code>，会抛异常</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>注意上面两种case，上面一个是有<code>}</code>而缺少<code>{</code>，这样是没有问题的；而下面那个则会抛异常</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>如果字符串中却是希望输出<code>{</code>，可以使用单引号来处理</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 2.2 单引号</h3>
<p>上面提到需要转移时，可以用单引号进行处理，在字符串模板的定义中，如果有单引号，需要各位注意</p>
<p><strong>只有一个单引号，会导致后面所有占位都不生效</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面这个输出结果可能和我们实际希望的不一致</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>要解决上面这个，就是使用两个单引号</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这样输出的就是我们预期的</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 2.3 序号省略</h3>
<p>上面的定义中，已经明确要求我们在<code>{}</code>中指定参数的序号，如果模板中没有指定会怎样?</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>直接抛异常</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2> 3. 小结</h2>
<p>本文介绍的实战小技巧属于是jdk原生提供的两种实现字符串占位替换的方式，除了这两个之外，我们日常开发中还会遇到其他的占位替换方式</p>
<p>比如sql的<code>?</code>替换，mybatis中sql参数组装使用<code>${paramName}</code>，或者logback日志输出中的<code>{}</code>来表示占位，spring的@Value注解声明的配置注入方式<code>${name:defaultValue}</code>，这些也都属于占位替换的范畴，那么它们又是怎么实现的呢？</p>
]]></content:encoded>
    </item>
    <item>
      <title>2. 数组与list互转</title>
      <link>https://liuyueyi.github.io/tutorial/java/skill/02.%E6%95%B0%E7%BB%84%E4%B8%8Elist%E4%BA%92%E8%BD%AC.html</link>
      <guid>https://liuyueyi.github.io/tutorial/java/skill/02.%E6%95%B0%E7%BB%84%E4%B8%8Elist%E4%BA%92%E8%BD%AC.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">2. 数组与list互转</source>
      <description>实战2：数组与list互转 这个考题比较常见，也比较简单，难道就这也有什么可以说到的门路不成？ 接下来本文好好的说一说它的几种实现姿势，总有一款你喜欢的 1.数组转List 1.1. Array.asList 这个考题太简单了，直接使用Array.asList不就完事了么，比如 @Test public void ary2list() { String[] ary = new String[]{ &amp;quot;1&amp;quot;, &amp;quot;a&amp;quot;}; List&amp;lt;String&amp;gt; list = Arrays.asList((ary); System.out.println(list); }</description>
      <category>Java</category>
      <category>编程技巧</category>
      <pubDate>Tue, 10 Aug 2021 08:42:44 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 实战2：数组与list互转</h1>
<p>这个考题比较常见，也比较简单，难道就这也有什么可以说到的门路不成？</p>
<p>接下来本文好好的说一说它的几种实现姿势，总有一款你喜欢的</p>
<h2> 1.数组转List</h2>
<h3> 1.1. Array.asList</h3>
<p>这个考题太简单了，直接使用<code>Array.asList</code>不就完事了么，比如</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>数组转list，so easy!!!</p>
<p>真的就这么简单么？？？</p>
<p>且看下面这一段代码</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>直接抛出了异常<code>java.lang.UnsupportedOperationException</code></p>
<p>有兴趣的小伙伴可以看一下源码实现方式，通过<code>Arrays.asList</code>创建的List，虽说也命名是<code>ArrayList</code>，但是它的全路径为 <code>java.util.Arrays.ArrayList</code>， 不支持<code>add</code>, <code>remove</code>等操作（所以下次再有面试官问ArrayList的知识点时，就可以反问一句，老哥你指的是哪个ArrayList😝，逼格是不是立马拉起来）</p>
<p><strong>知识点</strong></p>
<ul>
<li>通过<code>Arrays.asList</code>创建的列表，不允许新增，删除元素；但是可以更新列表中元素的值</li>
</ul>
<h3> 1.2. new ArrayList</h3>
<p>上面的数组转list方式虽然是最简单的，但不一定是合适的，特别是当我们可能对转换后的list进行操作时，可能埋坑（而且这种坑还非常隐晦，代码层面上很难发现）</p>
<p>为了减少在代码里面下毒的可能性，不妨使用下面这种方式<code>new ArrayList&lt;&gt;(Arrays.asList(ary))</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过上面这种方式创建的List，就是我们熟知的<code>ArrayList</code>了</p>
<p><strong>避雷预警</strong></p>
<p>看到上面这个使用姿势，就很容易想到一个常见的踩雷点，比如我们的应用中，有一个全局共享的配置列表，张三需要拿id为奇数的配置，李四拿id为偶数的配置，然后他们都是这么做的</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>然后跑了一次之后发现这个全局的列表清空了，这就是典型的没有做好资源隔离的case了，针对这种场景，要么是限制使用方，直接针对全局的资源进行修改，要么就是使用方拿到的是一个隔离的备份</p>
<p><strong>禁止修改：</strong></p>
<ul>
<li>使用不可变的容器，如前面提到的<code>java.util.Arrays.ArrayList</code> ()</li>
<li>使用<code>Collections.unmodifiableList</code>创建</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>列表拷贝</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>（上面这种属于深拷贝的实现，具体可以看一下jdk的源码实现）</p>
<h3> 1.3. Collections.addAll</h3>
<p>第三种方式借助jdk提供的容器工具类<code>Collections</code>来实现</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>原则上是比较推荐这种方式来实现的，至于为啥？看下源码实现</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码的实现是不是非常眼熟，如果让我们自己来写，也差不多会写成这样吧，简单直观高效，完美</p>
<h2> 2. 列表转数组</h2>
<p>不同于数组转列表的几种玩法，列表转数组就简单多了，直接调用<code>List.toArray</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 3. 小结</h2>
<p>今天的博文主题是数组与列表的互转，虽说题目简单，但是实现方式也是多种，需要搞清楚它们之间的本质区别，一不小心就可能采坑，而最简单的地方掉坑里，往往是最难发现和爬出来的</p>
<p>核心知识点小结如下</p>
<p><strong>数组转list：</strong></p>
<ul>
<li><code>Arrays.asList(xxx)</code>：创建的是不可变列表，不能删除和新增元素</li>
<li><code>new ArrayList&lt;&gt;(Arrays.asList(xxx)</code>: 相当于用列表创建列表，属于深拷贝的一种表现，获取到的列表支持新增、删除</li>
<li>推荐写法 <code>Collections.addAll()</code></li>
</ul>
<p><strong>列表转数组</strong></p>
<ul>
<li><code>list.toArray</code>: 如果需要指定数组类型，则传参指定</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>3.字符串与容器互转</title>
      <link>https://liuyueyi.github.io/tutorial/java/skill/03.%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8E%E5%AE%B9%E5%99%A8%E4%BA%92%E8%BD%AC.html</link>
      <guid>https://liuyueyi.github.io/tutorial/java/skill/03.%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8E%E5%AE%B9%E5%99%A8%E4%BA%92%E8%BD%AC.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">3.字符串与容器互转</source>
      <description>实战3：字符串与Collection的互转 将字符串转换为List，这种业务场景可以说非常非常常见了，实现方式也比较简单 public List&amp;lt;String&amp;gt; str2list(String str, String split) { String[] cells = str.split(split); return Arrays.asList(cells); } 那么除了上面这种实现方式之外，还有其他的么？</description>
      <category>Java</category>
      <category>编程技巧</category>
      <pubDate>Wed, 11 Aug 2021 08:32:54 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 实战3：字符串与Collection的互转</h1>
<p>将字符串转换为List，这种业务场景可以说非常非常常见了，实现方式也比较简单</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>那么除了上面这种实现方式之外，还有其他的么？</p>
<!-- more -->
<h2> 1. 字符串转列表</h2>
<p>上面的实现姿势相当于字符串先转数组，然后在通过数组转列表，所以可以沿用前一篇字数组转list的几种方式</p>
<h3> 1.1. jdk支持方式</h3>
<p>借助<code>Collections.addAll</code>来实现</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这种方式适用于输出String的列表，如果我希望转成int列表呢？可以采用下面的方式</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>直接将数组转换为流，然后基于jdk8的特性，来实现转换为int列表</p>
<h3> 1.2. guava方式</h3>
<p>引入依赖</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>除了使用jdk原生的方式之外，借助guava也是非常常见的的case了，主要通过Splitter来实现，写法看起来非常秀</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>简单直接的一行代码搞定，如果我们希望是对输出的列表类型进行指定，也可以如下操作</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1.3. apache-commons</h3>
<p>引入依赖</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面流的方式就很赞了，但是注意它是有jdk版本限制的，虽说现在基本上都是1.8以上的环境进行开发，但也不排除有上古的代码，比如我现在手上的项目，spring还是3...</p>
<p>如果我们不能使用流的方式，那么有什么简单的方式来实现字符串转换为指定类型的列表么？</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这个实现也没有多优雅，不过这里有个编程小技巧可以学习，<code>new Transformer(){}</code>的传参方式，这种实现方式有点像回调的写法，虽然他们有本质的区别，此外就是jdk8之后的函数方法，就充分的体现这种设计思路，比如上面的换成jdk8的写法，直接简化为</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 2. 列表转字符串</h2>
<h3> 2.1. StringBuilder</h3>
<p>最容易想到的，直接使用StringBuilder来实现拼接</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意两点：</p>
<ul>
<li>使用StringBuilder而不是StringBuffer (why?)</li>
<li>注意最后一个拼接符号不要</li>
</ul>
<h3> 2.2. String.join</h3>
<p>一个更简单的实现方式如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当然上面这个的缺点就是列表必须是字符串列表，如果换成int列表，则不行</p>
<h3> 2.3. gauva</h3>
<p>guava也提供了列表转String的方式，同样很简单，而且还没有列表类型的限制</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 3. 小结</h2>
<p>本文的考题也非常常见，列表与字符串的互转，这里介绍了多种实现方式，有jdk原生的case（如果没有什么限制，推荐使用它， <code>String.split</code>除外，原因后面再说），如果有更高级的定制场景，如非String类型类表，则可以考虑guava的Splitter/Joinner来实现</p>
<p>在上面的实现中，也提供了几种有意思的编程方式</p>
<ul>
<li>Stream: 流，jdk8之后非常常见了</li>
<li>函数方法，回调写法case</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>4.优雅的实现字符串拼接</title>
      <link>https://liuyueyi.github.io/tutorial/java/skill/04.%E4%BC%98%E9%9B%85%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5.html</link>
      <guid>https://liuyueyi.github.io/tutorial/java/skill/04.%E4%BC%98%E9%9B%85%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">4.优雅的实现字符串拼接</source>
      <description>实战4：字符串拼接 相信没有小伙伴没有写过这样的代码，比如说现在让我们来实现一个字符串拼接的场景，怎样的实现才算是优雅的呢？</description>
      <category>Java</category>
      <category>编程技巧</category>
      <pubDate>Thu, 12 Aug 2021 07:39:11 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 实战4：字符串拼接</h1>
<p>相信没有小伙伴没有写过这样的代码，比如说现在让我们来实现一个字符串拼接的场景，怎样的实现才算是优雅的呢？</p>
<!-- more -->
<p>以将int数组转为英文逗号分隔的字符串为例进行演示</p>
<h2> 1. 实现</h2>
<h3> 1.1. 普通写法</h3>
<p>直接使用StringBuilder来拼接</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这种写法相信比较常见，相对来说不太顺眼的地方就是最后的toString，需要将最后的一个英文逗号给干掉</p>
<p>当然也可以用下面这种事前判断方式，避免最终的字符串截取</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1.2. StringJoiner</h3>
<p>上面实现中，干掉最后的一个分隔符实在不是很优雅，那么有更好一点的用法么，接下来看一下使用<code>StringJoiner</code>的方式</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>StringJoiner由jdk1.8提供，除了上面的基础玩法之外，结合jdk1.8带来的流操作方式，可以更简洁的实现</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>怎么样，上面这个实现比起前面的代码是不是要简洁多了，一行代码完事</p>
<h3> 1.3. guava joiner</h3>
<p>如果使用的jdk还不是1.8版本，不能使用上面的StringJoiner，没关系，还有guava的Joiner也可以实现</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>注意</strong></p>
<ul>
<li>接收的参数类型为: 数组/Iterable/Iterator/可变参数, 基本上可以覆盖我们日常的业务场景</li>
</ul>
<h2> 2. 小结</h2>
<p>本篇文章的主题是一个非常非常常见的字符串拼接，一般来讲，我们在做字符串拼接时，最麻烦的事情就是分隔符的处理，要么就是分隔符前置添加，每次循环都需要判断是否为开头；要么就是后置，最后取字符串时，干掉最后一个分隔符</p>
<p>本文提供了一个非常使用的方式<code>StringJoiner</code>，完全解决了上面的分隔符问题，它的使用有两种场景</p>
<ul>
<li>简单的容器转String：直接借助Stream的<code>Collectors.joining</code>来实现</li>
<li>for循环 （这种场景一般是for循环内的逻辑不仅仅包括字符串拼接，还包括其他的业务逻辑）： 循环内直接执行<code>stringJoiner.add()</code>添加</li>
</ul>
<p>对于jdk1.8及以上的版本，优先推荐使用上面说的StringJoiner来实现字符串拼接；至于jdk1.8之下，那么Guava就是一个不错的选择了，使用姿势也很很简单</p>
]]></content:encoded>
    </item>
    <item>
      <title>5.驼峰与下划线互转</title>
      <link>https://liuyueyi.github.io/tutorial/java/skill/05.%E9%A9%BC%E5%B3%B0%E4%B8%8E%E4%B8%8B%E5%88%92%E7%BA%BF%E4%BA%92%E8%BD%AC.html</link>
      <guid>https://liuyueyi.github.io/tutorial/java/skill/05.%E9%A9%BC%E5%B3%B0%E4%B8%8E%E4%B8%8B%E5%88%92%E7%BA%BF%E4%BA%92%E8%BD%AC.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">5.驼峰与下划线互转</source>
      <description>实战5：驼峰与下划线划转 这个考题非常实用，特别是对于我们这些号称只需要CURD的后端开发来说，驼峰与下划线互转，这不是属于日常任务么；一般来讲db中的列名，要求是下划线格式（why? 阿里的数据库规范是这么定义的，就我感觉驼峰也没毛病），而java实体命名则是驼峰格式，所以它们之间的互转，就必然存在一个驼峰与下划线的互转 今天我们就来看一下，这两个的互转支持方式</description>
      <category>Java</category>
      <category>编程技巧</category>
      <pubDate>Sat, 14 Aug 2021 11:17:19 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 实战5：驼峰与下划线划转</h1>
<p>这个考题非常实用，特别是对于我们这些号称只需要CURD的后端开发来说，驼峰与下划线互转，这不是属于日常任务么；一般来讲db中的列名，要求是下划线格式（why? 阿里的数据库规范是这么定义的，就我感觉驼峰也没毛病），而java实体命名则是驼峰格式，所以它们之间的互转，就必然存在一个驼峰与下划线的互转</p>
<p>今天我们就来看一下，这两个的互转支持方式</p>
<!-- more -->
<h2> 1.实现</h2>
<h3> 1.1. Gauva</h3>
<p>一般来讲遇到这种普适性的问题，大部分都是有现成的工具类可以来直接使用的；在java生态中，说到好用的工具百宝箱，guava可以说是排列靠前的</p>
<p>接下来我们看一下如何使用Gauva来实现我们的目的</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这里主要使用的是<code>CaseFormat</code>来实现互转，guava的CaseFormat还提供了其他几种方式</p>
<p>上面这个虽然可以实现互转，但是如果我们有一个字符串为 <code>helloWorld_Case</code></p>
<p>将其他转换输出结果如下:</p>
<ul>
<li>下划线：<code>hello_world__case</code></li>
<li>驼峰：<code>helloworldCase</code></li>
</ul>
<p>这种输出，和标准的驼峰/下划线不太一样了（当然原因是由于输入也不标准）</p>
<h3> 1.2. Hutool</h3>
<p>除了上面的guava，hutool的使用也非常广，其中包含很多工具类，其<code>StrUtil</code>也提供了下划线与驼峰的互转支持</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>同样的我们再来看一下特殊的case</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果如下</p>
<ul>
<li>驼峰：<code>helloworldCase</code></li>
<li>下划线: <code>hello_world_case</code></li>
</ul>
<p>相比较上面的guava的场景，下划线这个貌似还行</p>
<h3> 1.3. 自定义实现</h3>
<p>接下来为了满足我们希望转换为标砖的驼峰/下划线输出方式的需求，我们自己来手撸一个</p>
<p><strong>下划线转驼峰:</strong></p>
<ul>
<li>关键点就是找到下划线，然后去掉它，下一个字符转大写续上（如果下一个还是下划线，那继续找下一个）</li>
</ul>
<p>根据上面这个思路来实现，如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>驼峰转下划线</strong></p>
<ul>
<li>关键点：大写的，则前位补一个下划线，当前字符转小写（如果前面已经是一个下划线了，那前面不补，直接转小写即可）</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>再次测试<code>helloWorld_Case</code>，输出如下</p>
<ul>
<li>驼峰：<code>helloWorldCase</code></li>
<li>下划线: <code>hello_world_case</code></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>6.枚举的特殊用法</title>
      <link>https://liuyueyi.github.io/tutorial/java/skill/06.%E6%9E%9A%E4%B8%BE%E7%9A%84%E7%89%B9%E6%AE%8A%E7%94%A8%E6%B3%95.html</link>
      <guid>https://liuyueyi.github.io/tutorial/java/skill/06.%E6%9E%9A%E4%B8%BE%E7%9A%84%E7%89%B9%E6%AE%8A%E7%94%A8%E6%B3%95.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">6.枚举的特殊用法</source>
      <description>实战6：枚举的特殊用法 难道我们日常使用的枚举还有什么特殊的玩法不成？没错，还真有，本文主要介绍枚举的两种不那么常见的使用姿势 利用枚举来实现单例模式 利用枚举来实现策略模式</description>
      <category>Java</category>
      <category>编程技巧</category>
      <pubDate>Mon, 16 Aug 2021 09:54:23 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 实战6：枚举的特殊用法</h1>
<p>难道我们日常使用的枚举还有什么特殊的玩法不成？没错，还真有，本文主要介绍枚举的两种不那么常见的使用姿势</p>
<ul>
<li>利用枚举来实现单例模式</li>
<li>利用枚举来实现策略模式</li>
</ul>
<!-- more -->
<h2> 1. 使用场景</h2>
<h3> 1.1. 单例模式</h3>
<p>单例模式可以说是每个java开发者必须掌握的一个设计模式了，通常我们说它的实现，有饱汉式和饿汉式，也有经常说的双重判断，今天我们介绍另外一种方式，借助枚举来实现</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用枚举来实现单例模式非常非常简单，将类声明为枚举，内部只定义一个值即可</p>
<p>为什么可以这样做？</p>
<ul>
<li>枚举类不能<code>new</code>，因此保证单例</li>
<li>枚举类不能被继承</li>
<li>类不加载时，不会实例化</li>
</ul>
<p>使用枚举类创建的单例有一个好处，就是即使用反射，也无法打破它的单例性质，这是相比较于其他的实现方式的一个优点</p>
<p>那么，为啥在实际的项目中，不太常见这种写法？</p>
<ul>
<li>就我个人的一点认知（不保证准确）：这个与我们对枚举的认知有一定关系，在 《Effect in java》一书中，推荐我们使用这种方式来实现单例，但是在实际的项目开发中，我们更多的将枚举作为常量来使用，很少在枚举类中，添加复杂的业务逻辑</li>
</ul>
<h3> 1.2. 策略模式</h3>
<p>枚举除了很容易就实现上面的单例模式之外，还可以非常简单的实现策略模式</p>
<p>举一个简单的例子，我现在有一个接口，通过接受的参数，来决定最终的数据存在什么地方</p>
<p>如果按照正常的写法，可能就是很多的if/else</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这种写法虽说简单直观，但是当type类型一多了之后，这个if/else的代码行数就会很多很多了，而且看起来也不美观</p>
<p>接下来我们介绍一种利用枚举，基于策略模式的思想来解决上面的if/else问题</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的实现，主要利用的是<code>抽象类 + 枚举</code>来完成不同的策略具体实现</p>
<p>这种实现方式，相比较与前面的单例模式，还是更常见一点，虽然整体看下来没有什么难度，但是仔细看一看，会发现几个知识点</p>
<ul>
<li>抽象方法的使用 （在模板设计模式中，更能体会抽象方法的使用妙处）</li>
<li>利用枚举原生提供的<code>values()</code>，来实现遍历，找到目标</li>
</ul>
<h2> 2. 小结</h2>
<p>枚举虽然说是jdk原生提供的一个基础数据类型，但是它的使用姿势除了我们熟知的常量之外，还可以有效的运用在设计模式中，让我们的代码实现更优雅</p>
<p>比如使用枚举来实现单例模式，就不用再面对让人烦躁的双重判断/内部类的方式了</p>
<p>使用枚举的策略模式，也可以有效解决我们类中大量的if/else</p>
]]></content:encoded>
    </item>
    <item>
      <title>7.排序比较要慎重</title>
      <link>https://liuyueyi.github.io/tutorial/java/skill/07.%E6%8E%92%E5%BA%8F%E6%AF%94%E8%BE%83%E8%A6%81%E6%85%8E%E9%87%8D.html</link>
      <guid>https://liuyueyi.github.io/tutorial/java/skill/07.%E6%8E%92%E5%BA%8F%E6%AF%94%E8%BE%83%E8%A6%81%E6%85%8E%E9%87%8D.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">7.排序比较要慎重</source>
      <description>实战7：排序比较要慎重 今天介绍的又是一个非常非常基本的基本知识点，为啥要单独拎出来？还是因为这个东西虽然非常简单，但是很容易掉坑，我已经遇到几次不严谨的写法了</description>
      <category>Java</category>
      <category>编程技巧</category>
      <pubDate>Tue, 17 Aug 2021 14:22:52 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 实战7：排序比较要慎重</h1>
<p>今天介绍的又是一个非常非常基本的基本知识点，为啥要单独拎出来？还是因为这个东西虽然非常简单，但是很容易掉坑，我已经遇到几次不严谨的写法了</p>
<!-- more -->
<h2> 1.排序</h2>
<h3> 1.1. Comparator 与 Comparable</h3>
<p>输掉排序，这两个接口好像不太容易绕过去，我们简单介绍下它们的区别</p>
<ul>
<li>如果你有一个类，希望支持同类型的自定义比较策略，可以实现接口<code>Compareable</code></li>
<li>如果某个类，没有实现<code>Compareable</code>接口，但是又希望对它进行比较，则可以自自定义一个<code>Comparator</code>，来定义这个类的比较规则</li>
</ul>
<p>通过一个简单的实例进行演示说明</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的实现中，重点关注 Demo类，实现了<code>Comparable</code>接口，因此可以直接调用<code>list.sort(null)</code>来进行比较；</p>
<p>但是如果我们现在需求改变了，希望实现针对demo类的age字段，进行升序排列，那么就可以利用<code>Comparator</code>来实现了</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1.2. 踩坑预告</h3>
<p>再上面的compare方法实现中，我们可以发现里面的实现有点不太美观，我们最终的目的是什么？</p>
<ul>
<li>如果左边的小于右边的，返回 -1</li>
<li>如果左边的大于右边的，返回 0</li>
<li>如果左边的等于右边的，返回 1</li>
</ul>
<p>基于此，经常可以看到的实现如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这个实现虽然简洁了，但是有一个致命的问题，可能溢出!!!</p>
<p>所以请注意，千万千万不要用上面这种写法</p>
<p>那么有没有更优雅的方式呢？</p>
<ul>
<li>有，使用基础类的<code>compare</code>方法</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这一段代码，再jdk1.8中，可以简化为下面一句</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>再扩展一下，如果希望倒排呢？</p>
<ul>
<li>第一种实现方式，调换位置</li>
<li>Jdk1.8方式，使用负数</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 2. 小结</h2>
<p>今天主要介绍的知识点是排序，再我们日常使用中，如果一个类希望支持排序，最好的方式就是让它实现<code>Comparable</code>接口，然后自定义排序方式</p>
<p>这样再容器中，如果需要排序，直接调用 <code>list.sort(null)</code> 或者 <code>CollectionUtils.sort(list)</code></p>
<p>如果目标类没有实现排序接口，或者希望使用另外一种排序方式，则通过自定义的<code>Comparator</code>来实现</p>
<p>最后关于<code>compare</code>方法的实现，设计到两个类的比较，这种最终的落脚地，多半是基础类型的比较</p>
<ul>
<li>o1 与 o2 比较，返回负数，则最终的结果中o1再前面（即升序排列）</li>
<li>不要直接使用 <code>o1-o2</code>会溢出，推荐使用 <code>Integer.compare(o1, o2);</code></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>8.容器的初始化大小指定</title>
      <link>https://liuyueyi.github.io/tutorial/java/skill/08.%E5%AE%B9%E5%99%A8%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%A4%A7%E5%B0%8F%E6%8C%87%E5%AE%9A.html</link>
      <guid>https://liuyueyi.github.io/tutorial/java/skill/08.%E5%AE%B9%E5%99%A8%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%A4%A7%E5%B0%8F%E6%8C%87%E5%AE%9A.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">8.容器的初始化大小指定</source>
      <description>实战8：容器的初始化大小指定 容器可以说是我们日常开发中，除了基本对象之外，使用最多的类了，那么平时在使用的时候，是否有主意到良好编程习惯的大佬，在创建容器的时候，一般会设置size；那么他们为什么要这么干呢？是出于什么进行考量的呢？ 今天我们将针对最常见的List/Map/Set三种容器类型的初始化值选择，进行说明</description>
      <category>Java</category>
      <category>编程技巧</category>
      <pubDate>Wed, 18 Aug 2021 14:11:05 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 实战8：容器的初始化大小指定</h1>
<p>容器可以说是我们日常开发中，除了基本对象之外，使用最多的类了，那么平时在使用的时候，是否有主意到良好编程习惯的大佬，在创建容器的时候，一般会设置size；那么他们为什么要这么干呢？是出于什么进行考量的呢？</p>
<p>今天我们将针对最常见的List/Map/Set三种容器类型的初始化值选择，进行说明</p>
<!-- more -->
<h2> 1. 容器初始化</h2>
<h3> 1.1. List</h3>
<p>列表，在我们日常使用过程中，会接触到下面几个</p>
<ul>
<li>ArrayList: 最常见的数组列表</li>
<li>LinkedList: 基于链表的列表</li>
<li>CopyOnWriteArrayList: 线程安全的数组列表</li>
</ul>
<p>接下来逐一进行说明</p>
<h4> 1.1.1 ArrayList</h4>
<p>现在以ArrayList为例，进行源码分析，当我们不指定列表大小，直接创建时</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面是内部实现，其中<code>elementData</code>就是列表中存数据的数组，初始化为默认数组</p>
<p>当我们第一次添加一个元素时，发现数组为默认值，会触发一次数组扩容，新的数组大小为10 （详情看源码）</p>
<p>其次就是数组的库容机制，通过源码/网上分享知识点可以知道，这个扩容的实现如下</p>
<ul>
<li>当新添加的元素，数组放不下时，实现扩容</li>
<li><code>扩容后的大小</code> = <code>扩容前大小</code> + max(<code>添加元素个数</code>, 1/2 * <code>扩容前大小</code>)</li>
</ul>
<p>基于上面的知识点，大致可以得出指定列表长度的好处</p>
<ul>
<li>节省空间（用多少申请多少，避免浪费）</li>
<li>减少扩容带来的拷贝（扩容一次就会带来一次数组拷贝，如果已知列表很大，结果还使用默认的10，这会产生很多可避免的扩容开销）</li>
</ul>
<h4> 1.1.2 LinkedList</h4>
<p>基于链表的列表，不同于上面的数组列表，它没有提供指定大小的构造方法，why?</p>
<p>因为链表本身的数据结构的特点，它就像糖葫芦一样，一个串一个，有数据，才有接上的可能，因此不需要指定大小</p>
<h4> 1.1.3 CopyOnWriteArrayList</h4>
<p>这个又非常有意思，它同样不能指定大小，但是原因与前面不同，主要在于它保证线程安全的实现方式</p>
<ul>
<li>每次新增/修改(加锁，保证单线程访问)，都是在拷贝的数组操作；完成之后，用新的替换旧的</li>
</ul>
<p>所以说，每次变更，都会存在数组拷贝，因此就没有必要提前指定数组大小</p>
<p>那么它的初始化每次都使用默认的么?</p>
<p>并不是这样的，当我们已知这个列表中的值时，推荐使用下面这种方式</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>将初始化值，放在一个普通的列表中，然后利用普通列表来初始化<code>CopyOnWriteArrayList</code></li>
</ul>
<h3> 1.2.Map</h3>
<p>常见的map容器使用，大多是下面几个</p>
<ul>
<li><code>HashMap</code></li>
<li><code>LinkedHashMap</code>: 有序的hashmap</li>
<li><code>TreeMap</code>: 有序的hashmap</li>
<li><code>ConcurrentHashMap</code>: 线程安全的map</li>
</ul>
<h4> 1.2.1 HashMap</h4>
<p>HashMap的底层数据结构是 <code>数组 + 链表/红黑树</code>，关于这个就不细说了</p>
<p>我们在初始化时，若不指定size，则数组的默认长度为8（请注意，Map的数组长度是2的倍数）</p>
<p>与ArrayList的扩容时机不一样的是，默认情况下，Map容量没满就会触发一次扩容</p>
<p>默认是数量达到 <code>size * 0.75</code>(0.75为扩容因子，可以在创建时修改)，就会触发一次扩容</p>
<p>why?</p>
<ul>
<li>主要是为了减少hash冲突</li>
</ul>
<p>同样的为了减少冲突，在初始化时，我们需要指定一个合适大小</p>
<p>比如我们</p>
<ul>
<li>已知map的数量为2，这个时候Map的大小选择因该是4</li>
<li>map数量为6，这个时候Map的大小选择是16</li>
</ul>
<p>有时候让我们自己来计算这个值，就有些麻烦了，这个时候，可以直接使用Guava的工具类来完成这个目的</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4> 1.2.2 LinkedHashMap</h4>
<p>初始化方式同上，略</p>
<h4> 1.2.3 ConcurrentHashMap</h4>
<p>初始化方式同上，略</p>
<h4> 1.2.4 TreeMap</h4>
<p>不同于上面几个的是treeMap，没有提供指定容器大小的构造方法</p>
<p>原因和前面说到的LinkedList有些类似，TreeMap的底层数据结构为Tree，所以新增数据是挂在树的一个节点下面，无需指定容量大小</p>
<h3> 1.3. Set</h3>
<p>集合用的最多应该就是<code>HashSet</code>了，底层结构模型复用，所以初始化大小指定与HashMap一致，也不需要多说</p>
<h2> 2. 小结</h2>
<p>今天这篇博文主要介绍的是三种常见的容器，在创建时，如何指定容量大小</p>
<p>首先明确一点，指定容量大小是为了</p>
<ul>
<li>减少扩容带来的额外开销</li>
<li>指定容量代销，可以减少无效的内存开销</li>
</ul>
<p>初始化值设置的关键点:</p>
<ul>
<li>ArrayList: 数据有多少个，初始化值就是多少</li>
<li>HashMap: 考虑到扩容因子，初始化大小 = <code>(size / 0.75 + 1)</code></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>9.List.subList使用不当StackOverflowError</title>
      <link>https://liuyueyi.github.io/tutorial/java/skill/09.List-subList%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%BD%93StackOverflowError.html</link>
      <guid>https://liuyueyi.github.io/tutorial/java/skill/09.List-subList%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%BD%93StackOverflowError.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">9.List.subList使用不当StackOverflowError</source>
      <description>实战9：List.subList使用不当StackOverflowError 相信每个小伙伴都使用过List.subList来获取子列表，日常使用可能没啥问题，但是，请注意，它的使用，很可能一不小心就可能导致oom</description>
      <category>Java</category>
      <category>编程技巧</category>
      <pubDate>Thu, 19 Aug 2021 14:13:42 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 实战9：List.subList使用不当StackOverflowError</h1>
<p>相信每个小伙伴都使用过<code>List.subList</code>来获取子列表，日常使用可能没啥问题，但是，请注意，它的使用，很可能一不小心就可能导致oom</p>
<!-- more -->
<h2> 1.实例说明</h2>
<h3> 1.1. subList</h3>
<p>场景复现，如基于list实现一个小顶堆</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这个执行完毕之后，居然出现栈溢出</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从实现来看，感觉也没啥问题啊， 我们稍微改一下上面的返回</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>再次执行，却没有异常；所以关键点就在与</p>
<ul>
<li>list.subList的使用上</li>
</ul>
<h3> 1.2. StackOverflowError分析</h3>
<p>接下来我们主要看一下<code>list.subList</code>的实现</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面返回的子列表是ArrayList的一个内部类<code>SubList</code>，它拥有一个指向父列表的成员<code>parrent</code></p>
<p>也就是说，从源头的ArryList开始，后面每次调用<code>subList</code>，这个指代关系就深一层</p>
<p>然后它的add方法也很有意思</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>重点看 <code>parent.add(parentOffset + index, e);</code>，添加的数据实际上是加在最源头的ArrayList上的，也就是说，虽然你现在拿到的SubList，只有几个元素，但是它对应的数组，可能超乎你的想象</p>
<p>当然上面这个异常主要是以为调用栈溢出（一直往上找parent）</p>
<p>这里反应的另外一个重要问题则是内存泄漏，就不继续说了</p>
<p>如果需要解决上面这个问题，改造方法如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 2. 小结</h2>
<p>jdk提供的原生方法虽然非常好用，但是在使用的时候，也需要多家注意，一不小心就可能掉进坑里；这也告诉我们多看源码是有必要的</p>
<p>最后一句关键知识点小结：</p>
<ul>
<li><code>ArrayList.subList</code> 返回的是内部类，与原ArrayList公用一个数组，只是限定了这个数组的起始下标和结束下标而已</li>
<li>在使用<code>subList</code>，请注意是否会存在内存泄露和栈溢出的问题</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>10.不可变容器</title>
      <link>https://liuyueyi.github.io/tutorial/java/skill/10.%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%AE%B9%E5%99%A8.html</link>
      <guid>https://liuyueyi.github.io/tutorial/java/skill/10.%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%AE%B9%E5%99%A8.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">10.不可变容器</source>
      <description>实战10：不可变容器 不可变容器，看着好像在实际的业务中不怎么会用到，但实则不然，相信每个小伙伴都用过，或者看到过下面的代码 Collections.emptyList(); Collections.emptyMap(); 今天我们来介绍一下如何使用不可变容器，以及使用时的注意事项</description>
      <category>Java</category>
      <category>编程技巧</category>
      <pubDate>Fri, 20 Aug 2021 17:59:24 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 实战10：不可变容器</h1>
<p>不可变容器，看着好像在实际的业务中不怎么会用到，但实则不然，相信每个小伙伴都用过，或者看到过下面的代码</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>今天我们来介绍一下如何使用不可变容器，以及使用时的注意事项</p>
<!-- more -->
<h2> 1. 不可变容器</h2>
<h3> 1.1. JDK不可变容器</h3>
<p>java原生提供了一些不可变容器，它们最大的特点就是不支持添加、删除、修改容器内的值</p>
<p><code>Collections.emptyXxx</code>空容器</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面三个是最常用的几个了，通常当我们一个方法的返回结果定义为容器类型时，可能为了避免npe，在返回空容器时，会如此使用</p>
<p>除了上面这几个空的不可变容器之外，还有</p>
<ul>
<li><code>UnmodifiableList</code></li>
<li><code>UnmodifiableMap</code></li>
<li><code>UnmodifiableSet</code></li>
</ul>
<p>它们的使用姿势，通常是借助<code>Collections</code>来实现</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>如上面创建的List，就不支持set/remove等修改操作</p>
<p>使用不可变容容器，最大的好处就是基于它的不可修改特性，来实现公用，且不会被污染</p>
<ul>
<li>所以一个自然而然能想到的应用场景就是 <code>全局共享的配置</code></li>
</ul>
<h3> 1.2. Guava不可变容器</h3>
<p>上面是jdk提供的不可变容器，相比较与它们，在实际的项目中，使用Gauva的不可变容器的可能更多</p>
<ul>
<li><code>ImmutableXxx</code>；不可变容器</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面是最常见的三个容器对应的不可变型</p>
<p>从使用角度来看，初始化非常方便（相比较与jdk版而言）</p>
<h2> 2. 注意事项</h2>
<p>不可变容器虽好，但是使用不当也是很坑的；就我个人的一个观点</p>
<ul>
<li>如果是应用内的接口方法，容器传参，返回容器时，尽量不要使用不可变容器；因为你没办法保证别人拿到你的返回容器之后，会对它进行什么操作</li>
<li>如果是对外提供返回结果，特别是null的场景，使用不可变的空容器优于返回null</li>
<li>不可变容器，用于全局公用资源，共享配置参数；多线程的数据传递时，属于比较合适的场景</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>11.Map转换的几种方式</title>
      <link>https://liuyueyi.github.io/tutorial/java/skill/11.Map%E8%BD%AC%E6%8D%A2%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F.html</link>
      <guid>https://liuyueyi.github.io/tutorial/java/skill/11.Map%E8%BD%AC%E6%8D%A2%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">11.Map转换的几种方式</source>
      <description>实战11：Map转换Map的几种方式 在日常开发过程中，从一个Map转换为另外一个Map属于基本操作了，那么我们一般怎么去实现这种场景呢？有什么更简洁省事的方法么？</description>
      <category>Java</category>
      <category>编程技巧</category>
      <pubDate>Tue, 02 Nov 2021 19:43:19 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 实战11：Map转换Map的几种方式</h1>
<p>在日常开发过程中，从一个Map转换为另外一个Map属于基本操作了，那么我们一般怎么去实现这种场景呢？有什么更简洁省事的方法么？</p>
<!-- more -->
<h2> 1.Map互转</h2>
<h3> 1.1 实例场景</h3>
<p>现在我们给一个简单的实例</p>
<p>希望将一个<code>Map&lt;String, Integer&gt;</code> 转换成 <code>Map&lt;String, String&gt;</code>，接下来看一下有哪些实现方式，以及各自的优缺点</p>
<p>首先提供一个创建Map的公共方法</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 1.1.1 基本的for循环转换</h4>
<p>这种方式是最容易想到和实现的，直接for循环来转换即可</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这种方式的优点很明显，实现容易，业务直观；</p>
<p>缺点就是可复用性较差，代码量多（相比于下面的case）</p>
<h4> 1.1.2 容器的流式使用</h4>
<p>在jdk1.8提供了流式操作，同样也可以采用这种方式来实现转换</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用stream的方式，优点就是链式，代码量少；缺点是相较于上面的阅读体验会差一些（当然这个取决于个人，有些小伙伴就更习惯看这种链式的代码）</p>
<h4> 1.1.3 Guava的trasform方式</h4>
<p>从代码层面来看，上面两个都不够直观，如果对guava熟悉的小伙伴对下面的代码可能就很熟悉了</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>核心逻辑就一行 <code>Maps.transformValues(map, String::valueOf)</code>，实现了我们的Map转换的诉求</p>
<p>很明显，这种方式的优点就是间接、直观；当然缺点就是需要引入guava，并且熟悉guava</p>
<h3> 1.2 最后一问，这篇文章目的是啥？</h3>
<p>既然我们的标题是实战小技巧，本文除了给大家介绍可以使用guava的<code>Maps.transformValues</code>来实现map转换之外，更主要的一个目的是如果让我们自己来实现一个工具类，来支持这个场景，应该怎么做？</p>
<p>直接提供一个转换方法？</p>
<p><strong>第一步：一个泛型的转换接口</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>定义上面这个接口之后，自然而然想到的缺点就是差一个value的转换实现</p>
<p><strong>第二步：value转换的定义</strong></p>
<p>这里采用Function接口思想来定义转换类</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>当然到这里我们就需要注意jdk1.8以下是不支持函数编程的，那么我们可以怎么来实现呢？</p>
<p>这个时候再对照一下guava的实现，然后再手撸一个，知识点就到手了</p>
]]></content:encoded>
    </item>
    <item>
      <title>12.巧用函数方法实现二维数组遍历</title>
      <link>https://liuyueyi.github.io/tutorial/java/skill/12.%E5%B7%A7%E7%94%A8%E5%87%BD%E6%95%B0%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E9%81%8D%E5%8E%86.html</link>
      <guid>https://liuyueyi.github.io/tutorial/java/skill/12.%E5%B7%A7%E7%94%A8%E5%87%BD%E6%95%B0%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E9%81%8D%E5%8E%86.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">12.巧用函数方法实现二维数组遍历</source>
      <description>实战12：巧用函数方法实现二维数组遍历 对于数组遍历，基本上每个开发者都写过，遍历本身没什么好说的，但是当我们在遍历的过程中，有一些复杂的业务逻辑时，将会发现代码的层级会逐渐加深</description>
      <category>Java</category>
      <category>编程技巧</category>
      <pubDate>Tue, 09 Aug 2022 18:35:40 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 实战12：巧用函数方法实现二维数组遍历</h1>
<p>对于数组遍历，基本上每个开发者都写过，遍历本身没什么好说的，但是当我们在遍历的过程中，有一些复杂的业务逻辑时，将会发现代码的层级会逐渐加深</p>
<!-- more -->
<p>如一个简单的case，将一个二维数组中的偶数找出来，保存到一个列表中</p>
<p>二维数组遍历，每个元素判断下是否为偶数，很容易就可以写出来，如</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这个实现没啥问题，但是这个代码的深度很容易就有三层了；当上面这个if中如果再有其他的判定条件，那么这个代码层级很容易增加了；二维数组还好，如果是三维数组，一个遍历就是三层；再加点逻辑，四层、五层不也是分分钟的事情么</p>
<p>那么问题来了，代码层级变多之后会有什么问题呢？</p>
<blockquote>
<p>只要代码能跑，又能有什么问题呢？！</p>
</blockquote>
<h2> 1. 函数方法消减代码层级</h2>
<p>由于多维数组的遍历层级天然就很深，那么有办法进行消减么？</p>
<p>要解决这个问题，关键是要抓住重点，遍历的重点是什么？获取每个元素的坐标！那么我们可以怎么办？</p>
<blockquote>
<p>定义一个函数方法，输入的就是函数坐标，在这个函数体中执行我们的遍历逻辑即可</p>
</blockquote>
<p>基于上面这个思路，相信我们可以很容易写一个二维的数组遍历通用方法</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>主要上面的实现，函数方法直接使用了JDK默认提供的BiConsumer，两个传参，都是int 数组下表；无返回值</p>
<p>那么上面这个怎么用呢？</p>
<p>同样是上面的例子，改一下之后，如</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>相比于前面的，貌似也就少了一层而已，好像也没什么了不起的</p>
<p>但是，当数组变为三维、四维、无维时，这个改动的写法层级都不会变哦</p>
<h2> 2. 遍历中return支持</h2>
<p>前面的实现对于正常的遍历没啥问题；但是当我们在遍历过程中，遇到某个条件直接返回，能支持么？</p>
<p>如一个遍历二维数组，我们希望判断其中是否有偶数，那么可以怎么整？</p>
<p>仔细琢磨一下我们的scan方法，希望可以支持return，主要的问题点就是这个函数方法执行之后，我该怎么知道是继续循环还是直接return呢?</p>
<p>很容易想到的就是执行逻辑中，添加一个额外的返回值，用于标记是否中断循环直接返回</p>
<p>基于此思路，我们可以实现一个简单的demo版本</p>
<p>定义一个函数方法，接受循环的下标 + 返回值</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>循环通用方法就可以相应的改成</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>基于上面这种思路，我们的实际使用姿势如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这个实现可满足我们的需求，唯一有个别扭的地方就是返回，总有点不太优雅；那么除了这种方式之外，还有其他的方式么？</p>
<p>既然考虑了返回值，那么再考虑一下传参呢？通过一个定义的参数来装在是否中断以及返回结果，是否可行呢？</p>
<p>基于这个思路，我们可以先定义一个参数包装类</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们希望通过Ans这个类来记录循环结果，其中tag=true，则表示不用继续循环了，直接返回ans结果吧</p>
<p>与之对应的方法改造及实例如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样看起来就比前面的要好一点了</p>
<p>实际跑一下，看下输出是否和我们预期的一致；</p>
<figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/546a699ae4334df4b6525332da4e5770~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure>
]]></content:encoded>
      <enclosure url="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/546a699ae4334df4b6525332da4e5770~tplv-k3u1fbpfcp-watermark.image?" type="image/"/>
    </item>
    <item>
      <title>13.List转Map List的几种姿势</title>
      <link>https://liuyueyi.github.io/tutorial/java/skill/13.List%E8%BD%ACMap-List%E7%9A%84%E5%87%A0%E7%A7%8D%E5%A7%BF%E5%8A%BF.html</link>
      <guid>https://liuyueyi.github.io/tutorial/java/skill/13.List%E8%BD%ACMap-List%E7%9A%84%E5%87%A0%E7%A7%8D%E5%A7%BF%E5%8A%BF.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">13.List转Map List的几种姿势</source>
      <description>实战13：List转Map List的几种姿势 今天介绍一个实用的小知识点，如何将List转为Map&amp;lt;Object, List&amp;lt;Object&amp;gt;&amp;gt;</description>
      <category>Java</category>
      <category>编程技巧</category>
      <pubDate>Tue, 17 May 2022 19:44:20 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 实战13：List转Map List的几种姿势</h1>
<p>今天介绍一个实用的小知识点，如何将List转为<code>Map&lt;Object, List&lt;Object&gt;&gt;</code></p>
<!-- more -->
<h2> 1. 转换方式</h2>
<h3> 1.1. 基本写法</h3>
<p>最开始介绍的当然是最常见、最直观的写法，当然也是任何限制的写法</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对于jdk8+，上面for循环中的内容可以利用<code>Map.computeIfAbsent</code>来替换，具体写法如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当然既然已经是jdk1.8了，借助Stream的流处理，可以将上面的更一步进行简化，如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 1.2. 通用方法</h3>
<p>上面是针对特定的列表，针对业务进行开发转换，那么我们接下来尝试构建一个通用的工具类</p>
<p>这里我们主要借助的知识点就是泛型，一个重要的点就是如何获取Map中的key</p>
<p>对于jdk &lt; 1.8的写法，通过接口来定义实现key的获取姿势</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用demo如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来再看一下jdk1.8之后的写法，结合stream + 函数方法来实现</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其对应的使用方式则如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1.3. 工具类</h3>
<p>上一节介绍了基于泛型 + jdk8 Stream + 函数方法来实现通用转换工具类的实现姿势，接下来我们小结一下，输出一个适用于1.8之后的工具类</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1.4.guava HashMultimap扩展知识点</h3>
<p>最后再介绍一个扩展知识点，Gauva工具包中提供了一个<code>HashMultimap</code>的工具类，他的使用姿势和我们平常的Map并无差别，但是需要在注意的是，它的value是个集合</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>实际输出如下，验证了value实际上是个集合（on只有一个，如果是我们上面的工具类，会输出两个）</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>14.分页遍历的两种使用姿势</title>
      <link>https://liuyueyi.github.io/tutorial/java/skill/14.%E5%88%86%E9%A1%B5%E9%81%8D%E5%8E%86%E7%9A%84%E4%B8%A4%E7%A7%8D%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF.html</link>
      <guid>https://liuyueyi.github.io/tutorial/java/skill/14.%E5%88%86%E9%A1%B5%E9%81%8D%E5%8E%86%E7%9A%84%E4%B8%A4%E7%A7%8D%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">14.分页遍历的两种使用姿势</source>
      <description>实战14：分页遍历得两种实现策略 在日常开发中，分页遍历迭代的场景可以说非常普遍了，比如扫表，每次捞100条数据，然后遍历这100条数据，依次执行某个业务逻辑；这100条执行完毕之后，再加载下一百条数据，直到扫描完毕 那么要实现上面这种分页迭代遍历的场景，我们可以怎么做呢 本文将介绍两种使用姿势 常规的使用方法 借助Iterator的使用姿势</description>
      <category>Java</category>
      <category>JDK</category>
      <pubDate>Thu, 25 Feb 2021 08:05:07 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 实战14：分页遍历得两种实现策略</h1>
<p>在日常开发中，分页遍历迭代的场景可以说非常普遍了，比如扫表，每次捞100条数据，然后遍历这100条数据，依次执行某个业务逻辑；这100条执行完毕之后，再加载下一百条数据，直到扫描完毕</p>
<p>那么要实现上面这种分页迭代遍历的场景，我们可以怎么做呢</p>
<p>本文将介绍两种使用姿势</p>
<ul>
<li>常规的使用方法</li>
<li>借助Iterator的使用姿势</li>
</ul>
<!-- more -->
<h2> 1. 实现方式</h2>
<h3> 1.1. 数据查询模拟</h3>
<p>首先mock一个分页获取数据的逻辑，直接随机生成数据，并且控制最多返回三页</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1.2. 基本实现方式</h3>
<p>针对这种场景，最常见也是最简单直观的实现方式</p>
<ul>
<li>while死循环</li>
<li>内部遍历</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1.3. 迭代器实现方式</h3>
<p>接下来介绍一种更有意思的方式，借助迭代器的遍历特性来实现，首先自定义一个通用分页迭代器</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来借助上面的迭代器可以比较简单的实现我们的需求了</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>那么问题来了，上面这种使用方式比前面的优势体现再哪儿呢？</p>
<ul>
<li>双层循环改为单层循环</li>
</ul>
<p>接下来接入重点了，在jdk1.8引入了函数方法 + lambda之后，又提供了一个更简洁的使用姿势</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在jdk1.8及之后的使用姿势，一行代码即可</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这次对比效果是不是非常显眼了，从此以后分页迭代遍历再也不用冗长的双重迭代了</p>
]]></content:encoded>
    </item>
    <item>
      <title>15.数组拷贝</title>
      <link>https://liuyueyi.github.io/tutorial/java/skill/15.%E6%95%B0%E7%BB%84%E6%8B%B7%E8%B4%9D.html</link>
      <guid>https://liuyueyi.github.io/tutorial/java/skill/15.%E6%95%B0%E7%BB%84%E6%8B%B7%E8%B4%9D.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">15.数组拷贝</source>
      <description>实战15：数组拷贝 说实话，在实际的业务开发中，基本上很少很少很少...会遇到数组拷贝的场景，甚至是我们一般都不怎么用数组，List它不香嘛，为啥要用数组 现在问题来了，要实现数组拷贝，怎么整？</description>
      <category>Java</category>
      <category>编程技巧</category>
      <pubDate>Sat, 21 Aug 2021 06:56:34 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 实战15：数组拷贝</h1>
<p>说实话，在实际的业务开发中，基本上很少很少很少...会遇到数组拷贝的场景，甚至是我们一般都不怎么用数组，List它不香嘛，为啥要用数组</p>
<p>现在问题来了，要实现数组拷贝，怎么整？</p>
<!-- more -->
<h2> 1. 实现方式</h2>
<h3> 1.1. 基础写法</h3>
<p>最简单直接的写法，那就是新建一个数组，一个一个拷贝进去，不就完事了么</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1.2. 借用容器中转</h3>
<p>数组用起来有点麻烦，还是用容器舒爽，借助List来实现数组的拷贝，也就几行代码</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1.3. Array.copy</h3>
<p>上面这个有点绕得远了， 直接使用Array.copy</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1.4. System.arraycopy</h3>
<p>除了上面的，还可以使用更基础的用法</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果有看过jdk源码的小伙伴，上面这个用法应该不会陌生，特别是在容器类，这种数组拷贝的方式比比可见</p>
<p>参数说明:</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>src : 原数组</li>
<li>srcPos: 原数组用于拷贝的起始下标</li>
<li>dest: 拷贝后的数组</li>
<li>destPos: 目标数组的小标</li>
<li>length: 原数组中拷贝过去的数组长度</li>
</ul>
<p>从上面的描述也能看出来，这个方法不仅能实现数组拷贝，还可以实现数组内指定片段的拷贝</p>
]]></content:encoded>
    </item>
    <item>
      <title>16.如何判断类为基础类型or基础类型的包装类</title>
      <link>https://liuyueyi.github.io/tutorial/java/skill/16.%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E7%B1%BB%E4%B8%BA%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8Bor%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8C%85%E8%A3%85%E7%B1%BB.html</link>
      <guid>https://liuyueyi.github.io/tutorial/java/skill/16.%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E7%B1%BB%E4%B8%BA%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8Bor%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8C%85%E8%A3%85%E7%B1%BB.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">16.如何判断类为基础类型or基础类型的包装类</source>
      <description>实战16：判断类为基础类型or基础类型的包装类 判断一个类是否为基础类型属于常规操作了，一般我们遇到这种case，要怎么处理呢？ 一个一个的if/else判断? 还是其他的操作姿势？</description>
      <category>Java</category>
      <category>编程技巧</category>
      <pubDate>Fri, 03 Sep 2021 19:36:52 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 实战16：判断类为基础类型or基础类型的包装类</h1>
<p>判断一个类是否为基础类型属于常规操作了，一般我们遇到这种case，要怎么处理呢？</p>
<p>一个一个的if/else判断? 还是其他的操作姿势？</p>
<!-- more -->
<h2> 1. 基础类型判断</h2>
<p>基础类型可以借助class类的<code>isPrimitive</code>方法来实现判定，使用姿势也简单</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>如果返回true，那么这个对象就是基本类型</p>
<ul>
<li>boolean</li>
<li>char</li>
<li>byte</li>
<li>short</li>
<li>int</li>
<li>long</li>
<li>float</li>
<li>double</li>
<li>void</li>
</ul>
<p>但是请注意，对于封装类型，比如Long，访问isPrimitive返回的是false</p>
<h2> 2. 封装类型判断</h2>
<p>那么封装类型可以怎么判断呢？难道一个一个的判定不成？</p>
<p>首先我们注意到<code>Class#isPrimitive</code>的方法签名，如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的注释中，提到了Boolean#Type之类的静态成员，也就是说包装类型，都有一个TYPE的静态成员</p>
<p>比如boolean的是这个</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>所以我们可以通过这个TYPE来判定，当前对象是否为封装对象</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果Class对象没有TYPE字段，那么就不是封装类，直接抛异常，返回false；当然这种通过异常的方式来判定，并不优雅；但是写法上比我们一个一个的if/else进行对比，要好得多了</p>
]]></content:encoded>
    </item>
    <item>
      <title>17.Java对象内存地址输出</title>
      <link>https://liuyueyi.github.io/tutorial/java/skill/17.Java%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80%E8%BE%93%E5%87%BA.html</link>
      <guid>https://liuyueyi.github.io/tutorial/java/skill/17.Java%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80%E8%BE%93%E5%87%BA.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">17.Java对象内存地址输出</source>
      <description>实战17：Java对象内存地址输出 输出对象地址 当一个对象没有重写hascode方法时，它返回的内存地址，当覆盖之后，我们有什么办法获取对象的内存地址么? 使用 System.identityHashCode() 输出内存地址</description>
      <category>Java</category>
      <category>JDK</category>
      <pubDate>Fri, 29 Jan 2021 10:37:36 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 实战17：Java对象内存地址输出</h1>
<h2> 输出对象地址</h2>
<p>当一个对象没有重写<code>hascode</code>方法时，它返回的内存地址，当覆盖之后，我们有什么办法获取对象的内存地址么?</p>
<ul>
<li>使用 <code>System.identityHashCode()</code> 输出内存地址</li>
</ul>
<!-- more -->
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果如:</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这个有啥用？</p>
<ul>
<li>判断两个对象是否为同一个对象时，可以借用（我是在验证Mybatis的一级缓存的，判断返回的Entity是否确实是同一个的时候以此来判定的）</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>18.随机数生成怎么选</title>
      <link>https://liuyueyi.github.io/tutorial/java/skill/18.%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%94%9F%E6%88%90%E6%80%8E%E4%B9%88%E9%80%89.html</link>
      <guid>https://liuyueyi.github.io/tutorial/java/skill/18.%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%94%9F%E6%88%90%E6%80%8E%E4%B9%88%E9%80%89.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">18.随机数生成怎么选</source>
      <description>实战18：随机数生成怎么选 随机数生成，java中有一个专门的Random类来实现，除此之外，使用Math.random的也比较多，接下来我们简单学习下，随机数的使用姿势</description>
      <category>Java</category>
      <category>编程技巧</category>
      <pubDate>Fri, 03 Sep 2021 19:40:13 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 实战18：随机数生成怎么选</h1>
<p>随机数生成，java中有一个专门的Random类来实现，除此之外，使用<code>Math.random</code>的也比较多，接下来我们简单学习下，随机数的使用姿势</p>
<!-- more -->
<h2> 1.随机数生成</h2>
<h3> 1.1. Math.random</h3>
<p>jdk提供的基础工具类Math中封装一些常用的基础方法，比如我们今天的主题，生成随机数，使用姿势如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>使用起来比较简单，生成的是[0,1)之间的浮点数，但是不要以为它就真的只能生成0-1之间的随机数，举例如下</p>
<p>如果想利用它，生成一个 <code>[120, 500]</code> 这个区间的随机数，怎么整？</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>为啥上面的可行？</p>
<p>将上面的代码翻译一下，取值区间如</p>
<p><code>Math.random() * 381 + 120</code> 取值范围如下</p>
<ul>
<li>[0, 1) * 381 + 120</li>
<li>[0, 381) + 120</li>
<li>[120, 501)</li>
</ul>
<p>借助<code>Math.ceil</code>只取浮点数中的整数部分，这样我们的取值范围就是 [120, 500]了，和我们的预期一致</p>
<p>最后简单来看下，<code>Math.random()</code>是怎么实现随机数的</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>请注意上面的实现，原来底层依然使用的是<code>Random</code>类来生成随机数，而且上面这种写法属于非常经典的单例模式写法（不同于我们常见的双重判定方式，这种属于内部类的玩法，后面再说为啥可以这么用）</p>
<h3> 1.2. Random</h3>
<p>除了使用上面的Math.random来获取随机数之外，直接使用Random类也是很常见的case；接下来先简单看一下Random的使用姿势</p>
<p><strong>创建Random对象</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>生成随机数</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>伪随机高斯分布双精度数</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>随机类的nextGaussian()方法返回下一个伪随机数，即与随机数生成器序列的平均值为0.0，标准差为1.0的高斯(正态)分布双精度值</p>
<p>这种使用场景可能用在更专业的场景，至少我接触过的业务开发中，没有用过这个😂</p>
<h3> 1.3. Math.random 与 Random如何选</h3>
<p>上面两个都可以用来生成随机数，那么在实际使用的时候，怎么选择呢？</p>
<p>从前面的描述也可以知道，它们两没啥本质区别，底层都是用的Random类，在实际的运用过程中，如果我们希望可以场景复现，比如测试中奖概率的场景下，选择Random类，指定随机种子可能更友好；如果只是简单的随机数生成使用，那么选择<code>Math.random</code>即可，至少使用起来一行代码即可</p>
]]></content:encoded>
    </item>
    <item>
      <title>19.数字格式化</title>
      <link>https://liuyueyi.github.io/tutorial/java/skill/19.%E6%95%B0%E5%AD%97%E6%A0%BC%E5%BC%8F%E5%8C%96.html</link>
      <guid>https://liuyueyi.github.io/tutorial/java/skill/19.%E6%95%B0%E5%AD%97%E6%A0%BC%E5%BC%8F%E5%8C%96.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">19.数字格式化</source>
      <description>实战19：数字格式化 数字的格式化场景，更多的是在日志输出、金额计算相关的领域中会用到，平常我们可能更多使用String.format来格式化，但是请注意，数字格式化是有一个DecimalFormat，专门来针对数字进行格式化 今天我们的知识点就是DecimalFormat来实现数字格式化</description>
      <category>Java</category>
      <category>编程技巧</category>
      <pubDate>Wed, 25 Aug 2021 19:12:33 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 实战19：数字格式化</h1>
<p>数字的格式化场景，更多的是在日志输出、金额计算相关的领域中会用到，平常我们可能更多使用<code>String.format</code>来格式化，但是请注意，数字格式化是有一个<code>DecimalFormat</code>，专门来针对数字进行格式化</p>
<p>今天我们的知识点就是DecimalFormat来实现数字格式化</p>
<!-- more -->
<h2> 1. 格式化</h2>
<h3> 1.1. DecimalFormat使用说明</h3>
<p>对于DecimalFormat的使用比较简单，主要是借助两个占位<code>0</code>与<code>#</code>，区别在于当格式化的占位数，多余实际数的时候，占位<code>0</code>的场景下，会用前缀0来补齐；而<code>#</code>则不需要补齐</p>
<p>上面这个可能不太好理解，举例说明如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面两个都是只输出整数，但是输出结果不同，如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>简单来说，就是<code>0</code>，主要用于定长的输出，对于不足的，前缀补0</p>
<p><strong>整数#小数</strong></p>
<p>除了上面的基本姿势之外，更常见的是设置整数、小数的位数</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>百分比</strong></p>
<p>百分比的输出也属于常见的case，使用DecimalFormat就很简单</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>输出如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>科学计数</strong></p>
<p>非专业场景下，科学技术的可能性比较小</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>金钱样式输出</strong></p>
<p>金融相关的钱输出时，非常有意思的是每三位加一个逗号分隔，如果想实现这个效果，也可以很简单完成</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>嵌入模板输出</strong></p>
<p>格式化模板，除了基础的<code>000, ###</code>之外，还可以直接放在一个字符串中，实现类似<code>String.format</code>的效果</p>
<p>比如显示余额</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>20.进制转换很简单</title>
      <link>https://liuyueyi.github.io/tutorial/java/skill/20.%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2%E5%BE%88%E7%AE%80%E5%8D%95.html</link>
      <guid>https://liuyueyi.github.io/tutorial/java/skill/20.%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2%E5%BE%88%E7%AE%80%E5%8D%95.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">20.进制转换很简单</source>
      <description>实战20：进制转换很简单 进制转换，属于基本技能了，在java中要实现进制转换很简单，可以非常简单的实现，接下来我们来看下它的使用姿势</description>
      <category>Java</category>
      <category>编程技巧</category>
      <pubDate>Thu, 26 Aug 2021 18:24:38 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 实战20：进制转换很简单</h1>
<p>进制转换，属于基本技能了，在java中要实现进制转换很简单，可以非常简单的实现，接下来我们来看下它的使用姿势</p>
<!-- more -->
<h2> 1. 进制转换</h2>
<h3> 1.1. toString实现进制转换</h3>
<p>Integer/Long#toString(int i, int radix) 可以将任一进制的整数，转换为其他任意进制的整数</p>
<ul>
<li>第一个参数：待转换的数字</li>
<li>第二个参数：转换后的进制位</li>
</ul>
<p><strong>十六进制转十进制</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>八进制转是十进制</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>八进制转二进制</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 1.2. 十进制转二进制</h3>
<p>除了使用上面的姿势之外，可以直接使用<code>toBinaryString</code>来实现转二进制</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1.3. 十进制转八进制</h3>
<p><code>Integer/Long#toOctalString</code>: 转八进制</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 1.4. 十进制转十六进制</h3>
<p><code>Integer/Long#toHexString</code>: 转十六进制</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>21.配置文件Properties</title>
      <link>https://liuyueyi.github.io/tutorial/java/skill/21.%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6Properties.html</link>
      <guid>https://liuyueyi.github.io/tutorial/java/skill/21.%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6Properties.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">21.配置文件Properties</source>
      <description>实战21：Properties配置文件 properties配置文件，相信各位小伙伴都不会太陌生，常用Spring的可能会经常看到它，虽说现在更推荐的是使用Yaml配置文件，但是properties配置文件的使用频率也不低 在jdk中有一个直接关连的类Properties，接下来我们来看一下它的用法</description>
      <category>Java</category>
      <category>编程技巧</category>
      <pubDate>Mon, 30 Aug 2021 09:34:18 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 实战21：Properties配置文件</h1>
<p>properties配置文件，相信各位小伙伴都不会太陌生，常用Spring的可能会经常看到它，虽说现在更推荐的是使用Yaml配置文件，但是properties配置文件的使用频率也不低</p>
<p>在jdk中有一个直接关连的类Properties，接下来我们来看一下它的用法</p>
<!-- more -->
<h2> 1. Properties配置类</h2>
<h3> 1.1. 配置文件</h3>
<p>properties文件的格式比较简单</p>
<ul>
<li><code>key = value</code>: 等号左边的为配置key，右边的为配置value（value值会去除前后的空格）</li>
<li><code>#</code>：以<code>#</code>来区分注释</li>
</ul>
<p>一个基础的配置文件如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1.2. 配置文件加载</h3>
<p>对于Properties配置文件，我们可以非常简单的借助<code>Properties</code>类，来实现配置的加载</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>直接使用<code>Properties#config</code>就可以读取配置文件内容，并赋值到java对象</p>
<p><strong>重点注意：</strong></p>
<p>重点看一下Properties类的继承关系，它的父类是Hashtable, 也就是说它的本质是Map对象</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1.3. Properties对象使用</h3>
<p>因为<code>Properties</code>是继承自Hashtable，而Hashtable是线程安全的Map容器，因此Properties也是线程安全的，同样的，在多线程并发获取配置的时候，它的性能表现也就不咋地了，why?</p>
<p>首先看一下配置获取</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面两个方法的使用频率很高，从签名上也很容易知道使用姿势；接下来需要看一下的为啥说并发效率很低</p>
<p>关键点就在第一个方法的<code>super.get()</code>，它对应的源码正是</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>方法签名上有<code>synchronized</code>，所以为啥说并发环境下的性能表现不会特别好也就知道原因了</p>
<p>除了获取配置之外，另外一个常用的就是更新配置</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 2. 小结</h2>
<p>本文介绍的知识点主要是properties配置文件的处理，使用同名的java类来操作；需要重点注意的是Properties类属于Hashtable的子类，同样属于容器的范畴</p>
<p>最后提一个扩展的问题，在SpringBoot的配置自动装载中，可以将配置内容自动装载到配置类中，简单来讲就是支持配置到java bean的映射，如果现在让我们来实现这个，可以怎么整？</p>
]]></content:encoded>
    </item>
    <item>
      <title>22.Properties配置文件自动装载JavaBean</title>
      <link>https://liuyueyi.github.io/tutorial/java/skill/22.Properties%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%87%AA%E5%8A%A8%E8%A3%85%E8%BD%BDJavaBean.html</link>
      <guid>https://liuyueyi.github.io/tutorial/java/skill/22.Properties%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%87%AA%E5%8A%A8%E8%A3%85%E8%BD%BDJavaBean.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">22.Properties配置文件自动装载JavaBean</source>
      <description>实战22：Properties配置文件自动装载JavaBean SpringBoot的配置自动装载，使用起来还是很舒爽的，可以非常简单的将properties配置文件的内容，填充到Java bean对象中，如果我们现在是一个脱离于Springboot框架的项目，想实现上面这个功能，可以怎么来做呢？</description>
      <category>Java</category>
      <category>编程技巧</category>
      <pubDate>Fri, 03 Sep 2021 19:38:55 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 实战22：Properties配置文件自动装载JavaBean</h1>
<p>SpringBoot的配置自动装载，使用起来还是很舒爽的，可以非常简单的将properties配置文件的内容，填充到Java bean对象中，如果我们现在是一个脱离于Springboot框架的项目，想实现上面这个功能，可以怎么来做呢？</p>
<!-- more -->
<h2> 1.配置封装</h2>
<h3> 1.1. 配置文件自动装载</h3>
<p>前面介绍了Properties文件的读取以及基本使用姿势，通过上篇博文已知Properties类的本质是一个Map，所以我们需要干的就是将Map容器的值，赋值到JavaBean的成员属性中</p>
<p>要实现这个功能，自然而然会想到的就是利用反射（考虑到我们赋值的通常为标准的java bean，使用内省是个更好的选择）</p>
<p>接下来我们需要实现的也比较清晰了，第一步获取成员属性，两种方式</p>
<ul>
<li>内省: <code>BeanInfo bean = Introspector.getBeanInfo(clz); PropertyDescriptor[] propertyDescriptors = bean.getPropertyDescriptors();</code></li>
<li>反射: <code>Field[] fields = clz.getDeclaredFields();</code></li>
</ul>
<p>第二步遍历成员属性，进行赋值</p>
<ul>
<li>内省：借助前面获取的<code>PropertyDescriptor</code>对象，拿到set方法，进行赋值
<ul>
<li><code>descriptor.getWriteMethod().invoke(obj, value)</code></li>
</ul>
</li>
<li>反射：适应<code>Field.set</code>来赋值
<ul>
<li><code>field.set(obj, value);</code></li>
</ul>
</li>
</ul>
<p><strong>注意</strong></p>
<ul>
<li>上面的两种赋值方式，都要求我们传入的value对象类型与定义类型一直，否则会抛类型转换异常</li>
</ul>
<p>为了避免复杂的类型转换与判定，我们这里介绍下apache的<code>commons-beanutils</code>来实现属性拷贝</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来核心的实现逻辑如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意上面的实现，首先通过内省的方式获取所有的成员，然后进行遍历，借助<code>BeanUtils.setProperty</code>来实现属性值设置</p>
<p>这里面有两个知识点</p>
<ul>
<li><code>BeanUtil</code> 还是 <code>PropertyUtil</code>
<ul>
<li>它们两都有个设置属性的方法，但是BeanUtil支持简单类型的自动转换；而后者不行，要求类型完全一致</li>
</ul>
</li>
<li>非简单类型
<ul>
<li>对于非简单类型，上面采用了递归的调用方式来处理；请注意，这里并不完善，比如BigDecimal, Date, List, Map这些相对基础的类型，是不太适用的哦</li>
</ul>
</li>
</ul>
<h3> 1.2. 功能测试</h3>
<p>最后针对上面的实现功能，简单的测试一下，是否可行</p>
<p>配置文件<code>mail.properties</code></p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>两个Java Bean</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>转换测试类</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果如下：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>23.基于引入包选择具体实现类</title>
      <link>https://liuyueyi.github.io/tutorial/java/skill/23.%E5%9F%BA%E4%BA%8E%E5%BC%95%E5%85%A5%E5%8C%85%E9%80%89%E6%8B%A9%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0%E7%B1%BB.html</link>
      <guid>https://liuyueyi.github.io/tutorial/java/skill/23.%E5%9F%BA%E4%BA%8E%E5%BC%95%E5%85%A5%E5%8C%85%E9%80%89%E6%8B%A9%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0%E7%B1%BB.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">23.基于引入包选择具体实现类</source>
      <description>实战23：基于引入包选择具体实现类 最近遇到一个需求场景，开源的工具包，新增了一个高级特性，会依赖json序列化工具，来做一些特殊操作；但是，这个辅助功能并不是必须的，也就是说对于使用这个工具包的业务方而言，正常使用完全不需要json相关的功能；如果我强引用某个json工具，一是对于不适用高级特性的用户而言没有必要；二则是我引入的json工具极有可能与使用者的不一致，会增加使用者的成本 因此我希望这个工具包对外提供时，并不会引入具体的json工具依赖；也就是说maven依赖中的&amp;lt;scope&amp;gt;设置为provided；具体的json序列化的实现，则取决于调用方自身引入了什么json工具包 那么可以怎么实现上面这个方式呢？</description>
      <category>Java</category>
      <category>编程技巧</category>
      <pubDate>Wed, 24 Aug 2022 18:54:08 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 实战23：基于引入包选择具体实现类</h1>
<p>最近遇到一个需求场景，开源的工具包，新增了一个高级特性，会依赖json序列化工具，来做一些特殊操作；但是，这个辅助功能并不是必须的，也就是说对于使用这个工具包的业务方而言，正常使用完全不需要json相关的功能；如果我强引用某个json工具，一是对于不适用高级特性的用户而言没有必要；二则是我引入的json工具极有可能与使用者的不一致，会增加使用者的成本</p>
<p>因此我希望这个工具包对外提供时，并不会引入具体的json工具依赖；也就是说maven依赖中的<code>&lt;scope&gt;</code>设置为<code>provided</code>；具体的json序列化的实现，则取决于调用方自身引入了什么json工具包</p>
<p>那么可以怎么实现上面这个方式呢？</p>
<!-- more -->
<h2> 1.实现方式</h2>
<h3> 1.1. 任务说明</h3>
<p>上面的简单的说了一下我们需要做的事情，接下来我们重点盘一下，我们到底是要干什么</p>
<p>核心诉求相对清晰</p>
<ol>
<li>不强引入某个json工具</li>
<li>若需要使用高级特性，则直接使用当前环境中已集成的json序列化工具；若没有提供，则抛异常，不支持</li>
</ol>
<p>对于上面这个场景，常年使用Spring的我们估计不会陌生，Spring集成了很多的第三方开源组件，根据具体的依赖来选择最终的实现，比如日志，可以是logback，也可以是log4j；比如redis操作，可以是jedis，也可以是lettuce</p>
<p>那么Spring是怎么实现的呢？</p>
<h3> 1.2.具体实现</h3>
<p>在Spring中有个注解名为<code>ConditionalOnClass</code>，表示当某个类存在时，才会干某些事情（如初始化bean对象）</p>
<p>它是怎么是实现的呢？（感兴趣的小伙伴可以搜索一下，或者重点关注下 <code>SpringBootCondition</code> 的实现）</p>
<p>这里且抛开Spring的实现姿势，我们采用传统的实现方式，直接判断是否有加载对应的类，来判断有没有引入相应的工具包</p>
<p>如需要判断是否引入了gson包，则判断ClassLoader是否有加载<code>com.google.gson.Gson</code>类</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这种实现方式就可以达到我们的效果了；接下来我们参考下Spring的ClassUtils实现，做一个简单的封装，以判断是否存在某个类</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>工具类存在之后，我们实现一个简单的json工具类，根据已有的json包来选择具体的实现</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的实现中，根据已有的json序列化工具，选择具体的实现类，我们定义了一个JsonApi接口，然后分别gson,jackson,fastjson给出默认的实现类</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>最后的问题来了，如果调用方并没有使用上面三个序列化工具，而是使用其他的呢，可以支持么？</p>
<p>既然我们定义了一个JsonApi，那么是不是可以由用户自己来实现接口，然后自动选择它呢？</p>
<p>现在的问题就是如何找到用户自定义的接口实现了</p>
<h3> 1.3. 扩展机制</h3>
<p>对于SPI机制比较熟悉的小伙伴可能非常清楚，可以通过在配置目录<code>META-INF/services/</code>下新增接口文件，内容为实现类的全路径名称，然后通过 <code>ServiceLoader.load(JsonApi.class)</code> 的方式来获取所有实现类</p>
<p>除了SPI的实现方式之外，另外一个策略则是上面提到的Spring的实现原理，借助字节码来处理（详情原理后面专文说明）</p>
<p>当然也有更容易想到的策略，扫描包路径下的class文件，遍历判断是否为实现类(额外注意jar包内的实现类场景)</p>
<p>接下来以SPI的方式来介绍下扩展实现方式，首先初始化JsonApi的方式改一下，优先使用用户自定义实现</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对于使用者而言，首先是实现接口</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接着就是实现定义, <code>resources/META-INF/services/</code> 目录下，新建文件名为 <code>com.github.hui.quick.plugin.qrcode.util.json.JsonApi</code></p>
<p>内容如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>然后完工~</p>
<h2> 2. 小结</h2>
<p>主要介绍一个小的知识点，如何根据应用已有的jar包来选择具体的实现类的方式；本文介绍的方案是通过ClassLoader来尝试加载对应的类，若能正常加载，则认为有；否则认为没有；这种实现方式虽然非常简单，但是请注意，它是有缺陷的，至于缺陷是啥...</p>
<p>除此之外，也可以考虑通过字节码的方式来判断是否有某个类，或者获取某个接口的实现；文中最后抛出了一个问题，如何获取接口的所有实现类</p>
<p>常见的方式有下面三类（具体介绍了SPI的实现姿势，其他的两种感兴趣的可以搜索一下）</p>
<ul>
<li>SPI定义方式</li>
<li>扫描包路径</li>
<li>字节码方式(如Spring，如Tomcat的<code>@HandlesTypes</code>)</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>24.基于JDK的LRU算法实现</title>
      <link>https://liuyueyi.github.io/tutorial/java/skill/24.%E5%9F%BA%E4%BA%8EJDK%E7%9A%84LRU%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0.html</link>
      <guid>https://liuyueyi.github.io/tutorial/java/skill/24.%E5%9F%BA%E4%BA%8EJDK%E7%9A%84LRU%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">24.基于JDK的LRU算法实现</source>
      <description>实战24： 基于JDK的LRU算法实现 1. LRU算法 缓存淘汰算法--LRU算法LRU（Least recently used，最近最少使用）算法 根据数据的历史访问记录来进行淘汰数据，其核心思想是&amp;quot;如果数据最近被访问过，那么将来被访问的几率也更高&amp;quot; 再Java中可以非常简单的实现LRU算法，主要利用的是LinkedHashMap容器 1.1 LRU算法实现 inkedHashMap底层就是用的HashMap加双链表实现的，而且本身已经实现了按照访问顺序的存储。此外，LinkedHashMap中本身就实现了一个方法removeEldestEntry用于判断是否需要移除最不常读取的数，方法默认是直接返回false，不会移除元素</description>
      <category>Java</category>
      <category>编程技巧</category>
      <pubDate>Thu, 21 Oct 2021 18:54:08 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 实战24： 基于JDK的LRU算法实现</h1>
<h2> 1. LRU算法</h2>
<p>缓存淘汰算法--LRU算法LRU（Least recently used，最近最少使用）算法</p>
<p>根据数据的历史访问记录来进行淘汰数据，其核心思想是"如果数据最近被访问过，那么将来被访问的几率也更高"</p>
<p>再Java中可以非常简单的实现LRU算法，主要利用的是LinkedHashMap容器</p>
<h3> 1.1 LRU算法实现</h3>
<p>inkedHashMap底层就是用的HashMap加双链表实现的，而且本身已经实现了按照访问顺序的存储。此外，LinkedHashMap中本身就实现了一个方法removeEldestEntry用于判断是否需要移除最不常读取的数，方法默认是直接返回false，不会移除元素</p>
<p>因此我们只需要重写这个方法，可以实现当缓存满之后，就移除最不常用的数据</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意上面的访问，当i == 6 时，主动访问了一下 <code>一灰灰blog_2</code>，主要就是不希望淘汰掉它，再看下对应的输出</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>实际输出与我们预期一致</p>
<h3> 1.2 小结</h3>
<p>jdk中蕴含了大量的财富，就看我们能不能识别出来了；通常我非常推荐&lt;3年的小伙伴，有事没事多盘一下jdk的经典实现，比如各种容器的底层结构，并发类的设计思想等</p>
]]></content:encoded>
    </item>
    <item>
      <title>25.数字型字面量中的下划线</title>
      <link>https://liuyueyi.github.io/tutorial/java/skill/25.%E6%95%B0%E5%AD%97%E5%9E%8B%E5%AD%97%E9%9D%A2%E9%87%8F%E4%B8%AD%E7%9A%84%E4%B8%8B%E5%88%92%E7%BA%BF.html</link>
      <guid>https://liuyueyi.github.io/tutorial/java/skill/25.%E6%95%B0%E5%AD%97%E5%9E%8B%E5%AD%97%E9%9D%A2%E9%87%8F%E4%B8%AD%E7%9A%84%E4%B8%8B%E5%88%92%E7%BA%BF.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">25.数字型字面量中的下划线</source>
      <description>实战25： 数字型字面量中的下划线 不知道有没有小伙伴看过下面这种写法，不用质疑，它没有语法错误；再很多开源的框架中可以看到类似的写法；这种再字面量中添加下划线的方式，是一种小却使用的编程小技巧，推荐给CURD开发者 long price = 1_000_123L;</description>
      <category>Java</category>
      <category>编程技巧</category>
      <pubDate>Wed, 26 Sep 2018 01:13:36 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 实战25： 数字型字面量中的下划线</h1>
<p>不知道有没有小伙伴看过下面这种写法，不用质疑，它没有语法错误；再很多开源的框架中可以看到类似的写法；这种再字面量中添加下划线的方式，是一种小却使用的编程小技巧，推荐给CURD开发者</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><!-- more -->
<h2> 1. Java7新特性之数字中使用下划线</h2>
<p>为了直观性而言，在大数之间，加上下划线用于肉眼区分，下面实例小结下用法</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>简单来说，就是在数中间，插上下划线，用于划分段落</p>
<h2> 2. 小结</h2>
<p>再字面量中添加下划线，主要用于分割大数，方便阅读，重点注意：</p>
<ul>
<li>不能在小数点正前后添加</li>
<li>不要在L/D/F等数据类型标识的正前方添加</li>
<li>不能作为数字开头，也不能作为结尾</li>
<li>不要往进制修饰符中间或后面添加</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>26.列表遍历删除使用实例</title>
      <link>https://liuyueyi.github.io/tutorial/java/skill/26.%E5%88%97%E8%A1%A8%E9%81%8D%E5%8E%86%E5%88%A0%E9%99%A4%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BE%8B.html</link>
      <guid>https://liuyueyi.github.io/tutorial/java/skill/26.%E5%88%97%E8%A1%A8%E9%81%8D%E5%8E%86%E5%88%A0%E9%99%A4%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BE%8B.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">26.列表遍历删除使用实例</source>
      <description>实战26：列表遍历删除使用实例 在实际的业务开发中，容器的遍历可以说是非常非常常见的场景了，遍历删除呢，用的机会也不会少，但你真的会用么？</description>
      <category>Java</category>
      <category>编程技巧</category>
      <pubDate>Tue, 21 May 2019 20:21:35 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 实战26：列表遍历删除使用实例</h1>
<p>在实际的业务开发中，容器的遍历可以说是非常非常常见的场景了，遍历删除呢，用的机会也不会少，但你真的会用么？</p>
<!-- more -->
<h2> 1. List遍历删除</h2>
<p>对于列表，这里以ArrayList进行举例说明，下面给出几种经常会遇到的写法</p>
<p>首先初始化一个list数组</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1.1. foreach</h3>
<p>这个属于我们最常见的foreach循环，在循环内部判断满足条件的直接删除</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这种写法导致的问题，很容易可以发现，因为上面代码跑完之后，堆栈就出来了</p>
<figure><img src="https://blog.hhui.top/hexblog/imgs/190521/00.jpg" alt="IMAGE" tabindex="0" loading="lazy"><figcaption>IMAGE</figcaption></figure>
<p>很典型的并发修改错误，在foreach循环中不允许删除,新增</p>
<h3> 1.2. 普通for循环</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这种写法呢？我们希望把列表中，第0，5，10，15位置的元素干掉，正常执行，倒是不会报错，然而输出的结果却和我们的预期不一致</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>for循环中，另外一种写法可能更加常见，为了避免每次都访问 <code>list.size()</code> 方法，我可能提前用一个变量保存数组大小</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这个问题就很明显了，数组越界</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1.3. 迭代方式</h3>
<p>下面这种可以说是标准的迭代删除的写法了，基本上大多都是这么玩</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1.4. jdk8+ 流方式</h3>
<p>jdk8+ 推荐下面这种写法，简洁明了</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2> 2. 小结</h2>
<p>注意不要在for/foreach遍历过程中删除元素，如果有移除元素的需求，使用迭代器；或者使用jdk8的流式写法也行</p>
]]></content:encoded>
      <enclosure url="https://blog.hhui.top/hexblog/imgs/190521/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>27.HashMap遍历删除使用实例</title>
      <link>https://liuyueyi.github.io/tutorial/java/skill/27.Map%E9%81%8D%E5%8E%86%E5%88%A0%E9%99%A4%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BE%8B.html</link>
      <guid>https://liuyueyi.github.io/tutorial/java/skill/27.Map%E9%81%8D%E5%8E%86%E5%88%A0%E9%99%A4%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BE%8B.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">27.HashMap遍历删除使用实例</source>
      <description>实战27：HashMap遍历删除使用实例 map的迭代删除，和我们常见的list，set不太一样，不能直接获取Iteraotr对象，提供的删除方法也是单个的，根据key进行删除，如果我们有个需求，将map中满足某些条件的元素删除掉，要怎么做呢？</description>
      <category>Java</category>
      <category>编程技巧</category>
      <pubDate>Wed, 29 May 2019 21:38:18 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 实战27：HashMap遍历删除使用实例</h1>
<p>map的迭代删除，和我们常见的list，set不太一样，不能直接获取Iteraotr对象，提供的删除方法也是单个的，根据key进行删除，如果我们有个需求，将map中满足某些条件的元素删除掉，要怎么做呢？</p>
<!-- more -->
<h2> 1. Map 迭代删除</h2>
<p>迭代删除，在不考虑并发安全的前提下，我们看下可以怎么支持</p>
<h3> 1.1. 非常不优雅版本</h3>
<p>我们知道map并不是继承自Collection接口的，HashMap 也没有提供迭代支持，既然没法直接迭代，那我就老老实的low b版好了</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的实现怎么样？并没有什么毛病</p>
<p>(为啥不直接在遍历中删除？）</p>
<h3> 1.2. 正确姿势版</h3>
<p>虽然Map没有迭代，但是它的entrySet有啊，所以我们可以通过它来实现遍历删除</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这个可能是我们经常使用的操作姿势了，利用迭代器来操作元素</p>
<h3> 1.3. 简洁版</h3>
<p>到jdk8之后，针对容器提供了很多简洁的操作方式，迭代删除这方面可以说更加简单了</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 2. 小结</h2>
<p>和列表删除元素一样，不要在for/foreach迭代过程中删除数据，如有需要，迭代器才是正解；jdk8之后更推荐流式写法</p>
]]></content:encoded>
    </item>
    <item>
      <title>28.优雅的代码耗时统计策略</title>
      <link>https://liuyueyi.github.io/tutorial/java/skill/28.%E4%BC%98%E9%9B%85%E7%9A%84%E4%BB%A3%E7%A0%81%E8%80%97%E6%97%B6%E7%BB%9F%E8%AE%A1.html</link>
      <guid>https://liuyueyi.github.io/tutorial/java/skill/28.%E4%BC%98%E9%9B%85%E7%9A%84%E4%BB%A3%E7%A0%81%E8%80%97%E6%97%B6%E7%BB%9F%E8%AE%A1.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">28.优雅的代码耗时统计策略</source>
      <description>实战28：优雅的实现代码耗时统计 在我们的实际开发中，多多少少会遇到统计一段代码片段的耗时的情况，我们一般的写法如下 long start = System.currentTimeMillis(); try { // .... 具体的代码段 } finally { System.out.println(&amp;quot;cost: &amp;quot; + (System.currentTimeMillis() - start)); } 上面的写法没有什么毛病，但是看起来就不太美观了，那么有没有什么更优雅的写法呢？</description>
      <category>Java</category>
      <category>编程技巧</category>
      <pubDate>Tue, 03 Mar 2020 09:58:40 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 实战28：优雅的实现代码耗时统计</h1>
<p>在我们的实际开发中，多多少少会遇到统计一段代码片段的耗时的情况，我们一般的写法如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的写法没有什么毛病，但是看起来就不太美观了，那么有没有什么更优雅的写法呢？</p>
<!-- more -->
<h2> 1. 代理方式</h2>
<p>了解Spring AOP的同学可能立马会想到一个解决方法，如果想要统计某个方法耗时，使用切面可以无侵入的实现，如</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Spring AOP的底层支持原理为代理模式，为目标对象提供增强功能；在Spring的生态体系下，使用aop的方式来统计方法耗时，可以说少侵入且实现简单，但是有以下几个问题</p>
<ul>
<li>统计粒度为方法级别</li>
<li>类内部方法调用无法生效（详情可以参考博文：<a href="http://spring.hhui.top/spring-blog/2019/03/02/190302-SpringBoot%E5%9F%BA%E7%A1%80%E7%AF%87AOP%E4%B9%8B%E9%AB%98%E7%BA%A7%E4%BD%BF%E7%94%A8%E6%8A%80%E8%83%BD/" target="_blank" rel="noopener noreferrer">【SpringBoot 基础系列教程】AOP之高级使用技能</a>）</li>
</ul>
<h2> 2. AutoCloseable</h2>
<p>在JDK1.7引入了一个新的接口<code>AutoCloseable</code>, 通常它的实现类配合<code>try{}</code>使用，可在IO流的使用上，经常可以看到下面这种写法</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意上面的写法中，最值得关注一点是，不需要再主动的写<code>stream.close</code>了，主要原因就是在<code>try(){}</code>执行完毕之后，会调用方法<code>AutoCloseable#close</code>方法；</p>
<p>基于此，我们就会有一个大单的想法，下一个<code>Cost</code>类实现<code>AutoCloseable</code>接口，创建时记录一个时间，close方法中记录一个时间，并输出时间差值；将需要统计耗时的逻辑放入<code>try(){}</code>代码块</p>
<p>下面是一个具体的实现：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>执行后输出如下:</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果代码块抛异常，也会正常输出耗时么？</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>再次输出如下，并没有问题</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 3. 小结</h2>
<p>除了上面介绍的两种方式，还有一种在业务开发中不太常见，但是在中间件、偏基础服务的功能组件中可以看到，利用Java Agent探针技术来实现，比如阿里的arthas就是在JavaAgent的基础上做了各种上天的功能，后续介绍java探针技术时会专门介绍</p>
<p>下面小结一下三种统计耗时的方式</p>
<p><strong>基本写法</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>优点是简单，适用范围广泛；缺点是侵入性强，大量的重复代码</p>
<p><strong>Spring AOP</strong></p>
<p>在Spring生态下，可以借助AOP来拦截目标方法，统计耗时</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>优点：无侵入，适合统一管理（比如测试环境输出统计耗时，生产环境不输出）；缺点是适用范围小，且粒度为方法级别，并受限于AOP的使用范围</p>
<p><strong>AutoCloseable</strong></p>
<p>这种方式可以看做是第一种写法的进阶版</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>优点是：简单，适用范围广泛，且适合统一管理；缺点是依然有代码侵入</p>
<p><strong>说明</strong></p>
<p>上面第二种方法看着属于最优雅的方式，但是限制性强；如果有更灵活的需求，建议考虑第三种写法，在代码的简洁性和统一管理上都要优雅很多，相比较第一种可以减少大量冗余代码</p>
]]></content:encoded>
    </item>
    <item>
      <title>29.获取类路径的常见方式</title>
      <link>https://liuyueyi.github.io/tutorial/java/skill/29.%E8%8E%B7%E5%8F%96%E7%B1%BB%E8%B7%AF%E5%BE%84%E7%9A%84%E5%B8%B8%E8%A7%81%E6%96%B9%E5%BC%8F.html</link>
      <guid>https://liuyueyi.github.io/tutorial/java/skill/29.%E8%8E%B7%E5%8F%96%E7%B1%BB%E8%B7%AF%E5%BE%84%E7%9A%84%E5%B8%B8%E8%A7%81%E6%96%B9%E5%BC%8F.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">29.获取类路径的常见方式</source>
      <description>实战29：获取类路径的常见方式 1. 资源路径查询 在Java环境中，如何获取当前类的路径，如何获取项目根路径，可以说是比较常见的需求场景了，下面简单的记录一下</description>
      <category>Java</category>
      <category>编程技巧</category>
      <pubDate>Mon, 27 Aug 2018 09:58:40 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 实战29：获取类路径的常见方式</h1>
<h2> 1. 资源路径查询</h2>
<p>在Java环境中，如何获取当前类的路径，如何获取项目根路径，可以说是比较常见的需求场景了，下面简单的记录一下</p>
<!-- more -->
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出如下:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 2. 小结</h2>
<ol>
<li><code>new File(this.getClass().getResource("/").getPath())</code>
<ul>
<li>获取类加载的根路径</li>
</ul>
</li>
<li><code>new File(this.getClass().getResource("").getPath())</code>
<ul>
<li>获取当前类的所在工程路径; 如果不加“/”  获取当前类的加载目录</li>
</ul>
</li>
<li><code>new File("").getCanonicalPath()</code>
<ul>
<li>获取项目路径</li>
</ul>
</li>
<li><code>this.getClass().getClassLoader().getResource("")</code></li>
<li><code>System.getProperty("user.dir")</code></li>
<li><code>System.getProperty("java.class.path")</code>
<ul>
<li>获取所有的类路径 包括jar包的路径</li>
</ul>
</li>
</ol>
]]></content:encoded>
    </item>
    <item>
      <title>30.Deflater压缩与Inflater解压</title>
      <link>https://liuyueyi.github.io/tutorial/java/skill/30.Deflater%E5%8E%8B%E7%BC%A9%E4%B8%8EInflater%E8%A7%A3%E5%8E%8B.html</link>
      <guid>https://liuyueyi.github.io/tutorial/java/skill/30.Deflater%E5%8E%8B%E7%BC%A9%E4%B8%8EInflater%E8%A7%A3%E5%8E%8B.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">30.Deflater压缩与Inflater解压</source>
      <description>实战30：JDK压缩与解压工具类 在实际的应用场景中，特别是对外传输数据时，将原始数据压缩之后丢出去，可以说是非常常见的一个case了，平常倒是没有直接使用JDK原生的压缩工具类，使用Protosutff和Kryo的机会较多,正好在实际的工作场景中遇到了，现在简单的看下使用姿势</description>
      <category>Java</category>
      <category>编程技巧</category>
      <pubDate>Mon, 27 Aug 2018 09:58:40 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 实战30：JDK压缩与解压工具类</h1>
<p>在实际的应用场景中，特别是对外传输数据时，将原始数据压缩之后丢出去，可以说是非常常见的一个case了，平常倒是没有直接使用JDK原生的压缩工具类，使用Protosutff和Kryo的机会较多,正好在实际的工作场景中遇到了，现在简单的看下使用姿势</p>
<!-- more -->
<h2> 1. 压缩与解压工具类</h2>
<h3> 1.1. 基本实现</h3>
<p>主要借助的就是Deflater, Inflater两个工具类，其使用姿势如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>一个简单的测试</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1.2. 注意事项</h3>
<p>上面这个运作的还挺好，但在接入使用时，总是提示<code>java.util.zip.DataFormatException: incorrect header check</code>, 因为接受的是第三方传递过来的压缩数据，比较坑爹的是对方就写了个Deflater压缩，然后什么都没有了，那么这个是啥原因呢？</p>
<p>其实看下Deflater的构造方法，发现还可以传一个boolean值(nowrap), 官方说明是</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>简单来说，就是压缩时，如果nowrap为true，那么解压时也要为true；否则对不上时，就会抛异常</p>
<p>接下来简单对比下两种不同传参的情况，首先更新下工具类</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>测试如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果如下，从大小来看，前者小那么一点点</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 2. 小结</h2>
<p>一般来说，jdk自带的压缩与解压，除了方便之外，可能优势并不是那么的大，这里盗一张网上的对比表格</p>
<p>以下来自: <a href="https://www.cnblogs.com/lonelywolfmoutain/p/5563985.html" target="_blank" rel="noopener noreferrer">[java]序列化框架性能对比（kryo、hessian、java、protostuff）</a></p>
<table>
<thead>
<tr>
<th></th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>kryo</td>
<td>速度快，序列化后体积小</td>
<td>跨语言支持较复杂</td>
</tr>
<tr>
<td>hessian</td>
<td>默认支持跨语言</td>
<td>较慢</td>
</tr>
<tr>
<td>protostuff</td>
<td>速度快，基于protobuf</td>
<td>需静态编译</td>
</tr>
<tr>
<td>Protostuff-Runtime</td>
<td>无需静态编译，但序列化前需预先传入schema</td>
<td>不支持无默认构造函数的类，反序列化时需用户自己初始化序列化后的对象，其只负责将该对象进行赋值</td>
</tr>
<tr>
<td>jdk</td>
<td>使用方便，可序列化所有类</td>
<td>速度慢，占空间</td>
</tr>
</tbody>
</table>
<p>其次，在使用java的压缩与解压时，需要注意下，nowrap这个参数，需要保持一致，否则会报错</p>
]]></content:encoded>
    </item>
    <item>
      <title>31.深拷贝浅拷贝及对象拷贝的两种方式</title>
      <link>https://liuyueyi.github.io/tutorial/java/skill/31.%E6%B7%B1%E6%8B%B7%E8%B4%9D%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%8F%8A%E5%AF%B9%E8%B1%A1%E6%8B%B7%E8%B4%9D%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F.html</link>
      <guid>https://liuyueyi.github.io/tutorial/java/skill/31.%E6%B7%B1%E6%8B%B7%E8%B4%9D%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%8F%8A%E5%AF%B9%E8%B1%A1%E6%8B%B7%E8%B4%9D%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">31.深拷贝浅拷贝及对象拷贝的两种方式</source>
      <description>实战31：深拷贝浅拷贝及对象拷贝的两种方式 1. Java之Clone 1.1 背景 对象拷贝，是一个非常基础的内容了，为什么会单独的把这个领出来讲解，主要是先前遇到了一个非常有意思的场景 有一个任务，需要解析类xml标记语言，然后生成document对象，之后将会有一系列针对document对象的操作 通过实际的测试，发现生成Document对象是比较耗时的一个操作，再加上这个任务场景中，需要解析的xml文档是固定的几个，那么一个可以优化的思路就是能不能缓存住创建后的Document对象，在实际使用的时候clone一份出来</description>
      <category>Java</category>
      <category>编程技巧</category>
      <pubDate>Sun, 17 Dec 2017 19:53:51 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 实战31：深拷贝浅拷贝及对象拷贝的两种方式</h1>
<h2> 1. Java之Clone</h2>
<h3> 1.1 背景</h3>
<p>对象拷贝，是一个非常基础的内容了，为什么会单独的把这个领出来讲解，主要是先前遇到了一个非常有意思的场景</p>
<p>有一个任务，需要解析类xml标记语言，然后生成document对象，之后将会有一系列针对document对象的操作</p>
<p>通过实际的测试，发现生成Document对象是比较耗时的一个操作，再加上这个任务场景中，需要解析的xml文档是固定的几个，那么一个可以优化的思路就是能不能缓存住创建后的Document对象，在实际使用的时候clone一份出来</p>
<!-- more  -->
<h3> 1.2 内容说明</h3>
<p>看到了上面的应用背景，自然而言的就会想到深拷贝了，本篇博文则主要内容如下</p>
<ul>
<li>介绍下两种拷贝方式的区别</li>
<li>深拷贝的辅助工具类</li>
<li>如何自定义实现对象拷贝</li>
</ul>
<h2> 2. 深拷贝和浅拷贝</h2>
<h3> 2.1 定义说明</h3>
<p><strong>深拷贝</strong></p>
<p>相当于创建了一个新的对象，只是这个对象的所有内容，都和被拷贝的对象一模一样而已，即两者的修改是隔离的，相互之间没有影响</p>
<p><strong>浅拷贝</strong></p>
<p>也是创建了一个对象，但是这个对象的某些内容（比如A）依然是被拷贝对象的，即通过这两个对象中任意一个修改A，两个对象的A都会受到影响</p>
<p>看到上面两个简单的说明，那么问题来了</p>
<ul>
<li>浅拷贝中，是所有的内容公用呢？还是某些内容公用？</li>
<li>从隔离来将，都不希望出现浅拷贝这种方式了，太容易出错了，那么两种拷贝方式的应用场景是怎样的？</li>
</ul>
<h3> 2.2 浅拷贝</h3>
<p>一般来说，浅拷贝方式需要实现<code>Cloneable</code>接口，下面结合一个实例，来看下浅拷贝中哪些是独立的，哪些是公用的</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>结果分析：</p>
<ul>
<li>拷贝后获取的是一个独立的对象，和原对象拥有不同的内存地址</li>
<li>基本元素类型，两者是隔离的（虽然上面只给出了int，String）
<ul>
<li>基本元素类型包括:</li>
<li>int, Integer, long, Long, char, Charset, byte,Byte, boolean, Boolean, float,Float, double, Double, String</li>
</ul>
</li>
<li>非基本数据类型（如基本容器，其他对象等），只是拷贝了一份引用出去了，实际指向的依然是同一份</li>
</ul>
<p>其实，浅拷贝有个非常简单的理解方式：</p>
<p><strong>浅拷贝的整个过程就是，创建一个新的对象，然后新对象的每个值都是由原对象的值，通过 <code>=</code> 进行赋值</strong></p>
<p>这个怎么理解呢？</p>
<p>上面的流程拆解就是：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>那么=赋值有什么特点呢？</p>
<p>基本数据类型是值赋值；非基本的就是引用赋值</p>
<h3> 2.3 深拷贝</h3>
<p>深拷贝，就是要创建一个全新的对象，新的对象内部所有的成员也都是全新的，只是初始化的值已经由被拷贝的对象确定了而已</p>
<p>那么上面的实例改成深拷贝应该是怎样的呢？</p>
<p>可以加上这么一个方法</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果为：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>结果分析：</p>
<ul>
<li>深拷贝独立的对象</li>
<li>拷贝后对象的内容，与原对象的内容完全没关系，都是独立的</li>
</ul>
<p>简单来说，深拷贝是需要自己来实现的，对于基本类型可以直接赋值，而对于对象、容器、数组来讲，需要创建一个新的出来，然后重新赋值</p>
<h3> 2.4 应用场景区分</h3>
<p>深拷贝的用途我们很容易可以想见，某个复杂对象创建比较消耗资源的时候，就可以缓存一个蓝本，后续的操作都是针对深clone后的对象，这样就不会出现混乱的情况了</p>
<p>那么浅拷贝呢？感觉留着是一个坑，一个人修改了这个对象的值，结果发现对另一个人造成了影响，真不是坑爹么？</p>
<p>假设又这么一个通知对象长下面这样</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们现在随机挑选了一千个人，同时发送通知消息，所以需要创建一千个上面的对象，这些对象中呢，除了notifyUser不同，其他的都一样</p>
<p>在发送之前，突然发现要临时新增一条通知信息，如果是浅拷贝的话，只用在任意一个通知对象的notifyRules中添加一调消息，那么这一千个对象的通知消息都会变成最新的了；而如果你是用深拷贝，那么苦逼的得遍历这一千个对象，每个都加一条消息了</p>
<hr>
<h2> 3. 对象拷贝工具</h2>
<p>上面说到，浅拷贝，需要实现Clonebale接口，深拷贝一般需要自己来实现，那么我现在拿到一个对象A，它自己没有提供深拷贝接口，我们除了主动一条一条的帮它实现之外，有什么辅助工具可用么？</p>
<p>对象拷贝区别与clone，它可以支持两个不同对象之间实现内容拷贝</p>
<p><strong>Apache的两个版本：（反射机制）</strong></p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>Spring版本：（反射机制）</strong></p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>cglib版本：（使用动态代理，效率高）</strong></p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>从上面的几个有名的工具类来看，提供了两种使用者姿势，一个是反射，一个是动态代理，下面分别来看两种思路</p>
<h3> 3.1 借助反射实现对象拷贝</h3>
<p>通过反射的方式实现对象拷贝的思路还是比较清晰的，先通过反射获取对象的所有属性，然后修改可访问级别，然后赋值；再获取继承的父类的属性，同样利用反射进行赋值</p>
<p>上面的几个开源工具，内部实现封装得比较好，所以直接贴源码可能不太容易一眼就能看出反射方式的原理，所以简单的实现了一个, 仅提供思路</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的实现步骤还是非常清晰的，首先是找同名的属性，然后利用反射获取对应的值</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果找不到，则找getXXX, isXXX来获取</p>
<h3> 3.2 代理的方式实现对象拷贝</h3>
<p>Cglib的BeanCopier就是通过代理的方式实现拷贝，性能优于反射的方式，特别是在大量的数据拷贝时，比较明显</p>
<p>代理，我们知道可以区分为静态代理和动态代理，简单来讲就是你要操作对象A，但是你不直接去操作A，而是找一个中转porxyA, 让它来帮你操作对象A</p>
<p>那么这种技术是如何使用在对象拷贝的呢？</p>
<p>我们知道，效率最高的对象拷贝方式就是Getter/Setter方法了，前面说的代理的含义指我们不直接操作，而是找个中间商来赚差价，那么方案就出来了</p>
<p>将原SourceA拷贝到目标DestB</p>
<ul>
<li>创建一个代理 copyProxy</li>
<li>在代理中，依次调用 SourceA的get方法获取属性值，然后调用DestB的set方法进行赋值</li>
</ul>
<p>实际上BeanCopier的思路大致如上，具体的方案当然就不太一样了, 简单看了一下实现逻辑，挺有意思的一块，先留个坑，后面单独开个博文补上</p>
<p><strong>说明</strong></p>
<p>从实现原理和通过简单的测试，发现BeanCopier是扫描原对象的getXXX方法，然后赋值给同名的 setXXX 方法，也就是说，如果这个对象中某个属性没有get/set方法，那么就无法赋值成功了</p>
<hr>
<h2> 3. 小结</h2>
<h3> 3.1 深拷贝和浅拷贝</h3>
<p><strong>深拷贝</strong></p>
<blockquote>
<p>相当于创建了一个新的对象，只是这个对象的所有内容，都和被拷贝的对象一模一样而已，即两者的修改是隔离的，相互之间没有影响</p>
</blockquote>
<ul>
<li>完全独立</li>
</ul>
<p><strong>浅拷贝</strong></p>
<blockquote>
<p>也是创建了一个对象，但是这个对象的某些内容（比如A）依然是被拷贝对象的，即通过这两个对象中任意一个修改A，两个对象的A都会受到影响</p>
</blockquote>
<ul>
<li>等同与新创建一个对象，然后使用=，将原对象的属性赋值给新对象的属性</li>
<li>需要实现Cloneable接口</li>
</ul>
<h3> 3.2 对象拷贝的两种方法</h3>
<p><strong>通过反射方式实现对象拷贝</strong></p>
<p>主要原理就是通过反射获取所有的属性，然后反射更改属性的内容</p>
<p><strong>通过代理实现对象拷贝</strong></p>
<p>将原SourceA拷贝到目标DestB</p>
<p>创建一个代理 copyProxy
在代理中，依次调用 SourceA的get方法获取属性值，然后调用DestB的set方法进行赋值</p>
]]></content:encoded>
    </item>
    <item>
      <title>32.文件变动监听</title>
      <link>https://liuyueyi.github.io/tutorial/java/skill/32.%E6%96%87%E4%BB%B6%E5%8F%98%E5%8A%A8%E7%9B%91%E5%90%AC.html</link>
      <guid>https://liuyueyi.github.io/tutorial/java/skill/32.%E6%96%87%E4%BB%B6%E5%8F%98%E5%8A%A8%E7%9B%91%E5%90%AC.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">32.文件变动监听</source>
      <description>Java可以如何实现文件变动的监听 应用中使用logback作为日志输出组件的话，大部分会去配置 logback.xml 这个文件，而且生产环境下，直接去修改logback.xml文件中的日志级别，不用重启应用就可以生效 那么，这个功能是怎么实现的呢？</description>
      <category>Java</category>
      <category>编程技巧</category>
      <pubDate>Thu, 08 Feb 2018 12:01:58 GMT</pubDate>
      <content:encoded><![CDATA[<h1> Java可以如何实现文件变动的监听</h1>
<p>应用中使用logback作为日志输出组件的话，大部分会去配置 <code>logback.xml</code> 这个文件，而且生产环境下，直接去修改logback.xml文件中的日志级别，不用重启应用就可以生效</p>
<p>那么，这个功能是怎么实现的呢？</p>
<!-- more -->
<h2> 1. 问题描述及分析</h2>
<p>针对上面的这个问题，首先抛出一个实际的case，在我的个人网站 * <a href="https://tool.hhui.top/" target="_blank" rel="noopener noreferrer">神奇工具箱 - 小工具集合</a> 中，所有的小工具都是通过配置文件来动态新增和隐藏的，因为只有一台服务器，所以配置文件就简化的直接放在了服务器的某个目录下</p>
<p>现在的问题时，我需要在这个文件的内容发生变动时，应用可以感知这种变动，并重新加载文件内容，更新应用内部缓存</p>
<p>一个最容易想到的方法，就是轮询，判断文件是否发生修改，如果修改了，则重新加载，并刷新内存，所以主要需要关心的问题如下：</p>
<ul>
<li>如何轮询？</li>
<li>如何判断文件是否修改？</li>
<li>配置异常，会不会导致服务不可用？（即容错，这个与本次主题关联不大，但又比较重要...）</li>
</ul>
<h2> 2. 设计与实现</h2>
<p>问题抽象出来之后，对应的解决方案就比较清晰了</p>
<ul>
<li>如何轮询 ？ --》 定时器 Timer, ScheduledExecutorService 都可以实现</li>
<li>如何判断文件修改？ --》根据 <code>java.io.File#lastModified</code> 获取文件的上次修改时间，比对即可</li>
</ul>
<p>那么一个很简单的实现就比较容易了:</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这个属于一个非常简单，非常基础的实现了，基本上也可以满足我们的需求，那么这个实现有什么问题呢？</p>
<p><strong>定时任务的执行中，如果出现了异常会怎样？</strong></p>
<p>对上面的代码稍作修改</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>实际测试，发现只有首次修改的时候，触发了上面的代码，但是再次修改则没有效果了，即当抛出异常之后，定时任务将不再继续执行了，这个问题的主要原因是因为 <code>ScheduledExecutorService</code> 的原因了</p>
<p>直接查看ScheduledExecutorService的源码注释说明</p>
<blockquote>
<p>If any execution of the task encounters an exception, subsequent executions are suppressed.Otherwise, the task will only terminate via cancellation or termination of the executor.
即如果定时任务执行过程中遇到发生异常，则后面的任务将不再执行。</p>
</blockquote>
<p><strong>所以，使用这种姿势的时候，得确保自己的任务不会抛出异常，否则后面就没法玩了</strong></p>
<p>对应的解决方法也比较简单，整个catch一下就好</p>
<h2> 3. 进阶版</h2>
<p>前面是一个基础的实现版本了，当然在java圈，基本上很多常见的需求，都是可以找到对应的开源工具来使用的，当然这个也不例外，而且应该还是大家比较属性的apache系列</p>
<h3> 3.1 apache版</h3>
<p>首先maven依赖</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>主要是借助这个工具中的 <code>FileAlterationObserver</code>, <code>FileAlterationListener</code>, <code>FileAlterationMonitor</code> 三个类来实现相关的需求场景了，当然使用也算是很简单了，以至于都不太清楚可以再怎么去说明了，直接看下面从我的一个开源项目quick-alarm中拷贝出来的代码</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>针对上面的实现，简单说明几点：</p>
<ul>
<li>这个文件监听，是以目录为根源，然后可以设置过滤器，来实现对应文件变动的监听</li>
<li>如上面<code>registerConfChangeListener</code>方法，传入的file是具体的配置文件，因此构建参数的时候，捞出了目录，捞出了文件名作为过滤</li>
<li>第二参数是jdk8语法，其中为具体的读取配置文件内容，并映射为对应的实体对象</li>
</ul>
<p>一个问题，如果 func方法执行时，也抛出了异常，会怎样？</p>
<p>实际测试表现结果和上面一样，抛出异常之后，依然跪，所以依然得注意，不要跑异常</p>
<p>那么简单来看一下上面的实现逻辑，直接扣出核心模块</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从上面基本上一目了然，整个的实现逻辑了，和我们的第一种定时任务的方法不太一样，这儿直接使用线程，死循环，内部采用sleep的方式来来暂停，因此出现异常时，相当于直接抛出去了，这个线程就跪了</p>
<h3> 3.2 JDK版本</h3>
<p>jdk1.7，提供了一个<code>WatchService</code>，也可以用来实现文件变动的监听，之前也没有接触过，看到说明，然后搜了一下使用相关，发现也挺简单的，同样给出一个简单的示例demo</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 4. 小结</h2>
<p>使用Java来实现配置文件变动的监听，主要涉及到的就是两个点</p>
<ul>
<li>如何轮询：  定时器（Timer, ScheduledExecutorService）, 线程死循环+sleep</li>
<li>文件修改： File#lastModified</li>
</ul>
<p>整体来说，这个实现还是比较简单的，无论是自定义实现，还是依赖 commos-io来做，都没太大的技术成本，但是需要注意的一点是：</p>
<ul>
<li>千万不要在定时任务 or 文件变动的回调方法中抛出异常！！！</li>
</ul>
<p>为了避免上面这个情况，一个可以做的实现是借助EventBus的异步消息通知来实现，当文件变动之后，发送一个消息即可，然后在具体的重新加载文件内容的方法上，添加一个 <code>@Subscribe</code>注解即可，这样既实现了解耦，也避免了异常导致的服务异常 （如果对这个实现有兴趣的可以评论说明）</p>
]]></content:encoded>
    </item>
    <item>
      <title>33.实用的Map初始化工具类</title>
      <link>https://liuyueyi.github.io/tutorial/java/skill/33.%E5%AE%9E%E7%94%A8%E7%9A%84Map%E5%88%9D%E5%A7%8B%E5%8C%96%E5%B7%A5%E5%85%B7%E7%B1%BB.html</link>
      <guid>https://liuyueyi.github.io/tutorial/java/skill/33.%E5%AE%9E%E7%94%A8%E7%9A%84Map%E5%88%9D%E5%A7%8B%E5%8C%96%E5%B7%A5%E5%85%B7%E7%B1%BB.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">33.实用的Map初始化工具类</source>
      <description>实战33：实用的Map初始化工具类 虽说java作为编译语言，但是它本身也提供了很多运行时能力，今天介绍一个非常基础的知识点，可变参数传递</description>
      <category>Java</category>
      <category>编程技巧</category>
      <pubDate>Mon, 11 Oct 2021 20:45:27 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 实战33：实用的Map初始化工具类</h1>
<p>虽说java作为编译语言，但是它本身也提供了很多运行时能力，今天介绍一个非常基础的知识点，可变参数传递</p>
<!-- more -->
<p>在日常的开发过程中，创建Map对象还是比较常见的，现在我希望写一个工具类，可以非常简单创建并初始化Map对象</p>
<p>因此我们可以实现一个MapUtil工具类，来支持这个场景</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意一下上面的实现，kv这个参数就是我们要说的可变参数，在方法内部，kv可以看成是一个数组对象（而且是安全的对象，当不传递时，它的取值也不是null）</p>
<p>在使用可变参数时，下面是一些需要注意的点</p>
<p><strong>可变参数注意与数组参数的冲突</strong></p>
<p>注意下面的两个方法，不能同时出现，直接出现编译错误</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>重载的选择</strong></p>
<p>如果只有一个可变参数的方法，<code>newMap("key", "value")</code>不会报错，会直接访问下面这个方法，kv参数为空数组</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>当出现重载时，即如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>上面两个方法的调用，如果传参只有两个时，会调用哪个？</p>
<ul>
<li><code>newMap("key", "value")</code> 调用的下面的方法</li>
<li>`newMap("key", "value", "k", "v") 调用的上面的方法</li>
</ul>
<p><strong>可变参数传数组会怎样</strong></p>
<p>虽说我们在使用的时候，将可变参数当做数组来使用，但是传递时，若传数组，是否可行呢？</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>实际输出如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>从实际测试来看，传数组并没有问题</p>
]]></content:encoded>
    </item>
    <item>
      <title>34.通用的根据路径获取文件资源的工具类</title>
      <link>https://liuyueyi.github.io/tutorial/java/skill/34.%E9%80%9A%E7%94%A8%E7%9A%84%E6%A0%B9%E6%8D%AE%E8%B7%AF%E5%BE%84%E8%8E%B7%E5%8F%96%E6%96%87%E4%BB%B6%E8%B5%84%E6%BA%90%E7%9A%84%E5%B7%A5%E5%85%B7%E7%B1%BB.html</link>
      <guid>https://liuyueyi.github.io/tutorial/java/skill/34.%E9%80%9A%E7%94%A8%E7%9A%84%E6%A0%B9%E6%8D%AE%E8%B7%AF%E5%BE%84%E8%8E%B7%E5%8F%96%E6%96%87%E4%BB%B6%E8%B5%84%E6%BA%90%E7%9A%84%E5%B7%A5%E5%85%B7%E7%B1%BB.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">34.通用的根据路径获取文件资源的工具类</source>
      <description>实战34：通用的根据路径获取文件资源的工具类 通常我们最多的场景是从本地资源中读取文件，这个时候我们经常需要注意的是相对路径、绝对路径问题； 除了从本地获取文件之外，从网络中获取文件资源（如图片）也属于相对常见的场景，接下来我们封装一个工具类，可以支持以上各种类型的数据读取</description>
      <category>Java</category>
      <category>编程技巧</category>
      <pubDate>Mon, 08 Nov 2021 20:20:59 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 实战34：通用的根据路径获取文件资源的工具类</h1>
<p>通常我们最多的场景是从本地资源中读取文件，这个时候我们经常需要注意的是相对路径、绝对路径问题；</p>
<p>除了从本地获取文件之外，从网络中获取文件资源（如图片）也属于相对常见的场景，接下来我们封装一个工具类，可以支持以上各种类型的数据读取</p>
<!-- more -->
<h2> 1. 工具实现类</h2>
<p>首先定义一个公共方法如下，内部支持四种方式的数据获取</p>
<ul>
<li>相对路径</li>
<li>绝对路径</li>
<li>用户根目录</li>
<li>网络</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>请注意上面的实现，绝对路径与相对路径比较好理解，用户目录，这个处理又是怎样的呢？</p>
<p>关键点在于，用户目录转绝对路径</p>
<ul>
<li>借助<code>System.getProperties</code>系统属性来处理</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来再看如何判断一个路径是否为绝对路径呢？</p>
<p>这里需要格外注意不同操作系统的差异性，比如win，区分C盘，D盘，但是mac/linux则不分这个，上面判断的核心逻辑如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>除了上面的三种本地资源获取之外，还有一个就是网络资源的读取，上面介绍的实现姿势主要是基于JDK原生的URL，在实际使用时，这个并不稳定，不能确定能获取到完整的数据，原则上不推荐使用；如果可以，使用http-client/okhttp都是不错的选择</p>
<p>最后给一个简单的测试</p>
<p>最后一个简单下载图片的case</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0542b4ae409b4336a431fac44c1cef5f~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure>
]]></content:encoded>
      <enclosure url="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0542b4ae409b4336a431fac44c1cef5f~tplv-k3u1fbpfcp-watermark.image?" type="image/"/>
    </item>
    <item>
      <title>35.调用本地程序的几种姿势</title>
      <link>https://liuyueyi.github.io/tutorial/java/skill/35.%E8%B0%83%E7%94%A8%E6%9C%AC%E5%9C%B0%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%87%A0%E7%A7%8D%E5%A7%BF%E5%8A%BF.html</link>
      <guid>https://liuyueyi.github.io/tutorial/java/skill/35.%E8%B0%83%E7%94%A8%E6%9C%AC%E5%9C%B0%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%87%A0%E7%A7%8D%E5%A7%BF%E5%8A%BF.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">35.调用本地程序的几种姿势</source>
      <description>实战35：调用本地程序的几种姿势 作为一个后端同学，经常被安全的小伙伴盯上，找一找安全漏洞；除了常说的注入之外，还有比较吓人的执行远程命令，唤醒本地应用程序等；然后有意思的问题就来了，写了这么多年的代码，好像还真没有尝试过用java来唤醒本地应用程序的 比如说一个最简单的，打开本地的计算器，应该怎么搞？ 接下来本文将介绍一下如何使用java打开本地应用，以及打开mac系统中特殊一点的处理方式（直白来说就是不同操作系统，使用姿势不一样）</description>
      <category>Java</category>
      <category>编程技巧</category>
      <pubDate>Fri, 31 Dec 2021 10:55:56 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 实战35：调用本地程序的几种姿势</h1>
<p>作为一个后端同学，经常被安全的小伙伴盯上，找一找安全漏洞；除了常说的注入之外，还有比较吓人的执行远程命令，唤醒本地应用程序等；然后有意思的问题就来了，写了这么多年的代码，好像还真没有尝试过用java来唤醒本地应用程序的</p>
<p>比如说一个最简单的，打开本地的计算器，应该怎么搞？</p>
<p>接下来本文将介绍一下如何使用java打开本地应用，以及打开mac系统中特殊一点的处理方式（直白来说就是不同操作系统，使用姿势不一样）</p>
<!-- more -->
<h2> 1. Runtime使用方式</h2>
<p>主要是基于<code>Runtime.getRuntime().exec()</code>来执行shell命令，来打开应用</p>
<ul>
<li>传参就是需要打开的应用名</li>
</ul>
<p>比如上面说到的打开计算器</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从上面的传参也可以看出两者的区别，为什么mac会整一个 <code>open -n</code>， 这个其实可以理解为在终端执行命令，打开计算器</p>
<p><strong>注意事项</strong></p>
<p>对于mac系统而言，除了上面这种打开方式之外，还有下面这种姿势</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>在exec中指定计算器的路径，有个很容易采的坑，直接写成下面这种</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面这个直接执行之后会提示<code>权限错误</code>，其主要原因是mac系统的应用和win中的exe作为启动方式不太一样，对于mac而言，可以理解<code>xxx.app</code>为一个目录，真正执行文件是内部的<code>xxx/Contents/MacOS/xxx</code></p>
<h2> 2. ProcessBuilder使用方式</h2>
<p>除了Runtime唤起之外，使用ProcessBuilder也属于非常常见的case</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用上面这种姿势，特别需要注意的是内部传参不能是<code>open -n</code></p>
<h2> 3. 小结</h2>
<p>从上面介绍的方式来看，其实打开应用程序的思路主要就是利用java来执行脚本命令；内容比较简单，隐患却是比较大的；在自己的项目中，最好不要出现这种调用方式</p>
]]></content:encoded>
    </item>
    <item>
      <title>Java系列专栏</title>
      <link>https://liuyueyi.github.io/tutorial/java/</link>
      <guid>https://liuyueyi.github.io/tutorial/java/</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">Java系列专栏</source>
      <description>Java专栏 精选实战系列</description>
      <pubDate>Thu, 16 Feb 2023 06:42:50 GMT</pubDate>
      <content:encoded><![CDATA[<h2> Java专栏</h2>
<ul>
<li><a href="/tutorial/java/skill/" target="blank">精选实战系列</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>实战系列</title>
      <link>https://liuyueyi.github.io/tutorial/java/skill/</link>
      <guid>https://liuyueyi.github.io/tutorial/java/skill/</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">实战系列</source>
      <description>Java实战演练 实战小技巧，可用于实际编码过程中的 code snippets 带你再日常得编码中写得更加顺畅 本专栏中所有内容来自于笔者（一灰灰blog）的日常收集与分享，其中每一个主题都是针对真实的应用场景，通过提供切实可用与项目中的代码片段或者工具类，来给给位小伙伴提供帮助</description>
      <pubDate>Thu, 16 Feb 2023 06:42:50 GMT</pubDate>
      <content:encoded><![CDATA[<h1> Java实战演练</h1>
<blockquote>
<p>实战小技巧，可用于实际编码过程中的 <code>code snippets</code> 带你再日常得编码中写得更加顺畅</p>
</blockquote>
<p>本专栏中所有内容来自于笔者（一灰灰blog）的日常收集与分享，其中每一个主题都是针对真实的应用场景，通过提供切实可用与项目中的代码片段或者工具类，来给给位小伙伴提供帮助</p>
]]></content:encoded>
    </item>
    <item>
      <title>1.Eureka注册中心初体验</title>
      <link>https://liuyueyi.github.io/tutorial/spring/cloud/Eureka/01.200513-SpringCloud%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B9%8BEureka%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E5%88%9D%E4%BD%93%E9%AA%8C.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/cloud/Eureka/01.200513-SpringCloud%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B9%8BEureka%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E5%88%9D%E4%BD%93%E9%AA%8C.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">1.Eureka注册中心初体验</source>
      <description>在SpringCloud微服务体系中，有几个比较重要的组件，如注册中心，配置中心，网关，安全、负载均衡、监控等等，接下来我们将来看一下这些常用的组件有什么用，在微服务架构下的该怎么用。 本文为为第一篇，注册中心Eureka的使用说明</description>
      <category>SpringCloud</category>
      <category>Eureka系列</category>
      <pubDate>Wed, 13 May 2020 09:14:47 GMT</pubDate>
      <content:encoded><![CDATA[<p>在SpringCloud微服务体系中，有几个比较重要的组件，如注册中心，配置中心，网关，安全、负载均衡、监控等等，接下来我们将来看一下这些常用的组件有什么用，在微服务架构下的该怎么用。</p>
<p>本文为为第一篇，注册中心Eureka的使用说明</p>
<!-- more -->
<h2> I. 基本介绍</h2>
<h3> 1. 注册中心</h3>
<p>注册中心，主要的核心点是服务的注册与发现。</p>
<p>简单来讲，就是我们的所有服务都会在注册中心上标识自己，注册中心统一管理所有的服务名与具体的应用之间的映射关系，这样微服务之间的访问，就可以直接通过服务名来相互通信，相比较于直接通过ip端口的访问，这样的好处是当某个服务下线、新增或者换了机器，对调用者而言，只要维持一份注册中心的最新映射表即可，不需要其他任何改动逻辑。</p>
<p>我们通常可用的注册中心有 <code>Eureka</code>, <code>Consul</code>, <code>Zookeeper</code>, <code>nacos</code>等，在我们后续的教程中会逐一进行介绍</p>
<blockquote>
<p>Eureka2.x 闭源，1.x虽然可用，但新项目的话不建议再使用它，比如<code>Consul</code>, <code>nacos</code> 都是不错的选择</p>
<p>如果出于学习的目的，或者由于历史原因（比如我），学习了解一下Eureka知识点也没什么坏处</p>
</blockquote>
<h3> 2. Eureka</h3>
<p>Eureka是Netflix开源的服务发现组件，本身是一个基于REST的服务，通常包含Server和Client端</p>
<p><strong>原理如下图</strong></p>
<figure><img src="/imgs/200513/00.jpg" alt="来源于网络" tabindex="0" loading="lazy"><figcaption>来源于网络</figcaption></figure>
<ul>
<li>server: 提供服务注册，并在服务注册表中存储所有可用服务节点的信息</li>
<li>client: 简化与Server之间的交互，比如封装了发送心跳，获取注册信息表等基本操作</li>
</ul>
<h2> II. 实例演示</h2>
<h3> 1. 版本说明</h3>
<p>后续的演示项目中，我们的环境与版本信息如下</p>
<ul>
<li>开发环境: IDEA + maven</li>
<li>SpringBoot: <code>2.2.1.RELEASE</code></li>
<li>SpringCloud: <code>Hoxton.M2</code></li>
</ul>
<h3> 2. Eureka Server端</h3>
<p>Eureka区分了Server和Client两端，即我们有一个独立的注册中心服务，其他的微服务则作为Client端</p>
<p>Server端核心依赖如下</p>
<div class="language-pom line-numbers-mode" data-ext="pom"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后在配置文件中，添加一些基本信息</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>请注意，上面的<code>registerWithEureka</code>这个配置，设置为false，不像自己注册服务（后续会介绍多个Eureka实例时，可以如何配置）</p>
<p>然后再启动类上，添加注解<code>@EnableEurekaServer</code>来申明Eureka服务</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>到此，一个Eureka服务端已经完成，此时我们可以直接访问<code>http://localhost:8081</code>，会看到一个自带的控制台，会提供一些基本信息</p>
<h3> 3. Eureka 客户端</h3>
<p>我们这里设计两个客户端，一个提供服务，另外一个调用，演示一下Eureka的基本功能</p>
<h4> a. 客户端 eureka-service-provider</h4>
<p>客户端需要在pom文件中，添加下面的关键依赖</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来需要在配置文件中，指定注册中心的地址，以及服务名（请注意，这个服务名是重要线索，后面会用到！！！）</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>同样的需要在启动类上，通过<code>@EnableEurekaClient</code>来标注客户端</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们在这个项目中，写一个基本REST接口，供后面的服务进行调用</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>再看一下上面的实现，你会发现和平时写的Controller没有任何的区别</p>
<p>到这里第一个Eureka客户端已经完成，并提供了一个REST接口，接下来我们开始写第二个Eureka客户端，用来访问上面的REST服务</p>
<h4> b. 客户端 eureka-service-consumer</h4>
<p>基本的流程和上面没有任何区别，只是将配置文件稍微改一下</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>那么在这个服务中，如何访问 <code>eureka-service-provider</code> 提供的服务呢？</p>
<ul>
<li>通过<code>RestTemplate</code>来实现</li>
</ul>
<p>请注意，这个RestTemplate和我们普通的<code>new RestTemplate()</code>创建的不一样哦，我们是通过如下方式获取实例</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>重点关注方法上的<code>@LoadBalanced</code>注解，这个会在后续的Ribbon的章节中深入介绍，在这里只需要知道通过它生成的<code>RestTemplate</code>，在发起访问时，会借助Eureka的注册信息表，将服务名翻译为对应的<code>ip+端口号</code></p>
<p>接下来就是我们的访问环节，写法如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>请着重看一下访问的url: <code>"http://eureka-service-provider/userService/getUserById?userId=" + userId</code>,这里没有域名，没有ip，是直接通过服务名进行访问的</p>
<h3> 4. 测试与小结</h3>
<p>我们依次将上面的Server和两个Client启动，然后访问<code>http://localhost:8081</code>，查看Eureka控制台，可以看到如下界面，两个客户端都已经注册好了</p>
<figure><img src="/imgs/200513/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>然后再测试一下通过consumer访问provider的服务</p>
<figure><img src="/imgs/200513/02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>到此Eureka的核心功能已经演示完毕，当然如果仅仅只是这样，这个学习成本好像很低了，作为一个有思考的小青年，看了上面的流程自然会有几个疑问</p>
<ul>
<li>安全问题
<ul>
<li>注册中心控制台直接访问，这要是暴露出去了...</li>
<li>一个Eureka实例，单点故障怎么解</li>
</ul>
</li>
<li>服务注册多久生效？服务下线多久会从注册信息表中摘除？服务存活判断是怎样的？</li>
<li>通过<code>RestTemplate</code>方式使用，很不优雅啊，有没有类似rmi的通过类调用的方式呢？</li>
</ul>
<h2> II. 其他</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：
<ul>
<li><a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-cloud/eurka-server" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-cloud/eurka-server</a></li>
<li><a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-cloud/eurka-service-consumer" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-cloud/eurka-service-consumer</a></li>
<li><a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-cloud/eurka-service-provider" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-cloud/eurka-service-provider</a></li>
</ul>
</li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/200513/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>Eureka</title>
      <link>https://liuyueyi.github.io/tutorial/spring/cloud/Eureka/</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/cloud/Eureka/</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">Eureka</source>
      <description>注册中心Eureka全知道</description>
      <pubDate>Fri, 10 Feb 2023 04:50:05 GMT</pubDate>
      <content:encoded><![CDATA[<p>注册中心Eureka全知道</p>
]]></content:encoded>
    </item>
    <item>
      <title>1.Feign请求参数包装异常问题定位</title>
      <link>https://liuyueyi.github.io/tutorial/spring/cloud/Feign/01.190306-SpringCloud%E4%B9%8BFeign%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E5%8C%85%E8%A3%85%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/cloud/Feign/01.190306-SpringCloud%E4%B9%8BFeign%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E5%8C%85%E8%A3%85%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">1.Feign请求参数包装异常问题定位</source>
      <description>通过Feign包装rpc的调用姿势，在使用的版本中发现一个奇怪的bug，大部分场景下请求正常，少数情况下请求返回400，记录下原因</description>
      <category>SpringCloud</category>
      <category>Feign系列</category>
      <category>采坑记录</category>
      <pubDate>Wed, 06 Mar 2019 12:43:08 GMT</pubDate>
      <content:encoded><![CDATA[<p>通过Feign包装rpc的调用姿势，在使用的版本中发现一个奇怪的bug，大部分场景下请求正常，少数情况下请求返回400，记录下原因</p>
<!-- more -->
<h2> 场景复现</h2>
<h3> 1. 环境相关版本</h3>
<p>Spring版本如</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>Feign版本</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对应的feign-core版本为</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 服务接口</h3>
<p>接口形如</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用时报400的case</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>简单来说，接口参数为集合的情况下，如果传一个空集合，那么这就会出现400的错误</p>
<p>通过在提供服务的应用中，写一个fitler拦截请求，打印出请求参数</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后发起rpc调用前面的测试用例，通过断点查看请求参数，确实只有两个参数，而我们传入空pairIds集合，直接被吃掉了</p>
<figure><img src="/imgs/190306/00.jpg" alt="filter截图" tabindex="0" loading="lazy"><figcaption>filter截图</figcaption></figure>
<p>再对应到我们的api声明方式，要求三个参数，因此问题就很清晰了，解决办法就是在api中参数的必填设置为false即可</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面只是表层的解决了问题，接下来就需要确定，为什么请求参数会被吃掉，通过浅显的推测，多半原因在feign的请求参数封装上了</p>
<h3> 2. 问题定位</h3>
<p>对于容易复现的问题，最佳的定位方法就是debug了，直接单步进去，找到对应的请求参数封装逻辑，</p>
<p>第一步定位到<code>RequestTemplate</code>的创建</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来深入进去之后，参数解析的位置</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>再进去一步就到了根源点</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>下图是我们最终定位的一个截图，从代码实现来看，feign的设计理念是，如果请求参数为null，空集合，则不会将参数拼接到最终的请求参数中，也就导致最终发起请求时，少了一个参数</p>
<figure><img src="/imgs/190306/01.jpg" alt="debug截图" tabindex="0" loading="lazy"><figcaption>debug截图</figcaption></figure>
<p>问题清晰之后，然后就可以确认下是bug还是就是这么设计的了，最简单的办法就是看最新的代码有没有改掉了，从git上，目前已经更新到10.x；10.x与9.x的差别挺大，底层很多东西重写了，然而官方的<code>Spring-Cloud-openfeing</code>并没有升级到最新，so，只能取看9.7.0版本的实现了，和9.5.2并没有太大的区别；</p>
<p>so，站在feign开发者角度出发，这么设计的理由可能有以下几点</p>
<ul>
<li>既然允许传入空集合、null参数，那么在api的声明时，就有必要加上 <code>require=False</code></li>
<li>对于这种无效的请求参数，也没有太大的必要传过去（虽然从使用者角度来说，你就应该老老实实的把我调用的参数都丢过去）</li>
</ul>
<h3> 3. 小结</h3>
<p>最后小结一下，使用feign作为SpringCloud的rpc封装工具时，请注意，</p>
<ul>
<li>如果api的请求参数允许为null，请在注解中显示声明；</li>
<li>此外请求方传入的null、空集合最终不会拼装的请求参数中，即对于接受者而言，就像没有这个参数一样，对于出现400错误的场景，可以考虑下是否是这种问题导致的</li>
<li>对于复杂的请求参数，推荐使用DTO来替代多参数的类型（因为这样接口的复用性是最佳的，如新增和修改条件时，往往不需要新增api)</li>
</ul>
<h2> II. 其他</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">spring-boot-demo</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/190306/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>Feign</title>
      <link>https://liuyueyi.github.io/tutorial/spring/cloud/Feign/</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/cloud/Feign/</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">Feign</source>
      <description>基于Feign实现微服务访问</description>
      <pubDate>Fri, 10 Feb 2023 04:50:05 GMT</pubDate>
      <content:encoded><![CDATA[<p>基于Feign实现微服务访问</p>
]]></content:encoded>
    </item>
    <item>
      <title>1.整合docker镜像打包</title>
      <link>https://liuyueyi.github.io/tutorial/spring/middle/Docker/210304-SpringBoot%E7%B3%BB%E5%88%97%E6%95%B4%E5%90%88docker%E9%95%9C%E5%83%8F%E6%89%93%E5%8C%85.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/middle/Docker/210304-SpringBoot%E7%B3%BB%E5%88%97%E6%95%B4%E5%90%88docker%E9%95%9C%E5%83%8F%E6%89%93%E5%8C%85.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">1.整合docker镜像打包</source>
      <description>SpringBoot项目整合docker，打包镜像工程演示</description>
      <category>SpringBoot</category>
      <category>运维系列</category>
      <category>Docker</category>
      <pubDate>Thu, 04 Mar 2021 19:27:54 GMT</pubDate>
      <content:encoded><![CDATA[<p>SpringBoot项目整合docker，打包镜像工程演示</p>
<!-- more -->
<h2> I. 整合步骤</h2>
<h3> 1. 基本环境</h3>
<p>本项目借助<code>SpringBoot 2.2.1.RELEASE</code> + <code>maven 3.5.3</code> + <code>IDEA</code> + <code>MAC</code>进行开发</p>
<p>首先确保本机有安装docker，对于docker基本知识点，可以参考</p>
<ul>
<li><a href="https://blog.hhui.top/hexblog/2019/12/06/191206-Centos%E5%AE%89%E8%A3%85docker%E4%B8%8E%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/" target="_blank" rel="noopener noreferrer">Centos安装docker与使用说明</a></li>
<li><a href="https://blog.hhui.top/hexblog/2019/12/06/191206-Docker-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E9%80%9F%E6%9F%A5%E6%89%8B%E5%86%8C/" target="_blank" rel="noopener noreferrer">Docker 常用命令速查手册</a></li>
</ul>
<h3> 2. pom配置</h3>
<p>创建一个基本的SpringBoot项目之后，关键是设置<code>pom.xml</code>文件，我们主要借助<code>docker-maven-plugin</code>来打镜像包</p>
<p>一个可用的配置如下</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. Dockerfile 文件</h3>
<p>接下需要配置我们自己的dockerfile文件，在项目根目录下，新建文件名<code>Dockerfile</code>，如果路径有修改，需要调整上面pom配置中的<code>dockerDirectory</code>参数</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>关于dockerfile语法，可以参考</p>
<ul>
<li><a href="https://www.runoob.com/docker/docker-dockerfile.html" target="_blank" rel="noopener noreferrer">Docker Dockerfile语法说明</a></li>
</ul>
<p>我们上面的case，就是拉一个jdk8的运行环境，将打的jar包重命名为app.jar到指定目录，同时使用命令<code>java -jar app.jar</code>来启动应用</p>
<h3> 4. 测试demo</h3>
<p>提供一个最基础的demo实例</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>打包命令 <code>mvn clean package docker:build -DskipTests=true</code></p>
<p><strong>注意</strong></p>
<ul>
<li>打包的前提是docker已经启动了</li>
</ul>
<p>打包成功之后，可以看到会多一个docker镜像</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>运行镜像并测试</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/210304/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> II. 其他</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>项目: <a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/400-docker-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/400-docker-demo</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/210304/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>Docker</title>
      <link>https://liuyueyi.github.io/tutorial/spring/middle/Docker/</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/middle/Docker/</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">Docker</source>
      <description>SpringBoot配置docker，实现容器化管理部署</description>
      <pubDate>Fri, 10 Feb 2023 04:50:05 GMT</pubDate>
      <content:encoded><![CDATA[<p>SpringBoot配置docker，实现容器化管理部署</p>
]]></content:encoded>
    </item>
    <item>
      <title>1.邮件发送姿势介绍</title>
      <link>https://liuyueyi.github.io/tutorial/spring/middle/Email/210802-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8B%E9%82%AE%E4%BB%B6%E5%8F%91%E9%80%81%E5%A7%BF%E5%8A%BF%E4%BB%8B%E7%BB%8D.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/middle/Email/210802-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8B%E9%82%AE%E4%BB%B6%E5%8F%91%E9%80%81%E5%A7%BF%E5%8A%BF%E4%BB%8B%E7%BB%8D.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">1.邮件发送姿势介绍</source>
      <description>邮件发送，在实际的项目开发中，可能用的不是特别多，如果没有特定的需求，相信也没有多少小伙伴会特意的去关注，那么如果现在我们希望针对项目做一个异常的报警系统，当出现异常的时候，可以向指定的小伙伴发送邮件提醒，那么让我们来实现这个功能，可以怎么办呢？ 这里介绍一下如何使用SpringBoot封装好的MailSender来实现邮件发送</description>
      <category>SpringBoot</category>
      <category>中间件</category>
      <category>Email</category>
      <pubDate>Mon, 02 Aug 2021 21:41:28 GMT</pubDate>
      <content:encoded><![CDATA[<p>邮件发送，在实际的项目开发中，可能用的不是特别多，如果没有特定的需求，相信也没有多少小伙伴会特意的去关注，那么如果现在我们希望针对项目做一个异常的报警系统，当出现异常的时候，可以向指定的小伙伴发送邮件提醒，那么让我们来实现这个功能，可以怎么办呢？</p>
<p>这里介绍一下如何使用SpringBoot封装好的MailSender来实现邮件发送</p>
<!-- more -->
<h2> I. 项目环境</h2>
<h3> 1. 项目依赖</h3>
<p>本项目借助<code>SpringBoot 2.2.1.RELEASE</code> + <code>maven 3.5.3</code> + <code>IDEA</code>进行开发</p>
<p>开一个web服务用于测试</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 配置</h3>
<p>在开始之前，我们需要先准备一个用于发送邮件的账号，比如我这里使用163的邮箱来发送邮件，需要先到邮箱提供商哪里获取授权码，具体如何获取这个东西，不同的邮箱姿势有些不同，各位小伙伴根据自己的实际情况，搜索一下，相信很快就能get到</p>
<p>这里简单介绍下网易邮箱的获取方式</p>
<figure><img src="/imgs/210802/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>接下来设置发送邮件相关的配置信息，配置文件<code>application.yml</code></p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> II. 邮件发送</h2>
<p>接下来进入正题，我们将从简单基础的文本邮件发送开始，逐渐介绍如何添加附件，使用漂亮的html模板等</p>
<h3> 1. 简单文本邮件发送</h3>
<p>我们这里直接使用<code>JavaMailSender</code>来发送一个基础的文本邮件</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>JavaMailSender: 直接作为一个Spring 的bean对象使用</li>
<li>SimpleMailMessage：简单的邮件对象，里面有一些邮件发送时，关联的基础信息
<ul>
<li>from: 发送方</li>
<li>replyTo: 邮件回复的收件人</li>
<li>to: 收件人</li>
<li>cc: 抄送</li>
<li>bcc: 密送</li>
<li>subject: 主题，也就是邮件标题</li>
<li>text: 邮件正文，文本格式</li>
<li>date: 邮件发送时间</li>
</ul>
</li>
</ul>
<h3> 2. html发送</h3>
<p>对于简单的文本邮件发送，用上面的基本就够了，如果我们希望邮件的内容更美观一点的话，可以借助HTML来实现排版</p>
<p>区别于上面的SimpleMailMessage, 这里使用的是MimeMessage，来实现html内容发送</p>
<p>使用姿势与上面相比差不多，无非就是正文变成了html文本罢了</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>重点注意</strong></p>
<ul>
<li>注意上面的<code>setText</code>方法的第二个参数，必须有，且为true，否则会当成文本内容发送</li>
</ul>
<h3> 3. 添加附件</h3>
<p>邮件中添加附件，我们自己写邮件的时候可以直接选择附件上传，那么代码的实现方式又有什么区别呢？</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意上面的实现，与前面差别不大，关键点在于<code>attachment</code>附件，上面的实现是在附件中添加一个图片，为了简单起见，图片是直接从网络下载的，然后将Stream作为传参</p>
<h3> 4. Freemaker模板</h3>
<p>上面的html发送，会发现需要我们自己来组装html正文，这个操作可能就不是很美好了，借助页面渲染引擎来实现邮件模板支持，可以说是一个比较常见的方案了，这里简单介绍下Freemaker的实现姿势，至于themlaf, beef或者jsp啥的，都没有太大的区别</p>
<p>首先写一个邮件模板 <code>resources/template/mail.ftl</code></p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的模板中，定义了两个变量，一个<code>title</code>，一个<code>content</code>，这个就是我们需要替换的值</p>
<p>接下来是邮件发送实例</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意上面的实现，关键点就利用<code>FreeMarkerTemplateUtils</code>来实现模板的渲染，输出html正文，因此如果想使用其他的模板渲染引擎，就是改这里即可</p>
<h3> 5. 测试与小结</h3>
<p>最后简单的调用一下上面的实现，看下邮件是否可以发送成功</p>
<figure><img src="/imgs/210802/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<figure><img src="/imgs/210802/02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>本篇博文介绍了一下如何发送邮件，并针对简单的文本邮件，html正文，附件等不同的给出了实例；整体看下来使用姿势不难，不过邮件的几个术语可以了解一下</p>
<ul>
<li>to: 接收人，就是邮件发送的目标群众</li>
<li>cc: 抄送，一般来讲抄送的名单，只是让他感知到有这封邮件，属于周知对象</li>
<li>bcc: 密送，与上面两个不一样，接收人和抄送人不知道密送给谁了，这就是最大的区别，说实话这个玩意我从没用过</li>
</ul>
<p>接下来一篇博文，将介绍一下如何将log日志与邮件发送关联起来，当出现异常的时候，邮件发送给开发者</p>
<h2> III. 不能错过的源码和相关知识点</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/210802/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>2.实战：基于异常日志的邮件报警</title>
      <link>https://liuyueyi.github.io/tutorial/spring/middle/Email/210803-SpringBoot%E5%AE%9E%E6%88%98%E5%9F%BA%E4%BA%8E%E5%BC%82%E5%B8%B8%E6%97%A5%E5%BF%97%E7%9A%84%E9%82%AE%E4%BB%B6%E6%8A%A5%E8%AD%A6.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/middle/Email/210803-SpringBoot%E5%AE%9E%E6%88%98%E5%9F%BA%E4%BA%8E%E5%BC%82%E5%B8%B8%E6%97%A5%E5%BF%97%E7%9A%84%E9%82%AE%E4%BB%B6%E6%8A%A5%E8%AD%A6.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">2.实战：基于异常日志的邮件报警</source>
      <description>相信所有奋斗在一线的小伙伴，会很关心自己的系统的运行情况，一般来说，基础设施齐全一点的公司都会有完善的报警方案，那么如果我们是一个小公司呢，不能因为基础设施没有，就失去对象的感知能力吧；如果我们的系统大量异常却不能实时的触达给我们，那么也就只会有一个结果--杀个程序猿祭天 本文简单的介绍一种实现思路，基于error日志来实现邮件的报警方案</description>
      <category>SpringBoot</category>
      <category>中间件</category>
      <category>Email</category>
      <pubDate>Tue, 03 Aug 2021 21:09:39 GMT</pubDate>
      <content:encoded><![CDATA[<p>相信所有奋斗在一线的小伙伴，会很关心自己的系统的运行情况，一般来说，基础设施齐全一点的公司都会有完善的报警方案，那么如果我们是一个小公司呢，不能因为基础设施没有，就失去对象的感知能力吧；如果我们的系统大量异常却不能实时的触达给我们，那么也就只会有一个结果--杀个程序猿祭天</p>
<p>本文简单的介绍一种实现思路，基于error日志来实现邮件的报警方案</p>
<!-- more -->
<h2> I. 项目环境</h2>
<h3> 1. 项目依赖</h3>
<p>本项目借助<code>SpringBoot 2.2.1.RELEASE</code> + <code>maven 3.5.3</code> + <code>IDEA</code>进行开发</p>
<p>开一个web服务用于测试</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 配置</h3>
<p>邮件相关配置如下，注意使用自己的用户名 + 授权码填充下面缺失的配置</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> II. 异常日志的邮件预警</h2>
<h3> 1. 设计思路</h3>
<p>接下来这个方案的主要出发点在于，当程序出现大量的异常，表明应用多半出现了问题，需要立马发送给项目owner</p>
<p>要实现这个方案，关键点就在于异常出现的感知与上报</p>
<ul>
<li>异常的捕获，并输出日志（这个感觉属于标配了吧，别告诉我现在还有应用不输出日志文件的...）
<ul>
<li>对于这个感知，借助logback的扩展机制，可以实现，后面介绍</li>
</ul>
</li>
<li>异常上报：邮件发送</li>
</ul>
<p>关于email的使用姿势，推荐参考博文 <a href="http://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247486591&amp;idx=1&amp;sn=04f18e2f313abd371947f9818e238067&amp;chksm=fce717d3cb909ec575b8e521843eff04edfcf844e59ca976515bc29d8a23782c4d5d30580d0e&amp;token=908878619&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">SpringBoot 系列之邮件发送姿势介绍</a></p>
<h3> 2. 自定义appender</h3>
<p>定义一个用于错误发送的Appender，如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. Spring容器</h3>
<p>上面的邮件发送中，需要使用<code>JavaMailSender</code>，写一个简单的SpringContext工具类，用于获取Bean/Propertiy</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4. logback配置</h3>
<p>接下来就是在日志配置中，使用我们上面定义的Appender</p>
<p><code>logback-spring.xml</code>文件内容如下：</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 5. 测试demo</h3>
<p>接下来演示一下，是否可以达到我们的预期</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/210803/00.gif" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 5.小结</h3>
<p>本篇博文主要提供了一个思路，借助logback的扩展机制，来实现错误日志与预警邮件绑定，实现一个简单的应用异常监控</p>
<p>上面这个实现只算是一个雏形，算是抛砖引玉，有更多可以丰富的细节，比如</p>
<ul>
<li>飞书/钉钉通知（借助飞书钉钉的机器来报警，相比较于邮件感知性更高）</li>
<li>根据异常类型，做预警的区分</li>
<li>更高级的频率限制等</li>
</ul>
<p>在这里推荐一个我之前开源的预警系统，可以实现灵活预警方案配置，频率限制，重要性升级等</p>
<ul>
<li>一个可扩展的报警系统 <a href="https://github.com/liuyueyi/quick-alarm" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/quick-alarm</a></li>
</ul>
<h2> III. 不能错过的源码和相关知识点</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-case/430-mail-alarm" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-case/430-mail-alarm</a></li>
</ul>
<p>推荐关联博文</p>
<ul>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247486591&amp;idx=1&amp;sn=04f18e2f313abd371947f9818e238067&amp;chksm=fce717d3cb909ec575b8e521843eff04edfcf844e59ca976515bc29d8a23782c4d5d30580d0e&amp;token=908878619&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">SpringBoot 系列之邮件发送姿势介绍</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/210803/00.gif" type="image/gif"/>
    </item>
    <item>
      <title>Email</title>
      <link>https://liuyueyi.github.io/tutorial/spring/middle/Email/index.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/middle/Email/index.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">Email</source>
      <description>SpringBoot无障碍使用邮箱服务</description>
      <pubDate>Fri, 10 Feb 2023 04:50:05 GMT</pubDate>
      <content:encoded><![CDATA[<p>SpringBoot无障碍使用邮箱服务</p>
]]></content:encoded>
    </item>
    <item>
      <title>1.Prometheus实现应用监控</title>
      <link>https://liuyueyi.github.io/tutorial/spring/middle/Prometheus/210419-SpringBoot%E6%95%B4%E5%90%88Prometheus%E5%AE%9E%E7%8E%B0%E5%BA%94%E7%94%A8%E7%9B%91%E6%8E%A7.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/middle/Prometheus/210419-SpringBoot%E6%95%B4%E5%90%88Prometheus%E5%AE%9E%E7%8E%B0%E5%BA%94%E7%94%A8%E7%9B%91%E6%8E%A7.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">1.Prometheus实现应用监控</source>
      <description>1. prometheus 安装 教程文档: https://www.prometheus.wang/quickstart/install-prometheus-server.html 1.1 什么是Prometheus 普罗米修斯：Prometheus是一个开放性的监控解决方案，用户可以非常方便的安装和使用Prometheus并且能够非常方便的对其进行扩展</description>
      <category>SpringBoot</category>
      <category>中间件</category>
      <category>Prometheus</category>
      <pubDate>Mon, 19 Apr 2021 18:40:03 GMT</pubDate>
      <content:encoded><![CDATA[<h3> 1. prometheus 安装</h3>
<p>教程文档: <a href="https://www.prometheus.wang/quickstart/install-prometheus-server.html" target="_blank" rel="noopener noreferrer">https://www.prometheus.wang/quickstart/install-prometheus-server.html</a></p>
<h4> 1.1 什么是Prometheus</h4>
<blockquote>
<p>普罗米修斯：Prometheus是一个开放性的监控解决方案，用户可以非常方便的安装和使用Prometheus并且能够非常方便的对其进行扩展</p>
</blockquote>
<!-- more -->
<p>下面将实现一个SpringBoot应用接入Prometheus的全过程</p>
<h4> 1.2 安装</h4>
<p>Linux 安装</p>
<ul>
<li>官网指定下载包:  <a href="https://prometheus.io/download/" target="_blank" rel="noopener noreferrer">https://prometheus.io/download/</a></li>
</ul>
<p>下载本地安装启动</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>启动完毕之后，本地访问 <a href="http://127.0.0.1:9090/graph" target="_blank" rel="noopener noreferrer">http://127.0.0.1:9090/graph</a> 可以看到默认提供的界面</p>
<h3> 2. SpringBoot应用接入</h3>
<p>我们演示的SpringBoot为2.0+，因此直接选择<code>io.micrometer</code> 的依赖包来实现；更低版本的不能使用这种姿势，可以直接使用官方提供的client来实现；这里不进行扩展</p>
<h4> 2.1 依赖配置</h4>
<p>借助SpringBoot的actuator来提供扩展端点（所以本文采用的是Prometheus的拉工作模式）</p>
<p>SpringBoot版本为 <code>2.2.1.RELEASE</code></p>
<p>核心依赖</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>yaml配置文件，需要指定Prometheus相关的参数，一个demo如下</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>注意</strong></p>
<ul>
<li><code>management.endpoints.web.exposure.include</code> 这里指定所有的web接口都会上报</li>
<li><code>metrics.tags.application</code> 这个应用所有上报的metrics 都会带上<code>application</code>这个标签</li>
</ul>
<p>上面配置完毕之后，会提供一个 <code>/actuator/prometheus</code>的端点，供prometheus来拉取Metrics信息</p>
<h4> 2.2 应用启动</h4>
<p>对于SpringBoot而言，此时就不需要额外做什么，就可以实现应用的基本信息上报了</p>
<p>一个简单的demo如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>到此，springboot应用的监控就算是完成了；接下来配置一下prometheus的服务端</p>
<h3> 3. prometheus 配置与实测</h3>
<p>在前面下载的包下面，有一个配置文件 <code>prometheus.yml</code>，新增一个Job</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>修改配置之后，需要重启一下，当服务启动之后，可以在控制台上我们的应用信息</p>
<figure><img src="/imgs/210419/00.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>接下来访问Graph，选择metric: <code>http_server_requests_seconds_count</code> 可以看到一条抓起metric的记录</p>
<figure><img src="/imgs/210419/01.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>前面我们定义了一个Controller，接下来简单访问几次，然后再看一下，会发现多一条记录</p>
<figure><img src="/imgs/210419/02.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>这些数据由框架层直接集成，实现REST接口的相关信息上报，借助这个metric，我们可以实现qps的统计</p>
<h4> 3.1 qps统计</h4>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="/imgs/210419/03.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<ul>
<li>rate: 用于统计增长趋势，要求上报的Metric为Counter类型（只增不减）</li>
<li>irate: 与rate相似，区别在于rate统计的是一段时间内的平均增长速率，无法反应这个时间窗口内的突发情况（即瞬时高峰），irate通过区间向量中最后两个样本数据来计算增长速率，但是当选用的区间范围较大时，可能造成不小的偏差</li>
<li>sum: 求和，适用于统计场景</li>
</ul>
<p>更多内置函数，可以参考: <a href="https://www.prometheus.wang/promql/prometheus-promql-functions.html" target="_blank" rel="noopener noreferrer">PromQL内置函数</a></p>
<h4> 3.2 耗时统计</h4>
<p>除了qps，另外一个经常关注的指标就是rt了，如上面接口的平均rt，通过两个Metric的组合来实现</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="/imgs/210419/04.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>将sum聚合去掉之后，则可以看到各接口的访问情况</p>
<figure><img src="/imgs/210419/05.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 4. Grafana 大盘配置</h3>
<p>面板监控，还是Grafana的比较强大，特别是grafana本身提供了很多模板可以直接导入</p>
<blockquote>
<p>安装可以参考: <a href="https://blog.hhui.top/hexblog/2021/03/18/210318-linux-grafana%E5%A4%A7%E7%9B%98%E6%8E%A5%E5%85%A5mysql/" target="_blank" rel="noopener noreferrer">210318-linux grafana大盘接入mysql</a></p>
</blockquote>
<h4> 4.1 大盘配置</h4>
<p>grafana启动之后，配置数据源Promethues</p>
<figure><img src="/imgs/210419/06.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>接下来配置SpringBoot的应用配置面板，可以直接使用现成的模板，比如 12856</p>
<figure><img src="/imgs/210419/07.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>导入完毕之后，大盘展示如下</p>
<figure><img src="/imgs/210419/08.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>可以看一下请求耗时的统计promql</p>
<figure><img src="/imgs/210419/09.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h4> 4.2 大盘模板哪里找</h4>
<p>如何找直接可用的大盘呢？</p>
<ul>
<li>官网的大盘上查找即可</li>
<li>如 <a href="https://grafana.com/grafana/dashboards?dataSource=prometheus&amp;search=spring" target="_blank" rel="noopener noreferrer">https://grafana.com/grafana/dashboards?dataSource=prometheus&amp;search=spring</a></li>
<li>选择一个，点进去之后，右边的<code>Copy ID toClipboard</code> 对应的数字就是我们需要的</li>
</ul>
<figure><img src="/imgs/210419/10.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 5. 小结</h3>
<p>上面整个流程走下来会发现SpringBoot项目接入Prometheus成本很低，基本上没有太多的编码工作，就可以配置给功能集全的监控大盘，简直不要太嗨</p>
<p>高度封装的便捷性再这里体现得非常突出了，但是搞完之后，再回想一下，我get到了什么？</p>
<p>好像什么都没get到，如果我的服务只提供grpc/dubbo接口，现在假设让我们接入监控，好像还是抓瞎，这该怎么玩</p>
<h2> II. 其他</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>项目源码: <a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/420-prometheus-basic" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/420-prometheus-basic</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/210419/00.png" type="image/png"/>
    </item>
    <item>
      <title>2.自定义埋点上报</title>
      <link>https://liuyueyi.github.io/tutorial/spring/middle/Prometheus/211109-SpringBoot%E4%B9%8BPrometheus%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%8B%E7%82%B9%E4%B8%8A%E6%8A%A5.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/middle/Prometheus/211109-SpringBoot%E4%B9%8BPrometheus%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%8B%E7%82%B9%E4%B8%8A%E6%8A%A5.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">2.自定义埋点上报</source>
      <description>之前介绍了一篇SpringBoot集成Prometheus实现数据上报的博文，在前面一篇博文中，更多的是一个SpringBoot应用如何最小成本的接入Prometheus，并结合Grafana配置一个完整的应用监控大盘 有看过前文的小伙伴可能知晓，SpringBoot接入Prometheus之后，基本上不用做额外的开发，就已经实现了我们关心的JVM情况、GC情况、HTTP调用请求等信息，然而在实际的业务开发过程中，我们总会遇到一些需要手动上报的场景，那么我们可以怎么处理呢？ 本文的核心知识点： 通过一个实例演示SpringBoot应用，如何实现自定义的数据上报 上篇博文: SpringBoot整合Prometheus实现应用监控</description>
      <category>SpringBoot</category>
      <category>中间件</category>
      <category>Prometheus</category>
      <pubDate>Tue, 09 Nov 2021 18:44:30 GMT</pubDate>
      <content:encoded><![CDATA[<p>之前介绍了一篇SpringBoot集成Prometheus实现数据上报的博文，在前面一篇博文中，更多的是一个SpringBoot应用如何最小成本的接入Prometheus，并结合Grafana配置一个完整的应用监控大盘</p>
<p>有看过前文的小伙伴可能知晓，SpringBoot接入Prometheus之后，基本上不用做额外的开发，就已经实现了我们关心的JVM情况、GC情况、HTTP调用请求等信息，然而在实际的业务开发过程中，我们总会遇到一些需要手动上报的场景，那么我们可以怎么处理呢？</p>
<p>本文的核心知识点：</p>
<ul>
<li>通过一个实例演示SpringBoot应用，如何实现自定义的数据上报</li>
</ul>
<p>上篇博文: <a href="https://spring.hhui.top/spring-blog/2021/04/19/210419-SpringBoot%E6%95%B4%E5%90%88Prometheus%E5%AE%9E%E7%8E%B0%E5%BA%94%E7%94%A8%E7%9B%91%E6%8E%A7/" target="_blank" rel="noopener noreferrer">SpringBoot整合Prometheus实现应用监控</a></p>
<!-- more -->
<h2> I. 项目环境搭建</h2>
<p>本文演示的项目主要为SpringBoot2.2.1版本，更高的版本使用姿势没有太大的区别，至于1.x版本的不确保可行（因为我并没有测试）</p>
<h3> 1.依赖</h3>
<p>pom依赖，主要是下面几个包</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 配置信息</h3>
<p>其次是配置文件，注册下Prometheus的相关信息</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面配置中，有两个关键信息，前面博文也有介绍，这里简单说明</p>
<ul>
<li><code>management.endpoints.web.exposure.include</code> 这里指定所有的web接口都会上报</li>
<li><code>metrics.tags.application</code> 这个应用所有上报的metrics 都会带上application这个标签</li>
</ul>
<p>配置完毕之后，会提供一个 <code>/actuator/prometheus</code>的端点，供prometheus来拉取Metrics信息</p>
<h2> II. 自定义上报</h2>
<p>假设我们现在想自己上报http请求的相关信息，当前计划采集下面几个信息</p>
<ul>
<li>总的请求数：采用<code>Counter</code></li>
<li>当前正在处理的请求数：采用<code>Gauge</code></li>
<li>请求耗时直方图: <code>Histogram</code></li>
</ul>
<h3> 1. Prometheus Metric封装</h3>
<p>基于上面的分析，我们这里实现了三种常见的Metric信息上报，这里提供一个统一的封装类，用于获取对应的Metric类型</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意上面的<code>setApplicationContext()</code>的方法实现逻辑，其中在创建<code>Counter/Gauge/Histogram</code>时，使用的是<code>simpleclient</code>包中提供的最基础的用法，并不是<code>micrometer</code>的封装方式，后面一篇博文会介绍到两种的差异性</p>
<p>上面实现的特点在于，创建Metric时，就已经定义好了label标签，这里定义了</p>
<ul>
<li>path: 请求url路径</li>
<li>method: http方法, get/post</li>
<li>code: 状态码，表示请求成功还是异常</li>
</ul>
<h3> 2. 拦截器实现自定义信息采集上报</h3>
<p>接下来我们实现一个自定义的拦截器，拦截所有的http请求，然后上报关键信息</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对于拦截器的知识点这里不进行展开，有兴趣的小伙伴可以查看 <a href="https://spring.hhui.top/spring-blog/2021/08/04/210804-SpringBoot%E7%B3%BB%E5%88%97Web%E7%AF%87%E4%B9%8B%E6%8B%A6%E6%88%AA%E5%99%A8Interceptor%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF%E4%BB%8B%E7%BB%8D/" target="_blank" rel="noopener noreferrer">SpringBoot系列Web篇之拦截器Interceptor使用姿势介绍</a></p>
<p>这里我们主要关心的就两点</p>
<ul>
<li>执行之前（<code>preHandle</code>）： gauge计数+1，开始计时</li>
<li>执行之后 (<code>afterCompletion</code>)： guage计数-1，counter计数+1，计时收集</li>
</ul>
<h3> 3. 测试</h3>
<p>最后我们需要注册上面的拦截器，并写个demo进行测试一下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>应用启动之后，访问几次hello的http接口，然后在查看一下metric信息，看是否有我们刚才上报的数据</p>
<figure><img src="/imgs/211109/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 4. 小结</h3>
<p>这一篇博文算是上一篇的补全，若我们希望自定义上报一些信息，可以使用上面这种方式来支持</p>
<p>当然，上报并不代表结束，接下来配置大盘等信息也非常的关键，特别是直方图如何配置Grafana？怎么查看请求的耗时分布情况，就由下文来介绍了</p>
<h2> III. 不能错过的源码和相关知识点</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/</a></li>
</ul>
<h3> 1. 微信公众号: 一灰灰Blog</h3>
<p>尽信书则不如，以上内容，纯属一家之言，因个人能力有限，难免有疏漏和错误之处，如发现bug或者有更好的建议，欢迎批评指正，不吝感激</p>
<p>下面一灰灰的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛</p>
<ul>
<li>一灰灰Blog个人博客 <a href="https://blog.hhui.top" target="_blank" rel="noopener noreferrer">https://blog.hhui.top</a></li>
<li>一灰灰Blog-Spring专题博客 <a href="http://spring.hhui.top" target="_blank" rel="noopener noreferrer">http://spring.hhui.top</a></li>
</ul>
<figure><img src="https://spring.hhui.top/spring-blog/imgs/info/info.png" alt="一灰灰blog" tabindex="0" loading="lazy"><figcaption>一灰灰blog</figcaption></figure>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/211109/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>3.自定义埋点姿势二</title>
      <link>https://liuyueyi.github.io/tutorial/spring/middle/Prometheus/211119-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8BPrometheus%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%8B%E7%82%B9%E5%A7%BF%E5%8A%BF%E4%BA%8C.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/middle/Prometheus/211119-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8BPrometheus%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%8B%E7%82%B9%E5%A7%BF%E5%8A%BF%E4%BA%8C.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">3.自定义埋点姿势二</source>
      <description>关于Prometheus的自定义埋点，前一篇博文已经介绍了，为啥这里又来一次？ 看过前文的小伙伴可能会知道，之前采用的simpleclient包定义的几个metric来实现的，实际上有更简单方便的姿势，那就是直接借助MeterRegistry来创建Metric来实现数据采集即可 相比较于前文的实现，总的来说简易程度可见一般，上篇文章可以点击下文查看 【中间件】Prometheus自定义埋点上报 | 一灰灰Blog</description>
      <category>SpringBoot</category>
      <category>中间件</category>
      <category>Prometheus</category>
      <pubDate>Fri, 19 Nov 2021 19:30:15 GMT</pubDate>
      <content:encoded><![CDATA[<p>关于Prometheus的自定义埋点，前一篇博文已经介绍了，为啥这里又来一次？</p>
<p>看过前文的小伙伴可能会知道，之前采用的<code>simpleclient</code>包定义的几个metric来实现的，实际上有更简单方便的姿势，那就是直接借助<code>MeterRegistry</code>来创建Metric来实现数据采集即可</p>
<p>相比较于前文的实现，总的来说简易程度可见一般，上篇文章可以点击下文查看</p>
<ul>
<li><a href="https://spring.hhui.top/spring-blog/2021/11/09/211109-SpringBoot%E4%B9%8BPrometheus%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%8B%E7%82%B9%E4%B8%8A%E6%8A%A5/" target="_blank" rel="noopener noreferrer">【中间件】Prometheus自定义埋点上报 | 一灰灰Blog</a></li>
</ul>
<!-- more -->
<h2> I. 自定义上报</h2>
<p>依然是搭建一个基础项目工程，本文演示的项目主要为SpringBoot2.2.1版本，更高的版本使用姿势没有太大的区别，至于1.x版本的不确保可行（因为我并没有测试）</p>
<h3> 1.依赖</h3>
<p>pom依赖，主要是下面几个包</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 配置信息</h3>
<p>其次是配置文件，注册下Prometheus的相关信息</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面配置中，有两个关键信息，前面博文也有介绍，这里简单说明</p>
<ul>
<li><code>management.endpoints.web.exposure.include</code> 这里指定所有的web接口都会上报</li>
<li><code>metrics.tags.application</code> 这个应用所有上报的metrics 都会带上application这个标签</li>
</ul>
<p>配置完毕之后，会提供一个 <code>/actuator/prometheus</code>的端点，供prometheus来拉取Metrics信息</p>
<h3> 3. 自定义拦截器实现采集上报</h3>
<p>实现一个基础的拦截器，用来拦截所有的http请求，然后收集请求信息上报</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意上面的三种Metric的创建方式</p>
<ul>
<li>Counter: 直接使用 <code>meterRegistry.counter()</code>来创建metric并实现计数+1
<ul>
<li>传参中，Tags组成的就是propmetheus中定义的label，kv格式，第一个参数用来定义MetricName</li>
</ul>
</li>
<li>Gauge: 使用姿势与上面基本相同，不过需要注意计数的加减是直接在传参中</li>
<li>Histogram: 它的使用姿势就需要特别注意下了，在preHander中定义的是 <code>Timer.Sampler</code>对象，在 <code>postHandler</code>中实现的数据采集</li>
</ul>
<p>上面短短一点代码，就实现了一个简单的自定义信息上报；接下来就是注册拦截器了</p>
<h3> 4. 注册并测试</h3>
<p>拦截器依赖了Spring的bean对象，因此需要将它定义为bean对象</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>基于此一个简单的自定义采集上报就完成了；项目启动之后，通过访问采集端点查看是否有数据上报</p>
<figure><img src="/imgs/211119/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>最后小结一下，虽然SpringBoot可以非常方便的接入prometheus来采集一些常见的指标，但是当我们有自定义上报指标的需求时，直接使用<code>MeterRegistry</code>来收集信息，创建Metric是个不错的选择，通常我们选择的三种类型作用如下</p>
<ul>
<li>总的请求数：采用<code>Counter</code></li>
<li>当前正在处理的请求数：采用<code>Gauge</code></li>
<li>请求耗时直方图: <code>Histogram</code></li>
</ul>
<h2> II. 不能错过的源码和相关知识点</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/421-prometheus-micro" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/421-prometheus-micro</a></li>
</ul>
<h3> 1. 微信公众号: 一灰灰Blog</h3>
<p>尽信书则不如，以上内容，纯属一家之言，因个人能力有限，难免有疏漏和错误之处，如发现bug或者有更好的建议，欢迎批评指正，不吝感激</p>
<p>下面一灰灰的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛</p>
<ul>
<li>一灰灰Blog个人博客 <a href="https://blog.hhui.top" target="_blank" rel="noopener noreferrer">https://blog.hhui.top</a></li>
<li>一灰灰Blog-Spring专题博客 <a href="http://spring.hhui.top" target="_blank" rel="noopener noreferrer">http://spring.hhui.top</a></li>
</ul>
<figure><img src="https://spring.hhui.top/spring-blog/imgs/info/info.png" alt="一灰灰blog" tabindex="0" loading="lazy"><figcaption>一灰灰blog</figcaption></figure>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/211119/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>4.基于AOP实现埋点采集上报</title>
      <link>https://liuyueyi.github.io/tutorial/spring/middle/Prometheus/211222-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8BPrometheus%E5%9F%BA%E4%BA%8EAOP%E5%AE%9E%E7%8E%B0%E5%9F%8B%E7%82%B9%E9%87%87%E9%9B%86%E4%B8%8A%E6%8A%A5.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/middle/Prometheus/211222-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8BPrometheus%E5%9F%BA%E4%BA%8EAOP%E5%AE%9E%E7%8E%B0%E5%9F%8B%E7%82%B9%E9%87%87%E9%9B%86%E4%B8%8A%E6%8A%A5.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">4.基于AOP实现埋点采集上报</source>
      <description>前面几篇文章介绍了SpringBoot继承Prometheus实现埋点上报，基本上可以非常简单的实现采样收集，对于由SpringBoot搭建的web应用，甚至是可以说是引入依赖，简单的配置下，剩下的啥也不用管，就可以配置一个REST应用的监控大盘 接下来我们通过AOP的方式，来定义一个自定义数据采集的功能，用于实现一些上面覆盖不到的场景（如应用内的定时任务执行情况，三方接口请求监控等） I. 方案确定与环境搭建 1.metric选择 通过前面的几篇文章，至少我们会了解到Prometheus的四种Metric，对于自定义的数据采集，根据最终希望监控的指标（每秒请求数 qps, 响应耗时 rt, 可用率 sla, 请求分布），我们这里选择Histogram</description>
      <category>SpringBoot</category>
      <category>中间件</category>
      <category>Prometheus</category>
      <pubDate>Wed, 22 Dec 2021 19:30:15 GMT</pubDate>
      <content:encoded><![CDATA[<p>前面几篇文章介绍了SpringBoot继承Prometheus实现埋点上报，基本上可以非常简单的实现采样收集，对于由SpringBoot搭建的web应用，甚至是可以说是引入依赖，简单的配置下，剩下的啥也不用管，就可以配置一个REST应用的监控大盘</p>
<p>接下来我们通过AOP的方式，来定义一个自定义数据采集的功能，用于实现一些上面覆盖不到的场景（如应用内的定时任务执行情况，三方接口请求监控等）</p>
<!--  more -->
<h2> I. 方案确定与环境搭建</h2>
<h3> 1.metric选择</h3>
<p>通过前面的几篇文章，至少我们会了解到Prometheus的四种Metric，对于自定义的数据采集，根据最终希望监控的指标（每秒请求数 qps, 响应耗时 rt, 可用率 sla, 请求分布），我们这里选择Histogram</p>
<ul>
<li>通过histogram指标中的 count 值来计算qps</li>
<li>通过 sum / count 来计算rt</li>
<li>通过<code>成功数 / 总请求数</code>计算可用率sla</li>
<li>通过histogram的bucket分布来查看请求分布</li>
</ul>
<h3> 2.项目依赖</h3>
<p>本项目借助<code>SpringBoot 2.2.1.RELEASE</code> +  <code>maven 3.5.3</code> + <code>IDEA</code>进行开发</p>
<p>其核心pom依赖，主要是下面几个包</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. 配置信息</h3>
<p>其次是配置文件，注册下Prometheus的相关信息</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面配置中，有两个关键信息，前面博文也有介绍，这里简单说明</p>
<ul>
<li><code>management.endpoints.web.exposure.include</code> 这里指定所有的web接口都会上报</li>
<li><code>metrics.tags.application</code> 这个应用所有上报的metrics 都会带上application这个标签</li>
</ul>
<p>配置完毕之后，会提供一个 <code>/actuator/prometheus</code>的端点，供prometheus来拉取Metrics信息</p>
<h2> II. AOP切面实现埋点上报</h2>
<h3> 1. 切面实现类</h3>
<p>通过切面来拦截目标类的执行，选择三个关键指标</p>
<ul>
<li>service: 表示具体执行的类</li>
<li>method：执行的方法</li>
<li>err: true 表示执行异常/else 表示执行正常</li>
</ul>
<p>直接使用Histogram来实现数据采集上报，直接使用前面博文* <a href="https://spring.hhui.top/spring-blog/2021/11/19/211119-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8BPrometheus%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%8B%E7%82%B9%E5%A7%BF%E5%8A%BF%E4%BA%8C/" target="_blank" rel="noopener noreferrer">【中间件】Prometheus自定义埋点姿势二 | 一灰灰Blog</a> 使用姿势即可</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 测试方法</h3>
<p>这里写两个简单的Service类，作为收集采样的目标</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后我们通过定时任务来不断的访问上面的服务方法，用来模拟请求场景</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. 启动类</h3>
<p>最后就是在启动类中注册一下MeterRegistryCustomizer，为所有的metric携带上<code>application</code>标签</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>应用启动之后，就可以通过<code>http://m-162d9nnes031u:8080/actuator/prometheus</code>来查看收集的采样信息了，如</p>
<figure><img src="/imgs/211222/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 4. 业务大盘配置</h3>
<p>上面基本即实现了一个基于aop的采样收集，接下来重点就是如何将这些收集上来的数据，可视化配置起来</p>
<p>借助Grafana无疑是个比较推荐的case，下一篇博文将详细介绍如何针对上面收集的信息进行友好的配置，欢迎有兴趣的小伙伴关注吐槽</p>
<h2> III. 不能错过的源码和相关知识点</h2>
<h3> 0. 项目源码</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-case/421-prometheus-metric" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-case/421-prometheus-metric</a></li>
</ul>
<p><strong>系列博文：</strong></p>
<ul>
<li><a href="https://spring.hhui.top/spring-blog/2021/11/19/211119-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8BPrometheus%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%8B%E7%82%B9%E5%A7%BF%E5%8A%BF%E4%BA%8C/" target="_blank" rel="noopener noreferrer">【中间件】Prometheus自定义埋点姿势二</a></li>
<li><a href="https://spring.hhui.top/spring-blog/2021/11/09/211109-SpringBoot%E4%B9%8BPrometheus%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%8B%E7%82%B9%E4%B8%8A%E6%8A%A5/" target="_blank" rel="noopener noreferrer">【中间件】Prometheus自定义埋点上报</a></li>
<li><a href="https://spring.hhui.top/spring-blog/2021/04/19/210419-SpringBoot%E6%95%B4%E5%90%88Prometheus%E5%AE%9E%E7%8E%B0%E5%BA%94%E7%94%A8%E7%9B%91%E6%8E%A7/" target="_blank" rel="noopener noreferrer">【中间件】Prometheus实现应用监控</a></li>
</ul>
<h3> 1. 微信公众号: 一灰灰Blog</h3>
<p>尽信书则不如，以上内容，纯属一家之言，因个人能力有限，难免有疏漏和错误之处，如发现bug或者有更好的建议，欢迎批评指正，不吝感激</p>
<p>下面一灰灰的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛</p>
<ul>
<li>一灰灰Blog个人博客 <a href="https://blog.hhui.top" target="_blank" rel="noopener noreferrer">https://blog.hhui.top</a></li>
<li>一灰灰Blog-Spring专题博客 <a href="http://spring.hhui.top" target="_blank" rel="noopener noreferrer">http://spring.hhui.top</a></li>
</ul>
<figure><img src="https://spring.hhui.top/spring-blog/imgs/info/info.png" alt="一灰灰blog" tabindex="0" loading="lazy"><figcaption>一灰灰blog</figcaption></figure>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/211222/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>5.Prometheus大盘配置实战</title>
      <link>https://liuyueyi.github.io/tutorial/spring/middle/Prometheus/211223-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8BPrometheus%E5%A4%A7%E7%9B%98%E9%85%8D%E7%BD%AE%E5%AE%9E%E6%88%98.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/middle/Prometheus/211223-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8BPrometheus%E5%A4%A7%E7%9B%98%E9%85%8D%E7%BD%AE%E5%AE%9E%E6%88%98.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">5.Prometheus大盘配置实战</source>
      <description>借助Grafana来实现大盘配置，关于Grafana的启用配置，这里就不详细说明，有兴趣的可以查看前文 * 【中间件】Prometheus实现应用监控 | 一灰灰Blog 接下来主要是针对上一篇 【中间件】Prometheus基于AOP实现埋点采集上报 上报的Histogram数据，来配置一套相对完整的业务监控大盘</description>
      <category>SpringBoot</category>
      <category>中间件</category>
      <category>Prometheus</category>
      <pubDate>Thu, 23 Dec 2021 10:17:10 GMT</pubDate>
      <content:encoded><![CDATA[<p>借助Grafana来实现大盘配置，关于Grafana的启用配置，这里就不详细说明，有兴趣的可以查看前文 * <a href="https://spring.hhui.top/spring-blog/2021/04/19/210419-SpringBoot%E6%95%B4%E5%90%88Prometheus%E5%AE%9E%E7%8E%B0%E5%BA%94%E7%94%A8%E7%9B%91%E6%8E%A7/" target="_blank" rel="noopener noreferrer">【中间件】Prometheus实现应用监控 | 一灰灰Blog</a></p>
<p>接下来主要是针对上一篇 <a href="https://spring.hhui.top/spring-blog/2021/12/22/211222-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8BPrometheus%E5%9F%BA%E4%BA%8EAOP%E5%AE%9E%E7%8E%B0%E5%9F%8B%E7%82%B9%E9%87%87%E9%9B%86%E4%B8%8A%E6%8A%A5/" target="_blank" rel="noopener noreferrer">【中间件】Prometheus基于AOP实现埋点采集上报</a> 上报的Histogram数据，来配置一套相对完整的业务监控大盘</p>
<!-- more -->
<h2> I.大盘配置</h2>
<h3> 1. 基本盘选择</h3>
<p>直接到官网查找模板大盘，这里选择SpringBoot搭建的服务器项目，可以输入spring关键字进行检索</p>
<blockquote>
<p>官网：<a href="https://grafana.com/grafana/dashboards?dataSource=prometheus&amp;search=spring" target="_blank" rel="noopener noreferrer">https://grafana.com/grafana/dashboards?dataSource=prometheus&amp;search=spring</a></p>
</blockquote>
<p>比如我们这里选择 <code>6756</code> 作为基础模板；然后在Grafana上导入</p>
<figure><img src="/imgs/211223/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>导入之后，对于变量的依赖顺序根据实际情况调整一下，比如我希望第一个变量是application,在选择应用之后，再选择对应的实例ip；</p>
<p>修改步骤如下：</p>
<ul>
<li>依次选择：dashboard settings -&gt; variables</li>
<li>将application变量前置到instance前</li>
<li>application:
<ul>
<li>修改query为: <code>label_values(jvm_classes_loaded_classes, application)</code></li>
</ul>
</li>
<li>instance:
<ul>
<li>修改query为: <code>label_values(jvm_classes_loaded_classes{application="$application"}, instance)</code></li>
</ul>
</li>
<li>新增service变量
<ul>
<li>query = <code>label_values(micro_service_histogram_seconds_count{application="$application", instance="$instance"}, service)</code></li>
</ul>
</li>
</ul>
<figure><img src="/imgs/211223/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p><strong>注意</strong></p>
<ul>
<li>一个变量的取值依赖另一个变量，请注意将被依赖的变量顺序放在前面</li>
<li>一个变量的取值依赖另一个变量，写法是 <code>metric{tag="$valName"}</code>， 这个变量名前缀是<code>$</code>，且使用双引号包裹</li>
<li>metric的选择，可以通过直接查看目标服务器的metric接口查看，比如service变量选择的metric就是自定义上报的<code>micro_service_histogram_seconds_count</code>，而application与instance则选取的是Prometheus-Spring组件上报的spring应用基础信息中的metric</li>
</ul>
<h3> 2. 业务盘配置</h3>
<p>常见的业务指标，如QPS + RT + TPS + SLA等，接下来看一下如何进行配置</p>
<h4> 2.1 qps 每秒请求数</h4>
<p>主要是借助内置函数<code>rate</code>来计算qps，通过一个计算时间窗口的平均增长速率，来展示接口的qps</p>
<div class="language-PrmomQL line-numbers-mode" data-ext="PrmomQL"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="/imgs/211223/02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>使用rate来计算qps时，会存在一个<code>长尾问题</code>，因为它实际上是根据1min内的所有样本数据，来计算平均增长率，因此当一个时间窗口内，存在瞬时的大数据场景，将不能很好的反应出来</p>
<p>因此更关注瞬时场景时，可以考虑使用<code>irate</code>来代替，它是通过一个时间范围内的区间向量数据中最后两个来计算增长速率的</p>
<h4> 2.2 rt 接口响应平均耗时</h4>
<p>对于耗时的统计，也是比较重要的一个指标，用于判断我们系统的响应情况以及性能表现</p>
<p>核心配置： <code>rate(sum / count)</code></p>
<div class="language-PromQL line-numbers-mode" data-ext="PromQL"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>注意Y轴单位选择 <code>seconds</code></p>
<figure><img src="/imgs/211223/03.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h4> 2.3 接口耗时分布统计</h4>
<p>基于Histogram样本数据，配合Grafana的热点图来配置耗时统计分布</p>
<div class="language-PromQL line-numbers-mode" data-ext="PromQL"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="/imgs/211223/04.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>几个关键的配置</p>
<ul>
<li>配置参数中的Format 选择 Heatmap</li>
<li>面板的Visualization中，选择 Heatmap</li>
<li>面板中的Display，mode选择Opacity</li>
</ul>
<p>根据颜色的深浅，来判断哪个bucket的请求量较多</p>
<h4> 2.4 SLA可用率</h4>
<p>根据成功响应的计数 / 总计数来表征接口请求成功率</p>
<div class="language-PromQL line-numbers-mode" data-ext="PromQL"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="/imgs/211223/05.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 3. 应用维度统计支持</h3>
<p>前面的几个配置，统计面板都是基于某个应用，某个实例中的某个方法的维度进行展示，但实际情况是我们也很关注整体应用维度的表现情况</p>
<p>因此我们需要在变量选择中，支持全部</p>
<ul>
<li>开启变量的include all， 并设置<code>custorm all value = .*</code></li>
</ul>
<figure><img src="/imgs/211223/06.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<figure><img src="/imgs/211223/07.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<ul>
<li>第二步就是修改PromQL，将完全匹配调整为正则匹配 (将<code>=</code>改成<code>=~</code>)</li>
</ul>
<figure><img src="/imgs/211223/08.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 4.小结</h3>
<p>本文主要是通过grafana的大盘配置来展示如何使用Prometheus采集的数据，为了更好的使用采集数据，PromQL又是一个无法避免的知识点，下篇博文将带来PromQL的科普</p>
<h2> II. 不能错过的源码和相关知识点</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-case/421-prometheus-metric" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-case/421-prometheus-metric</a></li>
</ul>
<p><strong>系列博文：</strong></p>
<ul>
<li><a href="https://spring.hhui.top/spring-blog/2021/12/22/211222-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8BPrometheus%E5%9F%BA%E4%BA%8EAOP%E5%AE%9E%E7%8E%B0%E5%9F%8B%E7%82%B9%E9%87%87%E9%9B%86%E4%B8%8A%E6%8A%A5/" target="_blank" rel="noopener noreferrer">【中间件】Prometheus基于AOP实现埋点采集上报</a></li>
<li><a href="https://spring.hhui.top/spring-blog/2021/11/19/211119-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8BPrometheus%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%8B%E7%82%B9%E5%A7%BF%E5%8A%BF%E4%BA%8C/" target="_blank" rel="noopener noreferrer">【中间件】Prometheus自定义埋点姿势二</a></li>
<li><a href="https://spring.hhui.top/spring-blog/2021/11/09/211109-SpringBoot%E4%B9%8BPrometheus%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%8B%E7%82%B9%E4%B8%8A%E6%8A%A5/" target="_blank" rel="noopener noreferrer">【中间件】Prometheus自定义埋点上报</a></li>
<li><a href="https://spring.hhui.top/spring-blog/2021/04/19/210419-SpringBoot%E6%95%B4%E5%90%88Prometheus%E5%AE%9E%E7%8E%B0%E5%BA%94%E7%94%A8%E7%9B%91%E6%8E%A7/" target="_blank" rel="noopener noreferrer">【中间件】Prometheus实现应用监控</a></li>
</ul>
<h3> 1. 微信公众号: 一灰灰Blog</h3>
<p>尽信书则不如，以上内容，纯属一家之言，因个人能力有限，难免有疏漏和错误之处，如发现bug或者有更好的建议，欢迎批评指正，不吝感激</p>
<p>下面一灰灰的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛</p>
<ul>
<li>一灰灰Blog个人博客 <a href="https://blog.hhui.top" target="_blank" rel="noopener noreferrer">https://blog.hhui.top</a></li>
<li>一灰灰Blog-Spring专题博客 <a href="http://spring.hhui.top" target="_blank" rel="noopener noreferrer">http://spring.hhui.top</a></li>
</ul>
<figure><img src="https://spring.hhui.top/spring-blog/imgs/info/info.png" alt="一灰灰blog" tabindex="0" loading="lazy"><figcaption>一灰灰blog</figcaption></figure>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/211223/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>Prometheus</title>
      <link>https://liuyueyi.github.io/tutorial/spring/middle/Prometheus/</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/middle/Prometheus/</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">Prometheus</source>
      <description>接入Prometheus，搭建应用监控体系</description>
      <pubDate>Fri, 10 Feb 2023 04:50:05 GMT</pubDate>
      <content:encoded><![CDATA[<p>接入Prometheus，搭建应用监控体系</p>
]]></content:encoded>
    </item>
    <item>
      <title>1.基础使用介绍</title>
      <link>https://liuyueyi.github.io/tutorial/spring/middle/ZooKeeper/210414-SpringBoot%E6%95%B4%E5%90%88zookeeper%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/middle/ZooKeeper/210414-SpringBoot%E6%95%B4%E5%90%88zookeeper%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">1.基础使用介绍</source>
      <description>ZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，广泛应用于分布式系统中，比如有用它做配置中心，注册中心，也有使用它来实现分布式锁的，作为高并发技术栈中不可或缺的一个基础组件，接下来我们将看一下，zk应该怎么玩，可以怎么玩 本文作为第一篇，将主要介绍基于zk-client的基本使用姿势，以次来了解下zk的基本概念</description>
      <category>SpringBoot</category>
      <category>中间件</category>
      <category>ZooKeeper</category>
      <pubDate>Wed, 14 Apr 2021 22:45:21 GMT</pubDate>
      <content:encoded><![CDATA[<p>ZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，广泛应用于分布式系统中，比如有用它做配置中心，注册中心，也有使用它来实现分布式锁的，作为高并发技术栈中不可或缺的一个基础组件，接下来我们将看一下，zk应该怎么玩，可以怎么玩</p>
<p>本文作为第一篇，将主要介绍基于zk-client的基本使用姿势，以次来了解下zk的基本概念</p>
<!-- more -->
<h2> I. 准备</h2>
<h3> 1. zk环境安装</h3>
<p>用于学习试点目的的体验zk功能，安装比较简单，可以参考博文: <a href="https://blog.hhui.top/hexblog/2021/03/10/210310-ZooKeeper%E5%AE%89%E8%A3%85%E5%8F%8A%E5%88%9D%E4%BD%93%E9%AA%8C/" target="_blank" rel="noopener noreferrer">210310-ZooKeeper安装及初体验</a></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 项目环境</h3>
<p>本文演示的是直接使用apache的zookeeper包来操作zk，与是否是SpringBoot环境无关</p>
<p>核心依赖</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>版本说明:</p>
<ul>
<li>zk: 3.6.2</li>
<li>SpringBoot: 2.2.1.RELEASE</li>
</ul>
<h2> II. ZK使用姿势</h2>
<h3> 1. zk基本知识点</h3>
<p>首先介绍下zk的几个主要的知识点，如zk的数据模型，四种常说的节点</p>
<h4> 1.1 数据模型</h4>
<p>zk的数据模型和我们常见的目录树很像，从<code>/</code>开始，每一个层级就是一个节点</p>
<p>每个节点，包含数据 + 子节点</p>
<p>注意：EPHEMERAL节点，不能有子节点（可以理解为这个目录下不能再挂目录）</p>
<p>zk中常说的监听器，就是基于节点的，一般来讲监听节点的创建、删除、数据变更</p>
<h4> 1.2 节点</h4>
<ul>
<li>持久节点 persistent node</li>
<li>持久顺序节点 persistent sequental</li>
<li>临时节点 ephemeral node</li>
<li>临时顺序节点 ephemeral sequental</li>
</ul>
<p><strong>注意：</strong></p>
<ul>
<li>节点类型一经指定，不允许修改</li>
<li>临时节点，当会话结束，会自动删除，且不能有子节点</li>
</ul>
<h3> 2. 节点创建</h3>
<p>接下来我们看一下zk的使用姿势，首先是创建节点，当然创建前提是得先拿到zkClient</p>
<p>初始化连接</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>节点创建方法，下面分别给出两种不同的case</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>节点创建，核心在于 <code>zooKeeper.create(path + "/yes", "保存的数据".getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);</code></p>
<ul>
<li>当节点已存在时，再创建会抛异常 <code>KeeperException.NodeExistsException</code></li>
<li>最后一个参数，来决定我们创建的节点类型</li>
<li>todo: 上面实例中在指定ttl时，没有成功，暂未找到原因，待解决</li>
</ul>
<h3> 3. 节点存在判断</h3>
<p>判断节点是否存在，比较常见了（比如我们在创建之前，可能会先判断一下是否存在）</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>注意</strong></p>
<p>核心用法： <code>zooKeeper.exists(path + "/yes", this);</code></p>
<ul>
<li>当节点存在时，返回Stat对象，包含一些基本信息；如果不存在，则返回null</li>
<li>第二个参数，传入的是事件回调对象，我们的测试类<code>NodeExmaple</code> 实现了接口 <code>Watcher</code>， 所以直接传的是<code>this</code></li>
<li>注册事件监听时，需要注意这个回调只会执行一次，即触发之后就没了；后面再次修改、删除、创建节点都不会再被接收到</li>
</ul>
<h3> 4. 子节点获取</h3>
<p>获取某个节点的所有子节点，这里返回的是当前节点的一级子节点</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 5. 数据获取与修改</h3>
<p>节点上是可以存储数据的，在创建的时候，可以加上数据；后期可以读取，也可以修改</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在设置数据时，可以指定版本，当version &gt; 0时，表示根据版本精确匹配；如果为-1时，则只要节点路径对上就成</p>
<h3> 6. 事件监听</h3>
<p>监听主要是针对节点而言，前面在判断节点是否存在、修改数据时都可以设置监听器，但是他们是一次性的，如果我们希望长久有效，则可以使用下面的<code>addWatch</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面给出了两种case，</p>
<ul>
<li>AddWatchMode.PERSISTENT： 表示只关心当前节点的删除、数据变更，创建，一级子节点的创建、删除；无法感知子节点的子节点创建、删除，无法感知子节点的数据变更</li>
<li>AddWatchMode.PERSISTENT_RECURSIVE: 相当于递归监听，改节点及其子节点的所有变更都监听</li>
</ul>
<h3> 7. 节点删除</h3>
<p>最后再介绍一个基本功能，节点删除，只有子节点都不存在时，才能删除当前节点（和linux的rmdir类似）</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 8. 小结</h3>
<p>本文主要介绍的是java侧对zookeeper的基本操作姿势，可以算是zk的入门，了解下节点的增删改，事件监听；</p>
<p>当然一般更加推荐的是使用Curator来操作zk，相比较于apache的jar包，使用姿势更加顺滑，后面也会做对比介绍</p>
<h2> II. 其他</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>项目源码: <a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/410-zookeeper-basic" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/410-zookeeper-basic</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>2.从0到1实现一个分布式锁</title>
      <link>https://liuyueyi.github.io/tutorial/spring/middle/ZooKeeper/210415-SpringBoot%E6%95%B4%E5%90%88Zookeeper%E4%BB%8E0%E5%88%B01%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/middle/ZooKeeper/210415-SpringBoot%E6%95%B4%E5%90%88Zookeeper%E4%BB%8E0%E5%88%B01%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">2.从0到1实现一个分布式锁</source>
      <description>分布式锁，在实际的业务使用场景中算是比较常用的了，而分布式锁的实现，常见的除了redis之外，就是zk的实现了，前面一篇博文介绍了zk的基本概念与使用姿势，那么如果让我们来记住zk的特性来设计一个分布式锁，可以怎么做呢?</description>
      <category>SpringBoot</category>
      <category>中间件</category>
      <category>ZooKeeper</category>
      <pubDate>Thu, 15 Apr 2021 20:18:26 GMT</pubDate>
      <content:encoded><![CDATA[<p>分布式锁，在实际的业务使用场景中算是比较常用的了，而分布式锁的实现，常见的除了redis之外，就是zk的实现了，前面一篇博文介绍了zk的基本概念与使用姿势，那么如果让我们来记住zk的特性来设计一个分布式锁，可以怎么做呢?</p>
<!-- more -->
<h2> I. 方案设计</h2>
<h3> 1. 创建节点方式实现</h3>
<p>zk有四种节点，一个最容易想到的策略就是创建节点，谁创建成功了，就表示谁持有了这个锁</p>
<p>这个思路与redis的<code>setnx</code>有点相似，因为zk的节点创建，也只会有一个会话会创建成功，其他的则会抛已存在的异常</p>
<p>借助临时节点，会话丢掉之后节点删除，这样可以避免持有锁的实例异常而没有主动释放导致所有实例都无法持有锁的问题</p>
<p>如果采用这种方案，如果我想实现阻塞获取锁的逻辑，那么其中一个方案就需要写一个while(true)来不断重试</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>另外一个策略则是借助事件监听，当节点存在时，注册一个节点删除的触发器，这样就不需要我自己重试判断了；充分借助zk的特性来实现异步回调</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>那么上面这个实现有什么问题呢？</p>
<p>每次节点的变更，那么所有的都会监听到变动，好处是非公平锁的支持；缺点就是剩下这些唤醒的实例中也只会有一个抢占到锁，无意义的唤醒浪费性能</p>
<h3> 2. 临时顺序节点方式</h3>
<p>接下来这种方案更加常见，晚上大部分的教程也是这种case，主要思路就是创建临时顺序节点</p>
<p>只有序号最小的节点，才表示抢占锁成功；如果不是最小的节点，那么就监听它前面一个节点的删除事件，前面节点删除了，一种可能是他放弃抢锁，一种是他释放自己持有的锁，不论哪种情况，对我而言，我都需要捞一下所有的节点，要么拿锁成功；要么换一个前置节点</p>
<h2> II.分布式锁实现</h2>
<p>接下来我们来一步步看下，基于临时顺序节点，可以怎么实现分布式锁</p>
<p>对于zk，我们依然采用apache的提供的包 <code>zookeeper</code>来操作；后续提供<code>Curator</code>的分布式锁实例</p>
<h3> 1. 依赖</h3>
<p>核心依赖</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>版本说明:</p>
<ul>
<li>zk版本: 3.6.2</li>
<li>SpringBoot: 2.2.1.RELEASE</li>
</ul>
<h3> 2. 简单的分布式锁</h3>
<p>第一步，都是实例创建</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在我们的这个设计中，我们需要持有当前节点和监听前一个节点的变更，所以我们在ZkLock实例中，添加两个成员</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来就是尝试获取锁的逻辑</p>
<ul>
<li>current不存在，在表示没有创建过，就创建一个临时顺序节点，并赋值current</li>
<li>current存在，则表示之前已经创建过了，目前处于等待锁释放过程</li>
<li>接下来根据当前节点顺序是否最小，来表明是否持有锁成功</li>
<li>当顺序不是最小时，找前面那个节点，并赋值 pre；</li>
<li>监听pre的变化</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>请注意上面的实现，这里并没有去监听前一个节点的变更，在设计<code>tryLock</code>，因为是立马返回成功or失败，所以使用这个接口的，不需要注册监听</p>
<p>我们的监听逻辑，放在 <code>lock()</code> 同步阻塞里面</p>
<ul>
<li>尝试抢占锁，成功则直接返回</li>
<li>拿锁失败，则监听前一个节点的删除事件</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>注意：</strong></p>
<ul>
<li>当节点不存在时，或者事件触发回调之后，重新调用<code>lock()</code>，表明我胡汉三又来竞争锁了？</li>
</ul>
<p>为啥不是直接返回 true? 而是需要重新竞争呢？</p>
<ul>
<li>因为前面节点的删除，有可能是因为前面节点的会话中断导致的；但是锁还在另外的实例手中，这个时候我应该做的是重新排队</li>
</ul>
<p>最后别忘了释放锁</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>到此，我们的分布式锁就完成了，接下来我们复盘下实现过程</p>
<ul>
<li>所有知识点来自前一篇的zk基础使用（创建节点，删除节点，获取所有自己点，监听事件）</li>
<li>抢锁过程 =》 创建序号最小的节点</li>
<li>若节点不是最小的，那么就监听前面的节点删除事件</li>
</ul>
<p>这个实现，支持了锁的重入（why? 因为锁未释放时，我们保存了current，当前节点存在时则直接判断是不是最小的；而不是重新创建）</p>
<h3> 3. 测试</h3>
<p>最后写一个测试case，来看下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果如下</p>
<figure><img src="/imgs/210415/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> II. 其他</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>项目源码：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/411-zookeeper-distributelock" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/411-zookeeper-distributelock</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/210415/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>Zookeeper</title>
      <link>https://liuyueyi.github.io/tutorial/spring/middle/ZooKeeper/</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/middle/ZooKeeper/</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">Zookeeper</source>
      <description>SpringBoot整合Zookeeper，并通过zk实现分布式锁来实战演示zk在应用中的想象空间</description>
      <pubDate>Fri, 10 Feb 2023 04:50:05 GMT</pubDate>
      <content:encoded><![CDATA[<p>SpringBoot整合Zookeeper，并通过zk实现分布式锁来实战演示zk在应用中的想象空间</p>
]]></content:encoded>
    </item>
    <item>
      <title>1.springboot + rabbitmq初体验</title>
      <link>https://liuyueyi.github.io/tutorial/spring/mq/RabbitMq/200210-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B9%8BRabbitMq%E5%88%9D%E4%BD%93%E9%AA%8C.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/mq/RabbitMq/200210-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B9%8BRabbitMq%E5%88%9D%E4%BD%93%E9%AA%8C.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">1.springboot + rabbitmq初体验</source>
      <description>mq在异步解耦削峰的优势非常突出，现在很多的项目都会用到，掌握mq的知识点，了解如何顺畅的使用mq，可以说是一个必备的职业技能点了 接下来我们进入rabbitmq的学习过程</description>
      <category>SpringBoot</category>
      <category>MQ系列</category>
      <category>RabbitMq</category>
      <pubDate>Mon, 10 Feb 2020 16:04:48 GMT</pubDate>
      <content:encoded><![CDATA[<p>mq在异步解耦削峰的优势非常突出，现在很多的项目都会用到，掌握mq的知识点，了解如何顺畅的使用mq，可以说是一个必备的职业技能点了</p>
<p>接下来我们进入rabbitmq的学习过程</p>
<!-- more -->
<h2> I. 环境准备</h2>
<p>在测试之前，需要安装rabbitmq，下面分别给出mac + centos的安装教程</p>
<h3> 1. mac 安装</h3>
<p>安装命令</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>启动控制台之前需要先开启插件</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>进入控制台: <code>http://localhost:15672/</code></p>
<p>用户名和密码：<code>guest,guest</code></p>
<h3> 2. centos 安装</h3>
<p>安装命令</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>插件开启</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. 配置</h3>
<p>添加账号，设置权限</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4. 项目环境</h3>
<p>接下我们创建一个SpringBoot项目，用于简单的体验一下rabbitmq的发布和消费消息</p>
<ul>
<li>springboot版本为<code>2.2.1.RELEASE</code></li>
<li>rabbitmq 版本为 <code>3.7.5</code></li>
</ul>
<p>依赖配置文件pom.xml</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在<code>application.yml</code>配置文件中，添加rabbitmq的相关属性</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> II. 实例演示</h2>
<p>接下来我们看一个<code>hello world</code>版本的rabbitmq的使用姿势，一个简单发布消息、消费消息</p>
<h3> 1. 发布消息</h3>
<p>消息发布，我们主要借助<code>AmqpTemplate</code>来实现</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的case中，主要方法在于<code>amqpTemplate#convertAndSend</code>，第一个参数为exchangeName, 第二个为routingKey</p>
<p>常量配置如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 消费消息</h3>
<p>消费消息，需要指定Queue，通过routingKey绑定exchange，如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. 测试demo</h3>
<p>写一个简单的rest接口，用于接收参数，发布消息到mq，并被<code>ConsumerDemo</code>消费</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/200210/00.gif" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> II. 其他</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码: <a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/300-rabbitmq" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/300-rabbitmq</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/200210/00.gif" type="image/gif"/>
    </item>
    <item>
      <title>2.RabbitMq核心知识点小结</title>
      <link>https://liuyueyi.github.io/tutorial/spring/mq/RabbitMq/200212-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B9%8BRabbitMq%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%E5%B0%8F%E7%BB%93.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/mq/RabbitMq/200212-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B9%8BRabbitMq%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%E5%B0%8F%E7%BB%93.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">2.RabbitMq核心知识点小结</source>
      <description>RabbitMQ是一个基于AMQP协议实现的企业级消息系统，想要顺畅的玩耍的前提是得先了解它，本文将主要介绍rabbitmq的一些基本知识点 特点 基本概念 消息投递消费的几种姿势 事务 集群</description>
      <category>SpringBoot</category>
      <category>MQ系列</category>
      <category>RabbitMq</category>
      <pubDate>Wed, 12 Feb 2020 16:58:31 GMT</pubDate>
      <content:encoded><![CDATA[<p>RabbitMQ是一个基于AMQP协议实现的企业级消息系统，想要顺畅的玩耍的前提是得先了解它，本文将主要介绍rabbitmq的一些基本知识点</p>
<ul>
<li>特点</li>
<li>基本概念</li>
<li>消息投递消费的几种姿势</li>
<li>事务</li>
<li>集群</li>
</ul>
<!-- more -->
<h2> I. 基本知识点</h2>
<p>它是采用Erlang语言实现的AMQP(Advanced Message Queued Protocol)的消息中间件，最初起源于金融系统，用在分布式系统存储转发消息，目前广泛应用于各类系统用于解耦、削峰</p>
<h3> 1.特点</h3>
<p>首先得了解一下rabbitmq的特点，看看是否满足我们的系统需求（毕竟学习一个框架也是要不少时间的）</p>
<blockquote>
<p>以下内容来自: <a href="https://blog.csdn.net/weixin_40792878/article/details/82555791" target="_blank" rel="noopener noreferrer">MQ和RabbitMQ作用特点</a></p>
</blockquote>
<p>主要特点，大致可以归纳为以下几个</p>
<ul>
<li>可靠性：通过支持消息持久化，支持事务，支持消费和传输的ack等来确保可靠性</li>
<li>路由机制：支持主流的订阅消费模式，如广播，订阅，headers匹配等</li>
<li>扩展性：多个RabbitMQ节点可以组成一个集群，也可以根据实际业务情况动态地扩展集群中节点。</li>
<li>高可用性：队列可以在集群中的机器上设置镜像，使得在部分节点出现问题的情况下队仍然可用。</li>
<li>多种协议：RabbitMQ除了原生支持AMQP协议，还支持STOMP，MQTT等多种消息中间件协议。</li>
<li>多语言客户端：RabbitMQ几乎支持所有常用语言，比如Jav a、Python、Ruby、PHP、C#、JavaScript等。</li>
<li>管理界面：RabbitMQ提供了一个易用的用户界面，使得用户可以监控和管理消息、集群中的节点等。</li>
<li>插件机制：RabbitMQ提供了许多插件，以实现从多方面进行扩展，当然也可以编写自己的插件。</li>
</ul>
<h3> 2. 基本概念</h3>
<p>下图为rabbitmq的内部结构图</p>
<figure><img src="/imgs/200212/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>从上图也可以发现几个基本概念（Message, Publisher, Exchange, Binding, Queue, Channel, Consuer, Virtual host）</p>
<p>下面逐一进行说明</p>
<h4> a. Message</h4>
<p>具体的消息，包含消息头（即附属的配置信息）和消息体（即消息的实体内容）</p>
<p>由发布者，将消息推送到Exchange，由消费者从Queue中获取</p>
<h4> b. Publisher</h4>
<p>消息生产者，负责将消息发布到交换器(Exchange)</p>
<h4> c. Exchange</h4>
<p>交换器，用来接收生产者发送的消息并将这些消息路由给服务器中的队列</p>
<h4> d. Binding</h4>
<p>绑定，用于给Exchange和Queue建立关系，从而决定将这个交换器中的哪些消息，发送到对应的Queue</p>
<h4> e. Queue</h4>
<p>消息队列，用来保存消息直到发送给消费者</p>
<p>它是消息的容器，也是消息的终点</p>
<p>一个消息可投入一个或多个队列</p>
<p>消息一直在队列里面，等待消费者连接到这个队列将其取走</p>
<h4> f. Connection</h4>
<p>连接，内部持有一些channel，用于和queue打交道</p>
<h4> g. Channel</h4>
<p>信道（通道），MQ与外部打交道都是通过Channel来的，发布消息、订阅队列还是接收消息，这些动作都是通过Channel完成；</p>
<p>简单来说就是消息通过Channel塞进队列或者流出队列</p>
<h4> h. Consumer</h4>
<p>消费者，从消息队列中获取消息的主体</p>
<h4> i. Virtual Host</h4>
<p>虚拟主机，表示一批交换器、消息队列和相关对象。</p>
<p>虚拟主机是共享相同的身份认证和加密环境的独立服务器域。</p>
<p>每个 vhost 本质上就是一个 mini 版的 RabbitMQ 服务器，拥有自己的队列、交换器、绑定和权限机制。</p>
<p>vhost 是 AMQP 概念的基础，必须在连接时指定，RabbitMQ 默认的 vhost 是 /</p>
<p><strong>可以理解为db中的数据库的概念，用于逻辑拆分</strong></p>
<h4> j. Broker</h4>
<p>消息队列服务器实体</p>
<h3> 3. 消息投递消费</h3>
<p>从前面的内部结构图可以知晓，消息由生产者发布到Exchange，然后通过路由规则，分发到绑定queue上，供消费者获取消息</p>
<p>接下来我们看一下Exchange支持的四种策略</p>
<h4> a. Direct策略</h4>
<figure><img src="/imgs/200212/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>消息中的路由键（routing key）如果和 Binding 中的 binding key 一致， 交换器就将消息发到对应的队列中</p>
<p>简单来讲，就是<code>rounting key</code>与<code>binding key</code>完全匹配</p>
<ul>
<li>如果一个队列绑定到交换机要求路由键为<code>dog</code></li>
<li>只转发<code>routing key</code> 标记为<code>dog</code>的消息，</li>
<li>不会转发<code>dog.puppy</code>，也不会转发“dog.guard”等等</li>
<li>它是完全匹配、单播的模式</li>
</ul>
<p>举例说明</p>
<figure><img src="/imgs/200212/02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>Exchange和两个队列绑定在一起：</p>
<ul>
<li>Q1的bindingkey是orange</li>
<li>Q2的binding key是black和green.</li>
<li>当Producer 发布一个消息，其<code>routing key</code>是<code>orange</code>时, exchange会把它放到Q1上, 如果是<code>black</code>或<code>green</code>就会到Q2上, 其余的Message被丢弃</li>
</ul>
<p><strong>注意</strong></p>
<ul>
<li>当有多个队列绑定到同一个Exchange，且binding key相同时，这时消息会分发给所有满足条件的队列</li>
</ul>
<h4> b. Topic策略</h4>
<figure><img src="/imgs/200212/03.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>这个策略可以看成是Direct策略的升级版，通过<code>routing key</code>与 <code>bingding key</code>的模式匹配方式来分发消息</p>
<p>简单来讲，直接策略是完全精确匹配，而topic则支持正则匹配，满足某类指定规则的（如以xxx开头的路由键），可以将消息分发过去</p>
<ul>
<li><code>#</code> 匹配0个或多个单词</li>
<li><code>*</code> 匹配不多不少一个单词</li>
</ul>
<p><strong>一个更直观的实例如下</strong></p>
<figure><img src="/imgs/200212/04.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>Producer发送消息时需要设置routing_key,</p>
<ul>
<li>Q1 的binding key 是<code>*.orange.*</code></li>
<li>Q2 是 <code>*.*.rabbit</code> 和 <code>lazy.#</code>：</li>
<li>发布一个<code>routing key</code>为<code>test.orange.mm</code> 消息，则会路由到Q1；
<ul>
<li><strong>注意：</strong> 如果是<code>routng key</code>是 <code>test.orange</code>则无法路由到Q1，</li>
<li>因为Q1的规则是三个单词，中间一个为orange，不满足这个规则的都无效</li>
</ul>
</li>
<li>发布一个<code>routing key</code>为<code>test.qq.rabbit</code>或者<code>lazy.qq</code>的消息 都可以分发到Q2；即路由key为三个单词，最后一个为rabbit或者不限制单词个数，主要第一个是lazy的消息，都可以分发过来</li>
<li>如果发布的是一个<code>test.orange.rabbit</code>消息，则Q1和Q2都可以满足
<ul>
<li><strong>注意：</strong> 这时两个队列都会接受到这个消息</li>
</ul>
</li>
</ul>
<h4> c. Fanout策略</h4>
<figure><img src="/imgs/200212/05.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>广播策略，忽略<code>routing key</code> 和 <code>binding key</code>，将消息分发给所有绑定在这个exchange上的queue</p>
<h4> d. Headers策略</h4>
<p>这个实际上用得不多，它是根据Message的一些头部信息来分发过滤Message，忽略routing key的属性，如果Header信息和message消息的头信息相匹配</p>
<h2> II. 消息一致性问题</h2>
<p>在进入rabbitmq如何保证一致性之前，我们先得理解，什么是消息一致性？</p>
<h3> 1. 一致性问题</h3>
<blockquote>
<p><a href="https://www.php.cn/faq/415782.html" target="_blank" rel="noopener noreferrer">数据的一致性是什么</a></p>
</blockquote>
<p><strong>按照我个人的粗浅理解，我认为的消息一致性，应该包含下面几个</strong></p>
<ul>
<li>生产者，确保消息发布成功
<ul>
<li>消息不会丢</li>
<li>顺序不会乱</li>
<li>消息不会重复（如重传，导致发布一次，却出现多个消息）</li>
</ul>
</li>
<li>消费者，确保消息消费成功
<ul>
<li>有序消费</li>
<li>不重复消费</li>
</ul>
</li>
</ul>
<p><strong>发送端</strong></p>
<p>为了确保发布者推送的消息不会丢失，我们需要消息持久化</p>
<ul>
<li>broker持久化消息</li>
</ul>
<p>为了确定消息正确接收</p>
<ul>
<li>publisher 需要知道消息投递并成功持久化</li>
</ul>
<h3> 2. 持久化</h3>
<p>这里的持久化，主要是指将内存中的消息保存到磁盘，避免mq宕机导致的内存中消息丢失；然而单纯的持久化，只是保证一致性的其中一个要素，比如publisher将消息发送到exchange，在broker持久化的工程中，宕机了导致持久化失败，而publisher并不知道持久化失败，这个时候就会出现数据丢失，为了解决这个问题，rabbitmq提供了事务机制</p>
<h3> 3. 事务机制</h3>
<p>事务机制能够解决生产者与broker之间消息确认的问题，只有消息成功被broker接受，事务才能提交成功，否则就进行事务回滚操作并进行消息重发。但是使用事务机制会降低RabbitMQ的消息吞吐量，不适用于需要发布大量消息的业务场景。</p>
<p><strong>注意，事务是同步的</strong></p>
<h3> 4. 消息确认机制</h3>
<blockquote>
<p><a href="https://blog.csdn.net/anumbrella/article/details/81321701" target="_blank" rel="noopener noreferrer">RabbitMQ学习(六)——消息确认机制(Confirm模式)</a></p>
</blockquote>
<p>消息确认机制，可以区分为生产端和消费端</p>
<p><strong>生产端</strong></p>
<ul>
<li>生产者将信道设置成Confirm模式，一旦信道进入Confirm模式，所有在该信道上面发布的消息都会被指派一个唯一的ID(以confirm.select为基础从1开始计数)，</li>
<li>一旦消息被投递到所有匹配的队列之后，Broker就会发送一个确认给生产者（包含消息的唯一ID）,这就使得生产者知道消息已经正确到达目的队列了，</li>
<li>如果消息和队列是可持久化的，那么确认消息会将消息写入磁盘之后发出，</li>
<li>Broker回传给生产者的确认消息中deliver-tag域包含了确认消息的序列号（此外Broker也可以设置basic.ack的multiple域，表示到这个序列号之前的所有消息都已经得到了处理）</li>
</ul>
<p>Confirm模式属性异步，publisher发布一条消息之后，在等信道返回确认的同时，依然可以继续发送下一条消息，所以小概率会出现投递的消息顺序和broker中持久化消息顺序不一致的问题</p>
<p>一般从编程角度出发，Confirm模式有三种姿势</p>
<ul>
<li>普通Confirm模式：发送一条消息之后，等到服务器confirm，然后再发布下一条消息（串行发布）</li>
<li>批量Confirm模式：发送一批消息之后，等到服务器confirm，然后再发布下一批消息（如果失败，这一批消息全部重复，所以会有重复问题）</li>
<li>异步Confirm模式：提供一个回调方法，服务器confirm之后，触发回调方法，因此不会阻塞下一条消息的发送</li>
</ul>
<p><strong>消费端</strong></p>
<p>ACK机制是消费者从RabbitMQ收到消息并处理完成后，反馈给RabbitMQ，RabbitMQ收到反馈后才将此消息从队列中删除。</p>
<ul>
<li>如果一个消费者在处理消息出现了网络不稳定、服务器异常等现象，那么就不会有ACK反馈，RabbitMQ会认为这个消息没有正常消费，会将消息重新放入队列中</li>
<li>如果在集群的情况下，RabbitMQ会立即将这个消息推送给这个在线的其他消费者。这种机制保证了在消费者服务端故障的时候，不丢失任何消息和任务</li>
<li>消息永远不会从RabbitMQ中删除，只有当消费者正确发送ACK反馈，RabbitMQ确认收到后，消息才会从RabbitMQ服务器的数据中删除</li>
</ul>
<h2> III. 集群</h2>
<p>按照目前的发展趋势，一个不支持集群的中间件基本上是不会有市场的；rabbitmq也是支持集群的，下面简单的介绍一下常见的4种集群架构模式</p>
<blockquote>
<p>以下内容来自网上博文，详情请点击右边：<a href="https://www.jianshu.com/p/b7cc32b94d2a" target="_blank" rel="noopener noreferrer">RabbitMQ 的4种集群架构</a></p>
</blockquote>
<h3> 1. 主备模式</h3>
<p>这个属于常见的集群模式了，但又不太一样</p>
<p>主节点提供读写，备用节点不提供读写。如果主节点挂了，就切换到备用节点，原来的备用节点升级为主节点提供读写服务，当原来的主节点恢复运行后，原来的主节点就变成备用节点</p>
<h3> 2. 远程模式</h3>
<p>远程模式可以实现双活的一种模式，简称 shovel 模式，所谓的 shovel 就是把消息进行不同数据中心的复制工作，可以跨地域的让两个 MQ 集群互联，远距离通信和复制。</p>
<ul>
<li>Shovel 就是我们可以把消息进行数据中心的复制工作，我们可以跨地域的让两个 MQ 集群互联。</li>
</ul>
<figure><img src="/imgs/200212/06.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>如上图，有两个异地的 MQ 集群（可以是更多的集群），当用户在地区 1 这里下单了，系统发消息到 1 区的 MQ 服务器，发现 MQ 服务已超过设定的阈值，负载过高，这条消息就会被转到 地区 2 的 MQ 服务器上，由 2 区的去执行后面的业务逻辑，相当于分摊我们的服务压力。</p>
<h3> 3. 镜像模式</h3>
<p>非常经典的 mirror 镜像模式，保证 100% 数据不丢失。在实际工作中也是用得最多的，并且实现非常的简单，一般互联网大厂都会构建这种镜像集群模式。</p>
<figure><img src="/imgs/200212/07.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>如上图，用 KeepAlived 做了 HA-Proxy 的高可用，然后有 3 个节点的 MQ 服务，消息发送到主节点上，主节点通过 mirror 队列把数据同步到其他的 MQ 节点，这样来实现其高可靠</p>
<h3> 4. 多活模式</h3>
<p>也是实现异地数据复制的主流模式，因为 shovel 模式配置比较复杂，所以一般来说，实现异地集群的都是采用这种双活 或者 多活模型来实现的。这种模式需要依赖 rabbitMQ 的 federation 插件，可以实现持续的，可靠的 AMQP 数据通信，多活模式在实际配置与应用非常的简单</p>
<p>rabbitMQ 部署架构采用双中心模式(多中心)，那么在两套(或多套)数据中心各部署一套 rabbitMQ 集群，各中心的rabbitMQ 服务除了需要为业务提供正常的消息服务外，中心之间还需要实现部分队列消息共享。</p>
<figure><img src="/imgs/200212/08.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>federation 插件是一个不需要构建 cluster ，而在 brokers 之间传输消息的高性能插件，federation 插件可以在 brokers 或者 cluster 之间传输消息，连接的双方可以使用不同的 users 和 virtual hosts，双方也可以使用不同版本的 rabbitMQ 和 erlang。federation 插件使用 AMQP 协议通信，可以接受不连续的传输。federation 不是建立在集群上的，而是建立在单个节点上的，如图上黄色的 rabbit node 3 可以与绿色的 node1、node2、node3 中的任意一个利用 federation 插件进行数据同步。</p>
<h2> IV. 其他</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
</ul>
<h3> 1. 相关博文</h3>
<ul>
<li><a href="https://www.rabbitmq.com/getstarted.html" target="_blank" rel="noopener noreferrer">RabbitMQ Tutorials</a></li>
<li><a href="https://blog.csdn.net/weixin_40792878/article/details/82555791" target="_blank" rel="noopener noreferrer">MQ和RabbitMQ作用特点</a></li>
<li><a href="https://blog.hhui.top/hexblog/2018/05/27/RabbitMQ%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/" target="_blank" rel="noopener noreferrer">RabbitMq基础教程之基本概念</a></li>
<li><a href="https://blog.csdn.net/anumbrella/article/details/81321701" target="_blank" rel="noopener noreferrer">RabbitMQ学习(六)——消息确认机制(Confirm模式)</a></li>
<li><a href="https://www.jianshu.com/p/b7cc32b94d2a" target="_blank" rel="noopener noreferrer">RabbitMQ 的4种集群架构</a></li>
<li><a href="http://www.voidcn.com/article/p-fdbmgrcd-brm.html" target="_blank" rel="noopener noreferrer">Rabbitmq是如何来保证事务的</a></li>
<li><a href="http://www.liaoqiqi.com/post/215" target="_blank" rel="noopener noreferrer">rabbitmq消息一致性问题</a></li>
<li></li>
</ul>
<h3> 2. 一灰灰Blog</h3>
<p>尽信书则不如，以上内容，纯属一家之言，因个人能力有限，难免有疏漏和错误之处，如发现bug或者有更好的建议，欢迎批评指正，不吝感激</p>
<p>下面一灰灰的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛</p>
<ul>
<li>一灰灰Blog个人博客 <a href="https://blog.hhui.top" target="_blank" rel="noopener noreferrer">https://blog.hhui.top</a></li>
<li>一灰灰Blog-Spring专题博客 <a href="http://spring.hhui.top" target="_blank" rel="noopener noreferrer">http://spring.hhui.top</a></li>
</ul>
<figure><img src="https://spring.hhui.top/spring-blog/imgs/info/info.png" alt="一灰灰blog" tabindex="0" loading="lazy"><figcaption>一灰灰blog</figcaption></figure>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/200212/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>3.发送消息基本使用姿势</title>
      <link>https://liuyueyi.github.io/tutorial/spring/mq/RabbitMq/200218-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B9%8BRabbitMq%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/mq/RabbitMq/200218-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B9%8BRabbitMq%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">3.发送消息基本使用姿势</source>
      <description>前面两篇博文，分别介绍了RabbitMq的核心知识点，以及整合SpringBoot的demo应用；接下来也该进入正题，看一下SpringBoot的环境下，如何玩转rabbitmq 本篇内容主要为消息发送，包括以下几点 RabbitTemplate 发送消息的基本使用姿势 自定义消息基本属性 自定义消息转换器AbstractMessageConverter 发送Object类型消息失败的case</description>
      <category>SpringBoot</category>
      <category>MQ系列</category>
      <category>RabbitMq</category>
      <pubDate>Tue, 18 Feb 2020 11:11:57 GMT</pubDate>
      <content:encoded><![CDATA[<p>前面两篇博文，分别介绍了RabbitMq的核心知识点，以及整合SpringBoot的demo应用；接下来也该进入正题，看一下SpringBoot的环境下，如何玩转rabbitmq</p>
<p>本篇内容主要为消息发送，包括以下几点</p>
<ul>
<li><code>RabbitTemplate</code> 发送消息的基本使用姿势</li>
<li>自定义消息基本属性</li>
<li>自定义消息转换器<code>AbstractMessageConverter</code></li>
<li>发送Object类型消息失败的case</li>
</ul>
<!-- more -->
<h2> I. 基本使用姿势</h2>
<h3> 1. 配置</h3>
<p>我们借助<code>SpringBoot 2.2.1.RELEASE</code> + <code>rabbitmq 3.7.5</code>来完整项目搭建与测试</p>
<p>项目pom.xml如下</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>配置文件<code>application.yml</code>内容如下</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 配置类</h3>
<p>通过前面rabbitmq的知识点学习，我们可以知道发送端的主要逻辑 “将消息发送给exchange，然后根据不同的策略分发给对应的queue”</p>
<p>本篇博文主要讨论的是消息发送，为了后续的实例演示，我们定义一个topic模式的exchange，并绑定一个的queue；（因为对发送端而言，不同的exchange类型，对发送端的使用姿势影响并不大，有影响的是消费者）</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. 消息发送</h3>
<p>消息发送，主要借助的是<code>RabbitTemplate#convertAndSend</code>方法来实现，通常情况下，我们直接使用即可</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的核心点就一行<code>rabbitTemplate.convertAndSend(MqConstants.exchange, MqConstants.routing, msg);</code></p>
<ul>
<li>表示将msg发送给指定的exchange，并设置消息的路由键</li>
</ul>
<p><strong>请注意</strong></p>
<p>通过上面的方式，发送的消息默认是持久化的，当持久化的消息，分发到持久化的队列时，会有消息的落盘操作；</p>
<p>在某些场景下，我们对消息的完整性要求并没有那么严格，反而更在意mq的性能，丢失一些数据也可以接受；这个时候我们可能需要定制一下发送的消息属性（比如将消息设置为非持久化的）</p>
<p>下面提供两种姿势，推荐第二种</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/200218/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p><strong>注意</strong></p>
<ul>
<li>在实际的项目开发中，推荐使用<code>MessagePostProcessor</code>来定制消息属性</li>
<li>其次不推荐在每次发送消息时都创建一个<code>MessagePostProcessor</code>对象，请定义一个通用的对象，能复用就复用</li>
</ul>
<h3> 4. 非序列化对象发送异常case</h3>
<p>通过查看<code>rabbitTemplate#convertAndSend</code>的接口定义，我们知道发送的消息可以是Object类型，那么是不是意味着任何对象，都可以推送给mq呢？</p>
<p>下面是一个测试case</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当我们调用上面的<code>publish2mq4</code>方法时，并不会是想象中的直接成功，相反抛出一个参数类型异常</p>
<figure><img src="/imgs/200218/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>为什么会出现这个问题呢？从堆栈分析，我们知道RabbitTemplate默认是利用<code>SimpleMessageConverter</code>来实现封装Message逻辑的，核心代码为</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面逻辑很明确的指出了，<strong>只接受byte数组，string字符串，可序列化对象（这里使用的是jdk的序列化方式来实现对象和byte数组之间的互转）</strong></p>
<ul>
<li>所以我们传递一个非序列化的对象会参数非法的异常</li>
</ul>
<p>自然而然的，我们会想有没有其他的<code>MessageConverter</code>来友好的支持任何类型的对象</p>
<h3> 5. 自定义MessageConverter</h3>
<p>接下来我们希望通过自定义一个json序列化方式的MessageConverter来解决上面的问题</p>
<p>一个比较简单的实现（利用FastJson来实现序列化/反序列化）</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>重新定义一个<code>rabbitTemplate</code>，并设置它的消息转换器为自定义的<code>SelfConverter</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后再次测试一下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>mq内接收到的推送消息如下</p>
<figure><img src="/imgs/200218/02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 6. Jackson2JsonMessageConverter</h3>
<p>上面虽然实现了Json格式的消息转换，但是比较简陋；而且这么基础通用的功能，按照Spring全家桶的一贯作风，肯定是有现成可用的，没错，这就是<code>Jackson2JsonMessageConverter</code></p>
<p>所以我们的使用姿势也可以如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>下面是通过Jackson序列化消息后的内容，与我们自定义的有一些不同，多了<code>headers</code>和<code>content_encoding</code></p>
<figure><img src="/imgs/200218/03.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 7. 小结</h3>
<p>本篇博文主要的知识点如下</p>
<ul>
<li>通过<code>RabbitTemplate#convertAndSend</code>来实现消息分发</li>
<li>通过<code>MessagePostProcessor</code>来自定义消息的属性（请注意默认投递的消息时持久化的）</li>
<li>默认的消息封装类为<code>SimpleMessageConverter</code>，只支持分发byte数组，字符串和可序列化的对象；不满足上面三个条件的方法调用会抛异常</li>
<li>我们可以通过实现<code>MessageConverter</code>接口，来定义自己的消息封装类，解决上面的问题</li>
</ul>
<p>在RabbitMq的知识点博文中，明确提到了，为了确保消息被brocker正确接收，提供了消息确认机制和事务机制两种case，那么如果需要使用这两种方式，消息生产者需要怎么做呢？</p>
<p>限于篇幅，下一篇博文将带来在消息确认机制/事务机制下的发送消息使用姿势</p>
<h2> II. 其他</h2>
<h3> 0. 系列博文&amp;项目源码</h3>
<p><strong>系列博文</strong></p>
<ul>
<li><a href="http://spring.hhui.top/spring-blog/2020/02/10/200210-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B9%8BRabbitMq%E5%88%9D%E4%BD%93%E9%AA%8C/" target="_blank" rel="noopener noreferrer">【MQ系列】springboot + rabbitmq初体验</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2020/02/12/200212-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B9%8BRabbitMq%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%E5%B0%8F%E7%BB%93/" target="_blank" rel="noopener noreferrer">【MQ系列】RabbitMq核心知识点小结</a></li>
</ul>
<p><strong>项目源码</strong></p>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/301-rabbitmq-publish" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/301-rabbitmq-publish</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/200218/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>4.消息确认机制/事务的使用姿势</title>
      <link>https://liuyueyi.github.io/tutorial/spring/mq/RabbitMq/200219-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B9%8BRabbitMq%E6%B6%88%E6%81%AF%E7%A1%AE%E8%AE%A4%E6%9C%BA%E5%88%B6-%E4%BA%8B%E5%8A%A1%E7%9A%84%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/mq/RabbitMq/200219-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B9%8BRabbitMq%E6%B6%88%E6%81%AF%E7%A1%AE%E8%AE%A4%E6%9C%BA%E5%88%B6-%E4%BA%8B%E5%8A%A1%E7%9A%84%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">4.消息确认机制/事务的使用姿势</source>
      <description>上一篇介绍了RabbitMq借助RabbitTemplate来发送消息的基本使用姿势，我们知道RabbitMq提供了两种机制，来确保发送端的消息被brocke正确接收，本文将主要介绍，在消息确认和事物两种机制的场景下，发送消息的使用姿势</description>
      <category>SpringBoot</category>
      <category>MQ系列</category>
      <category>RabbitMq</category>
      <pubDate>Wed, 19 Feb 2020 11:30:53 GMT</pubDate>
      <content:encoded><![CDATA[<p>上一篇介绍了RabbitMq借助RabbitTemplate来发送消息的基本使用姿势，我们知道RabbitMq提供了两种机制，来确保发送端的消息被brocke正确接收，本文将主要介绍，在消息确认和事物两种机制的场景下，发送消息的使用姿势</p>
<!-- more -->
<h2> I. 配置</h2>
<p>首先创建一个SpringBoot项目，用于后续的演示</p>
<ul>
<li>springboot版本为<code>2.2.1.RELEASE</code></li>
<li>rabbitmq 版本为 <code>3.7.5</code> （安装教程可参考: <a href="http://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484522&amp;idx=1&amp;sn=411fad078902200314d594b932fbdf35" target="_blank" rel="noopener noreferrer">【MQ系列】springboot + rabbitmq初体验</a>）</li>
</ul>
<p>依赖配置文件pom.xml</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在<code>application.yml</code>配置文件中，添加rabbitmq的相关属性</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> II. 消息确认机制</h2>
<p>本节来看一下消息确认机制的使用姿势，首先有必要了解一下什么是消息确认机制</p>
<h3> 1. 定义</h3>
<blockquote>
<p>简单来讲就是消息发送之后，需要接收到RabbitMq的正确反馈，然后才能判断消息是否正确发送成功；</p>
</blockquote>
<p>一般来说，RabbitMq的业务逻辑包括以下几点</p>
<ul>
<li>生产者将信道设置成Confirm模式，一旦信道进入Confirm模式，所有在该信道上面发布的消息都会被指派一个唯一的ID(以confirm.select为基础从1开始计数)</li>
<li>一旦消息被投递到所有匹配的队列之后，Broker就会发送一个确认给生产者（包含消息的唯一ID）,这就使得生产者知道消息已经正确到达目的队列了</li>
<li>如果消息和队列是可持久化的，那么确认消息会将消息写入磁盘之后发出</li>
<li>Broker回传给生产者的确认消息中deliver-tag域包含了确认消息的序列号（此外Broker也可以设置basic.ack的multiple域，表示到这个序列号之前的所有消息都已经得到了处理）</li>
</ul>
<h3> 2. 基本使用case</h3>
<p>从上面的解释，可以知道发送消息端，需要先将信道设置为Confirm模式，<code>RabbitProperties</code>配置类中，有个属性，正好是用来设置的这个参数的，所以我们可以直接在配置文件<code>application.yml</code>中，添加下面的配置</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面配置完毕之后，直接使用RabbitTemplate发送消息，表示已经支持Confirm模式了，但实际的使用，会有一点点区别，我们需要接收mq返回的消息，发送失败的回调（以实现重试逻辑等），所以一个典型的发送端代码可以如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>请注意上面的实现，首先需要给RabbitTemplate设置回调，这两个不可或缺</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. 手动配置方式</h3>
<p>上面利用的是标准的SpringBoot配置，一般来说是适用于绝大多数的场景的；当不能覆盖的时候，还可以通过手动的方式来定义一个特定的RabbitTemplate（比如一个项目中，只有某一个场景的消息发送需要确认机制，其他的默认即可，所以需要区分RabbitTemplate）</p>
<p>在自动配置类中，可以手动的注册一个RabbitTemplate的bean，来专职消息确认模式的发送</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>至于使用姿势，和前面完全一致，只是将<code>rabbitTemplate</code>换成<code>ackRabbitTemplate</code></p>
<h2> III. 事务机制</h2>
<p>消息确认机制属于异步模式，也就是说一个消息发送完毕之后，不待返回，就可以发送另外一条消息；这里就会有一个问题，publisher先后发送msg1, msg2，但是对RabbitMq而言，接收的顺序可能是msg2, msg1；所以消息的顺序可能会不一致</p>
<p>所以有了更加严格的事务机制，它属于同步模式，发送消息之后，等到接收到确认返回之后，才能发送下一条消息</p>
<h3> 1. 事务使用方式</h3>
<p>首先我们定义一个事务管理器</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>事务机制的使用姿势，看起来和上面的消息确认差不多，无非是需要添加一个<code>@Transactional</code>注解罢了</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>请注意，核心代码设置信道为事务模式必不可少</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2> IV. 测试</h2>
<p>我们这里主要测试一下事务和消息确认机制的性能对比吧，从定义上来看消息确认机制效率更高，我们简单的对比一下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>去掉无关的输出，仅保留耗时，对比如下（差距还是很明显的）</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> V. 其他</h2>
<p><strong>系列博文</strong></p>
<ul>
<li><a href="http://spring.hhui.top/spring-blog/2020/02/10/200210-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B9%8BRabbitMq%E5%88%9D%E4%BD%93%E9%AA%8C/" target="_blank" rel="noopener noreferrer">【MQ系列】springboot + rabbitmq初体验</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2020/02/12/200212-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B9%8BRabbitMq%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%E5%B0%8F%E7%BB%93/" target="_blank" rel="noopener noreferrer">【MQ系列】RabbitMq核心知识点小结</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2020/02/18/200218-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B9%8BRabbitMq%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF/" target="_blank" rel="noopener noreferrer">【MQ系列】SprigBoot + RabbitMq发送消息基本使用姿势</a></li>
</ul>
<p><strong>项目源码</strong></p>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/301-rabbitmq-publish" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/301-rabbitmq-publish</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>5.RabbitListener消费基本使用姿势</title>
      <link>https://liuyueyi.github.io/tutorial/spring/mq/RabbitMq/200318-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B9%8BRabbitListener%E6%B6%88%E8%B4%B9%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF%E4%BB%8B%E7%BB%8D.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/mq/RabbitMq/200318-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B9%8BRabbitListener%E6%B6%88%E8%B4%B9%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF%E4%BB%8B%E7%BB%8D.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">5.RabbitListener消费基本使用姿势</source>
      <description>之前介绍了rabbitmq的消息发送姿势，既然有发送，当然就得有消费者，在SpringBoot环境下，消费可以说比较简单了，借助@RabbitListener注解，基本上可以满足你90%以上的业务开发需求 下面我们来看一下@RabbitListener的最最常用使用姿势</description>
      <category>SpringBoot</category>
      <category>MQ系列</category>
      <category>RabbitMq</category>
      <pubDate>Wed, 18 Mar 2020 19:58:38 GMT</pubDate>
      <content:encoded><![CDATA[<p>之前介绍了rabbitmq的消息发送姿势，既然有发送，当然就得有消费者，在SpringBoot环境下，消费可以说比较简单了，借助<code>@RabbitListener</code>注解，基本上可以满足你90%以上的业务开发需求</p>
<p>下面我们来看一下<code>@RabbitListener</code>的最最常用使用姿势</p>
<!-- more -->
<h2> I. 配置</h2>
<p>首先创建一个SpringBoot项目，用于后续的演示</p>
<ul>
<li>springboot版本为<code>2.2.1.RELEASE</code></li>
<li>rabbitmq 版本为 <code>3.7.5</code> （安装教程可参考: <a href="http://spring.hhui.top/spring-blog/2020/02/10/200210-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B9%8BRabbitMq%E5%88%9D%E4%BD%93%E9%AA%8C/" target="_blank" rel="noopener noreferrer">【MQ系列】springboot + rabbitmq初体验</a>)</li>
</ul>
<p>依赖配置文件pom.xml</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在<code>application.yml</code>配置文件中，添加rabbitmq的相关属性</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> II. 消费姿势</h2>
<p>本文将目标放在实用性上，将结合具体的场景来演示<code>@RabbitListener</code>的使用姿势，因此当你发现看完本文之后这个注解里面有些属性还是不懂，请不要着急，下一篇会一一道来</p>
<h3> 0. mock数据</h3>
<p>消费消费，没有数据，怎么消费呢？所以我们第一步，先创建一个消息生产者，可以往exchange写数据，供后续的消费者测试使用</p>
<p>本篇的消费主要以topic模式来进行说明（其他的几个模式使用差别不大，如果有需求的话，后续补齐）</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>提供一个简单rest接口，可以指定往哪个exchange推送数据，并制定路由键</p>
<h3> 1. case1: exchange, queue已存在</h3>
<p>对于消费者而言其实是不需要管理exchange的创建/销毁的，它是由发送者定义的；一般来讲，消费者更关注的是自己的queue，包括定义queue并与exchange绑定，而这一套过程是可以直接通过rabbitmq的控制台操作的哦</p>
<figure><img src="/imgs/200318/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>所以实际开发过程中，exchange和queue以及对应的绑定关系已经存在的可能性是很高的，并不需要再代码中额外处理；</p>
<p>在这种场景下，消费数据，可以说非常非常简单了，如下：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>直接指定注解中的<code>queues</code>参数即可，参数值为对列名(queueName)</p>
<h3> 2. case2: queue不存在</h3>
<p>当queue的autoDelete属性为false时，上面的使用场景还是比较合适了；但是，当这个属性为true时，没有消费者队列就会自动删除了，这个时候再用上面的姿势，可能会得到下面的异常</p>
<figure><img src="/imgs/200318/01.jpg" alt="队列不存在" tabindex="0" loading="lazy"><figcaption>队列不存在</figcaption></figure>
<p>通常这种场景下，是需要我们来主动创建Queue，并建立与Exchange的绑定关系，下面给出<code>@RabbitListener</code>的推荐使用姿势</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>一个注解，内部声明了队列，并建立绑定关系，就是这么神奇！！！</p>
<p>注意<code>@QueueBinding</code>注解的三个属性：</p>
<ul>
<li>value: @Queue注解，用于声明队列，value为queueName, durable表示队列是否持久化, autoDelete表示没有消费者之后队列是否自动删除</li>
<li>exchange: @Exchange注解，用于声明exchange， type指定消息投递策略，我们这里用的topic方式</li>
<li>key: 在topic方式下，这个就是我们熟知的 routingKey</li>
</ul>
<p>以上，就是在队列不存在时的使用姿势，看起来也不复杂</p>
<h3> 3. case3: ack</h3>
<p>在前面rabbitmq的核心知识点学习过程中，会知道为了保证数据的一致性，有一个消息确认机制；</p>
<p>我们这里的ack主要是针对消费端而言，当我们希望更改默认ack方式(noack, auto, manual)，可以如下处理</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的实现也比较简单，设置<code>ackMode=MANUAL</code>，手动ack</p>
<p>但是，请注意我们的实现中，没有任何一个地方体现了手动ack，这就相当于一致都没有ack，在后面的测试中，可以看出这种不ack时，会发现数据一直在<code>unacked</code>这一栏，当Unacked数量超过限制的时候，就不会再消费新的数据了</p>
<h3> 4. case4: manual ack</h3>
<p>上面虽然选择ack方式，但是还缺一步ack的逻辑，接下来我们看一下如何补齐</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>请注意，方法多了两个参数</p>
<ul>
<li><code>deliveryTag</code>: 相当于消息的唯一标识，用于mq辨别是哪个消息被ack/nak了</li>
<li><code>channel</code>: mq和consumer之间的管道，通过它来ack/nak</li>
</ul>
<p>当我们正确消费时，通过调用 <code>basicAck</code> 方法即可</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>当我们消费失败，需要将消息重新塞入队列，等待重新消费时，可以使用 <code>basicNack</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3> 5. case5: 并发消费</h3>
<p>当消息很多，一个消费者吭哧吭哧的消费太慢，但是我的机器性能又杠杠的，这个时候我就希望并行消费，相当于同时有多个消费者来处理数据</p>
<p>要支持并行消费，如下设置即可</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/200318/02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>请注意注解中的<code>concurrency = "4"</code>属性，表示固定4个消费者；</p>
<p>除了上面这种赋值方式之外，还有一种 <code>m-n</code> 的格式，表示m个并行消费者，最多可以有n个</p>
<p>（额外说明：这个参数的解释实在<code>SimpleMessageListenerContainer</code>的场景下的，下一篇文章会介绍它与<code>DirectMessageListenerContainer</code>的区别）</p>
<h3> 6. 测试</h3>
<p>通过前面预留的消息发送接口，我们在浏览器中请求: <code>http://localhost:8080/publish?exchange=topic.e&amp;routing=r&amp;data=wahaha</code></p>
<figure><img src="/imgs/200318/03.jpg" alt="消费" tabindex="0" loading="lazy"><figcaption>消费</figcaption></figure>
<p>然后看一下输出，五个消费者都接收到了，特别是主动nak的那个消费者，一直在接收到消息；</p>
<p>（因为一直打印日志，所以重启一下应用，开始下一个测试）</p>
<p>然后再发送一条成功的消息，验证下手动真确ack，是否还会出现上面的情况，请求命令: <code>http://localhost:8080/publish?exchange=topic.e&amp;routing=r&amp;data=successMsg</code></p>
<figure><img src="/imgs/200318/04.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>然后再关注一下，没有ack的那个队列，一直有一个unack的消息</p>
<figure><img src="/imgs/200318/05.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> II. 其他</h2>
<p><strong>系列博文</strong></p>
<ul>
<li><a href="http://spring.hhui.top/spring-blog/2020/02/10/200210-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B9%8BRabbitMq%E5%88%9D%E4%BD%93%E9%AA%8C/" target="_blank" rel="noopener noreferrer">【MQ系列】springboot + rabbitmq初体验</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2020/02/12/200212-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B9%8BRabbitMq%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%E5%B0%8F%E7%BB%93/" target="_blank" rel="noopener noreferrer">【MQ系列】RabbitMq核心知识点小结</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2020/02/18/200218-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B9%8BRabbitMq%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF/" target="_blank" rel="noopener noreferrer">【MQ系列】SprigBoot + RabbitMq发送消息基本使用姿势</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2020/02/19/200219-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B9%8BRabbitMq%E6%B6%88%E6%81%AF%E7%A1%AE%E8%AE%A4%E6%9C%BA%E5%88%B6-%E4%BA%8B%E5%8A%A1%E7%9A%84%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF/" target="_blank" rel="noopener noreferrer">【MQ系列】RabbitMq消息确认/事务机制的使用姿势</a></li>
</ul>
<p><strong>项目源码</strong></p>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/302-rabbitmq-consumer" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/302-rabbitmq-consumer</a></li>
</ul>
<h3> 1. <a href="https://liuyueyi.github.io/hexblog" target="_blank" rel="noopener noreferrer">一灰灰Blog</a>： <a href="https://liuyueyi.github.io/hexblog" target="_blank" rel="noopener noreferrer">https://liuyueyi.github.io/hexblog</a></h3>
<p>一灰灰的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛</p>
<h3> 2. 声明</h3>
<p>尽信书则不如，以上内容，纯属一家之言，因个人能力有限，难免有疏漏和错误之处，如发现bug或者有更好的建议，欢迎批评指正，不吝感激</p>
<ul>
<li>微博地址: <a href="https://weibo.com/p/1005052169825577/home" target="_blank" rel="noopener noreferrer">小灰灰Blog</a></li>
<li>QQ： 一灰灰/3302797840</li>
</ul>
<h3> 3. 扫描关注</h3>
<p><strong>一灰灰blog</strong></p>
<figure><img src="https://spring.hhui.top/spring-blog/imgs/info/info.png" alt="QrCode" tabindex="0" loading="lazy"><figcaption>QrCode</figcaption></figure>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/200318/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>RabbitMQ</title>
      <link>https://liuyueyi.github.io/tutorial/spring/mq/RabbitMq/</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/mq/RabbitMq/</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">RabbitMQ</source>
      <description>消息队列RabbitMQ的基础 &amp;amp; 进阶教程，系列文章教你在生产中使用消息队列的各种姿势</description>
      <pubDate>Fri, 10 Feb 2023 04:50:05 GMT</pubDate>
      <content:encoded><![CDATA[<p>消息队列RabbitMQ的基础 &amp; 进阶教程，系列文章教你在生产中使用消息队列的各种姿势</p>
]]></content:encoded>
    </item>
    <item>
      <title>1.ES基本项目搭建</title>
      <link>https://liuyueyi.github.io/tutorial/spring/search/ElasticSearch/01.220328-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8BES%E5%9F%BA%E6%9C%AC%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/search/ElasticSearch/01.220328-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8BES%E5%9F%BA%E6%9C%AC%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">1.ES基本项目搭建</source>
      <description>之前一直没有写ES相关的博文，现在开始补课，预计5-6篇博文将es的使用姿势展示给各位小伙伴；本文将作为es结合springboot的第一篇博文，基本项目环境搭建</description>
      <category>SpringBoot</category>
      <category>搜索系列</category>
      <category>ElasticSearch</category>
      <pubDate>Mon, 28 Mar 2022 19:04:24 GMT</pubDate>
      <content:encoded><![CDATA[<p>之前一直没有写ES相关的博文，现在开始补课，预计5-6篇博文将es的使用姿势展示给各位小伙伴；本文将作为es结合springboot的第一篇博文，基本项目环境搭建</p>
<!-- more -->
<h2> I. 项目搭建</h2>
<h3> 1. 项目依赖</h3>
<p>本项目借助<code>SpringBoot 2.2.1.RELEASE</code> + <code>maven 3.5.3</code> + <code>IDEA</code>进行开发</p>
<p>开一个web服务用于测试</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 配置信息</h3>
<p>配置文件application.yml，注意下面的配置信息，下面采用的是由我们自己来解析配置的方式</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>说明</strong></p>
<p>上面配置介绍的是一种偏基础的es文档操作姿势，相比较于封装得更好的<code>spring-boot-starter-data-elasticsearch</code>，使用更加灵活</p>
<h2> II. SpringBoot结合ES使用</h2>
<h3> 1. RestHighLevelClient 初始化</h3>
<p>接下来我们基于<code>RestHighLevelClient</code>来操作es，首先第一步就是需要初始化这实例</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意上面的实现，用户名 + 密码并没有使用，当es设置了用户名、密码之后，是通过每次请求时，在请求头基于Basic Auth方式进行身份验证的；后面会介绍到</p>
<h3> 2. 基本使用</h3>
<p>我们在本机搭建了一个es用于模拟测试，在上面的配置完之后，就可以直接与es进行交互了</p>
<blockquote>
<p>es安装可以参考：</p>
<ul>
<li><a href="https://blog.hhui.top/hexblog/2020/06/05/200605-Centos-%E5%AE%89%E8%A3%85ElasticSearch/" target="_blank" rel="noopener noreferrer">200605-Centos 安装ElasticSearch - 一灰灰Blog</a></li>
<li><a href="https://blog.hhui.top/hexblog/2021/03/29/210329-Elastic-Kibana%E5%AE%89%E8%A3%85%E4%B8%8E%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/" target="_blank" rel="noopener noreferrer">210329-Elastic &amp; Kibana安装与基本使用 - 一灰灰Blog</a>
docker安装： <code>docker pull docker.elastic.co/elasticsearch/elasticsearch:xxx</code></li>
</ul>
</blockquote>
<p>下面是一个简单的使用姿势</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意上面的实现，有下面几个重要知识点</p>
<p><strong>身份验证</strong></p>
<p>采用Basic Auth方式进行身份校验，简单来说就是在请求头中添加一个</p>
<ul>
<li><code>key = Authorization</code></li>
<li><code>value = "Basic " + base64(user + ":" + pwd)</code></li>
</ul>
<p><strong>访问姿势</strong></p>
<p>上面是一个根据<code>id</code>查询文档的实例，简单可以理解为三步</p>
<ul>
<li>创建：<code>XxRequest</code></li>
<li>添加请求头：<code>RequestOptions.Builder.addHeader</code></li>
<li>执行: <code>client.get(xxRequest, RequestOptions)</code></li>
</ul>
<h2> III. 不能错过的源码和相关知识点</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/142-search-es" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/142-search-es</a></li>
</ul>
<h3> 1. 微信公众号: 一灰灰Blog</h3>
<p>尽信书则不如，以上内容，纯属一家之言，因个人能力有限，难免有疏漏和错误之处，如发现bug或者有更好的建议，欢迎批评指正，不吝感激</p>
<p>下面一灰灰的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛</p>
<ul>
<li>一灰灰Blog个人博客 <a href="https://blog.hhui.top" target="_blank" rel="noopener noreferrer">https://blog.hhui.top</a></li>
<li>一灰灰Blog-Spring专题博客 <a href="http://spring.hhui.top" target="_blank" rel="noopener noreferrer">http://spring.hhui.top</a></li>
</ul>
<figure><img src="https://spring.hhui.top/spring-blog/imgs/info/info.png" alt="一灰灰blog" tabindex="0" loading="lazy"><figcaption>一灰灰blog</figcaption></figure>
]]></content:encoded>
      <enclosure url="https://spring.hhui.top/spring-blog/imgs/info/info.png" type="image/png"/>
    </item>
    <item>
      <title>2.ES文档基本操作CURD实例演示</title>
      <link>https://liuyueyi.github.io/tutorial/spring/search/ElasticSearch/02.220331-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8BES%E6%96%87%E6%A1%A3%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9CCURD%E5%AE%9E%E4%BE%8B%E6%BC%94%E7%A4%BA.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/search/ElasticSearch/02.220331-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8BES%E6%96%87%E6%A1%A3%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9CCURD%E5%AE%9E%E4%BE%8B%E6%BC%94%E7%A4%BA.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">2.ES文档基本操作CURD实例演示</source>
      <description>本文将作为es系列第二篇，在前文项目搭建的基础上，先来看一下es的基本操作姿势，如何实现CURD</description>
      <category>SpringBoot</category>
      <category>搜索系列</category>
      <category>ElasticSearch</category>
      <pubDate>Thu, 31 Mar 2022 19:27:54 GMT</pubDate>
      <content:encoded><![CDATA[<p>本文将作为es系列第二篇，在前文项目搭建的基础上，先来看一下es的基本操作姿势，如何实现CURD</p>
<!-- more -->
<h2> I. 项目搭建</h2>
<h3> 1. 项目依赖</h3>
<p>本项目借助<code>SpringBoot 2.2.1.RELEASE</code> + <code>maven 3.5.3</code> + <code>IDEA</code>进行开发</p>
<p>开一个web服务用于测试</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 配置信息</h3>
<p>配置文件application.yml，注意下面的配置信息，下面采用的是由我们自己来解析配置的方式</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> II. CURD实例</h2>
<h3> 1. 配置</h3>
<p>注意，本文介绍的es是添加了权限验证，因此我们在于es进行交互时，需要在请求头中携带验证信息，注意下面的实现姿势</p>
<p>读取配置，初始化RestHighLevelClient，和前文介绍的差不多</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 添加数据</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>添加数据，注意是利用 <code>IndexRequest</code> 来构建请求对象，添加文档时有几个注意事项</p>
<ul>
<li><code>request.source()</code> : 具体需要上传的文档，就是通过它挂上去的，我们这里采用的是json方式</li>
<li><code>request.id()</code>: 如果上传的文档需要指定id，则可以使用它；若未指定，则表明自动生成id</li>
</ul>
<p>发起请求: <code>client.index()</code></p>
<h3> 3. 查询数据</h3>
<p>这里先介绍一个基础的根据id进行查询的实例case，更多的查询姿势后面会详细介绍</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. 增量更新数据</h3>
<p>根据主键进行更新文档，如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>注意</strong></p>
<ul>
<li>上面的实现属于增量更新策略</li>
<li>即：新传的文档，若key之前已经存在，则覆盖更新；若之前不存在，则插入；之前文档中未被覆盖的数据依然保留</li>
</ul>
<h3> 4. 全量更新</h3>
<p>另外一个根据条件进行更新的使用case如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 5. 删除数据</h3>
<p>直接根据id进行删除</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 6. 条件删除数据</h3>
<p>根据条件进行匹配删除</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 7. 测试case</h3>
<p>写一个测试demo，将上面的case都跑一遍</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> III. 不能错过的源码和相关知识点</h2>
<h3> 0. 项目</h3>
<p><strong>系列博文</strong></p>
<ul>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247487412&amp;idx=1&amp;sn=9d8afecd4dc4dcc2a016a89709a4cf34&amp;chksm=fce71418cb909d0e59e4599a4460642614104c3d254b691165f0f3630f198458073e908714a3&amp;token=1796894300&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">SpringBoot系列之ES基本项目搭建</a></li>
</ul>
<p><strong>源码</strong></p>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/142-search-es" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/142-search-es</a></li>
</ul>
<h3> 1. 微信公众号: 一灰灰Blog</h3>
<p>尽信书则不如，以上内容，纯属一家之言，因个人能力有限，难免有疏漏和错误之处，如发现bug或者有更好的建议，欢迎批评指正，不吝感激</p>
<p>下面一灰灰的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛</p>
<ul>
<li>一灰灰Blog个人博客 <a href="https://blog.hhui.top" target="_blank" rel="noopener noreferrer">https://blog.hhui.top</a></li>
<li>一灰灰Blog-Spring专题博客 <a href="http://spring.hhui.top" target="_blank" rel="noopener noreferrer">http://spring.hhui.top</a></li>
</ul>
<figure><img src="https://spring.hhui.top/spring-blog/imgs/info/info.png" alt="一灰灰blog" tabindex="0" loading="lazy"><figcaption>一灰灰blog</figcaption></figure>
]]></content:encoded>
      <enclosure url="https://spring.hhui.top/spring-blog/imgs/info/info.png" type="image/png"/>
    </item>
    <item>
      <title>3.ES查询常用实例演示</title>
      <link>https://liuyueyi.github.io/tutorial/spring/search/ElasticSearch/03.220418-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8BES%E6%9F%A5%E8%AF%A2%E7%9A%84%E5%B8%B8%E7%94%A8%E5%AE%9E%E4%BE%8B%E6%BC%94%E7%A4%BA.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/search/ElasticSearch/03.220418-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8BES%E6%9F%A5%E8%AF%A2%E7%9A%84%E5%B8%B8%E7%94%A8%E5%AE%9E%E4%BE%8B%E6%BC%94%E7%A4%BA.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">3.ES查询常用实例演示</source>
      <description>本文将作为es系列第三篇，结合常见的实例，来演示下如何通过RestHighLevelClient来实现es的各种查询支持</description>
      <category>SpringBoot</category>
      <category>搜索系列</category>
      <category>ElasticSearch</category>
      <pubDate>Mon, 18 Apr 2022 19:43:19 GMT</pubDate>
      <content:encoded><![CDATA[<p>本文将作为es系列第三篇，结合常见的实例，来演示下如何通过<code>RestHighLevelClient</code>来实现es的各种查询支持</p>
<!-- more -->
<h2> I. 项目搭建</h2>
<h3> 1. 项目依赖</h3>
<p>本项目借助<code>SpringBoot 2.2.1.RELEASE</code> + <code>maven 3.5.3</code> + <code>IDEA</code>进行开发</p>
<p>开一个web服务用于测试</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 配置信息</h3>
<p>配置文件application.yml，注意下面的配置信息，下面采用的是由我们自己来解析配置的方式</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> II. 实例演示</h2>
<h3> 0. 准备</h3>
<p>在开始之前，先准备插入几条数据，这里会借助上一篇CURD博文中的插入接口</p>
<blockquote>
<ul>
<li><a href="https://spring.hhui.top/spring-blog/2022/03/31/220331-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8BES%E6%96%87%E6%A1%A3%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9CCURD%E5%AE%9E%E4%BE%8B%E6%BC%94%E7%A4%BA/" target="_blank" rel="noopener noreferrer">【搜索系列】ES文档基本操作CURD实例演示 | 一灰灰Blog</a></li>
</ul>
</blockquote>
<p>在开始之前就准备两条数据</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1. 全量查询</h3>
<p>即查询所有的文档，如借助kibanan的控制台，发起的请求形如</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>于此对应的java实现如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意上面的实现：</p>
<ul>
<li>初始化<code>SearchRequest</code>实例，用于构建请求相关数据</li>
<li><code>SearchSourceBuilder</code> 来填充查询条件</li>
<li><code>client.search(searchRequest, requestOptions)</code> 执行查询请求，第二个参数为请求参数，这里主要是设置请求时的权限验证信息</li>
</ul>
<p>通常来说，实际的业务场景中，不太可能出现上面这种没有任何限制的查全量数据，即便真的有查全量数据的case，更常见的是分页查询，如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 根据Field值精确查询</h3>
<p>即es中常说的term查询，具体实现如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从上面的实现也可以看出，查询的套路没啥区别，无非就是<code>SearchSourceBuilder</code>中的参数构造不一样；上面主要通过</p>
<ul>
<li><code>QueryBuilders.termQuery("site", "blog.hhui.top")</code> 来构建 term的查询条件，表明查询 <code>site=blog.hhui.top</code> 的文档</li>
</ul>
<p><strong>中文查询不到问题</strong></p>
<p>在我们实际使用过程中，如果value为中文，在查询时，可能会遇到命名有对应的数据，但是就查不到，主要原因就在于分词，如对于中文的查询，可以考虑下面这种方式</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. Field值in查询</h3>
<p>另外一个常见的就是多值查询，也就是我们常说的 <code>field in (val1, val2...)</code>，这个对应的就是es中的<code>terms</code>查询</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4. 范围查询</h3>
<p>对于数值类型的Field，同样是支持比较、范围查询的，对应的是es中 <code>range</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意上面的查询有条件</p>
<ul>
<li><code>QueryBuilders.rangeQuery("age").gt(8).lt(12)</code></li>
<li>表示查询 <code>age &gt; 8 &amp;&amp; age &lt; 12</code></li>
<li>gte: 表示 &gt;=</li>
<li>lte: 表示 &lt;=</li>
</ul>
<h3> 5. Field是否存在查询</h3>
<p>es不同于mysql的在于它的field可以动态新增，当我们希望查询包含某个字段的文档时，可以考虑 <code>exists</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 6. 模糊查询</h3>
<p>es作为搜索引擎，更常见的是模糊匹配，比如match查询</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>多Field中进行查询</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在es的语法支持中，除了match，还有一个<code>wildcard</code>，可以使用<code>?</code>来代指单字符，<code>*</code>来代指0..n字符</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 7. 正则匹配</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 8. 前缀查询</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 9.小结</h3>
<p>本文虽然介绍了一些常见的查询case，但注意并不仅仅只有这些，比如</p>
<ul>
<li>查询指定Feild的内容</li>
<li>排序</li>
<li>分组聚合</li>
<li>多查询条件组合：and/or</li>
<li>高亮</li>
<li>...</li>
</ul>
<p>更多的使用实例，敬请期待...，欢迎感兴趣的小伙伴，点赞收藏评论一波😝</p>
<h2> III. 不能错过的源码和相关知识点</h2>
<h3> 0. 项目</h3>
<p><strong>系列博文</strong></p>
<ul>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247487412&amp;idx=1&amp;sn=9d8afecd4dc4dcc2a016a89709a4cf34&amp;chksm=fce71418cb909d0e59e4599a4460642614104c3d254b691165f0f3630f198458073e908714a3&amp;token=1796894300&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">SpringBoot系列之ES基本项目搭建</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247487420&amp;idx=1&amp;sn=3d64361be03a95631e1c50f6d84ab5f3&amp;chksm=fce71410cb909d069d43a59541933284b231a694620d31b8ba46065bd43c15c049e2b2c1bdb1&amp;token=623887797&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">SpringBoot之ES文档基本操作CURD实例演示</a></li>
</ul>
<p><strong>源码</strong></p>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/142-search-es" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/142-search-es</a></li>
</ul>
<h3> 1. 微信公众号: 一灰灰Blog</h3>
<p>尽信书则不如，以上内容，纯属一家之言，因个人能力有限，难免有疏漏和错误之处，如发现bug或者有更好的建议，欢迎批评指正，不吝感激</p>
<p>下面一灰灰的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛</p>
<ul>
<li>一灰灰Blog个人博客 <a href="https://blog.hhui.top" target="_blank" rel="noopener noreferrer">https://blog.hhui.top</a></li>
<li>一灰灰Blog-Spring专题博客 <a href="http://spring.hhui.top" target="_blank" rel="noopener noreferrer">http://spring.hhui.top</a></li>
</ul>
<figure><img src="https://spring.hhui.top/spring-blog/imgs/info/info.png" alt="一灰灰blog" tabindex="0" loading="lazy"><figcaption>一灰灰blog</figcaption></figure>
]]></content:encoded>
      <enclosure url="https://spring.hhui.top/spring-blog/imgs/info/info.png" type="image/png"/>
    </item>
    <item>
      <title>ElasticSearch</title>
      <link>https://liuyueyi.github.io/tutorial/spring/search/ElasticSearch/</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/search/ElasticSearch/</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">ElasticSearch</source>
      <description>SpringBoot整合ElasticSearch，支撑搜索全业务场景</description>
      <pubDate>Fri, 10 Feb 2023 04:50:05 GMT</pubDate>
      <content:encoded><![CDATA[<p>SpringBoot整合ElasticSearch，支撑搜索全业务场景</p>
]]></content:encoded>
    </item>
    <item>
      <title>1.环境搭建与简单测试</title>
      <link>https://liuyueyi.github.io/tutorial/spring/search/Solr/01.190510-SpringBoot%E9%AB%98%E7%BA%A7%E7%AF%87%E6%90%9C%E7%B4%A2%E4%B9%8BSolr%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E7%AE%80%E5%8D%95%E6%B5%8B%E8%AF%95.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/search/Solr/01.190510-SpringBoot%E9%AB%98%E7%BA%A7%E7%AF%87%E6%90%9C%E7%B4%A2%E4%B9%8BSolr%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E7%AE%80%E5%8D%95%E6%B5%8B%E8%AF%95.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">1.环境搭建与简单测试</source>
      <description>搜索可以说是非常常见的场景了，一般选择比较多的有solr和es，底层都是基于Lucene搜索引擎实现。之前简单的使用过solr，一直没有成体系的学习过，正好需要给一个内部项目封装统一的查询组件，借这个机会好好的撸一把solr的知识要点</description>
      <category>SpringBoot</category>
      <category>搜索系列</category>
      <category>Solr</category>
      <pubDate>Fri, 10 May 2019 20:10:41 GMT</pubDate>
      <content:encoded><![CDATA[<p>搜索可以说是非常常见的场景了，一般选择比较多的有solr和es，底层都是基于Lucene搜索引擎实现。之前简单的使用过solr，一直没有成体系的学习过，正好需要给一个内部项目封装统一的查询组件，借这个机会好好的撸一把solr的知识要点</p>
<!-- more -->
<h2> I. Solr环境搭建</h2>
<h3> 1. docker方式安装solr</h3>
<p>使用docker实现solr环境的搭建，快速简洁</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>启动solr容器</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>浏览器打开: <a href="http://localhost:8983/solr/#/" target="_blank" rel="noopener noreferrer">http://localhost:8983/solr/#/</a></p>
<p><strong>新建core</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>建立成功之后，终端会有相应的提示，然后刷新浏览器，可以看到新的yhh</p>
<figure><img src="/imgs/190510/00.jpg" alt="控制台" tabindex="0" loading="lazy"><figcaption>控制台</figcaption></figure>
<h3> 2. schema</h3>
<p>通过docker安装的最新solr版本为8.0，可以直接在http界面通过控制台来创建schema，而不需要像以前那样，进入配置文件进行添加处理；当然也可以通过修改对应的配置</p>
<p>假定我们现在需要在yhh这个core中存文章，结构为</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> a. 控制台添加方式</h4>
<p>首先进入schema的页面，可以如下操作，也可以点击连接: <a href="http://localhost:8983/solr/#/yhh/schema" target="_blank" rel="noopener noreferrer">http://localhost:8983/solr/#/yhh/schema</a></p>
<figure><img src="/imgs/190510/01.jpg" alt="1" tabindex="0" loading="lazy"><figcaption>1</figcaption></figure>
<p>然后通过点击Add Field按钮添加字段，确认按钮之后完成添加</p>
<figure><img src="/imgs/190510/02.jpg" alt="2" tabindex="0" loading="lazy"><figcaption>2</figcaption></figure>
<p>添加完成之后点击<code>please select...</code>，弹出下拉框，看到刚才添加的东西</p>
<figure><img src="/imgs/190510/03.jpg" alt="3" tabindex="0" loading="lazy"><figcaption>3</figcaption></figure>
<h4> b. 编辑xml文件方式</h4>
<p>通过控制台的overiew可以定位到core存储路径，然后我们找到对应的定义文件，添加两个字段</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>修改配置文件</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>修改完成之后如下图</p>
<figure><img src="/imgs/190510/04.jpg" alt="xml" tabindex="0" loading="lazy"><figcaption>xml</figcaption></figure>
<p>配置文件修改之后，再去刷控制台，发现并没有显示出来，通过重启solr之后，新的才显示出来</p>
<figure><img src="/imgs/190510/05.jpg" alt="show" tabindex="0" loading="lazy"><figcaption>show</figcaption></figure>
<h4> c. 功能测试</h4>
<p>schema定义完毕之后，就可以进行简单的测试了，先加几个文档；然后再进行查询</p>
<p><strong>添加文档</strong></p>
<p>直接在控制台进行添加: <a href="http://localhost:8983/solr/#/yhh/documents" target="_blank" rel="noopener noreferrer">http://localhost:8983/solr/#/yhh/documents</a></p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/190510/06.jpg" alt="添加文档" tabindex="0" loading="lazy"><figcaption>添加文档</figcaption></figure>
<p><strong>文档查询</strong></p>
<p>直接在控制台进行操作：<a href="http://localhost:8983/solr/#/yhh/query" target="_blank" rel="noopener noreferrer">http://localhost:8983/solr/#/yhh/query</a></p>
<figure><img src="/imgs/190510/07.jpg" alt="文档查询" tabindex="0" loading="lazy"><figcaption>文档查询</figcaption></figure>
<p>然后来个高级一点的查询，我希望查询所有内容包含一灰灰的数据，可以如下查询</p>
<figure><img src="/imgs/190510/08.jpg" alt="文档查询" tabindex="0" loading="lazy"><figcaption>文档查询</figcaption></figure>
<h2> II. SpringBoot搭建solr环境</h2>
<h3> 1. 配置</h3>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的配置中，需要注意是引入包 <code>spring-boot-starter-data-solr</code></p>
<p>引入这个包之后，我们就可以愉快的使用<code>SolrTemplate</code>来完成solr的各种骚操作了</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 简单测试</h3>
<p>下面搞一个简单的查询，看下能不能获取到solr文档</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. 测试</h3>
<p>启动下任务开始测试</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>执行截图如下</p>
<figure><img src="/imgs/190510/09.jpg" alt="测试输出" tabindex="0" loading="lazy"><figcaption>测试输出</figcaption></figure>
<h2> III. 小结</h2>
<p>上面介绍了最基础的solr环境搭建，springboot的solr测试环境准备，并实现了一个简单的查询实例，但距离真正上手撸solr还缺不少东西</p>
<ul>
<li>solr的基础知识，前面的字段定义是否合法，索引什么的改怎么考虑</li>
<li>配置修改，安全保证</li>
<li>中文分词如何设置，如何使用在solr中进行使用</li>
<li>solr的增删改查的基本操作姿势</li>
<li>solr的全文搜索优势如何体现</li>
<li>SpringBoot中进行solr操作</li>
<li>...</li>
</ul>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>项目： <a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/140-search-solr" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/140-search-solr</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/190510/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>2.文档新增与修改使用姿势</title>
      <link>https://liuyueyi.github.io/tutorial/spring/search/Solr/02.190526-SpringBoot%E9%AB%98%E7%BA%A7%E7%AF%87%E6%90%9C%E7%B4%A2Solr%E4%B9%8B%E6%96%87%E6%A1%A3%E6%96%B0%E5%A2%9E%E4%B8%8E%E4%BF%AE%E6%94%B9%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/search/Solr/02.190526-SpringBoot%E9%AB%98%E7%BA%A7%E7%AF%87%E6%90%9C%E7%B4%A2Solr%E4%B9%8B%E6%96%87%E6%A1%A3%E6%96%B0%E5%A2%9E%E4%B8%8E%E4%BF%AE%E6%94%B9%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">2.文档新增与修改使用姿势</source>
      <description>大多涉及到数据的处理，无非CURD四种操作，对于搜索SOLR而言，基本操作也可以说就这么几种，在实际应用中，搜索条件的多样性才是重点，我们在进入复杂的搜索之前，先来看一下如何新增和修改文档</description>
      <category>SpringBoot</category>
      <category>搜索系列</category>
      <category>Solr</category>
      <pubDate>Sun, 26 May 2019 20:36:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>大多涉及到数据的处理，无非CURD四种操作，对于搜索SOLR而言，基本操作也可以说就这么几种，在实际应用中，搜索条件的多样性才是重点，我们在进入复杂的搜索之前，先来看一下如何新增和修改文档</p>
<!-- more -->
<h2> I. 环境准备</h2>
<p>solr的基础环境需要准备好，如果对这一块有疑问的童鞋，可以参考下上一篇博文: 《<a href="http://spring.hhui.top/spring-blog/2019/05/10/190510-SpringBoot%E9%AB%98%E7%BA%A7%E7%AF%87%E6%90%9C%E7%B4%A2%E4%B9%8BSolr%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E7%AE%80%E5%8D%95%E6%B5%8B%E8%AF%95/" target="_blank" rel="noopener noreferrer">190510-SpringBoot高级篇搜索之Solr环境搭建与简单测试</a>》</p>
<h3> 1. 环境配置</h3>
<p>在pom文件中，设置好对应的依赖</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>因为我们采用默认的solr访问姿势，所以配置文件中可以不加对应的参数，当然也可以加上</p>
<p>打开 <code>application.yml</code> 配置文件</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果我们的solr加上了用户名密码访问条件，参数中并没有地方设置username和password，那应该怎么办?</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如上写法，将用户名和密码写入http的连接中</p>
<h3> 2. 自动装配</h3>
<p>我们主要使用SolrTemplate来和Solr打交到，因此我们需要先注册这个bean，可以怎么办？</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的配置是条件注入，只有当SolrTemplate对应的bean没有被自动加载时，才会加载，为什么要怎么干？</p>
<p>（可以想一想原因...）</p>
<h2> II. 使用姿势示例</h2>
<p>我们的操作主要依赖的是SolrTemplate，因此有必要在开始之前，看一下它的签名</p>
<p>Spring的源码中，可以发现大多<code>xxxTemplate</code>都会实现一个<code>xxxOperations</code> 接口，而这个接口就是用来定义CURD的api，比如我们看下 <code>SolrOperations</code>中与修改相关的api</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的api签名中，比较明确的说明了这个 <code>saveXXX</code> 既可以用来新增文档，也可以用来修改文档，主要有提供了两类</p>
<ul>
<li>单个与批量</li>
<li>saveDocument 与 saveBean</li>
</ul>
<h3> 1. 添加文档</h3>
<p>从上面的api签名上看，<code>saveDocument</code> 应该是相对原始的操作方式了，因此我们先看下它的使用姿势</p>
<h4> a. saveDocument</h4>
<p>首先就是创建文档 <code>SolrInputDocument</code> 对象，通过调用<code>addField</code>来设置成员值</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> b. saveBean</h4>
<p>前面需要创建<code>SolrInputDocument</code>对象，我们更希望的使用case是直接传入一个POJO，然后自动与solr的filed进行关联</p>
<p>因此一种使用方式可以如下</p>
<ul>
<li>定义pojo，成员上通过 @Field 注解来关联solr的field</li>
<li>pojo对象直接当做参数传入，保存之后，执行 commit 提交</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> c. 批量</h4>
<p>批量的方式就比较简单了，传入集合即可</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> d. 测试</h4>
<p>上面的几个方法，我们执行之后，我们看下是否能查询到新增加的数据</p>
<figure><img src="/imgs/190526/00.jpg" alt="output" tabindex="0" loading="lazy"><figcaption>output</figcaption></figure>
<h3> 2. 文档修改</h3>
<p>在看前面的接口签名时，就知道修改和新增用的是相同的api，所以修改文档和上面的使用实际上也没有什么特别的，下面简单的演示一下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的实例中，修改了id为5的文档标题，并删除了content内容，执行完毕之后，结果如何呢？</p>
<figure><img src="/imgs/190526/01.jpg" alt="output" tabindex="0" loading="lazy"><figcaption>output</figcaption></figure>
<ul>
<li>title被替换</li>
<li>content没有了</li>
</ul>
<p><strong>到这里就有个疑问了，对于调用而言，怎么保证是修改还是新增呢？</strong></p>
<ul>
<li>这里主要是根据id来判断，这个id类似db中的唯一主键，当我们没有指定id时，会随机生成一个id</li>
<li>如果存在相同的id，则修改文档；如果不存在，则新增文档</li>
</ul>
<h2> III. 其他</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">spring-boot-demo</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/190526/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>3.Solr文档删除</title>
      <link>https://liuyueyi.github.io/tutorial/spring/search/Solr/03.200114-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8BSolr%E4%B9%8B%E6%96%87%E6%A1%A3%E5%88%A0%E9%99%A4.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/search/Solr/03.200114-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8BSolr%E4%B9%8B%E6%96%87%E6%A1%A3%E5%88%A0%E9%99%A4.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">3.Solr文档删除</source>
      <description>之前的搜索教程开了个头就没有继续了，现在重新捡回来，至少也把CURD的基本操作姿势补全了；本篇主要介绍如何删除数据</description>
      <category>SpringBoot</category>
      <category>搜索系列</category>
      <category>Solr</category>
      <pubDate>Tue, 14 Jan 2020 16:16:57 GMT</pubDate>
      <content:encoded><![CDATA[<p>之前的搜索教程开了个头就没有继续了，现在重新捡回来，至少也把CURD的基本操作姿势补全了；本篇主要介绍如何删除数据</p>
<!-- more -->
<h2> I. 配置</h2>
<p>在介绍demo之前，需要先安装solr环境，搭建SpringBoot项目工程，具体的环境搭建过程不细说，推荐参考文档</p>
<ul>
<li><a href="http://spring.hhui.top/spring-blog/2019/05/10/190510-SpringBoot%E9%AB%98%E7%BA%A7%E7%AF%87%E6%90%9C%E7%B4%A2%E4%B9%8BSolr%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E7%AE%80%E5%8D%95%E6%B5%8B%E8%AF%95/" target="_blank" rel="noopener noreferrer">190510-SpringBoot高级篇搜索之Solr环境搭建与简单测试</a></li>
</ul>
<p>在<code>application.yml</code> 配置文件中红，指定solr的域名</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后在solr中，写入一些数据，供我们删除使用，可以通过控制台的方式写入，也可以通过<a href="http://spring.hhui.top/spring-blog/2019/05/26/190526-SpringBoot%E9%AB%98%E7%BA%A7%E7%AF%87%E6%90%9C%E7%B4%A2Solr%E4%B9%8B%E6%96%87%E6%A1%A3%E6%96%B0%E5%A2%9E%E4%B8%8E%E4%BF%AE%E6%94%B9%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF/" target="_blank" rel="noopener noreferrer">190526-SpringBoot高级篇搜索Solr之文档新增与修改使用姿势</a> 这篇文档的case添加</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> II. 删除</h2>
<p>我们依然是使用<code>SolrTemplate</code>来操作solr的正删改查，它整合了solr的各种基本操作</p>
<h3> 1. 根据主键删除</h3>
<p>请注意，这种case是根据主键id进行删除的，支持批量删除，需要<code>solrTemplate.commit("yhh");</code>这一行来提交修改</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 查询删除</h3>
<p>上面根据主键删除适合精准的删除操作，但是适用性有限；下面介绍查询删除的方式，将满足查询条件的数据都删除掉</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面提供了一个简单的查询条件，删除content内容以<code>新增</code>开头的文档，至于查询语句的使用姿势在下一篇介绍Solr的查询姿势时详细说明</p>
<h3> 3. 测试</h3>
<p>接下来测试一下上面的两种case</p>
<p>首先我们提供一个输出所有文档的方法，用于对比删除前后的数据变化</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来是方法调用</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果如下，id为4,5,6的都被删除了</p>
<div class="language-log line-numbers-mode" data-ext="log"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> II. 其他</h2>
<h3> 0. 系列博文&amp;项目源码</h3>
<p><strong>系列博文</strong></p>
<ul>
<li><a href="http://spring.hhui.top/spring-blog/2019/05/26/190526-SpringBoot%E9%AB%98%E7%BA%A7%E7%AF%87%E6%90%9C%E7%B4%A2Solr%E4%B9%8B%E6%96%87%E6%A1%A3%E6%96%B0%E5%A2%9E%E4%B8%8E%E4%BF%AE%E6%94%B9%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF/" target="_blank" rel="noopener noreferrer">190526-SpringBoot高级篇搜索Solr之文档新增与修改使用姿势</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2019/05/10/190510-SpringBoot%E9%AB%98%E7%BA%A7%E7%AF%87%E6%90%9C%E7%B4%A2%E4%B9%8BSolr%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E7%AE%80%E5%8D%95%E6%B5%8B%E8%AF%95/" target="_blank" rel="noopener noreferrer">190510-SpringBoot高级篇搜索之Solr环境搭建与简单测试</a></li>
</ul>
<p><strong>项目源码</strong></p>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码: <a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/140-search-solr" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/140-search-solr</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>4.Solr查询使用姿势小结</title>
      <link>https://liuyueyi.github.io/tutorial/spring/search/Solr/04.200115-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8BSolr%E4%B9%8B%E6%9F%A5%E8%AF%A2%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF%E5%B0%8F%E7%BB%93.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/search/Solr/04.200115-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8BSolr%E4%B9%8B%E6%9F%A5%E8%AF%A2%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF%E5%B0%8F%E7%BB%93.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">4.Solr查询使用姿势小结</source>
      <description>接下来进入solr CURD的第四篇，查询的使用姿势介绍，本文将主要包括以下知识点 基本的查询操作 fq查询 fl指定字段查询 比较/范围 排序 分页 分组</description>
      <category>SpringBoot</category>
      <category>搜索系列</category>
      <category>Solr</category>
      <pubDate>Wed, 15 Jan 2020 15:55:37 GMT</pubDate>
      <content:encoded><![CDATA[<p>接下来进入solr CURD的第四篇，查询的使用姿势介绍，本文将主要包括以下知识点</p>
<ul>
<li>基本的查询操作</li>
<li>fq查询</li>
<li>fl指定字段查询</li>
<li>比较/范围</li>
<li>排序</li>
<li>分页</li>
<li>分组</li>
</ul>
<!-- more -->
<h2> I. 配置</h2>
<p>在介绍demo之前，需要先安装solr环境，搭建SpringBoot项目工程，具体的环境搭建过程不细说，推荐参考文档</p>
<ul>
<li><a href="http://spring.hhui.top/spring-blog/2019/05/10/190510-SpringBoot%E9%AB%98%E7%BA%A7%E7%AF%87%E6%90%9C%E7%B4%A2%E4%B9%8BSolr%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E7%AE%80%E5%8D%95%E6%B5%8B%E8%AF%95/" target="_blank" rel="noopener noreferrer">190510-SpringBoot高级篇搜索之Solr环境搭建与简单测试</a></li>
</ul>
<p>在<code>application.yml</code> 配置文件中红，指定solr的域名</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后在solr中，写入一些数据，供我们查询使用，可以通过控制台的方式写入，也可以通过<a href="http://spring.hhui.top/spring-blog/2019/05/26/190526-SpringBoot%E9%AB%98%E7%BA%A7%E7%AF%87%E6%90%9C%E7%B4%A2Solr%E4%B9%8B%E6%96%87%E6%A1%A3%E6%96%B0%E5%A2%9E%E4%B8%8E%E4%BF%AE%E6%94%B9%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF/" target="_blank" rel="noopener noreferrer">190526-SpringBoot高级篇搜索Solr之文档新增与修改使用姿势</a> 这篇文档的case添加</p>
<p>初始化solr文档内容如下</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> II. 查询</h2>
<p>solr文档对应的POJO如下，（注意solr中的主键id为string类型，下面定义中用的是Integer，推荐与solr的数据类型保持一致）</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1. 主键查询</h3>
<p>支持单个查询和批量查询，三个参数，第一个为需要查询的Collection, 第二个为id/id集合，第三个为返回的数据类型</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 简单查询</h3>
<p>比如最简单的根据某个字段进行查询</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>直接在SimpleQuery中指定查询条件，上面的case表示查询title为<code>一灰灰</code>的文档</p>
<p>输出结果如下：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>简单的查询使用上面的姿势ok，当然就是阅读起来不太优雅；推荐另外一种基于<code>Criteria</code>的查询条件构建方式</p>
<ul>
<li>如果看过之前的mongodb系列教程，可以看到monodb的查询条件也用到了Criteria来拼装，但是请注意这两个并不是一个东西</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><code>Criteria</code>可以构建复杂的且阅读友好的查询条件，后面会有具体的演示，这里给出一个多条件查询的case</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果如下，在上面的基础上，捞出了contentId小于2的记录</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 3. fq查询</h3>
<p>fq 主要用来快速过滤，配合query进行操作，主要是借助<code>org.springframework.data.solr.core.query.Query#addFilterQuery</code>来添加fq条件</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果如:</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 4. fl指定查询字段</h3>
<p>当我们只关注solr文档中的部分字段时，可以考虑指定fl，只获取所需的字段；通过<code>org.springframework.data.solr.core.query.SimpleQuery#addProjectionOnFields(java.lang.String...)</code>来指定需要返回的字段名</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>请注意，我们指定了只需要返回<code>id</code>, <code>title</code>, <code>content</code>，所以返回的DO中其他的成员为null</p>
<h3> 5. 范围查询</h3>
<p>针对数字类型，支持范围查询，比如上面给出<code>Criteria.where("content_id").lessThanEqual(2)</code>，表示查询<code>content_id</code>小于2的记录，下面给出一个between的查询</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果如下，请注意between查询，左右都是闭区间</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>如果不想要闭区间，可以用<code>between</code>的重载方法</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果如</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 6. 排序</h3>
<p>上面的case中，已经用到了排序，主要是<code>Sort</code>来指定排序字段以及排序的方式；因为id在solr中实际上是字符串格式，所以如果用id进行排序时，实际上是根据字符串的排序规则来的（虽然我们的POJO中id为int类型）</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 7. 分页查询</h3>
<p>分页查询比较常见，特别是当数据量比较大时，请一定记得，添加分页条件</p>
<p>一个查询case如下，查询所有的数据，并制定了分页条件，查询第二条和第三条数据（计数从0开始）</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在返回结果中，查了返回查询的文档之外，还会给出满足条件的文档数量，可以通过<code>Page#getTotalElements</code>获取，</p>
<p>上面case输出结果如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 8. 分组查询</h3>
<p>分组和前面的查询有一点区别，主要在于结果的处理，以及分组参数必须指定分页信息</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的case虽然比较简单，但是有几点需要注意, 特别是返回结果的获取，包装层级有点深</p>
<ul>
<li>GroupOptions：
<ul>
<li>必须指定offset/limit，当两个条件都没有时会抛异常</li>
<li>只指定offset时，limit默认为1</li>
<li>只指定limit时，offset默认为0</li>
</ul>
</li>
<li>结果处理
<ul>
<li><code>GroupPage#getGroupResult(field)</code> 获取分组内容，其中field为指定分组的成员</li>
<li>遍历<code>GroupResult#getGroupEntries</code>，获取每个分组对应的文档列表</li>
</ul>
</li>
</ul>
<p>输出结果如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> III. 其他</h2>
<h3> 0. 系列博文&amp;工程源码</h3>
<p><strong>系列博文</strong></p>
<ul>
<li><a href="http://spring.hhui.top/spring-blog/2020/01/14/200114-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8BSolr%E4%B9%8B%E6%96%87%E6%A1%A3%E5%88%A0%E9%99%A4/" target="_blank" rel="noopener noreferrer">200114-SpringBoot系列教程Solr之文档删除</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2019/05/26/190526-SpringBoot%E9%AB%98%E7%BA%A7%E7%AF%87%E6%90%9C%E7%B4%A2Solr%E4%B9%8B%E6%96%87%E6%A1%A3%E6%96%B0%E5%A2%9E%E4%B8%8E%E4%BF%AE%E6%94%B9%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF/" target="_blank" rel="noopener noreferrer">190526-SpringBoot高级篇搜索Solr之文档新增与修改使用姿势</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2019/05/10/190510-SpringBoot%E9%AB%98%E7%BA%A7%E7%AF%87%E6%90%9C%E7%B4%A2%E4%B9%8BSolr%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E7%AE%80%E5%8D%95%E6%B5%8B%E8%AF%95/" target="_blank" rel="noopener noreferrer">190510-SpringBoot高级篇搜索之Solr环境搭建与简单测试</a></li>
</ul>
<p><strong>工程源码</strong></p>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码: <a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/140-search-solr" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/140-search-solr</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>5.Solr身份认证与授权更新异常解决方案</title>
      <link>https://liuyueyi.github.io/tutorial/spring/search/Solr/05.200330-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B9%8BSolr%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83%E6%9B%B4%E6%96%B0%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/search/Solr/05.200330-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B9%8BSolr%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83%E6%9B%B4%E6%96%B0%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">5.Solr身份认证与授权更新异常解决方案</source>
      <description>之前介绍solr的教程中，solr没有开启权限校验，所有的操作都是无需鉴权；当时提到，如果solr开启了权限校验，改一下solr的host，带上用户名/密码即可，然而真实情况却并不太一样，查询ok，涉及到修改的操作，则会抛异常 本文将带你了解一下，这到底是个什么鬼畜现象</description>
      <category>SpringBoot</category>
      <category>搜索系列</category>
      <category>Solr</category>
      <category>采坑记录</category>
      <pubDate>Mon, 30 Mar 2020 19:13:16 GMT</pubDate>
      <content:encoded><![CDATA[<p>之前介绍solr的教程中，solr没有开启权限校验，所有的操作都是无需鉴权；当时提到，如果solr开启了权限校验，改一下solr的host，带上用户名/密码即可，然而真实情况却并不太一样，查询ok，涉及到修改的操作，则会抛异常</p>
<p>本文将带你了解一下，这到底是个什么鬼畜现象</p>
<!-- more -->
<h2> I. Solr配置用户登录</h2>
<h3> 1. 安装</h3>
<p>之前的solr系列教程中，通过docker安装的solr，下面的步骤也是直接针对docker中的solr进行配置，基本步骤一样</p>
<p>具体可以参考： <a href="http://spring.hhui.top/spring-blog/2019/05/10/190510-SpringBoot%E9%AB%98%E7%BA%A7%E7%AF%87%E6%90%9C%E7%B4%A2%E4%B9%8BSolr%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E7%AE%80%E5%8D%95%E6%B5%8B%E8%AF%95/" target="_blank" rel="noopener noreferrer">【搜索系列】Solr环境搭建与简单测试</a></p>
<p>不想看的同学，直接用下面的命令即可:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 配置</h3>
<p>下面一步一步教你如何设置用户密码，也可以参考博文: <a href="https://blog.csdn.net/u011561335/article/details/90695860" target="_blank" rel="noopener noreferrer">手把手教你 对 solr8 配置用户登录验证</a></p>
<p>进入实例，注意使用<code>root</code>用户，否则某些操作可能没有权限</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>创建鉴权文件</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>内容如下，格式为 <code>用户名:密码,权限</code>， 一行一个账号</p>
<div class="language-properties line-numbers-mode" data-ext="properties"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>配置鉴权文件</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>添加下面的内容放在<code>Configure</code>标签内</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>修改web.xml</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>在<code>security-constraint</code>标签下面，新增</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>重启solr，配置生效</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2> II. 场景复现</h2>
<p>接下来介绍一下我们的环境</p>
<ul>
<li>springboot: 2.2.1.RELEASE</li>
<li>solr: 8.0</li>
</ul>
<h3> 1. 项目环境</h3>
<p>搭建一个简单的springboot项目，xml依赖如下</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对应的配置文件<code>application.yml</code></p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 复现</h3>
<p>关于solr的基本操作，如果有疑问的小伙伴可以翻一下我之前的搜索系列博文，满足你的扫盲需求；</p>
<p>核心的solr操作实例如下:</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>SolrTemplat</code>定义如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>开始测试</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/200330/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>请注意，复现上面的场景时，会发现查询没问题，修改则会抛异常</p>
<h3> 3. 解决方案</h3>
<h4> a. 降版本</h4>
<p>我之前用solr的时候，也是上面的操作方式，然而并没有出现过这种问题，这就有点蛋疼了；</p>
<p>找之前的项目查看版本，发现之前用的<code>solr-solrj</code>用的是<code>6.6.5</code>，换个版本试一下（默认的版本是<code>8.2.0</code>）</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>见证奇迹的时刻到了，执行正常了，虽然<code>saveDocument</code>方法的调用标红，但是不影响具体的执行哦</p>
<figure><img src="/imgs/200330/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h4> b. SystemDefaultHttpClient</h4>
<p>通过一顿debug，单步执行，终于找到为啥<code>6.6.5</code>版本的<code>solr-solrj</code>可以正常操作，而<code>8.2.0</code>却不行（如果想知道这一枯燥的过程，请评论告诉我，否则我也不知道啥时候可以看到😂）</p>
<p>关键的问题就是旧版本的用的是<code>SystemDefaultHttpClient</code>来实现solr的沟通；新版本使用的是<code>InternalHttpClient</code></p>
<p>那么一个可用的解决方法就是不降版本，改为指定Solr的<code>HttpClient</code></p>
<p>在配置类中，如下操作：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后测试，也是正常执行，输出结果就不截图了，各位小伙伴可以亲自测试一下</p>
<h4> c. HttpClient拦截器</h4>
<blockquote>
<p>关于下面的这段写法，来自: <a href="https://stackoverflow.com/questions/2014700/preemptive-basic-authentication-with-apache-httpclient-4/11868040#11868040" target="_blank" rel="noopener noreferrer">Preemptive Basic authentication with Apache HttpClient 4</a></p>
</blockquote>
<p>上面的方式虽然可以让我们正确操作solr了，但是<code>SystemDefaultHttpClient</code>有一个删除注解，也就是说不建议再直接用它了，那就借鉴它的使用方式，来满足我们的需求，所以可以如下操作</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的实现有点长，简单的拆解一下</p>
<ul>
<li><code>UrlDo</code>: 解析solr的url，得到我们需要的<code>host + port + user + password</code></li>
<li><code>solrClient</code>: 在创建<code>SolrClient</code> bean实例时，指定相应的授权信息</li>
<li><code>SolrAuthInterceptor</code>: 自定义拦截器，更新<code>authState</code>信息</li>
</ul>
<h4> d. SolrRequest</h4>
<p>上面的三种方式，适用于利用<code>SolrClient</code>或者<code>SolrTemplate</code>来操作的solr；当然我可以完全抛弃掉它们，直接使用<code>SolrRequest</code>来操作，如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4. 小结</h3>
<p>本篇博文主要是针对需要登录验证的solr更新操作异常时，给出了四种解决方案</p>
<ul>
<li>降<code>solr-solrj</code>版本到<code>6.6.0</code></li>
<li>指定<code>SolrClient</code>的<code>HttpClient</code>为<code>SystemDefaultHttpClient</code></li>
<li>HttpClient拦截器</li>
<li>SolrRequest指定用户名密码</li>
</ul>
<p>上面虽然给出了解决方法，但是为啥有这个问题呢？</p>
<p>直接通过curl来测试一下更新solr操作，正常返回，并没有问题，那么这个问题到底啥原因，究竟是谁的锅，请敬请期待后续问题定位盖锅定论</p>
<figure><img src="/imgs/200330/02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> II. 其他</h2>
<h3> 0. 系列博文&amp;工程源码</h3>
<p><strong>参考博文</strong></p>
<ul>
<li><a href="https://blog.csdn.net/u011561335/article/details/90695860" target="_blank" rel="noopener noreferrer">手把手教你 对 solr8 配置用户登录验证</a></li>
<li><a href="https://stackoverflow.com/questions/2014700/preemptive-basic-authentication-with-apache-httpclient-4/11868040#11868040" target="_blank" rel="noopener noreferrer">Preemptive Basic authentication with Apache HttpClient 4</a></li>
</ul>
<p><strong>系列博文</strong></p>
<ul>
<li><a href="http://spring.hhui.top/spring-blog/2020/01/15/200115-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8BSolr%E4%B9%8B%E6%9F%A5%E8%AF%A2%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF%E5%B0%8F%E7%BB%93/" target="_blank" rel="noopener noreferrer">200115-SpringBoot系列教程Solr之查询使用姿势小结</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2020/01/14/200114-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8BSolr%E4%B9%8B%E6%96%87%E6%A1%A3%E5%88%A0%E9%99%A4/" target="_blank" rel="noopener noreferrer">200114-SpringBoot系列教程Solr之文档删除</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2019/05/26/190526-SpringBoot%E9%AB%98%E7%BA%A7%E7%AF%87%E6%90%9C%E7%B4%A2Solr%E4%B9%8B%E6%96%87%E6%A1%A3%E6%96%B0%E5%A2%9E%E4%B8%8E%E4%BF%AE%E6%94%B9%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF/" target="_blank" rel="noopener noreferrer">190526-SpringBoot高级篇搜索Solr之文档新增与修改使用姿势</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2019/05/10/190510-SpringBoot%E9%AB%98%E7%BA%A7%E7%AF%87%E6%90%9C%E7%B4%A2%E4%B9%8BSolr%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E7%AE%80%E5%8D%95%E6%B5%8B%E8%AF%95/" target="_blank" rel="noopener noreferrer">190510-SpringBoot高级篇搜索之Solr环境搭建与简单测试</a></li>
</ul>
<p><strong>工程源码</strong></p>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/141-search-solr-auth" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/141-search-solr-auth</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/200330/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>Solr</title>
      <link>https://liuyueyi.github.io/tutorial/spring/search/Solr/</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/search/Solr/</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">Solr</source>
      <description>SpringBoot整合Solr，支撑搜索业务场景</description>
      <pubDate>Fri, 10 Feb 2023 04:50:05 GMT</pubDate>
      <content:encoded><![CDATA[<p>SpringBoot整合Solr，支撑搜索业务场景</p>
]]></content:encoded>
    </item>
    <item>
      <title>0.起源篇（零）</title>
      <link>https://liuyueyi.github.io/tutorial/spring/security/basic/191223-SpringBoot-%E6%95%B4%E5%90%88-SpringSecurity-%E4%B9%8B%E8%B5%B7%E6%BA%90%E7%AF%87%EF%BC%88%E9%9B%B6%EF%BC%89.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/security/basic/191223-SpringBoot-%E6%95%B4%E5%90%88-SpringSecurity-%E4%B9%8B%E8%B5%B7%E6%BA%90%E7%AF%87%EF%BC%88%E9%9B%B6%EF%BC%89.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">0.起源篇（零）</source>
      <description>本篇为SpringSecurity的第一篇，主要来介绍下什么是SpringSecurity，以及在springboot中如何使用它</description>
      <category>SpringSecurity</category>
      <pubDate>Mon, 23 Dec 2019 18:55:02 GMT</pubDate>
      <content:encoded><![CDATA[<p>本篇为SpringSecurity的第一篇，主要来介绍下什么是SpringSecurity，以及在springboot中如何使用它</p>
<!-- more -->
<h2> I. 基本知识点</h2>
<blockquote>
<p>官方文档: <a href="https://docs.spring.io/spring-security/site/docs/5.2.2.BUILD-SNAPSHOT/reference/htmlsingle/#community-help" target="_blank" rel="noopener noreferrer">https://docs.spring.io/spring-security/site/docs/5.2.2.BUILD-SNAPSHOT/reference/htmlsingle/#community-help</a></p>
</blockquote>
<p>下面是官方介绍</p>
<blockquote>
<p>Spring Security is a powerful and highly customizable authentication and access-control framework. It is the de-facto standard for securing Spring-based applications.</p>
</blockquote>
<blockquote>
<p>Spring Security is a framework that focuses on providing both authentication and authorization to Java applications. Like all Spring projects, the real power of Spring Security is found in how easily it can be extended to meet custom requirements</p>
</blockquote>
<p>用国语，简单抽象的说一下它的定义</p>
<ul>
<li>很🐂的认证和访问权限校验框架</li>
</ul>
<p>那么具体能干嘛？</p>
<ul>
<li>用户登录认证：用户名+密码登录，确定用户身份</li>
<li>用户访问鉴权（常见的ACL访问控制列表，RBAC角色访问控制）：判定是否有权限访问某个资源</li>
<li>安全保护（CSRF跨站点攻击,Session Fixation会话固定攻击...）</li>
</ul>
<h2> II. 初体验</h2>
<p>接下来我们看一下再springboot中如何使用springsecurity</p>
<h3> 1. 配置</h3>
<p>首先得是spring boot项目，然后添加上security的依赖即可，相对完整的pom配置如下（注意我们使用的springboot版本为2.2.1.RELEASE）</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 实例demo</h3>
<p>上面配置完之后，啥都不需要干，项目已经接入了spring security；项目中的服务都需要登录之后才能访问</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当我们需要访问首页时，会发现直接302重定向到登录页面了，如下图</p>
<figure><img src="/imgs/191223/00.gif" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>spring security默认给我们生成了一个用户名为user，密码为控制台中输出的一行日志如<code>Using generated security password: aa410186-5c04-4282-b217-507ffb1f61eb</code></p>
<p>登录之后会重定向回我们之前访问的url，通过抓包可以看到，登录成功之后，会设置请求方的cookie，后续的请求携带cookie来表明用户身份</p>
<figure><img src="/imgs/191223/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 3. 基本配置</h3>
<p>上面虽然演示了一个hello world的初体验项目，但是这个默认的用户名/密码有点鬼畜，默认的配置主要来自于<code>org.springframework.boot.autoconfigure.security.SecurityProperties.User</code>，下面是截图（所以前面的用户名为user）</p>
<figure><img src="/imgs/191223/02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>接下来我们需要配置为对人类友好的方式，在项目的配置文件<code>application.yml</code>中，指定登录的用户名/密码</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>重启测试项目，使用新的用户名/密码（yihuihui/123456)就可以登录成功了;</p>
<h3> 4. 用户身份获取</h3>
<p>上面虽然是一个简单的case，但还有一点不得不提一下，在我的接口中，虽然知道你登录了，但怎么知道你是谁呢？</p>
<p>我们可以直接通过<code>HttpServletRequest#getRemoteUser()</code>的方法来获取登录用户； 或者通过<code>SecurityContextHolder.getContext().getAuthentication().getPrincipal()</code>来获取授权信息</p>
<p>我们来写一个通用方法</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后稍微改一下我们的服务接口</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>再次访问之后，结果如下</p>
<figure><img src="/imgs/191223/03.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 5. 小结</h3>
<p>本文主要是spring security系列的起源篇，第一节介绍了下什么是SpringSecurity，有什么特点</p>
<ul>
<li>spring security是一个很🐂🍺的认证（可以简单理解为登录验证）和鉴权（可简单理解为访问控制）框架</li>
<li>三大特点：登录 + 鉴权 + 安全防护</li>
</ul>
<p>第二节介绍了一个简单入门的HelloWorld实例</p>
<ul>
<li>springboot项目，添加依赖 <code>spring-boot-starter-security</code>； 所有的http接口访问都需要登录，默认提供一个用户名为user，密码为控制台输出的UUID字符串</li>
<li>通过<code>spring.security.user.name</code>和<code>spring.security.user.password</code>来指定用户名密码</li>
<li>通过<code>HttpServletRequest#getRemoteUser()</code>获取登录用户</li>
</ul>
<p>那么问题来了，什么系统可能只有一个用户呢？要多用户怎么办？不同的用户不同的权限怎么办？某些接口所有人都可以访问又怎么办？</p>
<h2> II. 其他</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>代码: <a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-security/000-basic-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-security/000-basic-demo</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/191223/00.gif" type="image/gif"/>
    </item>
  </channel>
</rss>