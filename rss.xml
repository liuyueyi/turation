<?xml version="1.0" encoding="utf-8"?><?xml-stylesheet type="text/xsl" href="https://liuyueyi.github.io/tutorial/rss.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <atom:link href="https://liuyueyi.github.io/tutorial/rss.xml" rel="self" type="application/rss+xml"/>
    <title>一灰灰的站点</title>
    <link>https://liuyueyi.github.io/tutorial/</link>
    <description>一灰灰的全网知识站点</description>
    <language>zh-CN</language>
    <pubDate>Fri, 10 Feb 2023 07:18:18 GMT</pubDate>
    <lastBuildDate>Fri, 10 Feb 2023 07:18:18 GMT</lastBuildDate>
    <generator>vuepress-plugin-feed2</generator>
    <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
    <copyright>Copyright by 一灰灰blog</copyright>
    <image>
      <title>一灰灰的站点</title>
      <url>https://liuyueyi.github.io/tutorial/logo.svg</url>
      <link>https://liuyueyi.github.io/tutorial/</link>
    </image>
    <category>SpringCloud</category>
    <category>Eureka系列</category>
    <category>Feign系列</category>
    <category>采坑记录</category>
    <category>SpringBoot</category>
    <category>运维系列</category>
    <category>Docker</category>
    <category>中间件</category>
    <category>Email</category>
    <category>Prometheus</category>
    <category>ZooKeeper</category>
    <category>MQ系列</category>
    <category>RabbitMq</category>
    <category>搜索系列</category>
    <category>ElasticSearch</category>
    <category>Solr</category>
    <category>SpringSecurity</category>
    <category>WEB系列</category>
    <category>Request</category>
    <category>Response</category>
    <category>RestTemplate</category>
    <category>WebClient</category>
    <category>WebFlux</category>
    <category>WebSocket</category>
    <category>web三剑客</category>
    <category>Interceptor</category>
    <item>
      <title>1.Eureka注册中心初体验</title>
      <link>https://liuyueyi.github.io/tutorial/spring/cloud/Eureka/01.200513-SpringCloud%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B9%8BEureka%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E5%88%9D%E4%BD%93%E9%AA%8C.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/cloud/Eureka/01.200513-SpringCloud%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B9%8BEureka%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E5%88%9D%E4%BD%93%E9%AA%8C.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">1.Eureka注册中心初体验</source>
      <description>在SpringCloud微服务体系中，有几个比较重要的组件，如注册中心，配置中心，网关，安全、负载均衡、监控等等，接下来我们将来看一下这些常用的组件有什么用，在微服务架构下的该怎么用。 本文为为第一篇，注册中心Eureka的使用说明</description>
      <category>SpringCloud</category>
      <category>Eureka系列</category>
      <pubDate>Wed, 13 May 2020 09:14:47 GMT</pubDate>
      <content:encoded><![CDATA[<p>在SpringCloud微服务体系中，有几个比较重要的组件，如注册中心，配置中心，网关，安全、负载均衡、监控等等，接下来我们将来看一下这些常用的组件有什么用，在微服务架构下的该怎么用。</p>
<p>本文为为第一篇，注册中心Eureka的使用说明</p>
<!-- more -->
<h2> I. 基本介绍</h2>
<h3> 1. 注册中心</h3>
<p>注册中心，主要的核心点是服务的注册与发现。</p>
<p>简单来讲，就是我们的所有服务都会在注册中心上标识自己，注册中心统一管理所有的服务名与具体的应用之间的映射关系，这样微服务之间的访问，就可以直接通过服务名来相互通信，相比较于直接通过ip端口的访问，这样的好处是当某个服务下线、新增或者换了机器，对调用者而言，只要维持一份注册中心的最新映射表即可，不需要其他任何改动逻辑。</p>
<p>我们通常可用的注册中心有 <code>Eureka</code>, <code>Consul</code>, <code>Zookeeper</code>, <code>nacos</code>等，在我们后续的教程中会逐一进行介绍</p>
<blockquote>
<p>Eureka2.x 闭源，1.x虽然可用，但新项目的话不建议再使用它，比如<code>Consul</code>, <code>nacos</code> 都是不错的选择</p>
<p>如果出于学习的目的，或者由于历史原因（比如我），学习了解一下Eureka知识点也没什么坏处</p>
</blockquote>
<h3> 2. Eureka</h3>
<p>Eureka是Netflix开源的服务发现组件，本身是一个基于REST的服务，通常包含Server和Client端</p>
<p><strong>原理如下图</strong></p>
<figure><img src="/imgs/200513/00.jpg" alt="来源于网络" tabindex="0" loading="lazy"><figcaption>来源于网络</figcaption></figure>
<ul>
<li>server: 提供服务注册，并在服务注册表中存储所有可用服务节点的信息</li>
<li>client: 简化与Server之间的交互，比如封装了发送心跳，获取注册信息表等基本操作</li>
</ul>
<h2> II. 实例演示</h2>
<h3> 1. 版本说明</h3>
<p>后续的演示项目中，我们的环境与版本信息如下</p>
<ul>
<li>开发环境: IDEA + maven</li>
<li>SpringBoot: <code>2.2.1.RELEASE</code></li>
<li>SpringCloud: <code>Hoxton.M2</code></li>
</ul>
<h3> 2. Eureka Server端</h3>
<p>Eureka区分了Server和Client两端，即我们有一个独立的注册中心服务，其他的微服务则作为Client端</p>
<p>Server端核心依赖如下</p>
<div class="language-pom line-numbers-mode" data-ext="pom"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后在配置文件中，添加一些基本信息</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>请注意，上面的<code>registerWithEureka</code>这个配置，设置为false，不像自己注册服务（后续会介绍多个Eureka实例时，可以如何配置）</p>
<p>然后再启动类上，添加注解<code>@EnableEurekaServer</code>来申明Eureka服务</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>到此，一个Eureka服务端已经完成，此时我们可以直接访问<code>http://localhost:8081</code>，会看到一个自带的控制台，会提供一些基本信息</p>
<h3> 3. Eureka 客户端</h3>
<p>我们这里设计两个客户端，一个提供服务，另外一个调用，演示一下Eureka的基本功能</p>
<h4> a. 客户端 eureka-service-provider</h4>
<p>客户端需要在pom文件中，添加下面的关键依赖</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来需要在配置文件中，指定注册中心的地址，以及服务名（请注意，这个服务名是重要线索，后面会用到！！！）</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>同样的需要在启动类上，通过<code>@EnableEurekaClient</code>来标注客户端</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们在这个项目中，写一个基本REST接口，供后面的服务进行调用</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>再看一下上面的实现，你会发现和平时写的Controller没有任何的区别</p>
<p>到这里第一个Eureka客户端已经完成，并提供了一个REST接口，接下来我们开始写第二个Eureka客户端，用来访问上面的REST服务</p>
<h4> b. 客户端 eureka-service-consumer</h4>
<p>基本的流程和上面没有任何区别，只是将配置文件稍微改一下</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>那么在这个服务中，如何访问 <code>eureka-service-provider</code> 提供的服务呢？</p>
<ul>
<li>通过<code>RestTemplate</code>来实现</li>
</ul>
<p>请注意，这个RestTemplate和我们普通的<code>new RestTemplate()</code>创建的不一样哦，我们是通过如下方式获取实例</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>重点关注方法上的<code>@LoadBalanced</code>注解，这个会在后续的Ribbon的章节中深入介绍，在这里只需要知道通过它生成的<code>RestTemplate</code>，在发起访问时，会借助Eureka的注册信息表，将服务名翻译为对应的<code>ip+端口号</code></p>
<p>接下来就是我们的访问环节，写法如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>请着重看一下访问的url: <code>"http://eureka-service-provider/userService/getUserById?userId=" + userId</code>,这里没有域名，没有ip，是直接通过服务名进行访问的</p>
<h3> 4. 测试与小结</h3>
<p>我们依次将上面的Server和两个Client启动，然后访问<code>http://localhost:8081</code>，查看Eureka控制台，可以看到如下界面，两个客户端都已经注册好了</p>
<figure><img src="/imgs/200513/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>然后再测试一下通过consumer访问provider的服务</p>
<figure><img src="/imgs/200513/02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>到此Eureka的核心功能已经演示完毕，当然如果仅仅只是这样，这个学习成本好像很低了，作为一个有思考的小青年，看了上面的流程自然会有几个疑问</p>
<ul>
<li>安全问题
<ul>
<li>注册中心控制台直接访问，这要是暴露出去了...</li>
<li>一个Eureka实例，单点故障怎么解</li>
</ul>
</li>
<li>服务注册多久生效？服务下线多久会从注册信息表中摘除？服务存活判断是怎样的？</li>
<li>通过<code>RestTemplate</code>方式使用，很不优雅啊，有没有类似rmi的通过类调用的方式呢？</li>
</ul>
<h2> II. 其他</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：
<ul>
<li><a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-cloud/eurka-server" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-cloud/eurka-server</a></li>
<li><a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-cloud/eurka-service-consumer" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-cloud/eurka-service-consumer</a></li>
<li><a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-cloud/eurka-service-provider" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-cloud/eurka-service-provider</a></li>
</ul>
</li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/200513/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>Eureka</title>
      <link>https://liuyueyi.github.io/tutorial/spring/cloud/Eureka/</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/cloud/Eureka/</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">Eureka</source>
      <description>注册中心Eureka全知道</description>
      <pubDate>Fri, 10 Feb 2023 04:50:05 GMT</pubDate>
      <content:encoded><![CDATA[<p>注册中心Eureka全知道</p>
]]></content:encoded>
    </item>
    <item>
      <title>1.Feign请求参数包装异常问题定位</title>
      <link>https://liuyueyi.github.io/tutorial/spring/cloud/Feign/01.190306-SpringCloud%E4%B9%8BFeign%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E5%8C%85%E8%A3%85%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/cloud/Feign/01.190306-SpringCloud%E4%B9%8BFeign%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E5%8C%85%E8%A3%85%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">1.Feign请求参数包装异常问题定位</source>
      <description>通过Feign包装rpc的调用姿势，在使用的版本中发现一个奇怪的bug，大部分场景下请求正常，少数情况下请求返回400，记录下原因</description>
      <category>SpringCloud</category>
      <category>Feign系列</category>
      <category>采坑记录</category>
      <pubDate>Wed, 06 Mar 2019 12:43:08 GMT</pubDate>
      <content:encoded><![CDATA[<p>通过Feign包装rpc的调用姿势，在使用的版本中发现一个奇怪的bug，大部分场景下请求正常，少数情况下请求返回400，记录下原因</p>
<!-- more -->
<h2> 场景复现</h2>
<h3> 1. 环境相关版本</h3>
<p>Spring版本如</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>Feign版本</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对应的feign-core版本为</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 服务接口</h3>
<p>接口形如</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用时报400的case</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>简单来说，接口参数为集合的情况下，如果传一个空集合，那么这就会出现400的错误</p>
<p>通过在提供服务的应用中，写一个fitler拦截请求，打印出请求参数</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后发起rpc调用前面的测试用例，通过断点查看请求参数，确实只有两个参数，而我们传入空pairIds集合，直接被吃掉了</p>
<figure><img src="/imgs/190306/00.jpg" alt="filter截图" tabindex="0" loading="lazy"><figcaption>filter截图</figcaption></figure>
<p>再对应到我们的api声明方式，要求三个参数，因此问题就很清晰了，解决办法就是在api中参数的必填设置为false即可</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面只是表层的解决了问题，接下来就需要确定，为什么请求参数会被吃掉，通过浅显的推测，多半原因在feign的请求参数封装上了</p>
<h3> 2. 问题定位</h3>
<p>对于容易复现的问题，最佳的定位方法就是debug了，直接单步进去，找到对应的请求参数封装逻辑，</p>
<p>第一步定位到<code>RequestTemplate</code>的创建</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来深入进去之后，参数解析的位置</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>再进去一步就到了根源点</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>下图是我们最终定位的一个截图，从代码实现来看，feign的设计理念是，如果请求参数为null，空集合，则不会将参数拼接到最终的请求参数中，也就导致最终发起请求时，少了一个参数</p>
<figure><img src="/imgs/190306/01.jpg" alt="debug截图" tabindex="0" loading="lazy"><figcaption>debug截图</figcaption></figure>
<p>问题清晰之后，然后就可以确认下是bug还是就是这么设计的了，最简单的办法就是看最新的代码有没有改掉了，从git上，目前已经更新到10.x；10.x与9.x的差别挺大，底层很多东西重写了，然而官方的<code>Spring-Cloud-openfeing</code>并没有升级到最新，so，只能取看9.7.0版本的实现了，和9.5.2并没有太大的区别；</p>
<p>so，站在feign开发者角度出发，这么设计的理由可能有以下几点</p>
<ul>
<li>既然允许传入空集合、null参数，那么在api的声明时，就有必要加上 <code>require=False</code></li>
<li>对于这种无效的请求参数，也没有太大的必要传过去（虽然从使用者角度来说，你就应该老老实实的把我调用的参数都丢过去）</li>
</ul>
<h3> 3. 小结</h3>
<p>最后小结一下，使用feign作为SpringCloud的rpc封装工具时，请注意，</p>
<ul>
<li>如果api的请求参数允许为null，请在注解中显示声明；</li>
<li>此外请求方传入的null、空集合最终不会拼装的请求参数中，即对于接受者而言，就像没有这个参数一样，对于出现400错误的场景，可以考虑下是否是这种问题导致的</li>
<li>对于复杂的请求参数，推荐使用DTO来替代多参数的类型（因为这样接口的复用性是最佳的，如新增和修改条件时，往往不需要新增api)</li>
</ul>
<h2> II. 其他</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">spring-boot-demo</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/190306/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>Feign</title>
      <link>https://liuyueyi.github.io/tutorial/spring/cloud/Feign/</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/cloud/Feign/</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">Feign</source>
      <description>基于Feign实现微服务访问</description>
      <pubDate>Fri, 10 Feb 2023 04:50:05 GMT</pubDate>
      <content:encoded><![CDATA[<p>基于Feign实现微服务访问</p>
]]></content:encoded>
    </item>
    <item>
      <title>1.整合docker镜像打包</title>
      <link>https://liuyueyi.github.io/tutorial/spring/middle/Docker/210304-SpringBoot%E7%B3%BB%E5%88%97%E6%95%B4%E5%90%88docker%E9%95%9C%E5%83%8F%E6%89%93%E5%8C%85.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/middle/Docker/210304-SpringBoot%E7%B3%BB%E5%88%97%E6%95%B4%E5%90%88docker%E9%95%9C%E5%83%8F%E6%89%93%E5%8C%85.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">1.整合docker镜像打包</source>
      <description>SpringBoot项目整合docker，打包镜像工程演示</description>
      <category>SpringBoot</category>
      <category>运维系列</category>
      <category>Docker</category>
      <pubDate>Thu, 04 Mar 2021 19:27:54 GMT</pubDate>
      <content:encoded><![CDATA[<p>SpringBoot项目整合docker，打包镜像工程演示</p>
<!-- more -->
<h2> I. 整合步骤</h2>
<h3> 1. 基本环境</h3>
<p>本项目借助<code>SpringBoot 2.2.1.RELEASE</code> + <code>maven 3.5.3</code> + <code>IDEA</code> + <code>MAC</code>进行开发</p>
<p>首先确保本机有安装docker，对于docker基本知识点，可以参考</p>
<ul>
<li><a href="https://blog.hhui.top/hexblog/2019/12/06/191206-Centos%E5%AE%89%E8%A3%85docker%E4%B8%8E%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/" target="_blank" rel="noopener noreferrer">Centos安装docker与使用说明</a></li>
<li><a href="https://blog.hhui.top/hexblog/2019/12/06/191206-Docker-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E9%80%9F%E6%9F%A5%E6%89%8B%E5%86%8C/" target="_blank" rel="noopener noreferrer">Docker 常用命令速查手册</a></li>
</ul>
<h3> 2. pom配置</h3>
<p>创建一个基本的SpringBoot项目之后，关键是设置<code>pom.xml</code>文件，我们主要借助<code>docker-maven-plugin</code>来打镜像包</p>
<p>一个可用的配置如下</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. Dockerfile 文件</h3>
<p>接下需要配置我们自己的dockerfile文件，在项目根目录下，新建文件名<code>Dockerfile</code>，如果路径有修改，需要调整上面pom配置中的<code>dockerDirectory</code>参数</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>关于dockerfile语法，可以参考</p>
<ul>
<li><a href="https://www.runoob.com/docker/docker-dockerfile.html" target="_blank" rel="noopener noreferrer">Docker Dockerfile语法说明</a></li>
</ul>
<p>我们上面的case，就是拉一个jdk8的运行环境，将打的jar包重命名为app.jar到指定目录，同时使用命令<code>java -jar app.jar</code>来启动应用</p>
<h3> 4. 测试demo</h3>
<p>提供一个最基础的demo实例</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>打包命令 <code>mvn clean package docker:build -DskipTests=true</code></p>
<p><strong>注意</strong></p>
<ul>
<li>打包的前提是docker已经启动了</li>
</ul>
<p>打包成功之后，可以看到会多一个docker镜像</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>运行镜像并测试</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/210304/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> II. 其他</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>项目: <a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/400-docker-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/400-docker-demo</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/210304/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>Docker</title>
      <link>https://liuyueyi.github.io/tutorial/spring/middle/Docker/</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/middle/Docker/</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">Docker</source>
      <description>SpringBoot配置docker，实现容器化管理部署</description>
      <pubDate>Fri, 10 Feb 2023 04:50:05 GMT</pubDate>
      <content:encoded><![CDATA[<p>SpringBoot配置docker，实现容器化管理部署</p>
]]></content:encoded>
    </item>
    <item>
      <title>1.邮件发送姿势介绍</title>
      <link>https://liuyueyi.github.io/tutorial/spring/middle/Email/210802-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8B%E9%82%AE%E4%BB%B6%E5%8F%91%E9%80%81%E5%A7%BF%E5%8A%BF%E4%BB%8B%E7%BB%8D.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/middle/Email/210802-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8B%E9%82%AE%E4%BB%B6%E5%8F%91%E9%80%81%E5%A7%BF%E5%8A%BF%E4%BB%8B%E7%BB%8D.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">1.邮件发送姿势介绍</source>
      <description>邮件发送，在实际的项目开发中，可能用的不是特别多，如果没有特定的需求，相信也没有多少小伙伴会特意的去关注，那么如果现在我们希望针对项目做一个异常的报警系统，当出现异常的时候，可以向指定的小伙伴发送邮件提醒，那么让我们来实现这个功能，可以怎么办呢？ 这里介绍一下如何使用SpringBoot封装好的MailSender来实现邮件发送</description>
      <category>SpringBoot</category>
      <category>中间件</category>
      <category>Email</category>
      <pubDate>Mon, 02 Aug 2021 21:41:28 GMT</pubDate>
      <content:encoded><![CDATA[<p>邮件发送，在实际的项目开发中，可能用的不是特别多，如果没有特定的需求，相信也没有多少小伙伴会特意的去关注，那么如果现在我们希望针对项目做一个异常的报警系统，当出现异常的时候，可以向指定的小伙伴发送邮件提醒，那么让我们来实现这个功能，可以怎么办呢？</p>
<p>这里介绍一下如何使用SpringBoot封装好的MailSender来实现邮件发送</p>
<!-- more -->
<h2> I. 项目环境</h2>
<h3> 1. 项目依赖</h3>
<p>本项目借助<code>SpringBoot 2.2.1.RELEASE</code> + <code>maven 3.5.3</code> + <code>IDEA</code>进行开发</p>
<p>开一个web服务用于测试</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 配置</h3>
<p>在开始之前，我们需要先准备一个用于发送邮件的账号，比如我这里使用163的邮箱来发送邮件，需要先到邮箱提供商哪里获取授权码，具体如何获取这个东西，不同的邮箱姿势有些不同，各位小伙伴根据自己的实际情况，搜索一下，相信很快就能get到</p>
<p>这里简单介绍下网易邮箱的获取方式</p>
<figure><img src="/imgs/210802/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>接下来设置发送邮件相关的配置信息，配置文件<code>application.yml</code></p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> II. 邮件发送</h2>
<p>接下来进入正题，我们将从简单基础的文本邮件发送开始，逐渐介绍如何添加附件，使用漂亮的html模板等</p>
<h3> 1. 简单文本邮件发送</h3>
<p>我们这里直接使用<code>JavaMailSender</code>来发送一个基础的文本邮件</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>JavaMailSender: 直接作为一个Spring 的bean对象使用</li>
<li>SimpleMailMessage：简单的邮件对象，里面有一些邮件发送时，关联的基础信息
<ul>
<li>from: 发送方</li>
<li>replyTo: 邮件回复的收件人</li>
<li>to: 收件人</li>
<li>cc: 抄送</li>
<li>bcc: 密送</li>
<li>subject: 主题，也就是邮件标题</li>
<li>text: 邮件正文，文本格式</li>
<li>date: 邮件发送时间</li>
</ul>
</li>
</ul>
<h3> 2. html发送</h3>
<p>对于简单的文本邮件发送，用上面的基本就够了，如果我们希望邮件的内容更美观一点的话，可以借助HTML来实现排版</p>
<p>区别于上面的SimpleMailMessage, 这里使用的是MimeMessage，来实现html内容发送</p>
<p>使用姿势与上面相比差不多，无非就是正文变成了html文本罢了</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>重点注意</strong></p>
<ul>
<li>注意上面的<code>setText</code>方法的第二个参数，必须有，且为true，否则会当成文本内容发送</li>
</ul>
<h3> 3. 添加附件</h3>
<p>邮件中添加附件，我们自己写邮件的时候可以直接选择附件上传，那么代码的实现方式又有什么区别呢？</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意上面的实现，与前面差别不大，关键点在于<code>attachment</code>附件，上面的实现是在附件中添加一个图片，为了简单起见，图片是直接从网络下载的，然后将Stream作为传参</p>
<h3> 4. Freemaker模板</h3>
<p>上面的html发送，会发现需要我们自己来组装html正文，这个操作可能就不是很美好了，借助页面渲染引擎来实现邮件模板支持，可以说是一个比较常见的方案了，这里简单介绍下Freemaker的实现姿势，至于themlaf, beef或者jsp啥的，都没有太大的区别</p>
<p>首先写一个邮件模板 <code>resources/template/mail.ftl</code></p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的模板中，定义了两个变量，一个<code>title</code>，一个<code>content</code>，这个就是我们需要替换的值</p>
<p>接下来是邮件发送实例</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意上面的实现，关键点就利用<code>FreeMarkerTemplateUtils</code>来实现模板的渲染，输出html正文，因此如果想使用其他的模板渲染引擎，就是改这里即可</p>
<h3> 5. 测试与小结</h3>
<p>最后简单的调用一下上面的实现，看下邮件是否可以发送成功</p>
<figure><img src="/imgs/210802/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<figure><img src="/imgs/210802/02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>本篇博文介绍了一下如何发送邮件，并针对简单的文本邮件，html正文，附件等不同的给出了实例；整体看下来使用姿势不难，不过邮件的几个术语可以了解一下</p>
<ul>
<li>to: 接收人，就是邮件发送的目标群众</li>
<li>cc: 抄送，一般来讲抄送的名单，只是让他感知到有这封邮件，属于周知对象</li>
<li>bcc: 密送，与上面两个不一样，接收人和抄送人不知道密送给谁了，这就是最大的区别，说实话这个玩意我从没用过</li>
</ul>
<p>接下来一篇博文，将介绍一下如何将log日志与邮件发送关联起来，当出现异常的时候，邮件发送给开发者</p>
<h2> III. 不能错过的源码和相关知识点</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/210802/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>2.实战：基于异常日志的邮件报警</title>
      <link>https://liuyueyi.github.io/tutorial/spring/middle/Email/210803-SpringBoot%E5%AE%9E%E6%88%98%E5%9F%BA%E4%BA%8E%E5%BC%82%E5%B8%B8%E6%97%A5%E5%BF%97%E7%9A%84%E9%82%AE%E4%BB%B6%E6%8A%A5%E8%AD%A6.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/middle/Email/210803-SpringBoot%E5%AE%9E%E6%88%98%E5%9F%BA%E4%BA%8E%E5%BC%82%E5%B8%B8%E6%97%A5%E5%BF%97%E7%9A%84%E9%82%AE%E4%BB%B6%E6%8A%A5%E8%AD%A6.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">2.实战：基于异常日志的邮件报警</source>
      <description>相信所有奋斗在一线的小伙伴，会很关心自己的系统的运行情况，一般来说，基础设施齐全一点的公司都会有完善的报警方案，那么如果我们是一个小公司呢，不能因为基础设施没有，就失去对象的感知能力吧；如果我们的系统大量异常却不能实时的触达给我们，那么也就只会有一个结果--杀个程序猿祭天 本文简单的介绍一种实现思路，基于error日志来实现邮件的报警方案</description>
      <category>SpringBoot</category>
      <category>中间件</category>
      <category>Email</category>
      <pubDate>Tue, 03 Aug 2021 21:09:39 GMT</pubDate>
      <content:encoded><![CDATA[<p>相信所有奋斗在一线的小伙伴，会很关心自己的系统的运行情况，一般来说，基础设施齐全一点的公司都会有完善的报警方案，那么如果我们是一个小公司呢，不能因为基础设施没有，就失去对象的感知能力吧；如果我们的系统大量异常却不能实时的触达给我们，那么也就只会有一个结果--杀个程序猿祭天</p>
<p>本文简单的介绍一种实现思路，基于error日志来实现邮件的报警方案</p>
<!-- more -->
<h2> I. 项目环境</h2>
<h3> 1. 项目依赖</h3>
<p>本项目借助<code>SpringBoot 2.2.1.RELEASE</code> + <code>maven 3.5.3</code> + <code>IDEA</code>进行开发</p>
<p>开一个web服务用于测试</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 配置</h3>
<p>邮件相关配置如下，注意使用自己的用户名 + 授权码填充下面缺失的配置</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> II. 异常日志的邮件预警</h2>
<h3> 1. 设计思路</h3>
<p>接下来这个方案的主要出发点在于，当程序出现大量的异常，表明应用多半出现了问题，需要立马发送给项目owner</p>
<p>要实现这个方案，关键点就在于异常出现的感知与上报</p>
<ul>
<li>异常的捕获，并输出日志（这个感觉属于标配了吧，别告诉我现在还有应用不输出日志文件的...）
<ul>
<li>对于这个感知，借助logback的扩展机制，可以实现，后面介绍</li>
</ul>
</li>
<li>异常上报：邮件发送</li>
</ul>
<p>关于email的使用姿势，推荐参考博文 <a href="http://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247486591&amp;idx=1&amp;sn=04f18e2f313abd371947f9818e238067&amp;chksm=fce717d3cb909ec575b8e521843eff04edfcf844e59ca976515bc29d8a23782c4d5d30580d0e&amp;token=908878619&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">SpringBoot 系列之邮件发送姿势介绍</a></p>
<h3> 2. 自定义appender</h3>
<p>定义一个用于错误发送的Appender，如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. Spring容器</h3>
<p>上面的邮件发送中，需要使用<code>JavaMailSender</code>，写一个简单的SpringContext工具类，用于获取Bean/Propertiy</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4. logback配置</h3>
<p>接下来就是在日志配置中，使用我们上面定义的Appender</p>
<p><code>logback-spring.xml</code>文件内容如下：</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 5. 测试demo</h3>
<p>接下来演示一下，是否可以达到我们的预期</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/210803/00.gif" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 5.小结</h3>
<p>本篇博文主要提供了一个思路，借助logback的扩展机制，来实现错误日志与预警邮件绑定，实现一个简单的应用异常监控</p>
<p>上面这个实现只算是一个雏形，算是抛砖引玉，有更多可以丰富的细节，比如</p>
<ul>
<li>飞书/钉钉通知（借助飞书钉钉的机器来报警，相比较于邮件感知性更高）</li>
<li>根据异常类型，做预警的区分</li>
<li>更高级的频率限制等</li>
</ul>
<p>在这里推荐一个我之前开源的预警系统，可以实现灵活预警方案配置，频率限制，重要性升级等</p>
<ul>
<li>一个可扩展的报警系统 <a href="https://github.com/liuyueyi/quick-alarm" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/quick-alarm</a></li>
</ul>
<h2> III. 不能错过的源码和相关知识点</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-case/430-mail-alarm" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-case/430-mail-alarm</a></li>
</ul>
<p>推荐关联博文</p>
<ul>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247486591&amp;idx=1&amp;sn=04f18e2f313abd371947f9818e238067&amp;chksm=fce717d3cb909ec575b8e521843eff04edfcf844e59ca976515bc29d8a23782c4d5d30580d0e&amp;token=908878619&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">SpringBoot 系列之邮件发送姿势介绍</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/210803/00.gif" type="image/gif"/>
    </item>
    <item>
      <title>Email</title>
      <link>https://liuyueyi.github.io/tutorial/spring/middle/Email/index.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/middle/Email/index.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">Email</source>
      <description>SpringBoot无障碍使用邮箱服务</description>
      <pubDate>Fri, 10 Feb 2023 04:50:05 GMT</pubDate>
      <content:encoded><![CDATA[<p>SpringBoot无障碍使用邮箱服务</p>
]]></content:encoded>
    </item>
    <item>
      <title>1.Prometheus实现应用监控</title>
      <link>https://liuyueyi.github.io/tutorial/spring/middle/Prometheus/210419-SpringBoot%E6%95%B4%E5%90%88Prometheus%E5%AE%9E%E7%8E%B0%E5%BA%94%E7%94%A8%E7%9B%91%E6%8E%A7.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/middle/Prometheus/210419-SpringBoot%E6%95%B4%E5%90%88Prometheus%E5%AE%9E%E7%8E%B0%E5%BA%94%E7%94%A8%E7%9B%91%E6%8E%A7.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">1.Prometheus实现应用监控</source>
      <description>1. prometheus 安装 教程文档: https://www.prometheus.wang/quickstart/install-prometheus-server.html 1.1 什么是Prometheus 普罗米修斯：Prometheus是一个开放性的监控解决方案，用户可以非常方便的安装和使用Prometheus并且能够非常方便的对其进行扩展</description>
      <category>SpringBoot</category>
      <category>中间件</category>
      <category>Prometheus</category>
      <pubDate>Mon, 19 Apr 2021 18:40:03 GMT</pubDate>
      <content:encoded><![CDATA[<h3> 1. prometheus 安装</h3>
<p>教程文档: <a href="https://www.prometheus.wang/quickstart/install-prometheus-server.html" target="_blank" rel="noopener noreferrer">https://www.prometheus.wang/quickstart/install-prometheus-server.html</a></p>
<h4> 1.1 什么是Prometheus</h4>
<blockquote>
<p>普罗米修斯：Prometheus是一个开放性的监控解决方案，用户可以非常方便的安装和使用Prometheus并且能够非常方便的对其进行扩展</p>
</blockquote>
<!-- more -->
<p>下面将实现一个SpringBoot应用接入Prometheus的全过程</p>
<h4> 1.2 安装</h4>
<p>Linux 安装</p>
<ul>
<li>官网指定下载包:  <a href="https://prometheus.io/download/" target="_blank" rel="noopener noreferrer">https://prometheus.io/download/</a></li>
</ul>
<p>下载本地安装启动</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>启动完毕之后，本地访问 <a href="http://127.0.0.1:9090/graph" target="_blank" rel="noopener noreferrer">http://127.0.0.1:9090/graph</a> 可以看到默认提供的界面</p>
<h3> 2. SpringBoot应用接入</h3>
<p>我们演示的SpringBoot为2.0+，因此直接选择<code>io.micrometer</code> 的依赖包来实现；更低版本的不能使用这种姿势，可以直接使用官方提供的client来实现；这里不进行扩展</p>
<h4> 2.1 依赖配置</h4>
<p>借助SpringBoot的actuator来提供扩展端点（所以本文采用的是Prometheus的拉工作模式）</p>
<p>SpringBoot版本为 <code>2.2.1.RELEASE</code></p>
<p>核心依赖</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>yaml配置文件，需要指定Prometheus相关的参数，一个demo如下</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>注意</strong></p>
<ul>
<li><code>management.endpoints.web.exposure.include</code> 这里指定所有的web接口都会上报</li>
<li><code>metrics.tags.application</code> 这个应用所有上报的metrics 都会带上<code>application</code>这个标签</li>
</ul>
<p>上面配置完毕之后，会提供一个 <code>/actuator/prometheus</code>的端点，供prometheus来拉取Metrics信息</p>
<h4> 2.2 应用启动</h4>
<p>对于SpringBoot而言，此时就不需要额外做什么，就可以实现应用的基本信息上报了</p>
<p>一个简单的demo如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>到此，springboot应用的监控就算是完成了；接下来配置一下prometheus的服务端</p>
<h3> 3. prometheus 配置与实测</h3>
<p>在前面下载的包下面，有一个配置文件 <code>prometheus.yml</code>，新增一个Job</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>修改配置之后，需要重启一下，当服务启动之后，可以在控制台上我们的应用信息</p>
<figure><img src="/imgs/210419/00.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>接下来访问Graph，选择metric: <code>http_server_requests_seconds_count</code> 可以看到一条抓起metric的记录</p>
<figure><img src="/imgs/210419/01.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>前面我们定义了一个Controller，接下来简单访问几次，然后再看一下，会发现多一条记录</p>
<figure><img src="/imgs/210419/02.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>这些数据由框架层直接集成，实现REST接口的相关信息上报，借助这个metric，我们可以实现qps的统计</p>
<h4> 3.1 qps统计</h4>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="/imgs/210419/03.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<ul>
<li>rate: 用于统计增长趋势，要求上报的Metric为Counter类型（只增不减）</li>
<li>irate: 与rate相似，区别在于rate统计的是一段时间内的平均增长速率，无法反应这个时间窗口内的突发情况（即瞬时高峰），irate通过区间向量中最后两个样本数据来计算增长速率，但是当选用的区间范围较大时，可能造成不小的偏差</li>
<li>sum: 求和，适用于统计场景</li>
</ul>
<p>更多内置函数，可以参考: <a href="https://www.prometheus.wang/promql/prometheus-promql-functions.html" target="_blank" rel="noopener noreferrer">PromQL内置函数</a></p>
<h4> 3.2 耗时统计</h4>
<p>除了qps，另外一个经常关注的指标就是rt了，如上面接口的平均rt，通过两个Metric的组合来实现</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="/imgs/210419/04.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>将sum聚合去掉之后，则可以看到各接口的访问情况</p>
<figure><img src="/imgs/210419/05.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 4. Grafana 大盘配置</h3>
<p>面板监控，还是Grafana的比较强大，特别是grafana本身提供了很多模板可以直接导入</p>
<blockquote>
<p>安装可以参考: <a href="https://blog.hhui.top/hexblog/2021/03/18/210318-linux-grafana%E5%A4%A7%E7%9B%98%E6%8E%A5%E5%85%A5mysql/" target="_blank" rel="noopener noreferrer">210318-linux grafana大盘接入mysql</a></p>
</blockquote>
<h4> 4.1 大盘配置</h4>
<p>grafana启动之后，配置数据源Promethues</p>
<figure><img src="/imgs/210419/06.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>接下来配置SpringBoot的应用配置面板，可以直接使用现成的模板，比如 12856</p>
<figure><img src="/imgs/210419/07.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>导入完毕之后，大盘展示如下</p>
<figure><img src="/imgs/210419/08.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>可以看一下请求耗时的统计promql</p>
<figure><img src="/imgs/210419/09.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h4> 4.2 大盘模板哪里找</h4>
<p>如何找直接可用的大盘呢？</p>
<ul>
<li>官网的大盘上查找即可</li>
<li>如 <a href="https://grafana.com/grafana/dashboards?dataSource=prometheus&amp;search=spring" target="_blank" rel="noopener noreferrer">https://grafana.com/grafana/dashboards?dataSource=prometheus&amp;search=spring</a></li>
<li>选择一个，点进去之后，右边的<code>Copy ID toClipboard</code> 对应的数字就是我们需要的</li>
</ul>
<figure><img src="/imgs/210419/10.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 5. 小结</h3>
<p>上面整个流程走下来会发现SpringBoot项目接入Prometheus成本很低，基本上没有太多的编码工作，就可以配置给功能集全的监控大盘，简直不要太嗨</p>
<p>高度封装的便捷性再这里体现得非常突出了，但是搞完之后，再回想一下，我get到了什么？</p>
<p>好像什么都没get到，如果我的服务只提供grpc/dubbo接口，现在假设让我们接入监控，好像还是抓瞎，这该怎么玩</p>
<h2> II. 其他</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>项目源码: <a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/420-prometheus-basic" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/420-prometheus-basic</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/210419/00.png" type="image/png"/>
    </item>
    <item>
      <title>2.自定义埋点上报</title>
      <link>https://liuyueyi.github.io/tutorial/spring/middle/Prometheus/211109-SpringBoot%E4%B9%8BPrometheus%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%8B%E7%82%B9%E4%B8%8A%E6%8A%A5.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/middle/Prometheus/211109-SpringBoot%E4%B9%8BPrometheus%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%8B%E7%82%B9%E4%B8%8A%E6%8A%A5.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">2.自定义埋点上报</source>
      <description>之前介绍了一篇SpringBoot集成Prometheus实现数据上报的博文，在前面一篇博文中，更多的是一个SpringBoot应用如何最小成本的接入Prometheus，并结合Grafana配置一个完整的应用监控大盘 有看过前文的小伙伴可能知晓，SpringBoot接入Prometheus之后，基本上不用做额外的开发，就已经实现了我们关心的JVM情况、GC情况、HTTP调用请求等信息，然而在实际的业务开发过程中，我们总会遇到一些需要手动上报的场景，那么我们可以怎么处理呢？ 本文的核心知识点： 通过一个实例演示SpringBoot应用，如何实现自定义的数据上报 上篇博文: SpringBoot整合Prometheus实现应用监控</description>
      <category>SpringBoot</category>
      <category>中间件</category>
      <category>Prometheus</category>
      <pubDate>Tue, 09 Nov 2021 18:44:30 GMT</pubDate>
      <content:encoded><![CDATA[<p>之前介绍了一篇SpringBoot集成Prometheus实现数据上报的博文，在前面一篇博文中，更多的是一个SpringBoot应用如何最小成本的接入Prometheus，并结合Grafana配置一个完整的应用监控大盘</p>
<p>有看过前文的小伙伴可能知晓，SpringBoot接入Prometheus之后，基本上不用做额外的开发，就已经实现了我们关心的JVM情况、GC情况、HTTP调用请求等信息，然而在实际的业务开发过程中，我们总会遇到一些需要手动上报的场景，那么我们可以怎么处理呢？</p>
<p>本文的核心知识点：</p>
<ul>
<li>通过一个实例演示SpringBoot应用，如何实现自定义的数据上报</li>
</ul>
<p>上篇博文: <a href="https://spring.hhui.top/spring-blog/2021/04/19/210419-SpringBoot%E6%95%B4%E5%90%88Prometheus%E5%AE%9E%E7%8E%B0%E5%BA%94%E7%94%A8%E7%9B%91%E6%8E%A7/" target="_blank" rel="noopener noreferrer">SpringBoot整合Prometheus实现应用监控</a></p>
<!-- more -->
<h2> I. 项目环境搭建</h2>
<p>本文演示的项目主要为SpringBoot2.2.1版本，更高的版本使用姿势没有太大的区别，至于1.x版本的不确保可行（因为我并没有测试）</p>
<h3> 1.依赖</h3>
<p>pom依赖，主要是下面几个包</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 配置信息</h3>
<p>其次是配置文件，注册下Prometheus的相关信息</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面配置中，有两个关键信息，前面博文也有介绍，这里简单说明</p>
<ul>
<li><code>management.endpoints.web.exposure.include</code> 这里指定所有的web接口都会上报</li>
<li><code>metrics.tags.application</code> 这个应用所有上报的metrics 都会带上application这个标签</li>
</ul>
<p>配置完毕之后，会提供一个 <code>/actuator/prometheus</code>的端点，供prometheus来拉取Metrics信息</p>
<h2> II. 自定义上报</h2>
<p>假设我们现在想自己上报http请求的相关信息，当前计划采集下面几个信息</p>
<ul>
<li>总的请求数：采用<code>Counter</code></li>
<li>当前正在处理的请求数：采用<code>Gauge</code></li>
<li>请求耗时直方图: <code>Histogram</code></li>
</ul>
<h3> 1. Prometheus Metric封装</h3>
<p>基于上面的分析，我们这里实现了三种常见的Metric信息上报，这里提供一个统一的封装类，用于获取对应的Metric类型</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意上面的<code>setApplicationContext()</code>的方法实现逻辑，其中在创建<code>Counter/Gauge/Histogram</code>时，使用的是<code>simpleclient</code>包中提供的最基础的用法，并不是<code>micrometer</code>的封装方式，后面一篇博文会介绍到两种的差异性</p>
<p>上面实现的特点在于，创建Metric时，就已经定义好了label标签，这里定义了</p>
<ul>
<li>path: 请求url路径</li>
<li>method: http方法, get/post</li>
<li>code: 状态码，表示请求成功还是异常</li>
</ul>
<h3> 2. 拦截器实现自定义信息采集上报</h3>
<p>接下来我们实现一个自定义的拦截器，拦截所有的http请求，然后上报关键信息</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对于拦截器的知识点这里不进行展开，有兴趣的小伙伴可以查看 <a href="https://spring.hhui.top/spring-blog/2021/08/04/210804-SpringBoot%E7%B3%BB%E5%88%97Web%E7%AF%87%E4%B9%8B%E6%8B%A6%E6%88%AA%E5%99%A8Interceptor%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF%E4%BB%8B%E7%BB%8D/" target="_blank" rel="noopener noreferrer">SpringBoot系列Web篇之拦截器Interceptor使用姿势介绍</a></p>
<p>这里我们主要关心的就两点</p>
<ul>
<li>执行之前（<code>preHandle</code>）： gauge计数+1，开始计时</li>
<li>执行之后 (<code>afterCompletion</code>)： guage计数-1，counter计数+1，计时收集</li>
</ul>
<h3> 3. 测试</h3>
<p>最后我们需要注册上面的拦截器，并写个demo进行测试一下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>应用启动之后，访问几次hello的http接口，然后在查看一下metric信息，看是否有我们刚才上报的数据</p>
<figure><img src="/imgs/211109/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 4. 小结</h3>
<p>这一篇博文算是上一篇的补全，若我们希望自定义上报一些信息，可以使用上面这种方式来支持</p>
<p>当然，上报并不代表结束，接下来配置大盘等信息也非常的关键，特别是直方图如何配置Grafana？怎么查看请求的耗时分布情况，就由下文来介绍了</p>
<h2> III. 不能错过的源码和相关知识点</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/</a></li>
</ul>
<h3> 1. 微信公众号: 一灰灰Blog</h3>
<p>尽信书则不如，以上内容，纯属一家之言，因个人能力有限，难免有疏漏和错误之处，如发现bug或者有更好的建议，欢迎批评指正，不吝感激</p>
<p>下面一灰灰的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛</p>
<ul>
<li>一灰灰Blog个人博客 <a href="https://blog.hhui.top" target="_blank" rel="noopener noreferrer">https://blog.hhui.top</a></li>
<li>一灰灰Blog-Spring专题博客 <a href="http://spring.hhui.top" target="_blank" rel="noopener noreferrer">http://spring.hhui.top</a></li>
</ul>
<figure><img src="https://spring.hhui.top/spring-blog/imgs/info/info.png" alt="一灰灰blog" tabindex="0" loading="lazy"><figcaption>一灰灰blog</figcaption></figure>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/211109/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>3.自定义埋点姿势二</title>
      <link>https://liuyueyi.github.io/tutorial/spring/middle/Prometheus/211119-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8BPrometheus%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%8B%E7%82%B9%E5%A7%BF%E5%8A%BF%E4%BA%8C.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/middle/Prometheus/211119-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8BPrometheus%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%8B%E7%82%B9%E5%A7%BF%E5%8A%BF%E4%BA%8C.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">3.自定义埋点姿势二</source>
      <description>关于Prometheus的自定义埋点，前一篇博文已经介绍了，为啥这里又来一次？ 看过前文的小伙伴可能会知道，之前采用的simpleclient包定义的几个metric来实现的，实际上有更简单方便的姿势，那就是直接借助MeterRegistry来创建Metric来实现数据采集即可 相比较于前文的实现，总的来说简易程度可见一般，上篇文章可以点击下文查看 【中间件】Prometheus自定义埋点上报 | 一灰灰Blog</description>
      <category>SpringBoot</category>
      <category>中间件</category>
      <category>Prometheus</category>
      <pubDate>Fri, 19 Nov 2021 19:30:15 GMT</pubDate>
      <content:encoded><![CDATA[<p>关于Prometheus的自定义埋点，前一篇博文已经介绍了，为啥这里又来一次？</p>
<p>看过前文的小伙伴可能会知道，之前采用的<code>simpleclient</code>包定义的几个metric来实现的，实际上有更简单方便的姿势，那就是直接借助<code>MeterRegistry</code>来创建Metric来实现数据采集即可</p>
<p>相比较于前文的实现，总的来说简易程度可见一般，上篇文章可以点击下文查看</p>
<ul>
<li><a href="https://spring.hhui.top/spring-blog/2021/11/09/211109-SpringBoot%E4%B9%8BPrometheus%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%8B%E7%82%B9%E4%B8%8A%E6%8A%A5/" target="_blank" rel="noopener noreferrer">【中间件】Prometheus自定义埋点上报 | 一灰灰Blog</a></li>
</ul>
<!-- more -->
<h2> I. 自定义上报</h2>
<p>依然是搭建一个基础项目工程，本文演示的项目主要为SpringBoot2.2.1版本，更高的版本使用姿势没有太大的区别，至于1.x版本的不确保可行（因为我并没有测试）</p>
<h3> 1.依赖</h3>
<p>pom依赖，主要是下面几个包</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 配置信息</h3>
<p>其次是配置文件，注册下Prometheus的相关信息</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面配置中，有两个关键信息，前面博文也有介绍，这里简单说明</p>
<ul>
<li><code>management.endpoints.web.exposure.include</code> 这里指定所有的web接口都会上报</li>
<li><code>metrics.tags.application</code> 这个应用所有上报的metrics 都会带上application这个标签</li>
</ul>
<p>配置完毕之后，会提供一个 <code>/actuator/prometheus</code>的端点，供prometheus来拉取Metrics信息</p>
<h3> 3. 自定义拦截器实现采集上报</h3>
<p>实现一个基础的拦截器，用来拦截所有的http请求，然后收集请求信息上报</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意上面的三种Metric的创建方式</p>
<ul>
<li>Counter: 直接使用 <code>meterRegistry.counter()</code>来创建metric并实现计数+1
<ul>
<li>传参中，Tags组成的就是propmetheus中定义的label，kv格式，第一个参数用来定义MetricName</li>
</ul>
</li>
<li>Gauge: 使用姿势与上面基本相同，不过需要注意计数的加减是直接在传参中</li>
<li>Histogram: 它的使用姿势就需要特别注意下了，在preHander中定义的是 <code>Timer.Sampler</code>对象，在 <code>postHandler</code>中实现的数据采集</li>
</ul>
<p>上面短短一点代码，就实现了一个简单的自定义信息上报；接下来就是注册拦截器了</p>
<h3> 4. 注册并测试</h3>
<p>拦截器依赖了Spring的bean对象，因此需要将它定义为bean对象</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>基于此一个简单的自定义采集上报就完成了；项目启动之后，通过访问采集端点查看是否有数据上报</p>
<figure><img src="/imgs/211119/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>最后小结一下，虽然SpringBoot可以非常方便的接入prometheus来采集一些常见的指标，但是当我们有自定义上报指标的需求时，直接使用<code>MeterRegistry</code>来收集信息，创建Metric是个不错的选择，通常我们选择的三种类型作用如下</p>
<ul>
<li>总的请求数：采用<code>Counter</code></li>
<li>当前正在处理的请求数：采用<code>Gauge</code></li>
<li>请求耗时直方图: <code>Histogram</code></li>
</ul>
<h2> II. 不能错过的源码和相关知识点</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/421-prometheus-micro" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/421-prometheus-micro</a></li>
</ul>
<h3> 1. 微信公众号: 一灰灰Blog</h3>
<p>尽信书则不如，以上内容，纯属一家之言，因个人能力有限，难免有疏漏和错误之处，如发现bug或者有更好的建议，欢迎批评指正，不吝感激</p>
<p>下面一灰灰的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛</p>
<ul>
<li>一灰灰Blog个人博客 <a href="https://blog.hhui.top" target="_blank" rel="noopener noreferrer">https://blog.hhui.top</a></li>
<li>一灰灰Blog-Spring专题博客 <a href="http://spring.hhui.top" target="_blank" rel="noopener noreferrer">http://spring.hhui.top</a></li>
</ul>
<figure><img src="https://spring.hhui.top/spring-blog/imgs/info/info.png" alt="一灰灰blog" tabindex="0" loading="lazy"><figcaption>一灰灰blog</figcaption></figure>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/211119/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>4.基于AOP实现埋点采集上报</title>
      <link>https://liuyueyi.github.io/tutorial/spring/middle/Prometheus/211222-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8BPrometheus%E5%9F%BA%E4%BA%8EAOP%E5%AE%9E%E7%8E%B0%E5%9F%8B%E7%82%B9%E9%87%87%E9%9B%86%E4%B8%8A%E6%8A%A5.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/middle/Prometheus/211222-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8BPrometheus%E5%9F%BA%E4%BA%8EAOP%E5%AE%9E%E7%8E%B0%E5%9F%8B%E7%82%B9%E9%87%87%E9%9B%86%E4%B8%8A%E6%8A%A5.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">4.基于AOP实现埋点采集上报</source>
      <description>前面几篇文章介绍了SpringBoot继承Prometheus实现埋点上报，基本上可以非常简单的实现采样收集，对于由SpringBoot搭建的web应用，甚至是可以说是引入依赖，简单的配置下，剩下的啥也不用管，就可以配置一个REST应用的监控大盘 接下来我们通过AOP的方式，来定义一个自定义数据采集的功能，用于实现一些上面覆盖不到的场景（如应用内的定时任务执行情况，三方接口请求监控等） I. 方案确定与环境搭建 1.metric选择 通过前面的几篇文章，至少我们会了解到Prometheus的四种Metric，对于自定义的数据采集，根据最终希望监控的指标（每秒请求数 qps, 响应耗时 rt, 可用率 sla, 请求分布），我们这里选择Histogram</description>
      <category>SpringBoot</category>
      <category>中间件</category>
      <category>Prometheus</category>
      <pubDate>Wed, 22 Dec 2021 19:30:15 GMT</pubDate>
      <content:encoded><![CDATA[<p>前面几篇文章介绍了SpringBoot继承Prometheus实现埋点上报，基本上可以非常简单的实现采样收集，对于由SpringBoot搭建的web应用，甚至是可以说是引入依赖，简单的配置下，剩下的啥也不用管，就可以配置一个REST应用的监控大盘</p>
<p>接下来我们通过AOP的方式，来定义一个自定义数据采集的功能，用于实现一些上面覆盖不到的场景（如应用内的定时任务执行情况，三方接口请求监控等）</p>
<!--  more -->
<h2> I. 方案确定与环境搭建</h2>
<h3> 1.metric选择</h3>
<p>通过前面的几篇文章，至少我们会了解到Prometheus的四种Metric，对于自定义的数据采集，根据最终希望监控的指标（每秒请求数 qps, 响应耗时 rt, 可用率 sla, 请求分布），我们这里选择Histogram</p>
<ul>
<li>通过histogram指标中的 count 值来计算qps</li>
<li>通过 sum / count 来计算rt</li>
<li>通过<code>成功数 / 总请求数</code>计算可用率sla</li>
<li>通过histogram的bucket分布来查看请求分布</li>
</ul>
<h3> 2.项目依赖</h3>
<p>本项目借助<code>SpringBoot 2.2.1.RELEASE</code> +  <code>maven 3.5.3</code> + <code>IDEA</code>进行开发</p>
<p>其核心pom依赖，主要是下面几个包</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. 配置信息</h3>
<p>其次是配置文件，注册下Prometheus的相关信息</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面配置中，有两个关键信息，前面博文也有介绍，这里简单说明</p>
<ul>
<li><code>management.endpoints.web.exposure.include</code> 这里指定所有的web接口都会上报</li>
<li><code>metrics.tags.application</code> 这个应用所有上报的metrics 都会带上application这个标签</li>
</ul>
<p>配置完毕之后，会提供一个 <code>/actuator/prometheus</code>的端点，供prometheus来拉取Metrics信息</p>
<h2> II. AOP切面实现埋点上报</h2>
<h3> 1. 切面实现类</h3>
<p>通过切面来拦截目标类的执行，选择三个关键指标</p>
<ul>
<li>service: 表示具体执行的类</li>
<li>method：执行的方法</li>
<li>err: true 表示执行异常/else 表示执行正常</li>
</ul>
<p>直接使用Histogram来实现数据采集上报，直接使用前面博文* <a href="https://spring.hhui.top/spring-blog/2021/11/19/211119-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8BPrometheus%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%8B%E7%82%B9%E5%A7%BF%E5%8A%BF%E4%BA%8C/" target="_blank" rel="noopener noreferrer">【中间件】Prometheus自定义埋点姿势二 | 一灰灰Blog</a> 使用姿势即可</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 测试方法</h3>
<p>这里写两个简单的Service类，作为收集采样的目标</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后我们通过定时任务来不断的访问上面的服务方法，用来模拟请求场景</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. 启动类</h3>
<p>最后就是在启动类中注册一下MeterRegistryCustomizer，为所有的metric携带上<code>application</code>标签</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>应用启动之后，就可以通过<code>http://m-162d9nnes031u:8080/actuator/prometheus</code>来查看收集的采样信息了，如</p>
<figure><img src="/imgs/211222/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 4. 业务大盘配置</h3>
<p>上面基本即实现了一个基于aop的采样收集，接下来重点就是如何将这些收集上来的数据，可视化配置起来</p>
<p>借助Grafana无疑是个比较推荐的case，下一篇博文将详细介绍如何针对上面收集的信息进行友好的配置，欢迎有兴趣的小伙伴关注吐槽</p>
<h2> III. 不能错过的源码和相关知识点</h2>
<h3> 0. 项目源码</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-case/421-prometheus-metric" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-case/421-prometheus-metric</a></li>
</ul>
<p><strong>系列博文：</strong></p>
<ul>
<li><a href="https://spring.hhui.top/spring-blog/2021/11/19/211119-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8BPrometheus%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%8B%E7%82%B9%E5%A7%BF%E5%8A%BF%E4%BA%8C/" target="_blank" rel="noopener noreferrer">【中间件】Prometheus自定义埋点姿势二</a></li>
<li><a href="https://spring.hhui.top/spring-blog/2021/11/09/211109-SpringBoot%E4%B9%8BPrometheus%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%8B%E7%82%B9%E4%B8%8A%E6%8A%A5/" target="_blank" rel="noopener noreferrer">【中间件】Prometheus自定义埋点上报</a></li>
<li><a href="https://spring.hhui.top/spring-blog/2021/04/19/210419-SpringBoot%E6%95%B4%E5%90%88Prometheus%E5%AE%9E%E7%8E%B0%E5%BA%94%E7%94%A8%E7%9B%91%E6%8E%A7/" target="_blank" rel="noopener noreferrer">【中间件】Prometheus实现应用监控</a></li>
</ul>
<h3> 1. 微信公众号: 一灰灰Blog</h3>
<p>尽信书则不如，以上内容，纯属一家之言，因个人能力有限，难免有疏漏和错误之处，如发现bug或者有更好的建议，欢迎批评指正，不吝感激</p>
<p>下面一灰灰的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛</p>
<ul>
<li>一灰灰Blog个人博客 <a href="https://blog.hhui.top" target="_blank" rel="noopener noreferrer">https://blog.hhui.top</a></li>
<li>一灰灰Blog-Spring专题博客 <a href="http://spring.hhui.top" target="_blank" rel="noopener noreferrer">http://spring.hhui.top</a></li>
</ul>
<figure><img src="https://spring.hhui.top/spring-blog/imgs/info/info.png" alt="一灰灰blog" tabindex="0" loading="lazy"><figcaption>一灰灰blog</figcaption></figure>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/211222/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>5.Prometheus大盘配置实战</title>
      <link>https://liuyueyi.github.io/tutorial/spring/middle/Prometheus/211223-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8BPrometheus%E5%A4%A7%E7%9B%98%E9%85%8D%E7%BD%AE%E5%AE%9E%E6%88%98.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/middle/Prometheus/211223-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8BPrometheus%E5%A4%A7%E7%9B%98%E9%85%8D%E7%BD%AE%E5%AE%9E%E6%88%98.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">5.Prometheus大盘配置实战</source>
      <description>借助Grafana来实现大盘配置，关于Grafana的启用配置，这里就不详细说明，有兴趣的可以查看前文 * 【中间件】Prometheus实现应用监控 | 一灰灰Blog 接下来主要是针对上一篇 【中间件】Prometheus基于AOP实现埋点采集上报 上报的Histogram数据，来配置一套相对完整的业务监控大盘</description>
      <category>SpringBoot</category>
      <category>中间件</category>
      <category>Prometheus</category>
      <pubDate>Thu, 23 Dec 2021 10:17:10 GMT</pubDate>
      <content:encoded><![CDATA[<p>借助Grafana来实现大盘配置，关于Grafana的启用配置，这里就不详细说明，有兴趣的可以查看前文 * <a href="https://spring.hhui.top/spring-blog/2021/04/19/210419-SpringBoot%E6%95%B4%E5%90%88Prometheus%E5%AE%9E%E7%8E%B0%E5%BA%94%E7%94%A8%E7%9B%91%E6%8E%A7/" target="_blank" rel="noopener noreferrer">【中间件】Prometheus实现应用监控 | 一灰灰Blog</a></p>
<p>接下来主要是针对上一篇 <a href="https://spring.hhui.top/spring-blog/2021/12/22/211222-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8BPrometheus%E5%9F%BA%E4%BA%8EAOP%E5%AE%9E%E7%8E%B0%E5%9F%8B%E7%82%B9%E9%87%87%E9%9B%86%E4%B8%8A%E6%8A%A5/" target="_blank" rel="noopener noreferrer">【中间件】Prometheus基于AOP实现埋点采集上报</a> 上报的Histogram数据，来配置一套相对完整的业务监控大盘</p>
<!-- more -->
<h2> I.大盘配置</h2>
<h3> 1. 基本盘选择</h3>
<p>直接到官网查找模板大盘，这里选择SpringBoot搭建的服务器项目，可以输入spring关键字进行检索</p>
<blockquote>
<p>官网：<a href="https://grafana.com/grafana/dashboards?dataSource=prometheus&amp;search=spring" target="_blank" rel="noopener noreferrer">https://grafana.com/grafana/dashboards?dataSource=prometheus&amp;search=spring</a></p>
</blockquote>
<p>比如我们这里选择 <code>6756</code> 作为基础模板；然后在Grafana上导入</p>
<figure><img src="/imgs/211223/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>导入之后，对于变量的依赖顺序根据实际情况调整一下，比如我希望第一个变量是application,在选择应用之后，再选择对应的实例ip；</p>
<p>修改步骤如下：</p>
<ul>
<li>依次选择：dashboard settings -&gt; variables</li>
<li>将application变量前置到instance前</li>
<li>application:
<ul>
<li>修改query为: <code>label_values(jvm_classes_loaded_classes, application)</code></li>
</ul>
</li>
<li>instance:
<ul>
<li>修改query为: <code>label_values(jvm_classes_loaded_classes{application="$application"}, instance)</code></li>
</ul>
</li>
<li>新增service变量
<ul>
<li>query = <code>label_values(micro_service_histogram_seconds_count{application="$application", instance="$instance"}, service)</code></li>
</ul>
</li>
</ul>
<figure><img src="/imgs/211223/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p><strong>注意</strong></p>
<ul>
<li>一个变量的取值依赖另一个变量，请注意将被依赖的变量顺序放在前面</li>
<li>一个变量的取值依赖另一个变量，写法是 <code>metric{tag="$valName"}</code>， 这个变量名前缀是<code>$</code>，且使用双引号包裹</li>
<li>metric的选择，可以通过直接查看目标服务器的metric接口查看，比如service变量选择的metric就是自定义上报的<code>micro_service_histogram_seconds_count</code>，而application与instance则选取的是Prometheus-Spring组件上报的spring应用基础信息中的metric</li>
</ul>
<h3> 2. 业务盘配置</h3>
<p>常见的业务指标，如QPS + RT + TPS + SLA等，接下来看一下如何进行配置</p>
<h4> 2.1 qps 每秒请求数</h4>
<p>主要是借助内置函数<code>rate</code>来计算qps，通过一个计算时间窗口的平均增长速率，来展示接口的qps</p>
<div class="language-PrmomQL line-numbers-mode" data-ext="PrmomQL"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="/imgs/211223/02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>使用rate来计算qps时，会存在一个<code>长尾问题</code>，因为它实际上是根据1min内的所有样本数据，来计算平均增长率，因此当一个时间窗口内，存在瞬时的大数据场景，将不能很好的反应出来</p>
<p>因此更关注瞬时场景时，可以考虑使用<code>irate</code>来代替，它是通过一个时间范围内的区间向量数据中最后两个来计算增长速率的</p>
<h4> 2.2 rt 接口响应平均耗时</h4>
<p>对于耗时的统计，也是比较重要的一个指标，用于判断我们系统的响应情况以及性能表现</p>
<p>核心配置： <code>rate(sum / count)</code></p>
<div class="language-PromQL line-numbers-mode" data-ext="PromQL"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>注意Y轴单位选择 <code>seconds</code></p>
<figure><img src="/imgs/211223/03.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h4> 2.3 接口耗时分布统计</h4>
<p>基于Histogram样本数据，配合Grafana的热点图来配置耗时统计分布</p>
<div class="language-PromQL line-numbers-mode" data-ext="PromQL"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="/imgs/211223/04.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>几个关键的配置</p>
<ul>
<li>配置参数中的Format 选择 Heatmap</li>
<li>面板的Visualization中，选择 Heatmap</li>
<li>面板中的Display，mode选择Opacity</li>
</ul>
<p>根据颜色的深浅，来判断哪个bucket的请求量较多</p>
<h4> 2.4 SLA可用率</h4>
<p>根据成功响应的计数 / 总计数来表征接口请求成功率</p>
<div class="language-PromQL line-numbers-mode" data-ext="PromQL"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="/imgs/211223/05.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 3. 应用维度统计支持</h3>
<p>前面的几个配置，统计面板都是基于某个应用，某个实例中的某个方法的维度进行展示，但实际情况是我们也很关注整体应用维度的表现情况</p>
<p>因此我们需要在变量选择中，支持全部</p>
<ul>
<li>开启变量的include all， 并设置<code>custorm all value = .*</code></li>
</ul>
<figure><img src="/imgs/211223/06.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<figure><img src="/imgs/211223/07.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<ul>
<li>第二步就是修改PromQL，将完全匹配调整为正则匹配 (将<code>=</code>改成<code>=~</code>)</li>
</ul>
<figure><img src="/imgs/211223/08.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 4.小结</h3>
<p>本文主要是通过grafana的大盘配置来展示如何使用Prometheus采集的数据，为了更好的使用采集数据，PromQL又是一个无法避免的知识点，下篇博文将带来PromQL的科普</p>
<h2> II. 不能错过的源码和相关知识点</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-case/421-prometheus-metric" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-case/421-prometheus-metric</a></li>
</ul>
<p><strong>系列博文：</strong></p>
<ul>
<li><a href="https://spring.hhui.top/spring-blog/2021/12/22/211222-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8BPrometheus%E5%9F%BA%E4%BA%8EAOP%E5%AE%9E%E7%8E%B0%E5%9F%8B%E7%82%B9%E9%87%87%E9%9B%86%E4%B8%8A%E6%8A%A5/" target="_blank" rel="noopener noreferrer">【中间件】Prometheus基于AOP实现埋点采集上报</a></li>
<li><a href="https://spring.hhui.top/spring-blog/2021/11/19/211119-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8BPrometheus%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%8B%E7%82%B9%E5%A7%BF%E5%8A%BF%E4%BA%8C/" target="_blank" rel="noopener noreferrer">【中间件】Prometheus自定义埋点姿势二</a></li>
<li><a href="https://spring.hhui.top/spring-blog/2021/11/09/211109-SpringBoot%E4%B9%8BPrometheus%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%8B%E7%82%B9%E4%B8%8A%E6%8A%A5/" target="_blank" rel="noopener noreferrer">【中间件】Prometheus自定义埋点上报</a></li>
<li><a href="https://spring.hhui.top/spring-blog/2021/04/19/210419-SpringBoot%E6%95%B4%E5%90%88Prometheus%E5%AE%9E%E7%8E%B0%E5%BA%94%E7%94%A8%E7%9B%91%E6%8E%A7/" target="_blank" rel="noopener noreferrer">【中间件】Prometheus实现应用监控</a></li>
</ul>
<h3> 1. 微信公众号: 一灰灰Blog</h3>
<p>尽信书则不如，以上内容，纯属一家之言，因个人能力有限，难免有疏漏和错误之处，如发现bug或者有更好的建议，欢迎批评指正，不吝感激</p>
<p>下面一灰灰的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛</p>
<ul>
<li>一灰灰Blog个人博客 <a href="https://blog.hhui.top" target="_blank" rel="noopener noreferrer">https://blog.hhui.top</a></li>
<li>一灰灰Blog-Spring专题博客 <a href="http://spring.hhui.top" target="_blank" rel="noopener noreferrer">http://spring.hhui.top</a></li>
</ul>
<figure><img src="https://spring.hhui.top/spring-blog/imgs/info/info.png" alt="一灰灰blog" tabindex="0" loading="lazy"><figcaption>一灰灰blog</figcaption></figure>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/211223/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>Prometheus</title>
      <link>https://liuyueyi.github.io/tutorial/spring/middle/Prometheus/</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/middle/Prometheus/</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">Prometheus</source>
      <description>接入Prometheus，搭建应用监控体系</description>
      <pubDate>Fri, 10 Feb 2023 04:50:05 GMT</pubDate>
      <content:encoded><![CDATA[<p>接入Prometheus，搭建应用监控体系</p>
]]></content:encoded>
    </item>
    <item>
      <title>1.基础使用介绍</title>
      <link>https://liuyueyi.github.io/tutorial/spring/middle/ZooKeeper/210414-SpringBoot%E6%95%B4%E5%90%88zookeeper%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/middle/ZooKeeper/210414-SpringBoot%E6%95%B4%E5%90%88zookeeper%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">1.基础使用介绍</source>
      <description>ZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，广泛应用于分布式系统中，比如有用它做配置中心，注册中心，也有使用它来实现分布式锁的，作为高并发技术栈中不可或缺的一个基础组件，接下来我们将看一下，zk应该怎么玩，可以怎么玩 本文作为第一篇，将主要介绍基于zk-client的基本使用姿势，以次来了解下zk的基本概念</description>
      <category>SpringBoot</category>
      <category>中间件</category>
      <category>ZooKeeper</category>
      <pubDate>Wed, 14 Apr 2021 22:45:21 GMT</pubDate>
      <content:encoded><![CDATA[<p>ZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，广泛应用于分布式系统中，比如有用它做配置中心，注册中心，也有使用它来实现分布式锁的，作为高并发技术栈中不可或缺的一个基础组件，接下来我们将看一下，zk应该怎么玩，可以怎么玩</p>
<p>本文作为第一篇，将主要介绍基于zk-client的基本使用姿势，以次来了解下zk的基本概念</p>
<!-- more -->
<h2> I. 准备</h2>
<h3> 1. zk环境安装</h3>
<p>用于学习试点目的的体验zk功能，安装比较简单，可以参考博文: <a href="https://blog.hhui.top/hexblog/2021/03/10/210310-ZooKeeper%E5%AE%89%E8%A3%85%E5%8F%8A%E5%88%9D%E4%BD%93%E9%AA%8C/" target="_blank" rel="noopener noreferrer">210310-ZooKeeper安装及初体验</a></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 项目环境</h3>
<p>本文演示的是直接使用apache的zookeeper包来操作zk，与是否是SpringBoot环境无关</p>
<p>核心依赖</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>版本说明:</p>
<ul>
<li>zk: 3.6.2</li>
<li>SpringBoot: 2.2.1.RELEASE</li>
</ul>
<h2> II. ZK使用姿势</h2>
<h3> 1. zk基本知识点</h3>
<p>首先介绍下zk的几个主要的知识点，如zk的数据模型，四种常说的节点</p>
<h4> 1.1 数据模型</h4>
<p>zk的数据模型和我们常见的目录树很像，从<code>/</code>开始，每一个层级就是一个节点</p>
<p>每个节点，包含数据 + 子节点</p>
<p>注意：EPHEMERAL节点，不能有子节点（可以理解为这个目录下不能再挂目录）</p>
<p>zk中常说的监听器，就是基于节点的，一般来讲监听节点的创建、删除、数据变更</p>
<h4> 1.2 节点</h4>
<ul>
<li>持久节点 persistent node</li>
<li>持久顺序节点 persistent sequental</li>
<li>临时节点 ephemeral node</li>
<li>临时顺序节点 ephemeral sequental</li>
</ul>
<p><strong>注意：</strong></p>
<ul>
<li>节点类型一经指定，不允许修改</li>
<li>临时节点，当会话结束，会自动删除，且不能有子节点</li>
</ul>
<h3> 2. 节点创建</h3>
<p>接下来我们看一下zk的使用姿势，首先是创建节点，当然创建前提是得先拿到zkClient</p>
<p>初始化连接</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>节点创建方法，下面分别给出两种不同的case</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>节点创建，核心在于 <code>zooKeeper.create(path + "/yes", "保存的数据".getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);</code></p>
<ul>
<li>当节点已存在时，再创建会抛异常 <code>KeeperException.NodeExistsException</code></li>
<li>最后一个参数，来决定我们创建的节点类型</li>
<li>todo: 上面实例中在指定ttl时，没有成功，暂未找到原因，待解决</li>
</ul>
<h3> 3. 节点存在判断</h3>
<p>判断节点是否存在，比较常见了（比如我们在创建之前，可能会先判断一下是否存在）</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>注意</strong></p>
<p>核心用法： <code>zooKeeper.exists(path + "/yes", this);</code></p>
<ul>
<li>当节点存在时，返回Stat对象，包含一些基本信息；如果不存在，则返回null</li>
<li>第二个参数，传入的是事件回调对象，我们的测试类<code>NodeExmaple</code> 实现了接口 <code>Watcher</code>， 所以直接传的是<code>this</code></li>
<li>注册事件监听时，需要注意这个回调只会执行一次，即触发之后就没了；后面再次修改、删除、创建节点都不会再被接收到</li>
</ul>
<h3> 4. 子节点获取</h3>
<p>获取某个节点的所有子节点，这里返回的是当前节点的一级子节点</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 5. 数据获取与修改</h3>
<p>节点上是可以存储数据的，在创建的时候，可以加上数据；后期可以读取，也可以修改</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在设置数据时，可以指定版本，当version &gt; 0时，表示根据版本精确匹配；如果为-1时，则只要节点路径对上就成</p>
<h3> 6. 事件监听</h3>
<p>监听主要是针对节点而言，前面在判断节点是否存在、修改数据时都可以设置监听器，但是他们是一次性的，如果我们希望长久有效，则可以使用下面的<code>addWatch</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面给出了两种case，</p>
<ul>
<li>AddWatchMode.PERSISTENT： 表示只关心当前节点的删除、数据变更，创建，一级子节点的创建、删除；无法感知子节点的子节点创建、删除，无法感知子节点的数据变更</li>
<li>AddWatchMode.PERSISTENT_RECURSIVE: 相当于递归监听，改节点及其子节点的所有变更都监听</li>
</ul>
<h3> 7. 节点删除</h3>
<p>最后再介绍一个基本功能，节点删除，只有子节点都不存在时，才能删除当前节点（和linux的rmdir类似）</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 8. 小结</h3>
<p>本文主要介绍的是java侧对zookeeper的基本操作姿势，可以算是zk的入门，了解下节点的增删改，事件监听；</p>
<p>当然一般更加推荐的是使用Curator来操作zk，相比较于apache的jar包，使用姿势更加顺滑，后面也会做对比介绍</p>
<h2> II. 其他</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>项目源码: <a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/410-zookeeper-basic" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/410-zookeeper-basic</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>2.从0到1实现一个分布式锁</title>
      <link>https://liuyueyi.github.io/tutorial/spring/middle/ZooKeeper/210415-SpringBoot%E6%95%B4%E5%90%88Zookeeper%E4%BB%8E0%E5%88%B01%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/middle/ZooKeeper/210415-SpringBoot%E6%95%B4%E5%90%88Zookeeper%E4%BB%8E0%E5%88%B01%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">2.从0到1实现一个分布式锁</source>
      <description>分布式锁，在实际的业务使用场景中算是比较常用的了，而分布式锁的实现，常见的除了redis之外，就是zk的实现了，前面一篇博文介绍了zk的基本概念与使用姿势，那么如果让我们来记住zk的特性来设计一个分布式锁，可以怎么做呢?</description>
      <category>SpringBoot</category>
      <category>中间件</category>
      <category>ZooKeeper</category>
      <pubDate>Thu, 15 Apr 2021 20:18:26 GMT</pubDate>
      <content:encoded><![CDATA[<p>分布式锁，在实际的业务使用场景中算是比较常用的了，而分布式锁的实现，常见的除了redis之外，就是zk的实现了，前面一篇博文介绍了zk的基本概念与使用姿势，那么如果让我们来记住zk的特性来设计一个分布式锁，可以怎么做呢?</p>
<!-- more -->
<h2> I. 方案设计</h2>
<h3> 1. 创建节点方式实现</h3>
<p>zk有四种节点，一个最容易想到的策略就是创建节点，谁创建成功了，就表示谁持有了这个锁</p>
<p>这个思路与redis的<code>setnx</code>有点相似，因为zk的节点创建，也只会有一个会话会创建成功，其他的则会抛已存在的异常</p>
<p>借助临时节点，会话丢掉之后节点删除，这样可以避免持有锁的实例异常而没有主动释放导致所有实例都无法持有锁的问题</p>
<p>如果采用这种方案，如果我想实现阻塞获取锁的逻辑，那么其中一个方案就需要写一个while(true)来不断重试</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>另外一个策略则是借助事件监听，当节点存在时，注册一个节点删除的触发器，这样就不需要我自己重试判断了；充分借助zk的特性来实现异步回调</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>那么上面这个实现有什么问题呢？</p>
<p>每次节点的变更，那么所有的都会监听到变动，好处是非公平锁的支持；缺点就是剩下这些唤醒的实例中也只会有一个抢占到锁，无意义的唤醒浪费性能</p>
<h3> 2. 临时顺序节点方式</h3>
<p>接下来这种方案更加常见，晚上大部分的教程也是这种case，主要思路就是创建临时顺序节点</p>
<p>只有序号最小的节点，才表示抢占锁成功；如果不是最小的节点，那么就监听它前面一个节点的删除事件，前面节点删除了，一种可能是他放弃抢锁，一种是他释放自己持有的锁，不论哪种情况，对我而言，我都需要捞一下所有的节点，要么拿锁成功；要么换一个前置节点</p>
<h2> II.分布式锁实现</h2>
<p>接下来我们来一步步看下，基于临时顺序节点，可以怎么实现分布式锁</p>
<p>对于zk，我们依然采用apache的提供的包 <code>zookeeper</code>来操作；后续提供<code>Curator</code>的分布式锁实例</p>
<h3> 1. 依赖</h3>
<p>核心依赖</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>版本说明:</p>
<ul>
<li>zk版本: 3.6.2</li>
<li>SpringBoot: 2.2.1.RELEASE</li>
</ul>
<h3> 2. 简单的分布式锁</h3>
<p>第一步，都是实例创建</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在我们的这个设计中，我们需要持有当前节点和监听前一个节点的变更，所以我们在ZkLock实例中，添加两个成员</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来就是尝试获取锁的逻辑</p>
<ul>
<li>current不存在，在表示没有创建过，就创建一个临时顺序节点，并赋值current</li>
<li>current存在，则表示之前已经创建过了，目前处于等待锁释放过程</li>
<li>接下来根据当前节点顺序是否最小，来表明是否持有锁成功</li>
<li>当顺序不是最小时，找前面那个节点，并赋值 pre；</li>
<li>监听pre的变化</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>请注意上面的实现，这里并没有去监听前一个节点的变更，在设计<code>tryLock</code>，因为是立马返回成功or失败，所以使用这个接口的，不需要注册监听</p>
<p>我们的监听逻辑，放在 <code>lock()</code> 同步阻塞里面</p>
<ul>
<li>尝试抢占锁，成功则直接返回</li>
<li>拿锁失败，则监听前一个节点的删除事件</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>注意：</strong></p>
<ul>
<li>当节点不存在时，或者事件触发回调之后，重新调用<code>lock()</code>，表明我胡汉三又来竞争锁了？</li>
</ul>
<p>为啥不是直接返回 true? 而是需要重新竞争呢？</p>
<ul>
<li>因为前面节点的删除，有可能是因为前面节点的会话中断导致的；但是锁还在另外的实例手中，这个时候我应该做的是重新排队</li>
</ul>
<p>最后别忘了释放锁</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>到此，我们的分布式锁就完成了，接下来我们复盘下实现过程</p>
<ul>
<li>所有知识点来自前一篇的zk基础使用（创建节点，删除节点，获取所有自己点，监听事件）</li>
<li>抢锁过程 =》 创建序号最小的节点</li>
<li>若节点不是最小的，那么就监听前面的节点删除事件</li>
</ul>
<p>这个实现，支持了锁的重入（why? 因为锁未释放时，我们保存了current，当前节点存在时则直接判断是不是最小的；而不是重新创建）</p>
<h3> 3. 测试</h3>
<p>最后写一个测试case，来看下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果如下</p>
<figure><img src="/imgs/210415/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> II. 其他</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>项目源码：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/411-zookeeper-distributelock" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/411-zookeeper-distributelock</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/210415/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>Zookeeper</title>
      <link>https://liuyueyi.github.io/tutorial/spring/middle/ZooKeeper/</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/middle/ZooKeeper/</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">Zookeeper</source>
      <description>SpringBoot整合Zookeeper，并通过zk实现分布式锁来实战演示zk在应用中的想象空间</description>
      <pubDate>Fri, 10 Feb 2023 04:50:05 GMT</pubDate>
      <content:encoded><![CDATA[<p>SpringBoot整合Zookeeper，并通过zk实现分布式锁来实战演示zk在应用中的想象空间</p>
]]></content:encoded>
    </item>
    <item>
      <title>1.springboot + rabbitmq初体验</title>
      <link>https://liuyueyi.github.io/tutorial/spring/mq/RabbitMq/200210-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B9%8BRabbitMq%E5%88%9D%E4%BD%93%E9%AA%8C.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/mq/RabbitMq/200210-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B9%8BRabbitMq%E5%88%9D%E4%BD%93%E9%AA%8C.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">1.springboot + rabbitmq初体验</source>
      <description>mq在异步解耦削峰的优势非常突出，现在很多的项目都会用到，掌握mq的知识点，了解如何顺畅的使用mq，可以说是一个必备的职业技能点了 接下来我们进入rabbitmq的学习过程</description>
      <category>SpringBoot</category>
      <category>MQ系列</category>
      <category>RabbitMq</category>
      <pubDate>Mon, 10 Feb 2020 16:04:48 GMT</pubDate>
      <content:encoded><![CDATA[<p>mq在异步解耦削峰的优势非常突出，现在很多的项目都会用到，掌握mq的知识点，了解如何顺畅的使用mq，可以说是一个必备的职业技能点了</p>
<p>接下来我们进入rabbitmq的学习过程</p>
<!-- more -->
<h2> I. 环境准备</h2>
<p>在测试之前，需要安装rabbitmq，下面分别给出mac + centos的安装教程</p>
<h3> 1. mac 安装</h3>
<p>安装命令</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>启动控制台之前需要先开启插件</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>进入控制台: <code>http://localhost:15672/</code></p>
<p>用户名和密码：<code>guest,guest</code></p>
<h3> 2. centos 安装</h3>
<p>安装命令</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>插件开启</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. 配置</h3>
<p>添加账号，设置权限</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4. 项目环境</h3>
<p>接下我们创建一个SpringBoot项目，用于简单的体验一下rabbitmq的发布和消费消息</p>
<ul>
<li>springboot版本为<code>2.2.1.RELEASE</code></li>
<li>rabbitmq 版本为 <code>3.7.5</code></li>
</ul>
<p>依赖配置文件pom.xml</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在<code>application.yml</code>配置文件中，添加rabbitmq的相关属性</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> II. 实例演示</h2>
<p>接下来我们看一个<code>hello world</code>版本的rabbitmq的使用姿势，一个简单发布消息、消费消息</p>
<h3> 1. 发布消息</h3>
<p>消息发布，我们主要借助<code>AmqpTemplate</code>来实现</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的case中，主要方法在于<code>amqpTemplate#convertAndSend</code>，第一个参数为exchangeName, 第二个为routingKey</p>
<p>常量配置如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 消费消息</h3>
<p>消费消息，需要指定Queue，通过routingKey绑定exchange，如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. 测试demo</h3>
<p>写一个简单的rest接口，用于接收参数，发布消息到mq，并被<code>ConsumerDemo</code>消费</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/200210/00.gif" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> II. 其他</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码: <a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/300-rabbitmq" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/300-rabbitmq</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/200210/00.gif" type="image/gif"/>
    </item>
    <item>
      <title>2.RabbitMq核心知识点小结</title>
      <link>https://liuyueyi.github.io/tutorial/spring/mq/RabbitMq/200212-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B9%8BRabbitMq%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%E5%B0%8F%E7%BB%93.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/mq/RabbitMq/200212-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B9%8BRabbitMq%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%E5%B0%8F%E7%BB%93.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">2.RabbitMq核心知识点小结</source>
      <description>RabbitMQ是一个基于AMQP协议实现的企业级消息系统，想要顺畅的玩耍的前提是得先了解它，本文将主要介绍rabbitmq的一些基本知识点 特点 基本概念 消息投递消费的几种姿势 事务 集群</description>
      <category>SpringBoot</category>
      <category>MQ系列</category>
      <category>RabbitMq</category>
      <pubDate>Wed, 12 Feb 2020 16:58:31 GMT</pubDate>
      <content:encoded><![CDATA[<p>RabbitMQ是一个基于AMQP协议实现的企业级消息系统，想要顺畅的玩耍的前提是得先了解它，本文将主要介绍rabbitmq的一些基本知识点</p>
<ul>
<li>特点</li>
<li>基本概念</li>
<li>消息投递消费的几种姿势</li>
<li>事务</li>
<li>集群</li>
</ul>
<!-- more -->
<h2> I. 基本知识点</h2>
<p>它是采用Erlang语言实现的AMQP(Advanced Message Queued Protocol)的消息中间件，最初起源于金融系统，用在分布式系统存储转发消息，目前广泛应用于各类系统用于解耦、削峰</p>
<h3> 1.特点</h3>
<p>首先得了解一下rabbitmq的特点，看看是否满足我们的系统需求（毕竟学习一个框架也是要不少时间的）</p>
<blockquote>
<p>以下内容来自: <a href="https://blog.csdn.net/weixin_40792878/article/details/82555791" target="_blank" rel="noopener noreferrer">MQ和RabbitMQ作用特点</a></p>
</blockquote>
<p>主要特点，大致可以归纳为以下几个</p>
<ul>
<li>可靠性：通过支持消息持久化，支持事务，支持消费和传输的ack等来确保可靠性</li>
<li>路由机制：支持主流的订阅消费模式，如广播，订阅，headers匹配等</li>
<li>扩展性：多个RabbitMQ节点可以组成一个集群，也可以根据实际业务情况动态地扩展集群中节点。</li>
<li>高可用性：队列可以在集群中的机器上设置镜像，使得在部分节点出现问题的情况下队仍然可用。</li>
<li>多种协议：RabbitMQ除了原生支持AMQP协议，还支持STOMP，MQTT等多种消息中间件协议。</li>
<li>多语言客户端：RabbitMQ几乎支持所有常用语言，比如Jav a、Python、Ruby、PHP、C#、JavaScript等。</li>
<li>管理界面：RabbitMQ提供了一个易用的用户界面，使得用户可以监控和管理消息、集群中的节点等。</li>
<li>插件机制：RabbitMQ提供了许多插件，以实现从多方面进行扩展，当然也可以编写自己的插件。</li>
</ul>
<h3> 2. 基本概念</h3>
<p>下图为rabbitmq的内部结构图</p>
<figure><img src="/imgs/200212/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>从上图也可以发现几个基本概念（Message, Publisher, Exchange, Binding, Queue, Channel, Consuer, Virtual host）</p>
<p>下面逐一进行说明</p>
<h4> a. Message</h4>
<p>具体的消息，包含消息头（即附属的配置信息）和消息体（即消息的实体内容）</p>
<p>由发布者，将消息推送到Exchange，由消费者从Queue中获取</p>
<h4> b. Publisher</h4>
<p>消息生产者，负责将消息发布到交换器(Exchange)</p>
<h4> c. Exchange</h4>
<p>交换器，用来接收生产者发送的消息并将这些消息路由给服务器中的队列</p>
<h4> d. Binding</h4>
<p>绑定，用于给Exchange和Queue建立关系，从而决定将这个交换器中的哪些消息，发送到对应的Queue</p>
<h4> e. Queue</h4>
<p>消息队列，用来保存消息直到发送给消费者</p>
<p>它是消息的容器，也是消息的终点</p>
<p>一个消息可投入一个或多个队列</p>
<p>消息一直在队列里面，等待消费者连接到这个队列将其取走</p>
<h4> f. Connection</h4>
<p>连接，内部持有一些channel，用于和queue打交道</p>
<h4> g. Channel</h4>
<p>信道（通道），MQ与外部打交道都是通过Channel来的，发布消息、订阅队列还是接收消息，这些动作都是通过Channel完成；</p>
<p>简单来说就是消息通过Channel塞进队列或者流出队列</p>
<h4> h. Consumer</h4>
<p>消费者，从消息队列中获取消息的主体</p>
<h4> i. Virtual Host</h4>
<p>虚拟主机，表示一批交换器、消息队列和相关对象。</p>
<p>虚拟主机是共享相同的身份认证和加密环境的独立服务器域。</p>
<p>每个 vhost 本质上就是一个 mini 版的 RabbitMQ 服务器，拥有自己的队列、交换器、绑定和权限机制。</p>
<p>vhost 是 AMQP 概念的基础，必须在连接时指定，RabbitMQ 默认的 vhost 是 /</p>
<p><strong>可以理解为db中的数据库的概念，用于逻辑拆分</strong></p>
<h4> j. Broker</h4>
<p>消息队列服务器实体</p>
<h3> 3. 消息投递消费</h3>
<p>从前面的内部结构图可以知晓，消息由生产者发布到Exchange，然后通过路由规则，分发到绑定queue上，供消费者获取消息</p>
<p>接下来我们看一下Exchange支持的四种策略</p>
<h4> a. Direct策略</h4>
<figure><img src="/imgs/200212/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>消息中的路由键（routing key）如果和 Binding 中的 binding key 一致， 交换器就将消息发到对应的队列中</p>
<p>简单来讲，就是<code>rounting key</code>与<code>binding key</code>完全匹配</p>
<ul>
<li>如果一个队列绑定到交换机要求路由键为<code>dog</code></li>
<li>只转发<code>routing key</code> 标记为<code>dog</code>的消息，</li>
<li>不会转发<code>dog.puppy</code>，也不会转发“dog.guard”等等</li>
<li>它是完全匹配、单播的模式</li>
</ul>
<p>举例说明</p>
<figure><img src="/imgs/200212/02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>Exchange和两个队列绑定在一起：</p>
<ul>
<li>Q1的bindingkey是orange</li>
<li>Q2的binding key是black和green.</li>
<li>当Producer 发布一个消息，其<code>routing key</code>是<code>orange</code>时, exchange会把它放到Q1上, 如果是<code>black</code>或<code>green</code>就会到Q2上, 其余的Message被丢弃</li>
</ul>
<p><strong>注意</strong></p>
<ul>
<li>当有多个队列绑定到同一个Exchange，且binding key相同时，这时消息会分发给所有满足条件的队列</li>
</ul>
<h4> b. Topic策略</h4>
<figure><img src="/imgs/200212/03.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>这个策略可以看成是Direct策略的升级版，通过<code>routing key</code>与 <code>bingding key</code>的模式匹配方式来分发消息</p>
<p>简单来讲，直接策略是完全精确匹配，而topic则支持正则匹配，满足某类指定规则的（如以xxx开头的路由键），可以将消息分发过去</p>
<ul>
<li><code>#</code> 匹配0个或多个单词</li>
<li><code>*</code> 匹配不多不少一个单词</li>
</ul>
<p><strong>一个更直观的实例如下</strong></p>
<figure><img src="/imgs/200212/04.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>Producer发送消息时需要设置routing_key,</p>
<ul>
<li>Q1 的binding key 是<code>*.orange.*</code></li>
<li>Q2 是 <code>*.*.rabbit</code> 和 <code>lazy.#</code>：</li>
<li>发布一个<code>routing key</code>为<code>test.orange.mm</code> 消息，则会路由到Q1；
<ul>
<li><strong>注意：</strong> 如果是<code>routng key</code>是 <code>test.orange</code>则无法路由到Q1，</li>
<li>因为Q1的规则是三个单词，中间一个为orange，不满足这个规则的都无效</li>
</ul>
</li>
<li>发布一个<code>routing key</code>为<code>test.qq.rabbit</code>或者<code>lazy.qq</code>的消息 都可以分发到Q2；即路由key为三个单词，最后一个为rabbit或者不限制单词个数，主要第一个是lazy的消息，都可以分发过来</li>
<li>如果发布的是一个<code>test.orange.rabbit</code>消息，则Q1和Q2都可以满足
<ul>
<li><strong>注意：</strong> 这时两个队列都会接受到这个消息</li>
</ul>
</li>
</ul>
<h4> c. Fanout策略</h4>
<figure><img src="/imgs/200212/05.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>广播策略，忽略<code>routing key</code> 和 <code>binding key</code>，将消息分发给所有绑定在这个exchange上的queue</p>
<h4> d. Headers策略</h4>
<p>这个实际上用得不多，它是根据Message的一些头部信息来分发过滤Message，忽略routing key的属性，如果Header信息和message消息的头信息相匹配</p>
<h2> II. 消息一致性问题</h2>
<p>在进入rabbitmq如何保证一致性之前，我们先得理解，什么是消息一致性？</p>
<h3> 1. 一致性问题</h3>
<blockquote>
<p><a href="https://www.php.cn/faq/415782.html" target="_blank" rel="noopener noreferrer">数据的一致性是什么</a></p>
</blockquote>
<p><strong>按照我个人的粗浅理解，我认为的消息一致性，应该包含下面几个</strong></p>
<ul>
<li>生产者，确保消息发布成功
<ul>
<li>消息不会丢</li>
<li>顺序不会乱</li>
<li>消息不会重复（如重传，导致发布一次，却出现多个消息）</li>
</ul>
</li>
<li>消费者，确保消息消费成功
<ul>
<li>有序消费</li>
<li>不重复消费</li>
</ul>
</li>
</ul>
<p><strong>发送端</strong></p>
<p>为了确保发布者推送的消息不会丢失，我们需要消息持久化</p>
<ul>
<li>broker持久化消息</li>
</ul>
<p>为了确定消息正确接收</p>
<ul>
<li>publisher 需要知道消息投递并成功持久化</li>
</ul>
<h3> 2. 持久化</h3>
<p>这里的持久化，主要是指将内存中的消息保存到磁盘，避免mq宕机导致的内存中消息丢失；然而单纯的持久化，只是保证一致性的其中一个要素，比如publisher将消息发送到exchange，在broker持久化的工程中，宕机了导致持久化失败，而publisher并不知道持久化失败，这个时候就会出现数据丢失，为了解决这个问题，rabbitmq提供了事务机制</p>
<h3> 3. 事务机制</h3>
<p>事务机制能够解决生产者与broker之间消息确认的问题，只有消息成功被broker接受，事务才能提交成功，否则就进行事务回滚操作并进行消息重发。但是使用事务机制会降低RabbitMQ的消息吞吐量，不适用于需要发布大量消息的业务场景。</p>
<p><strong>注意，事务是同步的</strong></p>
<h3> 4. 消息确认机制</h3>
<blockquote>
<p><a href="https://blog.csdn.net/anumbrella/article/details/81321701" target="_blank" rel="noopener noreferrer">RabbitMQ学习(六)——消息确认机制(Confirm模式)</a></p>
</blockquote>
<p>消息确认机制，可以区分为生产端和消费端</p>
<p><strong>生产端</strong></p>
<ul>
<li>生产者将信道设置成Confirm模式，一旦信道进入Confirm模式，所有在该信道上面发布的消息都会被指派一个唯一的ID(以confirm.select为基础从1开始计数)，</li>
<li>一旦消息被投递到所有匹配的队列之后，Broker就会发送一个确认给生产者（包含消息的唯一ID）,这就使得生产者知道消息已经正确到达目的队列了，</li>
<li>如果消息和队列是可持久化的，那么确认消息会将消息写入磁盘之后发出，</li>
<li>Broker回传给生产者的确认消息中deliver-tag域包含了确认消息的序列号（此外Broker也可以设置basic.ack的multiple域，表示到这个序列号之前的所有消息都已经得到了处理）</li>
</ul>
<p>Confirm模式属性异步，publisher发布一条消息之后，在等信道返回确认的同时，依然可以继续发送下一条消息，所以小概率会出现投递的消息顺序和broker中持久化消息顺序不一致的问题</p>
<p>一般从编程角度出发，Confirm模式有三种姿势</p>
<ul>
<li>普通Confirm模式：发送一条消息之后，等到服务器confirm，然后再发布下一条消息（串行发布）</li>
<li>批量Confirm模式：发送一批消息之后，等到服务器confirm，然后再发布下一批消息（如果失败，这一批消息全部重复，所以会有重复问题）</li>
<li>异步Confirm模式：提供一个回调方法，服务器confirm之后，触发回调方法，因此不会阻塞下一条消息的发送</li>
</ul>
<p><strong>消费端</strong></p>
<p>ACK机制是消费者从RabbitMQ收到消息并处理完成后，反馈给RabbitMQ，RabbitMQ收到反馈后才将此消息从队列中删除。</p>
<ul>
<li>如果一个消费者在处理消息出现了网络不稳定、服务器异常等现象，那么就不会有ACK反馈，RabbitMQ会认为这个消息没有正常消费，会将消息重新放入队列中</li>
<li>如果在集群的情况下，RabbitMQ会立即将这个消息推送给这个在线的其他消费者。这种机制保证了在消费者服务端故障的时候，不丢失任何消息和任务</li>
<li>消息永远不会从RabbitMQ中删除，只有当消费者正确发送ACK反馈，RabbitMQ确认收到后，消息才会从RabbitMQ服务器的数据中删除</li>
</ul>
<h2> III. 集群</h2>
<p>按照目前的发展趋势，一个不支持集群的中间件基本上是不会有市场的；rabbitmq也是支持集群的，下面简单的介绍一下常见的4种集群架构模式</p>
<blockquote>
<p>以下内容来自网上博文，详情请点击右边：<a href="https://www.jianshu.com/p/b7cc32b94d2a" target="_blank" rel="noopener noreferrer">RabbitMQ 的4种集群架构</a></p>
</blockquote>
<h3> 1. 主备模式</h3>
<p>这个属于常见的集群模式了，但又不太一样</p>
<p>主节点提供读写，备用节点不提供读写。如果主节点挂了，就切换到备用节点，原来的备用节点升级为主节点提供读写服务，当原来的主节点恢复运行后，原来的主节点就变成备用节点</p>
<h3> 2. 远程模式</h3>
<p>远程模式可以实现双活的一种模式，简称 shovel 模式，所谓的 shovel 就是把消息进行不同数据中心的复制工作，可以跨地域的让两个 MQ 集群互联，远距离通信和复制。</p>
<ul>
<li>Shovel 就是我们可以把消息进行数据中心的复制工作，我们可以跨地域的让两个 MQ 集群互联。</li>
</ul>
<figure><img src="/imgs/200212/06.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>如上图，有两个异地的 MQ 集群（可以是更多的集群），当用户在地区 1 这里下单了，系统发消息到 1 区的 MQ 服务器，发现 MQ 服务已超过设定的阈值，负载过高，这条消息就会被转到 地区 2 的 MQ 服务器上，由 2 区的去执行后面的业务逻辑，相当于分摊我们的服务压力。</p>
<h3> 3. 镜像模式</h3>
<p>非常经典的 mirror 镜像模式，保证 100% 数据不丢失。在实际工作中也是用得最多的，并且实现非常的简单，一般互联网大厂都会构建这种镜像集群模式。</p>
<figure><img src="/imgs/200212/07.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>如上图，用 KeepAlived 做了 HA-Proxy 的高可用，然后有 3 个节点的 MQ 服务，消息发送到主节点上，主节点通过 mirror 队列把数据同步到其他的 MQ 节点，这样来实现其高可靠</p>
<h3> 4. 多活模式</h3>
<p>也是实现异地数据复制的主流模式，因为 shovel 模式配置比较复杂，所以一般来说，实现异地集群的都是采用这种双活 或者 多活模型来实现的。这种模式需要依赖 rabbitMQ 的 federation 插件，可以实现持续的，可靠的 AMQP 数据通信，多活模式在实际配置与应用非常的简单</p>
<p>rabbitMQ 部署架构采用双中心模式(多中心)，那么在两套(或多套)数据中心各部署一套 rabbitMQ 集群，各中心的rabbitMQ 服务除了需要为业务提供正常的消息服务外，中心之间还需要实现部分队列消息共享。</p>
<figure><img src="/imgs/200212/08.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>federation 插件是一个不需要构建 cluster ，而在 brokers 之间传输消息的高性能插件，federation 插件可以在 brokers 或者 cluster 之间传输消息，连接的双方可以使用不同的 users 和 virtual hosts，双方也可以使用不同版本的 rabbitMQ 和 erlang。federation 插件使用 AMQP 协议通信，可以接受不连续的传输。federation 不是建立在集群上的，而是建立在单个节点上的，如图上黄色的 rabbit node 3 可以与绿色的 node1、node2、node3 中的任意一个利用 federation 插件进行数据同步。</p>
<h2> IV. 其他</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
</ul>
<h3> 1. 相关博文</h3>
<ul>
<li><a href="https://www.rabbitmq.com/getstarted.html" target="_blank" rel="noopener noreferrer">RabbitMQ Tutorials</a></li>
<li><a href="https://blog.csdn.net/weixin_40792878/article/details/82555791" target="_blank" rel="noopener noreferrer">MQ和RabbitMQ作用特点</a></li>
<li><a href="https://blog.hhui.top/hexblog/2018/05/27/RabbitMQ%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/" target="_blank" rel="noopener noreferrer">RabbitMq基础教程之基本概念</a></li>
<li><a href="https://blog.csdn.net/anumbrella/article/details/81321701" target="_blank" rel="noopener noreferrer">RabbitMQ学习(六)——消息确认机制(Confirm模式)</a></li>
<li><a href="https://www.jianshu.com/p/b7cc32b94d2a" target="_blank" rel="noopener noreferrer">RabbitMQ 的4种集群架构</a></li>
<li><a href="http://www.voidcn.com/article/p-fdbmgrcd-brm.html" target="_blank" rel="noopener noreferrer">Rabbitmq是如何来保证事务的</a></li>
<li><a href="http://www.liaoqiqi.com/post/215" target="_blank" rel="noopener noreferrer">rabbitmq消息一致性问题</a></li>
<li></li>
</ul>
<h3> 2. 一灰灰Blog</h3>
<p>尽信书则不如，以上内容，纯属一家之言，因个人能力有限，难免有疏漏和错误之处，如发现bug或者有更好的建议，欢迎批评指正，不吝感激</p>
<p>下面一灰灰的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛</p>
<ul>
<li>一灰灰Blog个人博客 <a href="https://blog.hhui.top" target="_blank" rel="noopener noreferrer">https://blog.hhui.top</a></li>
<li>一灰灰Blog-Spring专题博客 <a href="http://spring.hhui.top" target="_blank" rel="noopener noreferrer">http://spring.hhui.top</a></li>
</ul>
<figure><img src="https://spring.hhui.top/spring-blog/imgs/info/info.png" alt="一灰灰blog" tabindex="0" loading="lazy"><figcaption>一灰灰blog</figcaption></figure>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/200212/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>3.发送消息基本使用姿势</title>
      <link>https://liuyueyi.github.io/tutorial/spring/mq/RabbitMq/200218-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B9%8BRabbitMq%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/mq/RabbitMq/200218-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B9%8BRabbitMq%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">3.发送消息基本使用姿势</source>
      <description>前面两篇博文，分别介绍了RabbitMq的核心知识点，以及整合SpringBoot的demo应用；接下来也该进入正题，看一下SpringBoot的环境下，如何玩转rabbitmq 本篇内容主要为消息发送，包括以下几点 RabbitTemplate 发送消息的基本使用姿势 自定义消息基本属性 自定义消息转换器AbstractMessageConverter 发送Object类型消息失败的case</description>
      <category>SpringBoot</category>
      <category>MQ系列</category>
      <category>RabbitMq</category>
      <pubDate>Tue, 18 Feb 2020 11:11:57 GMT</pubDate>
      <content:encoded><![CDATA[<p>前面两篇博文，分别介绍了RabbitMq的核心知识点，以及整合SpringBoot的demo应用；接下来也该进入正题，看一下SpringBoot的环境下，如何玩转rabbitmq</p>
<p>本篇内容主要为消息发送，包括以下几点</p>
<ul>
<li><code>RabbitTemplate</code> 发送消息的基本使用姿势</li>
<li>自定义消息基本属性</li>
<li>自定义消息转换器<code>AbstractMessageConverter</code></li>
<li>发送Object类型消息失败的case</li>
</ul>
<!-- more -->
<h2> I. 基本使用姿势</h2>
<h3> 1. 配置</h3>
<p>我们借助<code>SpringBoot 2.2.1.RELEASE</code> + <code>rabbitmq 3.7.5</code>来完整项目搭建与测试</p>
<p>项目pom.xml如下</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>配置文件<code>application.yml</code>内容如下</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 配置类</h3>
<p>通过前面rabbitmq的知识点学习，我们可以知道发送端的主要逻辑 “将消息发送给exchange，然后根据不同的策略分发给对应的queue”</p>
<p>本篇博文主要讨论的是消息发送，为了后续的实例演示，我们定义一个topic模式的exchange，并绑定一个的queue；（因为对发送端而言，不同的exchange类型，对发送端的使用姿势影响并不大，有影响的是消费者）</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. 消息发送</h3>
<p>消息发送，主要借助的是<code>RabbitTemplate#convertAndSend</code>方法来实现，通常情况下，我们直接使用即可</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的核心点就一行<code>rabbitTemplate.convertAndSend(MqConstants.exchange, MqConstants.routing, msg);</code></p>
<ul>
<li>表示将msg发送给指定的exchange，并设置消息的路由键</li>
</ul>
<p><strong>请注意</strong></p>
<p>通过上面的方式，发送的消息默认是持久化的，当持久化的消息，分发到持久化的队列时，会有消息的落盘操作；</p>
<p>在某些场景下，我们对消息的完整性要求并没有那么严格，反而更在意mq的性能，丢失一些数据也可以接受；这个时候我们可能需要定制一下发送的消息属性（比如将消息设置为非持久化的）</p>
<p>下面提供两种姿势，推荐第二种</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/200218/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p><strong>注意</strong></p>
<ul>
<li>在实际的项目开发中，推荐使用<code>MessagePostProcessor</code>来定制消息属性</li>
<li>其次不推荐在每次发送消息时都创建一个<code>MessagePostProcessor</code>对象，请定义一个通用的对象，能复用就复用</li>
</ul>
<h3> 4. 非序列化对象发送异常case</h3>
<p>通过查看<code>rabbitTemplate#convertAndSend</code>的接口定义，我们知道发送的消息可以是Object类型，那么是不是意味着任何对象，都可以推送给mq呢？</p>
<p>下面是一个测试case</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当我们调用上面的<code>publish2mq4</code>方法时，并不会是想象中的直接成功，相反抛出一个参数类型异常</p>
<figure><img src="/imgs/200218/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>为什么会出现这个问题呢？从堆栈分析，我们知道RabbitTemplate默认是利用<code>SimpleMessageConverter</code>来实现封装Message逻辑的，核心代码为</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面逻辑很明确的指出了，<strong>只接受byte数组，string字符串，可序列化对象（这里使用的是jdk的序列化方式来实现对象和byte数组之间的互转）</strong></p>
<ul>
<li>所以我们传递一个非序列化的对象会参数非法的异常</li>
</ul>
<p>自然而然的，我们会想有没有其他的<code>MessageConverter</code>来友好的支持任何类型的对象</p>
<h3> 5. 自定义MessageConverter</h3>
<p>接下来我们希望通过自定义一个json序列化方式的MessageConverter来解决上面的问题</p>
<p>一个比较简单的实现（利用FastJson来实现序列化/反序列化）</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>重新定义一个<code>rabbitTemplate</code>，并设置它的消息转换器为自定义的<code>SelfConverter</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后再次测试一下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>mq内接收到的推送消息如下</p>
<figure><img src="/imgs/200218/02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 6. Jackson2JsonMessageConverter</h3>
<p>上面虽然实现了Json格式的消息转换，但是比较简陋；而且这么基础通用的功能，按照Spring全家桶的一贯作风，肯定是有现成可用的，没错，这就是<code>Jackson2JsonMessageConverter</code></p>
<p>所以我们的使用姿势也可以如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>下面是通过Jackson序列化消息后的内容，与我们自定义的有一些不同，多了<code>headers</code>和<code>content_encoding</code></p>
<figure><img src="/imgs/200218/03.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 7. 小结</h3>
<p>本篇博文主要的知识点如下</p>
<ul>
<li>通过<code>RabbitTemplate#convertAndSend</code>来实现消息分发</li>
<li>通过<code>MessagePostProcessor</code>来自定义消息的属性（请注意默认投递的消息时持久化的）</li>
<li>默认的消息封装类为<code>SimpleMessageConverter</code>，只支持分发byte数组，字符串和可序列化的对象；不满足上面三个条件的方法调用会抛异常</li>
<li>我们可以通过实现<code>MessageConverter</code>接口，来定义自己的消息封装类，解决上面的问题</li>
</ul>
<p>在RabbitMq的知识点博文中，明确提到了，为了确保消息被brocker正确接收，提供了消息确认机制和事务机制两种case，那么如果需要使用这两种方式，消息生产者需要怎么做呢？</p>
<p>限于篇幅，下一篇博文将带来在消息确认机制/事务机制下的发送消息使用姿势</p>
<h2> II. 其他</h2>
<h3> 0. 系列博文&amp;项目源码</h3>
<p><strong>系列博文</strong></p>
<ul>
<li><a href="http://spring.hhui.top/spring-blog/2020/02/10/200210-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B9%8BRabbitMq%E5%88%9D%E4%BD%93%E9%AA%8C/" target="_blank" rel="noopener noreferrer">【MQ系列】springboot + rabbitmq初体验</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2020/02/12/200212-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B9%8BRabbitMq%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%E5%B0%8F%E7%BB%93/" target="_blank" rel="noopener noreferrer">【MQ系列】RabbitMq核心知识点小结</a></li>
</ul>
<p><strong>项目源码</strong></p>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/301-rabbitmq-publish" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/301-rabbitmq-publish</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/200218/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>4.消息确认机制/事务的使用姿势</title>
      <link>https://liuyueyi.github.io/tutorial/spring/mq/RabbitMq/200219-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B9%8BRabbitMq%E6%B6%88%E6%81%AF%E7%A1%AE%E8%AE%A4%E6%9C%BA%E5%88%B6-%E4%BA%8B%E5%8A%A1%E7%9A%84%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/mq/RabbitMq/200219-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B9%8BRabbitMq%E6%B6%88%E6%81%AF%E7%A1%AE%E8%AE%A4%E6%9C%BA%E5%88%B6-%E4%BA%8B%E5%8A%A1%E7%9A%84%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">4.消息确认机制/事务的使用姿势</source>
      <description>上一篇介绍了RabbitMq借助RabbitTemplate来发送消息的基本使用姿势，我们知道RabbitMq提供了两种机制，来确保发送端的消息被brocke正确接收，本文将主要介绍，在消息确认和事物两种机制的场景下，发送消息的使用姿势</description>
      <category>SpringBoot</category>
      <category>MQ系列</category>
      <category>RabbitMq</category>
      <pubDate>Wed, 19 Feb 2020 11:30:53 GMT</pubDate>
      <content:encoded><![CDATA[<p>上一篇介绍了RabbitMq借助RabbitTemplate来发送消息的基本使用姿势，我们知道RabbitMq提供了两种机制，来确保发送端的消息被brocke正确接收，本文将主要介绍，在消息确认和事物两种机制的场景下，发送消息的使用姿势</p>
<!-- more -->
<h2> I. 配置</h2>
<p>首先创建一个SpringBoot项目，用于后续的演示</p>
<ul>
<li>springboot版本为<code>2.2.1.RELEASE</code></li>
<li>rabbitmq 版本为 <code>3.7.5</code> （安装教程可参考: <a href="http://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484522&amp;idx=1&amp;sn=411fad078902200314d594b932fbdf35" target="_blank" rel="noopener noreferrer">【MQ系列】springboot + rabbitmq初体验</a>）</li>
</ul>
<p>依赖配置文件pom.xml</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在<code>application.yml</code>配置文件中，添加rabbitmq的相关属性</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> II. 消息确认机制</h2>
<p>本节来看一下消息确认机制的使用姿势，首先有必要了解一下什么是消息确认机制</p>
<h3> 1. 定义</h3>
<blockquote>
<p>简单来讲就是消息发送之后，需要接收到RabbitMq的正确反馈，然后才能判断消息是否正确发送成功；</p>
</blockquote>
<p>一般来说，RabbitMq的业务逻辑包括以下几点</p>
<ul>
<li>生产者将信道设置成Confirm模式，一旦信道进入Confirm模式，所有在该信道上面发布的消息都会被指派一个唯一的ID(以confirm.select为基础从1开始计数)</li>
<li>一旦消息被投递到所有匹配的队列之后，Broker就会发送一个确认给生产者（包含消息的唯一ID）,这就使得生产者知道消息已经正确到达目的队列了</li>
<li>如果消息和队列是可持久化的，那么确认消息会将消息写入磁盘之后发出</li>
<li>Broker回传给生产者的确认消息中deliver-tag域包含了确认消息的序列号（此外Broker也可以设置basic.ack的multiple域，表示到这个序列号之前的所有消息都已经得到了处理）</li>
</ul>
<h3> 2. 基本使用case</h3>
<p>从上面的解释，可以知道发送消息端，需要先将信道设置为Confirm模式，<code>RabbitProperties</code>配置类中，有个属性，正好是用来设置的这个参数的，所以我们可以直接在配置文件<code>application.yml</code>中，添加下面的配置</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面配置完毕之后，直接使用RabbitTemplate发送消息，表示已经支持Confirm模式了，但实际的使用，会有一点点区别，我们需要接收mq返回的消息，发送失败的回调（以实现重试逻辑等），所以一个典型的发送端代码可以如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>请注意上面的实现，首先需要给RabbitTemplate设置回调，这两个不可或缺</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. 手动配置方式</h3>
<p>上面利用的是标准的SpringBoot配置，一般来说是适用于绝大多数的场景的；当不能覆盖的时候，还可以通过手动的方式来定义一个特定的RabbitTemplate（比如一个项目中，只有某一个场景的消息发送需要确认机制，其他的默认即可，所以需要区分RabbitTemplate）</p>
<p>在自动配置类中，可以手动的注册一个RabbitTemplate的bean，来专职消息确认模式的发送</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>至于使用姿势，和前面完全一致，只是将<code>rabbitTemplate</code>换成<code>ackRabbitTemplate</code></p>
<h2> III. 事务机制</h2>
<p>消息确认机制属于异步模式，也就是说一个消息发送完毕之后，不待返回，就可以发送另外一条消息；这里就会有一个问题，publisher先后发送msg1, msg2，但是对RabbitMq而言，接收的顺序可能是msg2, msg1；所以消息的顺序可能会不一致</p>
<p>所以有了更加严格的事务机制，它属于同步模式，发送消息之后，等到接收到确认返回之后，才能发送下一条消息</p>
<h3> 1. 事务使用方式</h3>
<p>首先我们定义一个事务管理器</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>事务机制的使用姿势，看起来和上面的消息确认差不多，无非是需要添加一个<code>@Transactional</code>注解罢了</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>请注意，核心代码设置信道为事务模式必不可少</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2> IV. 测试</h2>
<p>我们这里主要测试一下事务和消息确认机制的性能对比吧，从定义上来看消息确认机制效率更高，我们简单的对比一下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>去掉无关的输出，仅保留耗时，对比如下（差距还是很明显的）</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> V. 其他</h2>
<p><strong>系列博文</strong></p>
<ul>
<li><a href="http://spring.hhui.top/spring-blog/2020/02/10/200210-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B9%8BRabbitMq%E5%88%9D%E4%BD%93%E9%AA%8C/" target="_blank" rel="noopener noreferrer">【MQ系列】springboot + rabbitmq初体验</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2020/02/12/200212-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B9%8BRabbitMq%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%E5%B0%8F%E7%BB%93/" target="_blank" rel="noopener noreferrer">【MQ系列】RabbitMq核心知识点小结</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2020/02/18/200218-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B9%8BRabbitMq%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF/" target="_blank" rel="noopener noreferrer">【MQ系列】SprigBoot + RabbitMq发送消息基本使用姿势</a></li>
</ul>
<p><strong>项目源码</strong></p>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/301-rabbitmq-publish" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/301-rabbitmq-publish</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>5.RabbitListener消费基本使用姿势</title>
      <link>https://liuyueyi.github.io/tutorial/spring/mq/RabbitMq/200318-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B9%8BRabbitListener%E6%B6%88%E8%B4%B9%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF%E4%BB%8B%E7%BB%8D.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/mq/RabbitMq/200318-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B9%8BRabbitListener%E6%B6%88%E8%B4%B9%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF%E4%BB%8B%E7%BB%8D.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">5.RabbitListener消费基本使用姿势</source>
      <description>之前介绍了rabbitmq的消息发送姿势，既然有发送，当然就得有消费者，在SpringBoot环境下，消费可以说比较简单了，借助@RabbitListener注解，基本上可以满足你90%以上的业务开发需求 下面我们来看一下@RabbitListener的最最常用使用姿势</description>
      <category>SpringBoot</category>
      <category>MQ系列</category>
      <category>RabbitMq</category>
      <pubDate>Wed, 18 Mar 2020 19:58:38 GMT</pubDate>
      <content:encoded><![CDATA[<p>之前介绍了rabbitmq的消息发送姿势，既然有发送，当然就得有消费者，在SpringBoot环境下，消费可以说比较简单了，借助<code>@RabbitListener</code>注解，基本上可以满足你90%以上的业务开发需求</p>
<p>下面我们来看一下<code>@RabbitListener</code>的最最常用使用姿势</p>
<!-- more -->
<h2> I. 配置</h2>
<p>首先创建一个SpringBoot项目，用于后续的演示</p>
<ul>
<li>springboot版本为<code>2.2.1.RELEASE</code></li>
<li>rabbitmq 版本为 <code>3.7.5</code> （安装教程可参考: <a href="http://spring.hhui.top/spring-blog/2020/02/10/200210-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B9%8BRabbitMq%E5%88%9D%E4%BD%93%E9%AA%8C/" target="_blank" rel="noopener noreferrer">【MQ系列】springboot + rabbitmq初体验</a>)</li>
</ul>
<p>依赖配置文件pom.xml</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在<code>application.yml</code>配置文件中，添加rabbitmq的相关属性</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> II. 消费姿势</h2>
<p>本文将目标放在实用性上，将结合具体的场景来演示<code>@RabbitListener</code>的使用姿势，因此当你发现看完本文之后这个注解里面有些属性还是不懂，请不要着急，下一篇会一一道来</p>
<h3> 0. mock数据</h3>
<p>消费消费，没有数据，怎么消费呢？所以我们第一步，先创建一个消息生产者，可以往exchange写数据，供后续的消费者测试使用</p>
<p>本篇的消费主要以topic模式来进行说明（其他的几个模式使用差别不大，如果有需求的话，后续补齐）</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>提供一个简单rest接口，可以指定往哪个exchange推送数据，并制定路由键</p>
<h3> 1. case1: exchange, queue已存在</h3>
<p>对于消费者而言其实是不需要管理exchange的创建/销毁的，它是由发送者定义的；一般来讲，消费者更关注的是自己的queue，包括定义queue并与exchange绑定，而这一套过程是可以直接通过rabbitmq的控制台操作的哦</p>
<figure><img src="/imgs/200318/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>所以实际开发过程中，exchange和queue以及对应的绑定关系已经存在的可能性是很高的，并不需要再代码中额外处理；</p>
<p>在这种场景下，消费数据，可以说非常非常简单了，如下：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>直接指定注解中的<code>queues</code>参数即可，参数值为对列名(queueName)</p>
<h3> 2. case2: queue不存在</h3>
<p>当queue的autoDelete属性为false时，上面的使用场景还是比较合适了；但是，当这个属性为true时，没有消费者队列就会自动删除了，这个时候再用上面的姿势，可能会得到下面的异常</p>
<figure><img src="/imgs/200318/01.jpg" alt="队列不存在" tabindex="0" loading="lazy"><figcaption>队列不存在</figcaption></figure>
<p>通常这种场景下，是需要我们来主动创建Queue，并建立与Exchange的绑定关系，下面给出<code>@RabbitListener</code>的推荐使用姿势</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>一个注解，内部声明了队列，并建立绑定关系，就是这么神奇！！！</p>
<p>注意<code>@QueueBinding</code>注解的三个属性：</p>
<ul>
<li>value: @Queue注解，用于声明队列，value为queueName, durable表示队列是否持久化, autoDelete表示没有消费者之后队列是否自动删除</li>
<li>exchange: @Exchange注解，用于声明exchange， type指定消息投递策略，我们这里用的topic方式</li>
<li>key: 在topic方式下，这个就是我们熟知的 routingKey</li>
</ul>
<p>以上，就是在队列不存在时的使用姿势，看起来也不复杂</p>
<h3> 3. case3: ack</h3>
<p>在前面rabbitmq的核心知识点学习过程中，会知道为了保证数据的一致性，有一个消息确认机制；</p>
<p>我们这里的ack主要是针对消费端而言，当我们希望更改默认ack方式(noack, auto, manual)，可以如下处理</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的实现也比较简单，设置<code>ackMode=MANUAL</code>，手动ack</p>
<p>但是，请注意我们的实现中，没有任何一个地方体现了手动ack，这就相当于一致都没有ack，在后面的测试中，可以看出这种不ack时，会发现数据一直在<code>unacked</code>这一栏，当Unacked数量超过限制的时候，就不会再消费新的数据了</p>
<h3> 4. case4: manual ack</h3>
<p>上面虽然选择ack方式，但是还缺一步ack的逻辑，接下来我们看一下如何补齐</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>请注意，方法多了两个参数</p>
<ul>
<li><code>deliveryTag</code>: 相当于消息的唯一标识，用于mq辨别是哪个消息被ack/nak了</li>
<li><code>channel</code>: mq和consumer之间的管道，通过它来ack/nak</li>
</ul>
<p>当我们正确消费时，通过调用 <code>basicAck</code> 方法即可</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>当我们消费失败，需要将消息重新塞入队列，等待重新消费时，可以使用 <code>basicNack</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3> 5. case5: 并发消费</h3>
<p>当消息很多，一个消费者吭哧吭哧的消费太慢，但是我的机器性能又杠杠的，这个时候我就希望并行消费，相当于同时有多个消费者来处理数据</p>
<p>要支持并行消费，如下设置即可</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/200318/02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>请注意注解中的<code>concurrency = "4"</code>属性，表示固定4个消费者；</p>
<p>除了上面这种赋值方式之外，还有一种 <code>m-n</code> 的格式，表示m个并行消费者，最多可以有n个</p>
<p>（额外说明：这个参数的解释实在<code>SimpleMessageListenerContainer</code>的场景下的，下一篇文章会介绍它与<code>DirectMessageListenerContainer</code>的区别）</p>
<h3> 6. 测试</h3>
<p>通过前面预留的消息发送接口，我们在浏览器中请求: <code>http://localhost:8080/publish?exchange=topic.e&amp;routing=r&amp;data=wahaha</code></p>
<figure><img src="/imgs/200318/03.jpg" alt="消费" tabindex="0" loading="lazy"><figcaption>消费</figcaption></figure>
<p>然后看一下输出，五个消费者都接收到了，特别是主动nak的那个消费者，一直在接收到消息；</p>
<p>（因为一直打印日志，所以重启一下应用，开始下一个测试）</p>
<p>然后再发送一条成功的消息，验证下手动真确ack，是否还会出现上面的情况，请求命令: <code>http://localhost:8080/publish?exchange=topic.e&amp;routing=r&amp;data=successMsg</code></p>
<figure><img src="/imgs/200318/04.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>然后再关注一下，没有ack的那个队列，一直有一个unack的消息</p>
<figure><img src="/imgs/200318/05.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> II. 其他</h2>
<p><strong>系列博文</strong></p>
<ul>
<li><a href="http://spring.hhui.top/spring-blog/2020/02/10/200210-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B9%8BRabbitMq%E5%88%9D%E4%BD%93%E9%AA%8C/" target="_blank" rel="noopener noreferrer">【MQ系列】springboot + rabbitmq初体验</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2020/02/12/200212-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B9%8BRabbitMq%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%E5%B0%8F%E7%BB%93/" target="_blank" rel="noopener noreferrer">【MQ系列】RabbitMq核心知识点小结</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2020/02/18/200218-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B9%8BRabbitMq%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF/" target="_blank" rel="noopener noreferrer">【MQ系列】SprigBoot + RabbitMq发送消息基本使用姿势</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2020/02/19/200219-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B9%8BRabbitMq%E6%B6%88%E6%81%AF%E7%A1%AE%E8%AE%A4%E6%9C%BA%E5%88%B6-%E4%BA%8B%E5%8A%A1%E7%9A%84%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF/" target="_blank" rel="noopener noreferrer">【MQ系列】RabbitMq消息确认/事务机制的使用姿势</a></li>
</ul>
<p><strong>项目源码</strong></p>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/302-rabbitmq-consumer" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/302-rabbitmq-consumer</a></li>
</ul>
<h3> 1. <a href="https://liuyueyi.github.io/hexblog" target="_blank" rel="noopener noreferrer">一灰灰Blog</a>： <a href="https://liuyueyi.github.io/hexblog" target="_blank" rel="noopener noreferrer">https://liuyueyi.github.io/hexblog</a></h3>
<p>一灰灰的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛</p>
<h3> 2. 声明</h3>
<p>尽信书则不如，以上内容，纯属一家之言，因个人能力有限，难免有疏漏和错误之处，如发现bug或者有更好的建议，欢迎批评指正，不吝感激</p>
<ul>
<li>微博地址: <a href="https://weibo.com/p/1005052169825577/home" target="_blank" rel="noopener noreferrer">小灰灰Blog</a></li>
<li>QQ： 一灰灰/3302797840</li>
</ul>
<h3> 3. 扫描关注</h3>
<p><strong>一灰灰blog</strong></p>
<figure><img src="https://spring.hhui.top/spring-blog/imgs/info/info.png" alt="QrCode" tabindex="0" loading="lazy"><figcaption>QrCode</figcaption></figure>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/200318/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>RabbitMQ</title>
      <link>https://liuyueyi.github.io/tutorial/spring/mq/RabbitMq/</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/mq/RabbitMq/</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">RabbitMQ</source>
      <description>消息队列RabbitMQ的基础 &amp;amp; 进阶教程，系列文章教你在生产中使用消息队列的各种姿势</description>
      <pubDate>Fri, 10 Feb 2023 04:50:05 GMT</pubDate>
      <content:encoded><![CDATA[<p>消息队列RabbitMQ的基础 &amp; 进阶教程，系列文章教你在生产中使用消息队列的各种姿势</p>
]]></content:encoded>
    </item>
    <item>
      <title>1.ES基本项目搭建</title>
      <link>https://liuyueyi.github.io/tutorial/spring/search/ElasticSearch/01.220328-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8BES%E5%9F%BA%E6%9C%AC%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/search/ElasticSearch/01.220328-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8BES%E5%9F%BA%E6%9C%AC%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">1.ES基本项目搭建</source>
      <description>之前一直没有写ES相关的博文，现在开始补课，预计5-6篇博文将es的使用姿势展示给各位小伙伴；本文将作为es结合springboot的第一篇博文，基本项目环境搭建</description>
      <category>SpringBoot</category>
      <category>搜索系列</category>
      <category>ElasticSearch</category>
      <pubDate>Mon, 28 Mar 2022 19:04:24 GMT</pubDate>
      <content:encoded><![CDATA[<p>之前一直没有写ES相关的博文，现在开始补课，预计5-6篇博文将es的使用姿势展示给各位小伙伴；本文将作为es结合springboot的第一篇博文，基本项目环境搭建</p>
<!-- more -->
<h2> I. 项目搭建</h2>
<h3> 1. 项目依赖</h3>
<p>本项目借助<code>SpringBoot 2.2.1.RELEASE</code> + <code>maven 3.5.3</code> + <code>IDEA</code>进行开发</p>
<p>开一个web服务用于测试</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 配置信息</h3>
<p>配置文件application.yml，注意下面的配置信息，下面采用的是由我们自己来解析配置的方式</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>说明</strong></p>
<p>上面配置介绍的是一种偏基础的es文档操作姿势，相比较于封装得更好的<code>spring-boot-starter-data-elasticsearch</code>，使用更加灵活</p>
<h2> II. SpringBoot结合ES使用</h2>
<h3> 1. RestHighLevelClient 初始化</h3>
<p>接下来我们基于<code>RestHighLevelClient</code>来操作es，首先第一步就是需要初始化这实例</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意上面的实现，用户名 + 密码并没有使用，当es设置了用户名、密码之后，是通过每次请求时，在请求头基于Basic Auth方式进行身份验证的；后面会介绍到</p>
<h3> 2. 基本使用</h3>
<p>我们在本机搭建了一个es用于模拟测试，在上面的配置完之后，就可以直接与es进行交互了</p>
<blockquote>
<p>es安装可以参考：</p>
<ul>
<li><a href="https://blog.hhui.top/hexblog/2020/06/05/200605-Centos-%E5%AE%89%E8%A3%85ElasticSearch/" target="_blank" rel="noopener noreferrer">200605-Centos 安装ElasticSearch - 一灰灰Blog</a></li>
<li><a href="https://blog.hhui.top/hexblog/2021/03/29/210329-Elastic-Kibana%E5%AE%89%E8%A3%85%E4%B8%8E%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/" target="_blank" rel="noopener noreferrer">210329-Elastic &amp; Kibana安装与基本使用 - 一灰灰Blog</a>
docker安装： <code>docker pull docker.elastic.co/elasticsearch/elasticsearch:xxx</code></li>
</ul>
</blockquote>
<p>下面是一个简单的使用姿势</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意上面的实现，有下面几个重要知识点</p>
<p><strong>身份验证</strong></p>
<p>采用Basic Auth方式进行身份校验，简单来说就是在请求头中添加一个</p>
<ul>
<li><code>key = Authorization</code></li>
<li><code>value = "Basic " + base64(user + ":" + pwd)</code></li>
</ul>
<p><strong>访问姿势</strong></p>
<p>上面是一个根据<code>id</code>查询文档的实例，简单可以理解为三步</p>
<ul>
<li>创建：<code>XxRequest</code></li>
<li>添加请求头：<code>RequestOptions.Builder.addHeader</code></li>
<li>执行: <code>client.get(xxRequest, RequestOptions)</code></li>
</ul>
<h2> III. 不能错过的源码和相关知识点</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/142-search-es" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/142-search-es</a></li>
</ul>
<h3> 1. 微信公众号: 一灰灰Blog</h3>
<p>尽信书则不如，以上内容，纯属一家之言，因个人能力有限，难免有疏漏和错误之处，如发现bug或者有更好的建议，欢迎批评指正，不吝感激</p>
<p>下面一灰灰的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛</p>
<ul>
<li>一灰灰Blog个人博客 <a href="https://blog.hhui.top" target="_blank" rel="noopener noreferrer">https://blog.hhui.top</a></li>
<li>一灰灰Blog-Spring专题博客 <a href="http://spring.hhui.top" target="_blank" rel="noopener noreferrer">http://spring.hhui.top</a></li>
</ul>
<figure><img src="https://spring.hhui.top/spring-blog/imgs/info/info.png" alt="一灰灰blog" tabindex="0" loading="lazy"><figcaption>一灰灰blog</figcaption></figure>
]]></content:encoded>
      <enclosure url="https://spring.hhui.top/spring-blog/imgs/info/info.png" type="image/png"/>
    </item>
    <item>
      <title>2.ES文档基本操作CURD实例演示</title>
      <link>https://liuyueyi.github.io/tutorial/spring/search/ElasticSearch/02.220331-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8BES%E6%96%87%E6%A1%A3%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9CCURD%E5%AE%9E%E4%BE%8B%E6%BC%94%E7%A4%BA.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/search/ElasticSearch/02.220331-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8BES%E6%96%87%E6%A1%A3%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9CCURD%E5%AE%9E%E4%BE%8B%E6%BC%94%E7%A4%BA.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">2.ES文档基本操作CURD实例演示</source>
      <description>本文将作为es系列第二篇，在前文项目搭建的基础上，先来看一下es的基本操作姿势，如何实现CURD</description>
      <category>SpringBoot</category>
      <category>搜索系列</category>
      <category>ElasticSearch</category>
      <pubDate>Thu, 31 Mar 2022 19:27:54 GMT</pubDate>
      <content:encoded><![CDATA[<p>本文将作为es系列第二篇，在前文项目搭建的基础上，先来看一下es的基本操作姿势，如何实现CURD</p>
<!-- more -->
<h2> I. 项目搭建</h2>
<h3> 1. 项目依赖</h3>
<p>本项目借助<code>SpringBoot 2.2.1.RELEASE</code> + <code>maven 3.5.3</code> + <code>IDEA</code>进行开发</p>
<p>开一个web服务用于测试</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 配置信息</h3>
<p>配置文件application.yml，注意下面的配置信息，下面采用的是由我们自己来解析配置的方式</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> II. CURD实例</h2>
<h3> 1. 配置</h3>
<p>注意，本文介绍的es是添加了权限验证，因此我们在于es进行交互时，需要在请求头中携带验证信息，注意下面的实现姿势</p>
<p>读取配置，初始化RestHighLevelClient，和前文介绍的差不多</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 添加数据</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>添加数据，注意是利用 <code>IndexRequest</code> 来构建请求对象，添加文档时有几个注意事项</p>
<ul>
<li><code>request.source()</code> : 具体需要上传的文档，就是通过它挂上去的，我们这里采用的是json方式</li>
<li><code>request.id()</code>: 如果上传的文档需要指定id，则可以使用它；若未指定，则表明自动生成id</li>
</ul>
<p>发起请求: <code>client.index()</code></p>
<h3> 3. 查询数据</h3>
<p>这里先介绍一个基础的根据id进行查询的实例case，更多的查询姿势后面会详细介绍</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. 增量更新数据</h3>
<p>根据主键进行更新文档，如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>注意</strong></p>
<ul>
<li>上面的实现属于增量更新策略</li>
<li>即：新传的文档，若key之前已经存在，则覆盖更新；若之前不存在，则插入；之前文档中未被覆盖的数据依然保留</li>
</ul>
<h3> 4. 全量更新</h3>
<p>另外一个根据条件进行更新的使用case如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 5. 删除数据</h3>
<p>直接根据id进行删除</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 6. 条件删除数据</h3>
<p>根据条件进行匹配删除</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 7. 测试case</h3>
<p>写一个测试demo，将上面的case都跑一遍</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> III. 不能错过的源码和相关知识点</h2>
<h3> 0. 项目</h3>
<p><strong>系列博文</strong></p>
<ul>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247487412&amp;idx=1&amp;sn=9d8afecd4dc4dcc2a016a89709a4cf34&amp;chksm=fce71418cb909d0e59e4599a4460642614104c3d254b691165f0f3630f198458073e908714a3&amp;token=1796894300&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">SpringBoot系列之ES基本项目搭建</a></li>
</ul>
<p><strong>源码</strong></p>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/142-search-es" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/142-search-es</a></li>
</ul>
<h3> 1. 微信公众号: 一灰灰Blog</h3>
<p>尽信书则不如，以上内容，纯属一家之言，因个人能力有限，难免有疏漏和错误之处，如发现bug或者有更好的建议，欢迎批评指正，不吝感激</p>
<p>下面一灰灰的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛</p>
<ul>
<li>一灰灰Blog个人博客 <a href="https://blog.hhui.top" target="_blank" rel="noopener noreferrer">https://blog.hhui.top</a></li>
<li>一灰灰Blog-Spring专题博客 <a href="http://spring.hhui.top" target="_blank" rel="noopener noreferrer">http://spring.hhui.top</a></li>
</ul>
<figure><img src="https://spring.hhui.top/spring-blog/imgs/info/info.png" alt="一灰灰blog" tabindex="0" loading="lazy"><figcaption>一灰灰blog</figcaption></figure>
]]></content:encoded>
      <enclosure url="https://spring.hhui.top/spring-blog/imgs/info/info.png" type="image/png"/>
    </item>
    <item>
      <title>3.ES查询常用实例演示</title>
      <link>https://liuyueyi.github.io/tutorial/spring/search/ElasticSearch/03.220418-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8BES%E6%9F%A5%E8%AF%A2%E7%9A%84%E5%B8%B8%E7%94%A8%E5%AE%9E%E4%BE%8B%E6%BC%94%E7%A4%BA.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/search/ElasticSearch/03.220418-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8BES%E6%9F%A5%E8%AF%A2%E7%9A%84%E5%B8%B8%E7%94%A8%E5%AE%9E%E4%BE%8B%E6%BC%94%E7%A4%BA.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">3.ES查询常用实例演示</source>
      <description>本文将作为es系列第三篇，结合常见的实例，来演示下如何通过RestHighLevelClient来实现es的各种查询支持</description>
      <category>SpringBoot</category>
      <category>搜索系列</category>
      <category>ElasticSearch</category>
      <pubDate>Mon, 18 Apr 2022 19:43:19 GMT</pubDate>
      <content:encoded><![CDATA[<p>本文将作为es系列第三篇，结合常见的实例，来演示下如何通过<code>RestHighLevelClient</code>来实现es的各种查询支持</p>
<!-- more -->
<h2> I. 项目搭建</h2>
<h3> 1. 项目依赖</h3>
<p>本项目借助<code>SpringBoot 2.2.1.RELEASE</code> + <code>maven 3.5.3</code> + <code>IDEA</code>进行开发</p>
<p>开一个web服务用于测试</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 配置信息</h3>
<p>配置文件application.yml，注意下面的配置信息，下面采用的是由我们自己来解析配置的方式</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> II. 实例演示</h2>
<h3> 0. 准备</h3>
<p>在开始之前，先准备插入几条数据，这里会借助上一篇CURD博文中的插入接口</p>
<blockquote>
<ul>
<li><a href="https://spring.hhui.top/spring-blog/2022/03/31/220331-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8BES%E6%96%87%E6%A1%A3%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9CCURD%E5%AE%9E%E4%BE%8B%E6%BC%94%E7%A4%BA/" target="_blank" rel="noopener noreferrer">【搜索系列】ES文档基本操作CURD实例演示 | 一灰灰Blog</a></li>
</ul>
</blockquote>
<p>在开始之前就准备两条数据</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1. 全量查询</h3>
<p>即查询所有的文档，如借助kibanan的控制台，发起的请求形如</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>于此对应的java实现如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意上面的实现：</p>
<ul>
<li>初始化<code>SearchRequest</code>实例，用于构建请求相关数据</li>
<li><code>SearchSourceBuilder</code> 来填充查询条件</li>
<li><code>client.search(searchRequest, requestOptions)</code> 执行查询请求，第二个参数为请求参数，这里主要是设置请求时的权限验证信息</li>
</ul>
<p>通常来说，实际的业务场景中，不太可能出现上面这种没有任何限制的查全量数据，即便真的有查全量数据的case，更常见的是分页查询，如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 根据Field值精确查询</h3>
<p>即es中常说的term查询，具体实现如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从上面的实现也可以看出，查询的套路没啥区别，无非就是<code>SearchSourceBuilder</code>中的参数构造不一样；上面主要通过</p>
<ul>
<li><code>QueryBuilders.termQuery("site", "blog.hhui.top")</code> 来构建 term的查询条件，表明查询 <code>site=blog.hhui.top</code> 的文档</li>
</ul>
<p><strong>中文查询不到问题</strong></p>
<p>在我们实际使用过程中，如果value为中文，在查询时，可能会遇到命名有对应的数据，但是就查不到，主要原因就在于分词，如对于中文的查询，可以考虑下面这种方式</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. Field值in查询</h3>
<p>另外一个常见的就是多值查询，也就是我们常说的 <code>field in (val1, val2...)</code>，这个对应的就是es中的<code>terms</code>查询</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4. 范围查询</h3>
<p>对于数值类型的Field，同样是支持比较、范围查询的，对应的是es中 <code>range</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意上面的查询有条件</p>
<ul>
<li><code>QueryBuilders.rangeQuery("age").gt(8).lt(12)</code></li>
<li>表示查询 <code>age &gt; 8 &amp;&amp; age &lt; 12</code></li>
<li>gte: 表示 &gt;=</li>
<li>lte: 表示 &lt;=</li>
</ul>
<h3> 5. Field是否存在查询</h3>
<p>es不同于mysql的在于它的field可以动态新增，当我们希望查询包含某个字段的文档时，可以考虑 <code>exists</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 6. 模糊查询</h3>
<p>es作为搜索引擎，更常见的是模糊匹配，比如match查询</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>多Field中进行查询</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在es的语法支持中，除了match，还有一个<code>wildcard</code>，可以使用<code>?</code>来代指单字符，<code>*</code>来代指0..n字符</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 7. 正则匹配</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 8. 前缀查询</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 9.小结</h3>
<p>本文虽然介绍了一些常见的查询case，但注意并不仅仅只有这些，比如</p>
<ul>
<li>查询指定Feild的内容</li>
<li>排序</li>
<li>分组聚合</li>
<li>多查询条件组合：and/or</li>
<li>高亮</li>
<li>...</li>
</ul>
<p>更多的使用实例，敬请期待...，欢迎感兴趣的小伙伴，点赞收藏评论一波😝</p>
<h2> III. 不能错过的源码和相关知识点</h2>
<h3> 0. 项目</h3>
<p><strong>系列博文</strong></p>
<ul>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247487412&amp;idx=1&amp;sn=9d8afecd4dc4dcc2a016a89709a4cf34&amp;chksm=fce71418cb909d0e59e4599a4460642614104c3d254b691165f0f3630f198458073e908714a3&amp;token=1796894300&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">SpringBoot系列之ES基本项目搭建</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247487420&amp;idx=1&amp;sn=3d64361be03a95631e1c50f6d84ab5f3&amp;chksm=fce71410cb909d069d43a59541933284b231a694620d31b8ba46065bd43c15c049e2b2c1bdb1&amp;token=623887797&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">SpringBoot之ES文档基本操作CURD实例演示</a></li>
</ul>
<p><strong>源码</strong></p>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/142-search-es" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/142-search-es</a></li>
</ul>
<h3> 1. 微信公众号: 一灰灰Blog</h3>
<p>尽信书则不如，以上内容，纯属一家之言，因个人能力有限，难免有疏漏和错误之处，如发现bug或者有更好的建议，欢迎批评指正，不吝感激</p>
<p>下面一灰灰的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛</p>
<ul>
<li>一灰灰Blog个人博客 <a href="https://blog.hhui.top" target="_blank" rel="noopener noreferrer">https://blog.hhui.top</a></li>
<li>一灰灰Blog-Spring专题博客 <a href="http://spring.hhui.top" target="_blank" rel="noopener noreferrer">http://spring.hhui.top</a></li>
</ul>
<figure><img src="https://spring.hhui.top/spring-blog/imgs/info/info.png" alt="一灰灰blog" tabindex="0" loading="lazy"><figcaption>一灰灰blog</figcaption></figure>
]]></content:encoded>
      <enclosure url="https://spring.hhui.top/spring-blog/imgs/info/info.png" type="image/png"/>
    </item>
    <item>
      <title>ElasticSearch</title>
      <link>https://liuyueyi.github.io/tutorial/spring/search/ElasticSearch/</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/search/ElasticSearch/</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">ElasticSearch</source>
      <description>SpringBoot整合ElasticSearch，支撑搜索全业务场景</description>
      <pubDate>Fri, 10 Feb 2023 04:50:05 GMT</pubDate>
      <content:encoded><![CDATA[<p>SpringBoot整合ElasticSearch，支撑搜索全业务场景</p>
]]></content:encoded>
    </item>
    <item>
      <title>1.环境搭建与简单测试</title>
      <link>https://liuyueyi.github.io/tutorial/spring/search/Solr/01.190510-SpringBoot%E9%AB%98%E7%BA%A7%E7%AF%87%E6%90%9C%E7%B4%A2%E4%B9%8BSolr%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E7%AE%80%E5%8D%95%E6%B5%8B%E8%AF%95.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/search/Solr/01.190510-SpringBoot%E9%AB%98%E7%BA%A7%E7%AF%87%E6%90%9C%E7%B4%A2%E4%B9%8BSolr%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E7%AE%80%E5%8D%95%E6%B5%8B%E8%AF%95.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">1.环境搭建与简单测试</source>
      <description>搜索可以说是非常常见的场景了，一般选择比较多的有solr和es，底层都是基于Lucene搜索引擎实现。之前简单的使用过solr，一直没有成体系的学习过，正好需要给一个内部项目封装统一的查询组件，借这个机会好好的撸一把solr的知识要点</description>
      <category>SpringBoot</category>
      <category>搜索系列</category>
      <category>Solr</category>
      <pubDate>Fri, 10 May 2019 20:10:41 GMT</pubDate>
      <content:encoded><![CDATA[<p>搜索可以说是非常常见的场景了，一般选择比较多的有solr和es，底层都是基于Lucene搜索引擎实现。之前简单的使用过solr，一直没有成体系的学习过，正好需要给一个内部项目封装统一的查询组件，借这个机会好好的撸一把solr的知识要点</p>
<!-- more -->
<h2> I. Solr环境搭建</h2>
<h3> 1. docker方式安装solr</h3>
<p>使用docker实现solr环境的搭建，快速简洁</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>启动solr容器</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>浏览器打开: <a href="http://localhost:8983/solr/#/" target="_blank" rel="noopener noreferrer">http://localhost:8983/solr/#/</a></p>
<p><strong>新建core</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>建立成功之后，终端会有相应的提示，然后刷新浏览器，可以看到新的yhh</p>
<figure><img src="/imgs/190510/00.jpg" alt="控制台" tabindex="0" loading="lazy"><figcaption>控制台</figcaption></figure>
<h3> 2. schema</h3>
<p>通过docker安装的最新solr版本为8.0，可以直接在http界面通过控制台来创建schema，而不需要像以前那样，进入配置文件进行添加处理；当然也可以通过修改对应的配置</p>
<p>假定我们现在需要在yhh这个core中存文章，结构为</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> a. 控制台添加方式</h4>
<p>首先进入schema的页面，可以如下操作，也可以点击连接: <a href="http://localhost:8983/solr/#/yhh/schema" target="_blank" rel="noopener noreferrer">http://localhost:8983/solr/#/yhh/schema</a></p>
<figure><img src="/imgs/190510/01.jpg" alt="1" tabindex="0" loading="lazy"><figcaption>1</figcaption></figure>
<p>然后通过点击Add Field按钮添加字段，确认按钮之后完成添加</p>
<figure><img src="/imgs/190510/02.jpg" alt="2" tabindex="0" loading="lazy"><figcaption>2</figcaption></figure>
<p>添加完成之后点击<code>please select...</code>，弹出下拉框，看到刚才添加的东西</p>
<figure><img src="/imgs/190510/03.jpg" alt="3" tabindex="0" loading="lazy"><figcaption>3</figcaption></figure>
<h4> b. 编辑xml文件方式</h4>
<p>通过控制台的overiew可以定位到core存储路径，然后我们找到对应的定义文件，添加两个字段</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>修改配置文件</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>修改完成之后如下图</p>
<figure><img src="/imgs/190510/04.jpg" alt="xml" tabindex="0" loading="lazy"><figcaption>xml</figcaption></figure>
<p>配置文件修改之后，再去刷控制台，发现并没有显示出来，通过重启solr之后，新的才显示出来</p>
<figure><img src="/imgs/190510/05.jpg" alt="show" tabindex="0" loading="lazy"><figcaption>show</figcaption></figure>
<h4> c. 功能测试</h4>
<p>schema定义完毕之后，就可以进行简单的测试了，先加几个文档；然后再进行查询</p>
<p><strong>添加文档</strong></p>
<p>直接在控制台进行添加: <a href="http://localhost:8983/solr/#/yhh/documents" target="_blank" rel="noopener noreferrer">http://localhost:8983/solr/#/yhh/documents</a></p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/190510/06.jpg" alt="添加文档" tabindex="0" loading="lazy"><figcaption>添加文档</figcaption></figure>
<p><strong>文档查询</strong></p>
<p>直接在控制台进行操作：<a href="http://localhost:8983/solr/#/yhh/query" target="_blank" rel="noopener noreferrer">http://localhost:8983/solr/#/yhh/query</a></p>
<figure><img src="/imgs/190510/07.jpg" alt="文档查询" tabindex="0" loading="lazy"><figcaption>文档查询</figcaption></figure>
<p>然后来个高级一点的查询，我希望查询所有内容包含一灰灰的数据，可以如下查询</p>
<figure><img src="/imgs/190510/08.jpg" alt="文档查询" tabindex="0" loading="lazy"><figcaption>文档查询</figcaption></figure>
<h2> II. SpringBoot搭建solr环境</h2>
<h3> 1. 配置</h3>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的配置中，需要注意是引入包 <code>spring-boot-starter-data-solr</code></p>
<p>引入这个包之后，我们就可以愉快的使用<code>SolrTemplate</code>来完成solr的各种骚操作了</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 简单测试</h3>
<p>下面搞一个简单的查询，看下能不能获取到solr文档</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. 测试</h3>
<p>启动下任务开始测试</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>执行截图如下</p>
<figure><img src="/imgs/190510/09.jpg" alt="测试输出" tabindex="0" loading="lazy"><figcaption>测试输出</figcaption></figure>
<h2> III. 小结</h2>
<p>上面介绍了最基础的solr环境搭建，springboot的solr测试环境准备，并实现了一个简单的查询实例，但距离真正上手撸solr还缺不少东西</p>
<ul>
<li>solr的基础知识，前面的字段定义是否合法，索引什么的改怎么考虑</li>
<li>配置修改，安全保证</li>
<li>中文分词如何设置，如何使用在solr中进行使用</li>
<li>solr的增删改查的基本操作姿势</li>
<li>solr的全文搜索优势如何体现</li>
<li>SpringBoot中进行solr操作</li>
<li>...</li>
</ul>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>项目： <a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/140-search-solr" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/140-search-solr</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/190510/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>2.文档新增与修改使用姿势</title>
      <link>https://liuyueyi.github.io/tutorial/spring/search/Solr/02.190526-SpringBoot%E9%AB%98%E7%BA%A7%E7%AF%87%E6%90%9C%E7%B4%A2Solr%E4%B9%8B%E6%96%87%E6%A1%A3%E6%96%B0%E5%A2%9E%E4%B8%8E%E4%BF%AE%E6%94%B9%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/search/Solr/02.190526-SpringBoot%E9%AB%98%E7%BA%A7%E7%AF%87%E6%90%9C%E7%B4%A2Solr%E4%B9%8B%E6%96%87%E6%A1%A3%E6%96%B0%E5%A2%9E%E4%B8%8E%E4%BF%AE%E6%94%B9%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">2.文档新增与修改使用姿势</source>
      <description>大多涉及到数据的处理，无非CURD四种操作，对于搜索SOLR而言，基本操作也可以说就这么几种，在实际应用中，搜索条件的多样性才是重点，我们在进入复杂的搜索之前，先来看一下如何新增和修改文档</description>
      <category>SpringBoot</category>
      <category>搜索系列</category>
      <category>Solr</category>
      <pubDate>Sun, 26 May 2019 20:36:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>大多涉及到数据的处理，无非CURD四种操作，对于搜索SOLR而言，基本操作也可以说就这么几种，在实际应用中，搜索条件的多样性才是重点，我们在进入复杂的搜索之前，先来看一下如何新增和修改文档</p>
<!-- more -->
<h2> I. 环境准备</h2>
<p>solr的基础环境需要准备好，如果对这一块有疑问的童鞋，可以参考下上一篇博文: 《<a href="http://spring.hhui.top/spring-blog/2019/05/10/190510-SpringBoot%E9%AB%98%E7%BA%A7%E7%AF%87%E6%90%9C%E7%B4%A2%E4%B9%8BSolr%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E7%AE%80%E5%8D%95%E6%B5%8B%E8%AF%95/" target="_blank" rel="noopener noreferrer">190510-SpringBoot高级篇搜索之Solr环境搭建与简单测试</a>》</p>
<h3> 1. 环境配置</h3>
<p>在pom文件中，设置好对应的依赖</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>因为我们采用默认的solr访问姿势，所以配置文件中可以不加对应的参数，当然也可以加上</p>
<p>打开 <code>application.yml</code> 配置文件</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果我们的solr加上了用户名密码访问条件，参数中并没有地方设置username和password，那应该怎么办?</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如上写法，将用户名和密码写入http的连接中</p>
<h3> 2. 自动装配</h3>
<p>我们主要使用SolrTemplate来和Solr打交到，因此我们需要先注册这个bean，可以怎么办？</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的配置是条件注入，只有当SolrTemplate对应的bean没有被自动加载时，才会加载，为什么要怎么干？</p>
<p>（可以想一想原因...）</p>
<h2> II. 使用姿势示例</h2>
<p>我们的操作主要依赖的是SolrTemplate，因此有必要在开始之前，看一下它的签名</p>
<p>Spring的源码中，可以发现大多<code>xxxTemplate</code>都会实现一个<code>xxxOperations</code> 接口，而这个接口就是用来定义CURD的api，比如我们看下 <code>SolrOperations</code>中与修改相关的api</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的api签名中，比较明确的说明了这个 <code>saveXXX</code> 既可以用来新增文档，也可以用来修改文档，主要有提供了两类</p>
<ul>
<li>单个与批量</li>
<li>saveDocument 与 saveBean</li>
</ul>
<h3> 1. 添加文档</h3>
<p>从上面的api签名上看，<code>saveDocument</code> 应该是相对原始的操作方式了，因此我们先看下它的使用姿势</p>
<h4> a. saveDocument</h4>
<p>首先就是创建文档 <code>SolrInputDocument</code> 对象，通过调用<code>addField</code>来设置成员值</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> b. saveBean</h4>
<p>前面需要创建<code>SolrInputDocument</code>对象，我们更希望的使用case是直接传入一个POJO，然后自动与solr的filed进行关联</p>
<p>因此一种使用方式可以如下</p>
<ul>
<li>定义pojo，成员上通过 @Field 注解来关联solr的field</li>
<li>pojo对象直接当做参数传入，保存之后，执行 commit 提交</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> c. 批量</h4>
<p>批量的方式就比较简单了，传入集合即可</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> d. 测试</h4>
<p>上面的几个方法，我们执行之后，我们看下是否能查询到新增加的数据</p>
<figure><img src="/imgs/190526/00.jpg" alt="output" tabindex="0" loading="lazy"><figcaption>output</figcaption></figure>
<h3> 2. 文档修改</h3>
<p>在看前面的接口签名时，就知道修改和新增用的是相同的api，所以修改文档和上面的使用实际上也没有什么特别的，下面简单的演示一下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的实例中，修改了id为5的文档标题，并删除了content内容，执行完毕之后，结果如何呢？</p>
<figure><img src="/imgs/190526/01.jpg" alt="output" tabindex="0" loading="lazy"><figcaption>output</figcaption></figure>
<ul>
<li>title被替换</li>
<li>content没有了</li>
</ul>
<p><strong>到这里就有个疑问了，对于调用而言，怎么保证是修改还是新增呢？</strong></p>
<ul>
<li>这里主要是根据id来判断，这个id类似db中的唯一主键，当我们没有指定id时，会随机生成一个id</li>
<li>如果存在相同的id，则修改文档；如果不存在，则新增文档</li>
</ul>
<h2> III. 其他</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">spring-boot-demo</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/190526/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>3.Solr文档删除</title>
      <link>https://liuyueyi.github.io/tutorial/spring/search/Solr/03.200114-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8BSolr%E4%B9%8B%E6%96%87%E6%A1%A3%E5%88%A0%E9%99%A4.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/search/Solr/03.200114-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8BSolr%E4%B9%8B%E6%96%87%E6%A1%A3%E5%88%A0%E9%99%A4.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">3.Solr文档删除</source>
      <description>之前的搜索教程开了个头就没有继续了，现在重新捡回来，至少也把CURD的基本操作姿势补全了；本篇主要介绍如何删除数据</description>
      <category>SpringBoot</category>
      <category>搜索系列</category>
      <category>Solr</category>
      <pubDate>Tue, 14 Jan 2020 16:16:57 GMT</pubDate>
      <content:encoded><![CDATA[<p>之前的搜索教程开了个头就没有继续了，现在重新捡回来，至少也把CURD的基本操作姿势补全了；本篇主要介绍如何删除数据</p>
<!-- more -->
<h2> I. 配置</h2>
<p>在介绍demo之前，需要先安装solr环境，搭建SpringBoot项目工程，具体的环境搭建过程不细说，推荐参考文档</p>
<ul>
<li><a href="http://spring.hhui.top/spring-blog/2019/05/10/190510-SpringBoot%E9%AB%98%E7%BA%A7%E7%AF%87%E6%90%9C%E7%B4%A2%E4%B9%8BSolr%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E7%AE%80%E5%8D%95%E6%B5%8B%E8%AF%95/" target="_blank" rel="noopener noreferrer">190510-SpringBoot高级篇搜索之Solr环境搭建与简单测试</a></li>
</ul>
<p>在<code>application.yml</code> 配置文件中红，指定solr的域名</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后在solr中，写入一些数据，供我们删除使用，可以通过控制台的方式写入，也可以通过<a href="http://spring.hhui.top/spring-blog/2019/05/26/190526-SpringBoot%E9%AB%98%E7%BA%A7%E7%AF%87%E6%90%9C%E7%B4%A2Solr%E4%B9%8B%E6%96%87%E6%A1%A3%E6%96%B0%E5%A2%9E%E4%B8%8E%E4%BF%AE%E6%94%B9%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF/" target="_blank" rel="noopener noreferrer">190526-SpringBoot高级篇搜索Solr之文档新增与修改使用姿势</a> 这篇文档的case添加</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> II. 删除</h2>
<p>我们依然是使用<code>SolrTemplate</code>来操作solr的正删改查，它整合了solr的各种基本操作</p>
<h3> 1. 根据主键删除</h3>
<p>请注意，这种case是根据主键id进行删除的，支持批量删除，需要<code>solrTemplate.commit("yhh");</code>这一行来提交修改</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 查询删除</h3>
<p>上面根据主键删除适合精准的删除操作，但是适用性有限；下面介绍查询删除的方式，将满足查询条件的数据都删除掉</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面提供了一个简单的查询条件，删除content内容以<code>新增</code>开头的文档，至于查询语句的使用姿势在下一篇介绍Solr的查询姿势时详细说明</p>
<h3> 3. 测试</h3>
<p>接下来测试一下上面的两种case</p>
<p>首先我们提供一个输出所有文档的方法，用于对比删除前后的数据变化</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来是方法调用</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果如下，id为4,5,6的都被删除了</p>
<div class="language-log line-numbers-mode" data-ext="log"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> II. 其他</h2>
<h3> 0. 系列博文&amp;项目源码</h3>
<p><strong>系列博文</strong></p>
<ul>
<li><a href="http://spring.hhui.top/spring-blog/2019/05/26/190526-SpringBoot%E9%AB%98%E7%BA%A7%E7%AF%87%E6%90%9C%E7%B4%A2Solr%E4%B9%8B%E6%96%87%E6%A1%A3%E6%96%B0%E5%A2%9E%E4%B8%8E%E4%BF%AE%E6%94%B9%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF/" target="_blank" rel="noopener noreferrer">190526-SpringBoot高级篇搜索Solr之文档新增与修改使用姿势</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2019/05/10/190510-SpringBoot%E9%AB%98%E7%BA%A7%E7%AF%87%E6%90%9C%E7%B4%A2%E4%B9%8BSolr%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E7%AE%80%E5%8D%95%E6%B5%8B%E8%AF%95/" target="_blank" rel="noopener noreferrer">190510-SpringBoot高级篇搜索之Solr环境搭建与简单测试</a></li>
</ul>
<p><strong>项目源码</strong></p>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码: <a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/140-search-solr" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/140-search-solr</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>4.Solr查询使用姿势小结</title>
      <link>https://liuyueyi.github.io/tutorial/spring/search/Solr/04.200115-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8BSolr%E4%B9%8B%E6%9F%A5%E8%AF%A2%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF%E5%B0%8F%E7%BB%93.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/search/Solr/04.200115-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8BSolr%E4%B9%8B%E6%9F%A5%E8%AF%A2%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF%E5%B0%8F%E7%BB%93.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">4.Solr查询使用姿势小结</source>
      <description>接下来进入solr CURD的第四篇，查询的使用姿势介绍，本文将主要包括以下知识点 基本的查询操作 fq查询 fl指定字段查询 比较/范围 排序 分页 分组</description>
      <category>SpringBoot</category>
      <category>搜索系列</category>
      <category>Solr</category>
      <pubDate>Wed, 15 Jan 2020 15:55:37 GMT</pubDate>
      <content:encoded><![CDATA[<p>接下来进入solr CURD的第四篇，查询的使用姿势介绍，本文将主要包括以下知识点</p>
<ul>
<li>基本的查询操作</li>
<li>fq查询</li>
<li>fl指定字段查询</li>
<li>比较/范围</li>
<li>排序</li>
<li>分页</li>
<li>分组</li>
</ul>
<!-- more -->
<h2> I. 配置</h2>
<p>在介绍demo之前，需要先安装solr环境，搭建SpringBoot项目工程，具体的环境搭建过程不细说，推荐参考文档</p>
<ul>
<li><a href="http://spring.hhui.top/spring-blog/2019/05/10/190510-SpringBoot%E9%AB%98%E7%BA%A7%E7%AF%87%E6%90%9C%E7%B4%A2%E4%B9%8BSolr%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E7%AE%80%E5%8D%95%E6%B5%8B%E8%AF%95/" target="_blank" rel="noopener noreferrer">190510-SpringBoot高级篇搜索之Solr环境搭建与简单测试</a></li>
</ul>
<p>在<code>application.yml</code> 配置文件中红，指定solr的域名</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后在solr中，写入一些数据，供我们查询使用，可以通过控制台的方式写入，也可以通过<a href="http://spring.hhui.top/spring-blog/2019/05/26/190526-SpringBoot%E9%AB%98%E7%BA%A7%E7%AF%87%E6%90%9C%E7%B4%A2Solr%E4%B9%8B%E6%96%87%E6%A1%A3%E6%96%B0%E5%A2%9E%E4%B8%8E%E4%BF%AE%E6%94%B9%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF/" target="_blank" rel="noopener noreferrer">190526-SpringBoot高级篇搜索Solr之文档新增与修改使用姿势</a> 这篇文档的case添加</p>
<p>初始化solr文档内容如下</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> II. 查询</h2>
<p>solr文档对应的POJO如下，（注意solr中的主键id为string类型，下面定义中用的是Integer，推荐与solr的数据类型保持一致）</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1. 主键查询</h3>
<p>支持单个查询和批量查询，三个参数，第一个为需要查询的Collection, 第二个为id/id集合，第三个为返回的数据类型</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 简单查询</h3>
<p>比如最简单的根据某个字段进行查询</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>直接在SimpleQuery中指定查询条件，上面的case表示查询title为<code>一灰灰</code>的文档</p>
<p>输出结果如下：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>简单的查询使用上面的姿势ok，当然就是阅读起来不太优雅；推荐另外一种基于<code>Criteria</code>的查询条件构建方式</p>
<ul>
<li>如果看过之前的mongodb系列教程，可以看到monodb的查询条件也用到了Criteria来拼装，但是请注意这两个并不是一个东西</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><code>Criteria</code>可以构建复杂的且阅读友好的查询条件，后面会有具体的演示，这里给出一个多条件查询的case</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果如下，在上面的基础上，捞出了contentId小于2的记录</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 3. fq查询</h3>
<p>fq 主要用来快速过滤，配合query进行操作，主要是借助<code>org.springframework.data.solr.core.query.Query#addFilterQuery</code>来添加fq条件</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果如:</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 4. fl指定查询字段</h3>
<p>当我们只关注solr文档中的部分字段时，可以考虑指定fl，只获取所需的字段；通过<code>org.springframework.data.solr.core.query.SimpleQuery#addProjectionOnFields(java.lang.String...)</code>来指定需要返回的字段名</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>请注意，我们指定了只需要返回<code>id</code>, <code>title</code>, <code>content</code>，所以返回的DO中其他的成员为null</p>
<h3> 5. 范围查询</h3>
<p>针对数字类型，支持范围查询，比如上面给出<code>Criteria.where("content_id").lessThanEqual(2)</code>，表示查询<code>content_id</code>小于2的记录，下面给出一个between的查询</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果如下，请注意between查询，左右都是闭区间</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>如果不想要闭区间，可以用<code>between</code>的重载方法</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果如</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 6. 排序</h3>
<p>上面的case中，已经用到了排序，主要是<code>Sort</code>来指定排序字段以及排序的方式；因为id在solr中实际上是字符串格式，所以如果用id进行排序时，实际上是根据字符串的排序规则来的（虽然我们的POJO中id为int类型）</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 7. 分页查询</h3>
<p>分页查询比较常见，特别是当数据量比较大时，请一定记得，添加分页条件</p>
<p>一个查询case如下，查询所有的数据，并制定了分页条件，查询第二条和第三条数据（计数从0开始）</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在返回结果中，查了返回查询的文档之外，还会给出满足条件的文档数量，可以通过<code>Page#getTotalElements</code>获取，</p>
<p>上面case输出结果如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 8. 分组查询</h3>
<p>分组和前面的查询有一点区别，主要在于结果的处理，以及分组参数必须指定分页信息</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的case虽然比较简单，但是有几点需要注意, 特别是返回结果的获取，包装层级有点深</p>
<ul>
<li>GroupOptions：
<ul>
<li>必须指定offset/limit，当两个条件都没有时会抛异常</li>
<li>只指定offset时，limit默认为1</li>
<li>只指定limit时，offset默认为0</li>
</ul>
</li>
<li>结果处理
<ul>
<li><code>GroupPage#getGroupResult(field)</code> 获取分组内容，其中field为指定分组的成员</li>
<li>遍历<code>GroupResult#getGroupEntries</code>，获取每个分组对应的文档列表</li>
</ul>
</li>
</ul>
<p>输出结果如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> III. 其他</h2>
<h3> 0. 系列博文&amp;工程源码</h3>
<p><strong>系列博文</strong></p>
<ul>
<li><a href="http://spring.hhui.top/spring-blog/2020/01/14/200114-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8BSolr%E4%B9%8B%E6%96%87%E6%A1%A3%E5%88%A0%E9%99%A4/" target="_blank" rel="noopener noreferrer">200114-SpringBoot系列教程Solr之文档删除</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2019/05/26/190526-SpringBoot%E9%AB%98%E7%BA%A7%E7%AF%87%E6%90%9C%E7%B4%A2Solr%E4%B9%8B%E6%96%87%E6%A1%A3%E6%96%B0%E5%A2%9E%E4%B8%8E%E4%BF%AE%E6%94%B9%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF/" target="_blank" rel="noopener noreferrer">190526-SpringBoot高级篇搜索Solr之文档新增与修改使用姿势</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2019/05/10/190510-SpringBoot%E9%AB%98%E7%BA%A7%E7%AF%87%E6%90%9C%E7%B4%A2%E4%B9%8BSolr%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E7%AE%80%E5%8D%95%E6%B5%8B%E8%AF%95/" target="_blank" rel="noopener noreferrer">190510-SpringBoot高级篇搜索之Solr环境搭建与简单测试</a></li>
</ul>
<p><strong>工程源码</strong></p>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码: <a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/140-search-solr" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/140-search-solr</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>5.Solr身份认证与授权更新异常解决方案</title>
      <link>https://liuyueyi.github.io/tutorial/spring/search/Solr/05.200330-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B9%8BSolr%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83%E6%9B%B4%E6%96%B0%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/search/Solr/05.200330-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B9%8BSolr%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83%E6%9B%B4%E6%96%B0%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">5.Solr身份认证与授权更新异常解决方案</source>
      <description>之前介绍solr的教程中，solr没有开启权限校验，所有的操作都是无需鉴权；当时提到，如果solr开启了权限校验，改一下solr的host，带上用户名/密码即可，然而真实情况却并不太一样，查询ok，涉及到修改的操作，则会抛异常 本文将带你了解一下，这到底是个什么鬼畜现象</description>
      <category>SpringBoot</category>
      <category>搜索系列</category>
      <category>Solr</category>
      <category>采坑记录</category>
      <pubDate>Mon, 30 Mar 2020 19:13:16 GMT</pubDate>
      <content:encoded><![CDATA[<p>之前介绍solr的教程中，solr没有开启权限校验，所有的操作都是无需鉴权；当时提到，如果solr开启了权限校验，改一下solr的host，带上用户名/密码即可，然而真实情况却并不太一样，查询ok，涉及到修改的操作，则会抛异常</p>
<p>本文将带你了解一下，这到底是个什么鬼畜现象</p>
<!-- more -->
<h2> I. Solr配置用户登录</h2>
<h3> 1. 安装</h3>
<p>之前的solr系列教程中，通过docker安装的solr，下面的步骤也是直接针对docker中的solr进行配置，基本步骤一样</p>
<p>具体可以参考： <a href="http://spring.hhui.top/spring-blog/2019/05/10/190510-SpringBoot%E9%AB%98%E7%BA%A7%E7%AF%87%E6%90%9C%E7%B4%A2%E4%B9%8BSolr%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E7%AE%80%E5%8D%95%E6%B5%8B%E8%AF%95/" target="_blank" rel="noopener noreferrer">【搜索系列】Solr环境搭建与简单测试</a></p>
<p>不想看的同学，直接用下面的命令即可:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 配置</h3>
<p>下面一步一步教你如何设置用户密码，也可以参考博文: <a href="https://blog.csdn.net/u011561335/article/details/90695860" target="_blank" rel="noopener noreferrer">手把手教你 对 solr8 配置用户登录验证</a></p>
<p>进入实例，注意使用<code>root</code>用户，否则某些操作可能没有权限</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>创建鉴权文件</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>内容如下，格式为 <code>用户名:密码,权限</code>， 一行一个账号</p>
<div class="language-properties line-numbers-mode" data-ext="properties"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>配置鉴权文件</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>添加下面的内容放在<code>Configure</code>标签内</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>修改web.xml</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>在<code>security-constraint</code>标签下面，新增</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>重启solr，配置生效</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2> II. 场景复现</h2>
<p>接下来介绍一下我们的环境</p>
<ul>
<li>springboot: 2.2.1.RELEASE</li>
<li>solr: 8.0</li>
</ul>
<h3> 1. 项目环境</h3>
<p>搭建一个简单的springboot项目，xml依赖如下</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对应的配置文件<code>application.yml</code></p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 复现</h3>
<p>关于solr的基本操作，如果有疑问的小伙伴可以翻一下我之前的搜索系列博文，满足你的扫盲需求；</p>
<p>核心的solr操作实例如下:</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>SolrTemplat</code>定义如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>开始测试</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/200330/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>请注意，复现上面的场景时，会发现查询没问题，修改则会抛异常</p>
<h3> 3. 解决方案</h3>
<h4> a. 降版本</h4>
<p>我之前用solr的时候，也是上面的操作方式，然而并没有出现过这种问题，这就有点蛋疼了；</p>
<p>找之前的项目查看版本，发现之前用的<code>solr-solrj</code>用的是<code>6.6.5</code>，换个版本试一下（默认的版本是<code>8.2.0</code>）</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>见证奇迹的时刻到了，执行正常了，虽然<code>saveDocument</code>方法的调用标红，但是不影响具体的执行哦</p>
<figure><img src="/imgs/200330/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h4> b. SystemDefaultHttpClient</h4>
<p>通过一顿debug，单步执行，终于找到为啥<code>6.6.5</code>版本的<code>solr-solrj</code>可以正常操作，而<code>8.2.0</code>却不行（如果想知道这一枯燥的过程，请评论告诉我，否则我也不知道啥时候可以看到😂）</p>
<p>关键的问题就是旧版本的用的是<code>SystemDefaultHttpClient</code>来实现solr的沟通；新版本使用的是<code>InternalHttpClient</code></p>
<p>那么一个可用的解决方法就是不降版本，改为指定Solr的<code>HttpClient</code></p>
<p>在配置类中，如下操作：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后测试，也是正常执行，输出结果就不截图了，各位小伙伴可以亲自测试一下</p>
<h4> c. HttpClient拦截器</h4>
<blockquote>
<p>关于下面的这段写法，来自: <a href="https://stackoverflow.com/questions/2014700/preemptive-basic-authentication-with-apache-httpclient-4/11868040#11868040" target="_blank" rel="noopener noreferrer">Preemptive Basic authentication with Apache HttpClient 4</a></p>
</blockquote>
<p>上面的方式虽然可以让我们正确操作solr了，但是<code>SystemDefaultHttpClient</code>有一个删除注解，也就是说不建议再直接用它了，那就借鉴它的使用方式，来满足我们的需求，所以可以如下操作</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的实现有点长，简单的拆解一下</p>
<ul>
<li><code>UrlDo</code>: 解析solr的url，得到我们需要的<code>host + port + user + password</code></li>
<li><code>solrClient</code>: 在创建<code>SolrClient</code> bean实例时，指定相应的授权信息</li>
<li><code>SolrAuthInterceptor</code>: 自定义拦截器，更新<code>authState</code>信息</li>
</ul>
<h4> d. SolrRequest</h4>
<p>上面的三种方式，适用于利用<code>SolrClient</code>或者<code>SolrTemplate</code>来操作的solr；当然我可以完全抛弃掉它们，直接使用<code>SolrRequest</code>来操作，如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4. 小结</h3>
<p>本篇博文主要是针对需要登录验证的solr更新操作异常时，给出了四种解决方案</p>
<ul>
<li>降<code>solr-solrj</code>版本到<code>6.6.0</code></li>
<li>指定<code>SolrClient</code>的<code>HttpClient</code>为<code>SystemDefaultHttpClient</code></li>
<li>HttpClient拦截器</li>
<li>SolrRequest指定用户名密码</li>
</ul>
<p>上面虽然给出了解决方法，但是为啥有这个问题呢？</p>
<p>直接通过curl来测试一下更新solr操作，正常返回，并没有问题，那么这个问题到底啥原因，究竟是谁的锅，请敬请期待后续问题定位盖锅定论</p>
<figure><img src="/imgs/200330/02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> II. 其他</h2>
<h3> 0. 系列博文&amp;工程源码</h3>
<p><strong>参考博文</strong></p>
<ul>
<li><a href="https://blog.csdn.net/u011561335/article/details/90695860" target="_blank" rel="noopener noreferrer">手把手教你 对 solr8 配置用户登录验证</a></li>
<li><a href="https://stackoverflow.com/questions/2014700/preemptive-basic-authentication-with-apache-httpclient-4/11868040#11868040" target="_blank" rel="noopener noreferrer">Preemptive Basic authentication with Apache HttpClient 4</a></li>
</ul>
<p><strong>系列博文</strong></p>
<ul>
<li><a href="http://spring.hhui.top/spring-blog/2020/01/15/200115-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8BSolr%E4%B9%8B%E6%9F%A5%E8%AF%A2%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF%E5%B0%8F%E7%BB%93/" target="_blank" rel="noopener noreferrer">200115-SpringBoot系列教程Solr之查询使用姿势小结</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2020/01/14/200114-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8BSolr%E4%B9%8B%E6%96%87%E6%A1%A3%E5%88%A0%E9%99%A4/" target="_blank" rel="noopener noreferrer">200114-SpringBoot系列教程Solr之文档删除</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2019/05/26/190526-SpringBoot%E9%AB%98%E7%BA%A7%E7%AF%87%E6%90%9C%E7%B4%A2Solr%E4%B9%8B%E6%96%87%E6%A1%A3%E6%96%B0%E5%A2%9E%E4%B8%8E%E4%BF%AE%E6%94%B9%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF/" target="_blank" rel="noopener noreferrer">190526-SpringBoot高级篇搜索Solr之文档新增与修改使用姿势</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2019/05/10/190510-SpringBoot%E9%AB%98%E7%BA%A7%E7%AF%87%E6%90%9C%E7%B4%A2%E4%B9%8BSolr%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E7%AE%80%E5%8D%95%E6%B5%8B%E8%AF%95/" target="_blank" rel="noopener noreferrer">190510-SpringBoot高级篇搜索之Solr环境搭建与简单测试</a></li>
</ul>
<p><strong>工程源码</strong></p>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/141-search-solr-auth" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/141-search-solr-auth</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/200330/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>Solr</title>
      <link>https://liuyueyi.github.io/tutorial/spring/search/Solr/</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/search/Solr/</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">Solr</source>
      <description>SpringBoot整合Solr，支撑搜索业务场景</description>
      <pubDate>Fri, 10 Feb 2023 04:50:05 GMT</pubDate>
      <content:encoded><![CDATA[<p>SpringBoot整合Solr，支撑搜索业务场景</p>
]]></content:encoded>
    </item>
    <item>
      <title>0.起源篇（零）</title>
      <link>https://liuyueyi.github.io/tutorial/spring/security/basic/191223-SpringBoot-%E6%95%B4%E5%90%88-SpringSecurity-%E4%B9%8B%E8%B5%B7%E6%BA%90%E7%AF%87%EF%BC%88%E9%9B%B6%EF%BC%89.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/security/basic/191223-SpringBoot-%E6%95%B4%E5%90%88-SpringSecurity-%E4%B9%8B%E8%B5%B7%E6%BA%90%E7%AF%87%EF%BC%88%E9%9B%B6%EF%BC%89.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">0.起源篇（零）</source>
      <description>本篇为SpringSecurity的第一篇，主要来介绍下什么是SpringSecurity，以及在springboot中如何使用它</description>
      <category>SpringSecurity</category>
      <pubDate>Mon, 23 Dec 2019 18:55:02 GMT</pubDate>
      <content:encoded><![CDATA[<p>本篇为SpringSecurity的第一篇，主要来介绍下什么是SpringSecurity，以及在springboot中如何使用它</p>
<!-- more -->
<h2> I. 基本知识点</h2>
<blockquote>
<p>官方文档: <a href="https://docs.spring.io/spring-security/site/docs/5.2.2.BUILD-SNAPSHOT/reference/htmlsingle/#community-help" target="_blank" rel="noopener noreferrer">https://docs.spring.io/spring-security/site/docs/5.2.2.BUILD-SNAPSHOT/reference/htmlsingle/#community-help</a></p>
</blockquote>
<p>下面是官方介绍</p>
<blockquote>
<p>Spring Security is a powerful and highly customizable authentication and access-control framework. It is the de-facto standard for securing Spring-based applications.</p>
</blockquote>
<blockquote>
<p>Spring Security is a framework that focuses on providing both authentication and authorization to Java applications. Like all Spring projects, the real power of Spring Security is found in how easily it can be extended to meet custom requirements</p>
</blockquote>
<p>用国语，简单抽象的说一下它的定义</p>
<ul>
<li>很🐂的认证和访问权限校验框架</li>
</ul>
<p>那么具体能干嘛？</p>
<ul>
<li>用户登录认证：用户名+密码登录，确定用户身份</li>
<li>用户访问鉴权（常见的ACL访问控制列表，RBAC角色访问控制）：判定是否有权限访问某个资源</li>
<li>安全保护（CSRF跨站点攻击,Session Fixation会话固定攻击...）</li>
</ul>
<h2> II. 初体验</h2>
<p>接下来我们看一下再springboot中如何使用springsecurity</p>
<h3> 1. 配置</h3>
<p>首先得是spring boot项目，然后添加上security的依赖即可，相对完整的pom配置如下（注意我们使用的springboot版本为2.2.1.RELEASE）</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 实例demo</h3>
<p>上面配置完之后，啥都不需要干，项目已经接入了spring security；项目中的服务都需要登录之后才能访问</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当我们需要访问首页时，会发现直接302重定向到登录页面了，如下图</p>
<figure><img src="/imgs/191223/00.gif" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>spring security默认给我们生成了一个用户名为user，密码为控制台中输出的一行日志如<code>Using generated security password: aa410186-5c04-4282-b217-507ffb1f61eb</code></p>
<p>登录之后会重定向回我们之前访问的url，通过抓包可以看到，登录成功之后，会设置请求方的cookie，后续的请求携带cookie来表明用户身份</p>
<figure><img src="/imgs/191223/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 3. 基本配置</h3>
<p>上面虽然演示了一个hello world的初体验项目，但是这个默认的用户名/密码有点鬼畜，默认的配置主要来自于<code>org.springframework.boot.autoconfigure.security.SecurityProperties.User</code>，下面是截图（所以前面的用户名为user）</p>
<figure><img src="/imgs/191223/02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>接下来我们需要配置为对人类友好的方式，在项目的配置文件<code>application.yml</code>中，指定登录的用户名/密码</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>重启测试项目，使用新的用户名/密码（yihuihui/123456)就可以登录成功了;</p>
<h3> 4. 用户身份获取</h3>
<p>上面虽然是一个简单的case，但还有一点不得不提一下，在我的接口中，虽然知道你登录了，但怎么知道你是谁呢？</p>
<p>我们可以直接通过<code>HttpServletRequest#getRemoteUser()</code>的方法来获取登录用户； 或者通过<code>SecurityContextHolder.getContext().getAuthentication().getPrincipal()</code>来获取授权信息</p>
<p>我们来写一个通用方法</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后稍微改一下我们的服务接口</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>再次访问之后，结果如下</p>
<figure><img src="/imgs/191223/03.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 5. 小结</h3>
<p>本文主要是spring security系列的起源篇，第一节介绍了下什么是SpringSecurity，有什么特点</p>
<ul>
<li>spring security是一个很🐂🍺的认证（可以简单理解为登录验证）和鉴权（可简单理解为访问控制）框架</li>
<li>三大特点：登录 + 鉴权 + 安全防护</li>
</ul>
<p>第二节介绍了一个简单入门的HelloWorld实例</p>
<ul>
<li>springboot项目，添加依赖 <code>spring-boot-starter-security</code>； 所有的http接口访问都需要登录，默认提供一个用户名为user，密码为控制台输出的UUID字符串</li>
<li>通过<code>spring.security.user.name</code>和<code>spring.security.user.password</code>来指定用户名密码</li>
<li>通过<code>HttpServletRequest#getRemoteUser()</code>获取登录用户</li>
</ul>
<p>那么问题来了，什么系统可能只有一个用户呢？要多用户怎么办？不同的用户不同的权限怎么办？某些接口所有人都可以访问又怎么办？</p>
<h2> II. 其他</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>代码: <a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-security/000-basic-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-security/000-basic-demo</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/191223/00.gif" type="image/gif"/>
    </item>
    <item>
      <title>1.基于内存认证（一）</title>
      <link>https://liuyueyi.github.io/tutorial/spring/security/basic/200111-SpringBoot-%E6%95%B4%E5%90%88-SpringSecurity-%E4%B9%8B%E5%9F%BA%E4%BA%8E%E5%86%85%E5%AD%98%E8%AE%A4%E8%AF%81%EF%BC%88%E4%B8%80%EF%BC%89.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/security/basic/200111-SpringBoot-%E6%95%B4%E5%90%88-SpringSecurity-%E4%B9%8B%E5%9F%BA%E4%BA%8E%E5%86%85%E5%AD%98%E8%AE%A4%E8%AF%81%EF%BC%88%E4%B8%80%EF%BC%89.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">1.基于内存认证（一）</source>
      <description>在第一篇的教程中，我们简单的了解了一下SpringSecurity的使用姿势，添加依赖，在application.yml文件中加几行配置，就可以实现一个基本的登录认证； 默认的配置只能设置一个账号，那么如果需要多个账号可以怎么支持呢？ 本文将介绍一下基于内存的认证方式</description>
      <category>SpringSecurity</category>
      <pubDate>Sat, 11 Jan 2020 11:53:44 GMT</pubDate>
      <content:encoded><![CDATA[<p>在第一篇的教程中，我们简单的了解了一下SpringSecurity的使用姿势，添加依赖，在<code>application.yml</code>文件中加几行配置，就可以实现一个基本的登录认证；</p>
<p>默认的配置只能设置一个账号，那么如果需要多个账号可以怎么支持呢？</p>
<p>本文将介绍一下基于内存的认证方式</p>
<!-- more -->
<h2> I. 内存认证</h2>
<p>基于内存保存认证信息的方式，本篇博文中，会介绍两种常见的使用姿势</p>
<h3> 0. 项目配置</h3>
<p>环境配置和前面一致，相关内容可以参考博文: <a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484424&amp;idx=1&amp;sn=614b861a69c5c04b193b5192d2c8b0e6" target="_blank" rel="noopener noreferrer">191223-SpringBoot 整合 SpringSecurity 之起源篇（零）</a></p>
<h3> 1. WebSecurityConfigurerAdapter</h3>
<p>这里主要是借助<code>SpringSecurity</code>的配置适配器来处理，下面是一个简单的case</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>主要逻辑在 <code>configure</code>这个方法中，但是需要注意，我们额外的设置了密码的加密方式, 当我们不设置这个的时候，实际登录的时候会发现，即便你输入了正确的用户名密码，也会提示失败(欢迎各位大佬实测一下)</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其次，在创建用户的时候，需要注意的是，除了设置了用户名和密码之外，还给用户加上了一个角色，这个会在后续文章的RBAC（基于角色的授权）中介绍它的作用</p>
<h3> 2. UserDetailsService</h3>
<p>这里介绍另外一种方式，在后面的db中保存认证信息时，也会用到；在SpringSecurity的实现中，通过 UserDetailService 这个bean来根据用户名查询对应的用户信息；所以我们只需要实现一个我们自定义的Bean来替换默认的，就可以来实现我们的目标</p>
<p>我们的配置类如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. 测试</h3>
<p>上面两种方式，都可以实现在内存中保存认证信息，接下来我们进入实测环节，首先写一个http接口</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在实际测试时，上面两种case都是ok的，下面的演示过程主要是基于第二种方式给出的示例</p>
<figure><img src="/imgs/200111/00.gif" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> II. 其他</h2>
<h3> 0. 系列博文&amp;项目源码</h3>
<p><strong>博文</strong></p>
<ul>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484424&amp;idx=1&amp;sn=614b861a69c5c04b193b5192d2c8b0e6" target="_blank" rel="noopener noreferrer">191223-SpringBoot 整合 SpringSecurity 之起源篇（零）</a></li>
</ul>
<p><strong>源码</strong></p>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：
<ul>
<li><a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-security/001-authentication-mem-config" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-security/001-authentication-mem-config</a></li>
<li><a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-security/001-authentication-mem-userdetail" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-security/001-authentication-mem-userdetail</a></li>
</ul>
</li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/200111/00.gif" type="image/gif"/>
    </item>
    <item>
      <title>SpringSecurity</title>
      <link>https://liuyueyi.github.io/tutorial/spring/security/basic/</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/security/basic/</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">SpringSecurity</source>
      <description>SpringBoot Security基础系列教程，目标是实现权限管理的无障碍接入使用</description>
      <pubDate>Fri, 10 Feb 2023 04:50:05 GMT</pubDate>
      <content:encoded><![CDATA[<p>SpringBoot Security基础系列教程，目标是实现权限管理的无障碍接入使用</p>
]]></content:encoded>
    </item>
    <item>
      <title>1.Get请求参数解析姿势汇总</title>
      <link>https://liuyueyi.github.io/tutorial/spring/web/Request/190824-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8Bweb%E7%AF%87%E4%B9%8BGet%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%E5%A7%BF%E5%8A%BF%E6%B1%87%E6%80%BB.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/web/Request/190824-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8Bweb%E7%AF%87%E4%B9%8BGet%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%E5%A7%BF%E5%8A%BF%E6%B1%87%E6%80%BB.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">1.Get请求参数解析姿势汇总</source>
      <description>一般在开发web应用的时候，如果提供http接口，最常见的http请求方式为GET/POST，我们知道这两种请求方式的一个显著区别是GET请求的参数在url中，而post请求可以不在url中；那么一个SpringBoot搭建的web应用可以如何解析发起的http请求参数呢？ 下面我们将结合实例汇总一下GET请求参数的几种常见的解析姿势</description>
      <category>SpringBoot</category>
      <category>WEB系列</category>
      <category>Request</category>
      <pubDate>Sat, 24 Aug 2019 22:07:56 GMT</pubDate>
      <content:encoded><![CDATA[<p>一般在开发web应用的时候，如果提供http接口，最常见的http请求方式为GET/POST，我们知道这两种请求方式的一个显著区别是GET请求的参数在url中，而post请求可以不在url中；那么一个SpringBoot搭建的web应用可以如何解析发起的http请求参数呢？</p>
<p>下面我们将结合实例汇总一下GET请求参数的几种常见的解析姿势</p>
<!-- more -->
<h2> I. 环境搭建</h2>
<p>首先得搭建一个web应用才有可能继续后续的测试，借助SpringBoot搭建一个web应用属于比较简单的活;</p>
<p>创建一个maven项目，pom文件如下</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>添加项目启动类<code>Application.cass</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在演示请求参数的解析实例中，我们使用终端的curl命令来发起http请求（主要原因是截图上传太麻烦，还是终端的文本输出比较方便；缺点是不太直观）</p>
<h2> II. GET请求参数解析</h2>
<p>接下来我们正式进入参数解析的妖娆姿势篇，会介绍一下常见的一些case（并不能说包含了所有的使用case）</p>
<p>下面所有的方法都放在 <code>ParamGetRest</code> 这个Controller中</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1. HttpServletRequest</h3>
<p>直接使用<code>HttpServletRequest</code>来获取请求参数，属于比较原始，但是灵活性最高的使用方法了。</p>
<p>常规使用姿势是方法的请求参数中有一个<code>HttpServletRequest</code>，我们通过<code>ServletRequest#getParameter(参数名)</code>来获取具体的请求参数，下面演示返回所有请求参数的case</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>测试case，注意下使用curl请求参数中有中文时，进行了url编码（后续会针对这个问题进行说明）</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用HttpServletRequest获取请求参数，还有另外一种使用case，不通过参数传递的方式获取Request实例，而是借助<code>RequestContextHolder</code>；这样的一个好处就是，假设我们想写一个AOP，拦截GET请求并输出请求参数时，可以通过下面这种方式来处理</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>测试case</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h3> 2. 方法参数</h3>
<p>这种解析方式比较厉害了，将GET参数与方法的参数根据参数名进行映射，从感官上来看，就像是直接调用这个一样</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>针对上面提供的方式，我们的测试自然会区分为下面几种，看下会怎样</p>
<ul>
<li>正好两个参数，与定义一直</li>
<li>缺少一个请求参数</li>
<li>多一个请求参数</li>
<li>参数类型不一致</li>
</ul>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从上面实际的case可以看出，利用方法参数解析GET传参时，实际效果是：</p>
<ul>
<li>方法参数与GET传参，通过参数签名进行绑定</li>
<li>方法参数类型，需要与接收的GET传参类型一致</li>
<li>方法参数非基本类型时，若传参没有，则为null；（也就是说如果为基本类型，无法转null，抛异常）</li>
<li>实际的GET传参可以多于方法定义的参数</li>
</ul>
<p>接下来给一个数组传参解析的实例</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>测试case如下，传数组时参数值用逗号分隔；基本类型，必须传参，否则解析异常</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h3> 3. RequestParam 注解</h3>
<p>这种方式看起来和前面有些相似，但更加灵活，我们先看一下注解</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>有两个参数需要注意，一个是name表示这个参数与GET传参的哪个关联；required表示这个参数是否可选</p>
<p>下面是一个简单的使用方式</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>测试如下:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用<code>RequestParam</code>注解时，如果指定了<code>name/value</code>，这个参数就与指定的GETGET传参关联；如果不指定时，则根据参数签名来关联</p>
<p>下面给出两个更有意思的使用方式，一个是枚举参数解析，一个是Map容纳参数，一个是数组参数解析</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>测试case如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从测试结果可以知道：</p>
<ul>
<li>GET传参映射到枚举时，根据<code>enum.valueOf()</code>来实例的</li>
<li>如果希望使用Map来容纳所有的传参，需要加上注解<code>@RequestParam</code></li>
<li>如果参数为List类型，必须添加注解<code>@RequestParam</code>；否则用数组来接收</li>
</ul>
<hr>
<h3> 4. PathVariable</h3>
<p>从请求的url路径中解析参数，使用方法和前面的差别不大</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面是一个常见的使用方式，对此我们带着几个疑问设计case</p>
<ul>
<li>只有name没有index，会怎样？</li>
<li>有name，有index，后面还有路径，会怎样？</li>
</ul>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从path中获取参数时，对url有相对严格的要求，注意使用</p>
<hr>
<h3> 5. POJO</h3>
<p>这种case，我个人用得比较多，特别是基于SpringCloud的生态下，借助Feign来调用第三方微服务，可以说是很舒爽了；下面看一下这种方式的使用姿势</p>
<p>首先定义一个POJO</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>提供一个服务</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>POJO中定义了三个参数，我们再测试的时候，看一下这些参数是否必选</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> II. 其他</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>项目: <a href="https://github.com/liuyueyi/spring-boot-demo/blob/master/spring-boot/202-web-params" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/blob/master/spring-boot/202-web-params</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>2.Post请求参数解析姿势汇总</title>
      <link>https://liuyueyi.github.io/tutorial/spring/web/Request/190828-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8Bweb%E7%AF%87%E4%B9%8BPost%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%E5%A7%BF%E5%8A%BF%E6%B1%87%E6%80%BB.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/web/Request/190828-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8Bweb%E7%AF%87%E4%B9%8BPost%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%E5%A7%BF%E5%8A%BF%E6%B1%87%E6%80%BB.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">2.Post请求参数解析姿势汇总</source>
      <description>作为一个常年提供各种Http接口的后端而言，如何获取请求参数可以说是一项基本技能了，本篇为《190824-SpringBoot系列教程web篇之Get请求参数解析姿势汇总》之后的第二篇，对于POST请求方式下，又可以怎样获取请求参数呢 本篇主要内容包括以下几种姿势 @RequestBody json格式 RequestEntity MultipartFile 文件上传</description>
      <category>SpringBoot</category>
      <category>WEB系列</category>
      <category>Request</category>
      <pubDate>Wed, 28 Aug 2019 18:41:16 GMT</pubDate>
      <content:encoded><![CDATA[<p>作为一个常年提供各种Http接口的后端而言，如何获取请求参数可以说是一项基本技能了，本篇为《<a href="http://spring.hhui.top/spring-blog/2019/08/24/190824-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8Bweb%E7%AF%87%E4%B9%8BGet%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%E5%A7%BF%E5%8A%BF%E6%B1%87%E6%80%BB/" target="_blank" rel="noopener noreferrer">190824-SpringBoot系列教程web篇之Get请求参数解析姿势汇总</a>》之后的第二篇，对于POST请求方式下，又可以怎样获取请求参数呢</p>
<p>本篇主要内容包括以下几种姿势</p>
<ul>
<li>@RequestBody  json格式</li>
<li>RequestEntity</li>
<li>MultipartFile 文件上传</li>
</ul>
<!-- more -->
<h2> I. 环境搭建</h2>
<p>首先得搭建一个web应用才有可能继续后续的测试，借助SpringBoot搭建一个web应用属于比较简单的活;</p>
<p>创建一个maven项目，pom文件如下</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>添加项目启动类<code>Application.cass</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在演示请求参数的解析实例中，我们使用终端的curl命令来发起http请求（主要原因是截图上传太麻烦，还是终端的文本输出比较方便；缺点是不太直观）</p>
<h2> II. POST请求参数解析</h2>
<p>接下来我们正式进入参数解析的妖娆姿势篇，会介绍一下常见的一些case（并不能说包含了所有的使用case）</p>
<p>下面所有的方法都放在 <code>ParamPostRest</code> 这个Controller中</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在正式介绍之前，强烈推荐看一下《<a href="http://spring.hhui.top/spring-blog/2019/08/24/190824-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8Bweb%E7%AF%87%E4%B9%8BGet%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%E5%A7%BF%E5%8A%BF%E6%B1%87%E6%80%BB/" target="_blank" rel="noopener noreferrer">190824-SpringBoot系列教程web篇之Get请求参数解析姿势汇总</a>》, 因为get传参的姿势，在post参数解析中同样适用，下面的内容并不会再次详细介绍</p>
<h3> 1. HttpServletRequest</h3>
<p>首先看一下最基本的使用case，和get请求里的case一样，我们先开一个接口</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们测试下两种post请求下，会出现怎样的结果</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从上面的case中可以知道，通过传统的表达方式提交的数据时，获取参数和get获取参数使用姿势一样；然而当然传入的是json串格式的数据时，直接通过<code>javax.servlet.ServletRequest#getParameter</code>获取不到对应的参数</p>
<p>我们通过debug，来看一下在传json串数据的时候，如果我们要获取数据，可以怎么做</p>
<figure><img src="/imgs/190828/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>上面截图演示了我们从请求的InputStream中获取post参数；所以再实际使用的时候需要注意，流中的数据只能读一次，读完了就没了; 这个和我们使用GET传参是有很大的差别的</p>
<p><strong>注意：如果您有一个打印请求参数日志的切面，在获取post传的参数时需要注意，是不是把流的数据读了，导致业务中无法获取到正确的数据！！！</strong></p>
<h3> 2. RequestBody</h3>
<p>上面说到传json串数据时，后端直接通过<code>HttpServletRequest</code>获取数据不太方便，那么有更优雅的使用姿势么？下面我们看一下<code>@RequestBody</code>注解的使用</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>只需要在参数中添加<code>@RequestBody</code>注解即可，然后这个接口就支持json串的POST提交了</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>说明：使用<code>@RequestBody</code>注解之后，可解析提交的json串；但不再支持表单提交参数方式(<code>application/x-www-form-urlencoded</code>)</strong></p>
<h3> 3. RequestEntity</h3>
<p>使用RequestEntity来解析参数，可能并不太常见，它用来解析json串提交的参数也比较合适，使用姿势也比较简单</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用case如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4. MultipartFile 文件上传</h3>
<p>文件上传也是一个比较常见的，支持起来也比较简单，有两种方式，一个是使用MultipartHttpServletRequest参数来获取上传的文件；一个是借助 <code>@RequestParam</code>注解</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>测试case如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 5. 其他</h3>
<p>上面介绍的几种有别于GET篇中的请求姿势，请注意GET请求参数的解析方式，在POST请求中，可能也是适用的，为什么说可能？因为在post请求中，不同的<code>content-type</code>，对参数的解析影响还是有的；</p>
<p>需要注意的是，对于传统的表单提交(application/x-www-form-urlencoded)方式，post的参数解析依然可以使用</p>
<ul>
<li>@RequsetParam</li>
<li>POJO（BEAN的解析方式）</li>
<li>@PathVariable参数解析</li>
<li>方法参数解析</li>
</ul>
<h2> II. 其他</h2>
<h3> 0. 项目&amp;相关博文</h3>
<ul>
<li><a href="http://spring.hhui.top/spring-blog/2019/08/24/190824-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8Bweb%E7%AF%87%E4%B9%8BGet%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%E5%A7%BF%E5%8A%BF%E6%B1%87%E6%80%BB/" target="_blank" rel="noopener noreferrer">190824-SpringBoot系列教程web篇之Get请求参数解析姿势汇总</a></li>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>项目: <a href="https://github.com/liuyueyi/spring-boot-demo/blob/master/spring-boot/202-web-params" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/blob/master/spring-boot/202-web-params</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/190828/01.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>3.如何自定义参数解析器</title>
      <link>https://liuyueyi.github.io/tutorial/spring/web/Request/190831-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8Bweb%E7%AF%87%E4%B9%8B%E5%A6%82%E4%BD%95%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%E5%99%A8.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/web/Request/190831-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8Bweb%E7%AF%87%E4%B9%8B%E5%A6%82%E4%BD%95%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%E5%99%A8.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">3.如何自定义参数解析器</source>
      <description>SpringMVC提供了各种姿势的http参数解析支持，从前面的GET/POST参数解析篇也可以看到，加一个@RequsetParam注解就可以将方法参数与http参数绑定，看到这时自然就会好奇这是怎么做到的,我们能不能自己定义一种参数解析规则呢？ 本文将介绍如何实现自定义的参数解析，并让其生效</description>
      <category>SpringBoot</category>
      <category>WEB系列</category>
      <category>Request</category>
      <pubDate>Sat, 31 Aug 2019 16:45:48 GMT</pubDate>
      <content:encoded><![CDATA[<p>SpringMVC提供了各种姿势的http参数解析支持，从前面的GET/POST参数解析篇也可以看到，加一个<code>@RequsetParam</code>注解就可以将方法参数与http参数绑定，看到这时自然就会好奇这是怎么做到的,我们能不能自己定义一种参数解析规则呢？</p>
<p>本文将介绍如何实现自定义的参数解析，并让其生效</p>
<!-- more -->
<h2> I. 环境搭建</h2>
<p>首先得搭建一个web应用才有可能继续后续的测试，借助SpringBoot搭建一个web应用属于比较简单的活;</p>
<p>创建一个maven项目，pom文件如下</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> II. 自定义参数解析器</h2>
<p>对于如何自定义参数解析器，一个较推荐的方法是，先搞清楚springmvc接收到一个请求之后完整的处理链路，然后再来看在什么地方，什么时机，来插入自定义参数解析器，无论是从理解还是实现都会简单很多。遗憾的是，本篇主要目标放在的是使用角度，所以这里只会简单的提一下参数解析的链路，具体的深入留待后续的源码解析</p>
<h3> 1. 参数解析链路</h3>
<p>http请求流程图，来自 <a href="https://www.jianshu.com/p/bf3537334e76" target="_blank" rel="noopener noreferrer">SpringBoot是如何解析HTTP参数的</a></p>
<figure><img src="/imgs/190831/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>既然是参数解析，所以肯定是在方法调用之前就会被触发，在Spring中，负责将http参数与目标方法参数进行关联的，主要是借助<code>org.springframework.web.method.support.HandlerMethodArgumentResolver</code>类来实现</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这段核心代码来自<code>org.springframework.web.method.support.HandlerMethodArgumentResolverComposite#resolveArgument</code>，主要作用就是获取一个合适的<code>HandlerMethodArgumentResolver</code>，实现将http参数(<code>webRequest</code>)映射到目标方法的参数上(<code>parameter</code>)</p>
<p>所以说，实现自定义参数解析器的核心就是实现一个自己的<code>HandlerMethodArgumentResolver</code></p>
<h3> 2. HandlerMethodArgumentResolver</h3>
<p>实现一个自定义的参数解析器，首先得有个目标，我们在get参数解析篇里面，当时遇到了一个问题，当传参为数组时，定义的方法参数需要为数组，而不能是List，否则无法正常解析；现在我们则希望能实现这样一个参数解析，以支持上面的场景</p>
<p>为了实现上面这个小目标，我们可以如下操作</p>
<h4> a. 自定义注解ListParam</h4>
<p>定义这个注解，主要就是用于表明，带有这个注解的参数，希望可以使用我们自定义的参数解析器来解析；</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> b. 参数解析器ListHandlerMethodArgumentResolver</h4>
<p>接下来就是自定义的参数解析器了，需要实现接口<code>HandlerMethodArgumentResolver</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面有两个方法：</p>
<ul>
<li><code>supportsParameter</code>就是用来表明这个参数解析器适不适用
<ul>
<li>实现也比较简单，就是看参数上有没有前面定义的<code>ListParam</code>注解</li>
</ul>
</li>
<li><code>resolveArgument</code> 这个方法就是实现将http参数粗转换为目标方法参数的具体逻辑
<ul>
<li>上面主要是为了演示自定义参数解析器的过程，实现比较简单，默认只支持<code>List&lt;String&gt;</code></li>
</ul>
</li>
</ul>
<h3> 3. 注册</h3>
<p>上面虽然实现了自定义的参数解析器，但是我们需要把它注册到<code>HandlerMethodArgumentResolver</code>才能生效，一个简单的方法如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4. 测试</h3>
<p>为了验证我们的自定义参数解析器ok，我们开两个对比的rest服务</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>演示demo如下，添加了<code>ListParam</code>注解的可以正常解析，没有添加注解的会抛异常</p>
<figure><img src="/imgs/190831/01.gif" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> II. 其他</h2>
<h3> 0. 项目&amp;相关博文</h3>
<ul>
<li><a href="http://spring.hhui.top/spring-blog/2019/08/24/190824-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8Bweb%E7%AF%87%E4%B9%8BGet%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%E5%A7%BF%E5%8A%BF%E6%B1%87%E6%80%BB/" target="_blank" rel="noopener noreferrer">190824-SpringBoot系列教程web篇之Get请求参数解析姿势汇总</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2019/08/28/190828-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8Bweb%E7%AF%87%E4%B9%8BPost%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%E5%A7%BF%E5%8A%BF%E6%B1%87%E6%80%BB/" target="_blank" rel="noopener noreferrer">190828-SpringBoot系列教程web篇之Post请求参数解析姿势汇总</a></li>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>项目: <a href="https://github.com/liuyueyi/spring-boot-demo/blob/master/spring-boot/202-web-params" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/blob/master/spring-boot/202-web-params</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/190831/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>4.自定义请求匹配条件RequestCondition</title>
      <link>https://liuyueyi.github.io/tutorial/spring/web/Request/191222-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8Bweb%E7%AF%87%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E8%AF%B7%E6%B1%82%E5%8C%B9%E9%85%8D%E6%9D%A1%E4%BB%B6RequestCondition.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/web/Request/191222-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8Bweb%E7%AF%87%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E8%AF%B7%E6%B1%82%E5%8C%B9%E9%85%8D%E6%9D%A1%E4%BB%B6RequestCondition.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">4.自定义请求匹配条件RequestCondition</source>
      <description>在spring mvc中，我们知道用户发起的请求可以通过url匹配到我们通过@RequestMapping定义的服务端点上；不知道有几个问题大家是否有过思考 一个项目中，能否存在完全相同的url？ 有了解http协议的同学可能很快就能给出答案，当然可以，url相同，请求方法不同即可；那么能否出现url相同且请求方法l也相同的呢？ 本文将介绍一下如何使用RequestCondition结合RequestMappingHandlerMapping，来实现url匹配规则的扩展，从而支持上面提出的case</description>
      <category>SpringBoot</category>
      <category>WEB系列</category>
      <category>Request</category>
      <pubDate>Sun, 22 Dec 2019 16:49:58 GMT</pubDate>
      <content:encoded><![CDATA[<p>在spring mvc中，我们知道用户发起的请求可以通过url匹配到我们通过<code>@RequestMapping</code>定义的服务端点上；不知道有几个问题大家是否有过思考</p>
<p>一个项目中，能否存在完全相同的url？</p>
<p>有了解http协议的同学可能很快就能给出答案，当然可以，url相同，请求方法不同即可；那么能否出现url相同且请求方法l也相同的呢？</p>
<p>本文将介绍一下如何使用<code>RequestCondition</code>结合<code>RequestMappingHandlerMapping</code>，来实现url匹配规则的扩展，从而支持上面提出的case</p>
<!-- more -->
<h2> I. 环境相关</h2>
<p>本文介绍的内容和实际case将基于<code>spring-boot-2.2.1.RELEASE</code>版本，如果在测试时，发现某些地方没法兼容时，请确定一下版本</p>
<h3> 1. 项目搭建</h3>
<p>首先我们需要搭建一个web工程，以方便后续的servelt注册的实例演示，可以通过spring boot官网创建工程，也可以建立一个maven工程，在pom.xml中如下配置</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. RequestCondition介绍</h3>
<p>在spring mvc中，通过<code>DispatchServlet</code>接收客户端发起的一个请求之后，会通过HanderMapping来获取对应的请求处理器；而HanderMapping如何找到可以处理这个请求的处理器呢，这就需要RequestCondition来决定了</p>
<p>接口定义如下，主要有三个方法，</p>
<div class="language-ja line-numbers-mode" data-ext="ja"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>简单说下三个接口的作用</p>
<ul>
<li>
<p><code>combine</code>: 某个接口有多个规则时，进行合并</p>
<ul>
<li>比如类上指定了<code>@RequestMapping</code>的url为 <code>root</code></li>
<li>而方法上指定的<code>@RequestMapping</code>的url为 <code>method</code></li>
<li>那么在获取这个接口的url匹配规则时，类上扫描一次，方法上扫描一次，这个时候就需要把这两个合并成一个，表示这个接口匹配<code>root/method</code></li>
</ul>
</li>
<li>
<p><code>getMatchingCondition</code>:</p>
<ul>
<li>判断是否成功，失败返回null；否则，则返回匹配成功的条件</li>
</ul>
</li>
<li>
<p><code>compareTo</code>:</p>
<ul>
<li>多个都满足条件时，用来指定具体选择哪一个</li>
</ul>
</li>
</ul>
<p>在Spring MVC中，默认提供了下面几种</p>
<table>
<thead>
<tr>
<th>类</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>PatternsRequestCondition</td>
<td>路径匹配，即url</td>
</tr>
<tr>
<td>RequestMethodsRequestCondition</td>
<td>请求方法，注意是指http请求方法</td>
</tr>
<tr>
<td>ParamsRequestCondition</td>
<td>请求参数条件匹配</td>
</tr>
<tr>
<td>HeadersRequestCondition</td>
<td>请求头匹配</td>
</tr>
<tr>
<td>ConsumesRequestCondition</td>
<td>可消费MIME匹配条件</td>
</tr>
<tr>
<td>ProducesRequestCondition</td>
<td>可生成MIME匹配条件</td>
</tr>
</tbody>
</table>
<h2> II. 实例说明</h2>
<p>单纯的看说明，可能不太好理解它的使用方式，接下来我们通过一个实际的case，来演示使用姿势</p>
<h3> 1. 场景说明</h3>
<p>我们有个服务同时针对app/wap/pc三个平台，我们希望可以指定某些接口只为特定的平台提供服务</p>
<h3> 2. 实现</h3>
<p>首先我们定义通过请求头中的<code>x-platform</code>来区分平台；即用户发起的请求中，需要携带这个请求头</p>
<p>定义平台枚举类</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后定义一个注解<code>@Platform</code>，如果某个接口需要指定平台，则加上这个注解即可</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>定义匹配规则<code>PlatformRequestCondition</code>继承自<code>RequestCondition</code>，实现三个接口，从请求头中获取平台，根据平台是否相同过来判定是否可以支持请求</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>匹配规则指定完毕之后，需要注册到HandlerMapping上才能生效，这里我们自定义一个<code>PlatformHandlerMapping</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>最后则是需要将我们的HandlerMapping注册到Spring MVC容器，在这里我们借助<code>WebMvcConfigurationSupport</code>来手动注册(注意一下，不同的版本，下面的方法可能会不太一样哦)</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. 测试</h3>
<p>接下来进入实测环节，定义几个接口，分别指定不同的平台</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果我们的规则可以正常生效，那么在请求头中设置不同的<code>x-platform</code>，返回的结果应该会不一样，实测结果如下</p>
<figure><img src="/imgs/191222/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>注意最后两个，一个是指定了一个不匹配我们的平台的请求头，一个是没有对应的请求头，都是走了默认的匹配规则；这是因为我们在<code>PlatformRequestCondition</code>中做了兼容，无法匹配平台时，分配到默认的<code>Platform.ALL</code></p>
<p>然后还有一个小疑问，如果有一个服务不区分平台，那么不加上<code>@Platform</code>注解是否可以呢?</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当然是可以的实测结果如下:</p>
<figure><img src="/imgs/191222/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>在不加上<code>@Platform</code>注解时，有一点需要注意，这个时候就不能出现多个url和请求方法相同的，在启动的时候会直接抛出异常哦</p>
<figure><img src="/imgs/191222/02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> III. 其他</h2>
<h4> web系列博文</h4>
<ul>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484393&amp;idx=1&amp;sn=84babe4c83fa49fe54605e156f81a18f&amp;chksm=fce71845cb9091533190e99f2928585aea56562312d087f2b2b0e5ae4f082e3393023349e903&amp;token=713643402&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">191206-SpringBoot系列教程web篇Listener四种注册姿势</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484377&amp;idx=1&amp;sn=a20ce7e5e04ede4dff5fa84a7c5c8448&amp;chksm=fce71875cb9091639124afa69d0ec7bbf8f50438fd7acaf582fb029b7a4adf2f36fa50d4f0fa&amp;token=1748723444&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">191122-SpringBoot系列教程web篇Servlet 注册的四种姿势</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484377&amp;idx=2&amp;sn=b341d12c8179ba803d5c82882d9799ee&amp;chksm=fce71875cb90916376c76a901187b396595082c8ab3bd9df699227132430b9a40d2b07b30638&amp;token=713643402&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">191120-SpringBoot系列教程Web篇之开启GZIP数据压缩</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484356&amp;idx=1&amp;sn=7c80f55f875f8d9ed37ef618cd7852ff&amp;chksm=fce71868cb90917ec76ed23990a287b25dfecd6e60300a215ff9b85d9d9db32b3ba1c7b549c7&amp;token=713643402&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">191018-SpringBoot系列教程web篇之过滤器Filter使用指南扩展篇</a></li>
<li><a href="https://mp.weixin.qq.com/s/f01KWO3d2zhoN0Qa9-Qb6w" target="_blank" rel="noopener noreferrer">191016-SpringBoot系列教程web篇之过滤器Filter使用指南</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484348&amp;idx=1&amp;sn=e9b36572c721418b097396b50319d140&amp;chksm=fce71810cb9091063e810327e44f7ed07256188aecd352fa43f37e63e63dc64292b1a48b00cf&amp;token=823367253&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">191012-SpringBoot系列教程web篇之自定义异常处理HandlerExceptionResolver</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484344&amp;idx=1&amp;sn=d4b1422a709d9540583e33443aab6fff&amp;chksm=fce71814cb9091025a960312c878ff9fc4f44fd0035aa597f55f37c90dcbac25a3e96ee2c528&amp;token=118864495&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">191010-SpringBoot系列教程web篇之全局异常处理</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484336&amp;idx=1&amp;sn=d70f15e77bbd219af8015f9037a167fb&amp;chksm=fce7181ccb90910aee427a3f3ed7660e8303c7460859c82622a651ce1cc3d7a97f62f80ed4e0&amp;token=2447275&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">190930-SpringBoot系列教程web篇之404、500异常页面配置</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484322&amp;idx=1&amp;sn=b18090f35b59097f78858b6609506b74&amp;chksm=fce7180ecb909118d939f3ddf741a11c0977b1213d7afa12c970590590d40441c3a085c43c52&amp;token=2447275&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">190929-SpringBoot系列教程web篇之重定向</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484310&amp;idx=1&amp;sn=f6259cf1b79db095ff2e9534993d27cf&amp;chksm=fce7183acb90912cd150f086e90ecab3eceb3464e9352853e2e722288d412dbb3eb20c6e6ae7&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190913-SpringBoot系列教程web篇之返回文本、网页、图片的操作姿势</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484309&amp;idx=1&amp;sn=33d782f7529268eef6607a1ab8d41018&amp;chksm=fce71839cb90912f6020aa9463bc0136cb57969ebe27eba865d97e212c28211435791aa874ea&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190905-SpringBoot系列教程web篇之中文乱码问题解决</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484291&amp;idx=1&amp;sn=3f7e8c92ca4d7270cc5c40cafea39683&amp;chksm=fce7182fcb90913922654a4f2f04e7029b8944d71c31741334a3235aecbe1e60babcb0c0be74&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190831-SpringBoot系列教程web篇之如何自定义参数解析器</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484287&amp;idx=1&amp;sn=44461f564d6b04cbf1a5902dcb4f23c6&amp;chksm=fce718d3cb9091c5d730e63ae954c0831d53f3dd5af5d19d9c78b6009102838efaf56f7838ff&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190828-SpringBoot系列教程web篇之Post请求参数解析姿势汇总</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484282&amp;idx=1&amp;sn=a8d236d935ae24cfbe6977e24a479caa&amp;chksm=fce718d6cb9091c0dd8a6b113236f9ae9388fb026c9403c97bdf7505f773bd7330a43e3b269c&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190824-SpringBoot系列教程web篇之Get请求参数解析姿势汇总</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484268&amp;idx=3&amp;sn=9e8a6121dce291c65bd2b3d4fab24178&amp;chksm=fce718c0cb9091d6674fb809d68ca3dc3b1695162368481abf8dc094000412116d2f9971c54b&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190822-SpringBoot系列教程web篇之Beetl环境搭建</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484268&amp;idx=2&amp;sn=f800c001061eabe74e2cad915af1921a&amp;chksm=fce718c0cb9091d682b600673a0584955783f0d339248e34323efbea9b698560c432018717ef&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190820-SpringBoot系列教程web篇之Thymeleaf环境搭建</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484268&amp;idx=1&amp;sn=acd691729488d81a94c938151d5737ce&amp;chksm=fce718c0cb9091d63ef5f12893bb835c256a18318e791a0d193d00ef767ecfd019491d02e83d&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190816-SpringBoot系列教程web篇之Freemaker环境搭建</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484217&amp;idx=1&amp;sn=9fdf45d2261cdcf2ccaccaebfb5ef598&amp;chksm=fce71895cb90918361f1afd55a2b5fc9d65508913c1d793710afa79cae38bd9d57e32ad2c187&amp;token=2447275&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">190421-SpringBoot高级篇WEB之websocket的使用说明</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484197&amp;idx=1&amp;sn=0184953527f58058ee8c2bbcfc2689ec&amp;chksm=fce71889cb90919f9be003bf2487343f7952d6b33ab5ee5fb7251ae37a631d4c32e6d8a57528&amp;token=2447275&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">190327-Spring-RestTemplate之urlencode参数解析异常全程分析</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484193&amp;idx=1&amp;sn=d8a284fe0a2b8e1fefe07d892558f563&amp;chksm=fce7188dcb90919b1f8a2408bf955e37e88b043e2dbd59b5290ac1501e3d2d303512bac6af2c&amp;token=2447275&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">190317-Spring MVC之基于java config无xml配置的web应用构建</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484186&amp;idx=1&amp;sn=18db571b670815965ae9185830c4e88f&amp;chksm=fce718b6cb9091a054e0ac4be051341d8ce38ff8e40c5911302e3d6981206c14b80770590044&amp;token=2447275&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">190316-Spring MVC之基于xml配置的web应用构建</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484139&amp;idx=1&amp;sn=b4a5f3ca6215641c6bcf5123f2bfb501&amp;chksm=fce71947cb9090511042ae97a12cc975d2b199521e17980e685cccb5e0be91a8e932cef4eb76&amp;token=2447275&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">190213-SpringBoot文件上传异常之提示The temporary upload location xxx is not valid</a></li>
</ul>
<h4> 项目源码</h4>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>项目: <a href="https://github.com/liuyueyi/spring-boot-demo/blob/master/spring-boot/208-web-mapping" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/blob/master/spring-boot/208-web-mapping</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/191222/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>5.参数校验Validation</title>
      <link>https://liuyueyi.github.io/tutorial/spring/web/Request/200526-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B9%8B%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/web/Request/200526-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B9%8B%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">5.参数校验Validation</source>
      <description>业务开发的小伙伴总有那么几个无法逃避的点，如大段if/else，接口的参数校验等。接下来将介绍几种使用Validation-Api的方式，来实现参数校验，让我们的业务代码更简洁</description>
      <category>SpringBoot</category>
      <category>WEB系列</category>
      <category>Request</category>
      <pubDate>Tue, 26 May 2020 09:14:34 GMT</pubDate>
      <content:encoded><![CDATA[<p>业务开发的小伙伴总有那么几个无法逃避的点，如大段if/else，接口的参数校验等。接下来将介绍几种使用<code>Validation-Api</code>的方式，来实现参数校验，让我们的业务代码更简洁</p>
<!-- more -->
<h2> I. 基本知识点</h2>
<h3> 1. validation-api</h3>
<p>参数校验有自己的一个规范JSR303, 它是一套 JavaBean 参数校验的标准，它定义了很多常用的校验注解。</p>
<p>java开发环境中，可以通过引入<code>validation-api</code>包的相关注解，来实现参数的条件限定</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>请注意上面这个包只是定义，如果项目中单独的引入上面的这个包，并没有什么效果，我们通常选用<code>hibernate-validator</code>来作为具体的实现</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>下面给出一些常用的参数限定注解</p>
<table>
<thead>
<tr>
<th>注解</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>@AssertFalse</code></td>
<td>被修饰的元素必须为 false</td>
</tr>
<tr>
<td><code>@AssertTrue</code></td>
<td>被修饰的元素必须是true</td>
</tr>
<tr>
<td><code>@DecimalMax</code></td>
<td>被修饰的元素必须是一个数字，其值必须小于等于指定的最大值</td>
</tr>
<tr>
<td><code>@DecimalMin</code></td>
<td>同DecimalMax</td>
</tr>
<tr>
<td><code>@Digits</code></td>
<td>被修饰的元素是数字</td>
</tr>
<tr>
<td><code>@Email</code></td>
<td>被修饰的元素必须是邮箱格式</td>
</tr>
<tr>
<td><code>@Future</code></td>
<td>将来的日期</td>
</tr>
<tr>
<td><code>@Max</code></td>
<td>被修饰的元素必须是一个数字，其值必须小于等于指定的最大值</td>
</tr>
<tr>
<td><code>@Min</code></td>
<td>被修饰的元素必须是一个数字，其值必须大于等于指定的最小值</td>
</tr>
<tr>
<td><code>@NotNull</code></td>
<td>不能是Null</td>
</tr>
<tr>
<td><code>@Null</code></td>
<td>元素是Null</td>
</tr>
<tr>
<td><code>@Past</code></td>
<td>被修饰的元素必须是一个过去的日期</td>
</tr>
<tr>
<td><code>@Pattern</code></td>
<td>被修饰的元素必须符合指定的正则表达式</td>
</tr>
<tr>
<td><code>@Size</code></td>
<td>被修饰的元素长度</td>
</tr>
<tr>
<td><code>@Positive</code></td>
<td>正数</td>
</tr>
<tr>
<td><code>@PositiveOrZero</code></td>
<td>0 or 正数</td>
</tr>
<tr>
<td><code>@Negative</code></td>
<td>负数</td>
</tr>
<tr>
<td><code>@NegativeOrZero</code></td>
<td>0 or 负数</td>
</tr>
</tbody>
</table>
<h3> 2. 项目搭建</h3>
<p>接下来我们创建一个SpringBoot项目，用于后续的实例演示</p>
<p>我们采用IDEA + JDK1.8 进行项目开发</p>
<ul>
<li>SpringBoot: <code>2.2.1.RELEASE</code></li>
</ul>
<p>pom核心依赖如下</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>请注意</strong> 并没有显示的添加上一小节的两个依赖，因为已经集成在start包中了</p>
<h2> II. 实例演示</h2>
<p>接下来我们进入实例演示环节，会给出几种常见的使用case，以及如何扩展参数校验，使其支持自己定制化的参数校验规则</p>
<h3> 1. 校验失败抛异常</h3>
<p>如果我们的参数校验失败，直接抛异常，可以说是最简单的使用方式了；首先我们创建一个简单ReqDo，并对参数进行一些必要的限定</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后提供一个rest接口</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>参数左边有一个<code>@Valid</code>注解，用于表示这个对象需要执行参数校验，如果校验失败，会抛400错误</p>
<p>演示如下</p>
<figure><img src="/imgs/200526/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 2. BindingResult</h3>
<p>将校验失败的结果塞入<code>BindingResult</code>，避免直接返回400，这种方式只需要在方法参数中，加一个对象即可，通过它来获取所有的参数异常错误</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/200526/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 3. 手动校验</h3>
<p>除了上面两个借助 <code>@Valid</code> 注解修饰，自动实现参数校验之外，我们还可以手动校验一个DO是否准确，下面给出一个简单的实例</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/200526/02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 4. 自定义参数校验</h3>
<p>虽然JSR303规范中给出了一些常见的校验限定，但显示的业务场景千千万万，总会有覆盖不到的地方，比如最简单的手机号校验就没有，所以可扩展就很有必要了，接下来我们演示一下，自定义一个身份证校验的注解</p>
<p>首先定义注解 <code>@IdCard</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的实现中，有几个需要注意的点</p>
<ul>
<li><code>@Constraint</code> 注解，指定校验器为 <code>IdCardValidator</code>, 即表示待有<code>@IdCard</code>直接的属性，由<code>IdCardValidator</code>来校验是否合乎规范</li>
<li><code>groups</code>: 分组，主要用于不同场景下，校验方式不一样的case
<ul>
<li>如新增数据时，主键id可以为空；更新数据时，主键id不能为空</li>
</ul>
</li>
<li><code>payload</code>: 知道这个具体干嘛用的老哥请留言指点一下</li>
</ul>
<p>接下来完成身份证号的校验器<code>IdCardValidator</code></p>
<blockquote>
<p>这里直接借助<code>hutool</code>工具集中的<code>cn.hutool.core.util.IdcardUtil#isValidCard</code>来实现身份证有效性判断</p>
</blockquote>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后将我们前面的ReqDo修改一下，新增一个身份证的字段</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>再次访问测试(说明，图1中身份证号是随便填的，图2中的身份证号是<code>http://sfz.uzuzuz.com/</code>这个网站生成的，并不指代真实的某个小伙伴)</p>
<p><img src="/imgs/200526/03.jpg" alt="IdCard校验" loading="lazy">
<img src="/imgs/200526/04.jpg" alt="IdCard校验" loading="lazy"></p>
<h2> II. 其他</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码: <a href="https://github.com/liuyueyi/spring-boot-demo/spring-boot/202-web-params-validate" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/spring-boot/202-web-params-validate</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/200526/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>6.静态资源配置与读取</title>
      <link>https://liuyueyi.github.io/tutorial/spring/web/Request/200611-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8BWeb%E7%AF%87%E4%B9%8B%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E9%85%8D%E7%BD%AE.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/web/Request/200611-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8BWeb%E7%AF%87%E4%B9%8B%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E9%85%8D%E7%BD%AE.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">6.静态资源配置与读取</source>
      <description>SpringWeb项目除了我们常见的返回json串之外，还可以直接返回静态资源（当然在现如今前后端分离比较普遍的情况下，不太常见了），一些简单的web项目中，前后端可能就一个人包圆了，前端页面，js/css文件也都直接放在Spring项目中，那么你知道这些静态资源文件放哪里么</description>
      <category>SpringBoot</category>
      <category>WEB系列</category>
      <category>Request</category>
      <pubDate>Thu, 11 Jun 2020 08:47:54 GMT</pubDate>
      <content:encoded><![CDATA[<p>SpringWeb项目除了我们常见的返回json串之外，还可以直接返回静态资源（当然在现如今前后端分离比较普遍的情况下，不太常见了），一些简单的web项目中，前后端可能就一个人包圆了，前端页面，js/css文件也都直接放在Spring项目中，那么你知道这些静态资源文件放哪里么</p>
<!-- more -->
<h2> I. 默认配置</h2>
<h3> 1. 配置</h3>
<p>静态资源路径，SpringBoot默认从属性<code>spring.resources.static-locations</code>中获取</p>
<p>默认值可以从<code>org.springframework.boot.autoconfigure.web.ResourceProperties#CLASSPATH_RESOURCE_LOCATIONS</code>获取</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意上面的默认值，默认有四个，优先级从高到低</p>
<ul>
<li><code>/META-INF/resources/</code></li>
<li><code>/resources/</code></li>
<li><code>/static/</code></li>
<li><code>/public/</code></li>
</ul>
<h3> 2. 实例演示</h3>
<blockquote>
<p>默认静态资源路径有四个，所以我们设计case需要依次访问这四个路径中的静态资源，看是否正常访问到；其次就是需要判定优先级的问题，是否和上面说的一致</p>
</blockquote>
<p>首先创建一个SpringBoot web项目，工程创建流程不额外多说，pom中主要确保有下面依赖即可（本文使用版本为: <code>2.2.1.RELEASE</code>)</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在资源文件夹<code>resources</code>下，新建四个目录，并添加html文件，用于测试是否可以访问到对应的资源文件（主要关注下图中标红的几个文件）</p>
<figure><img src="/imgs/200611/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h4> a. META-INF/resources</h4>
<p>静态文件 m.html</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>完成对应的Rest接口</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/200611/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h4> b. resources</h4>
<p>静态文件 r.html</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对应的Rest接口</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/200611/02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h4> c. static</h4>
<p>静态文件 s.html</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对应的Rest接口</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/200611/03.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h4> d. public</h4>
<p>静态文件 p.html</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对应的Rest接口</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/200611/04.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h4> e. 优先级测试</h4>
<p>关于优先级的测试用例，主要思路就是在上面四个不同的文件夹下面放相同文件名的静态资源，然后根据访问时具体的返回来确定相应的优先级。相关代码可以在文末的源码中获取，这里就不赘述了</p>
<h2> II. 自定义资源路径</h2>
<p>一般来讲，我们的静态资源放在上面的四个默认文件夹下面已经足够，但总会有特殊情况，如果资源文件放在其他的目录下，应该怎么办？</p>
<h3> 1. 修改配置文件</h3>
<p>第一种方式比较简单和实用，修改上面的<code>spring.resources.static-locations</code>配置，添加上自定义的资源目录，如在 <code>application.yml</code> 中，指定配置</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面指定了可以扫描<code>/out</code>目录下的静态资源文件，且它的优先级是最高的（上面的配置顺序中，优先级的高低从左到右）</p>
<p><strong>实例演示</strong></p>
<p>在资源目录下，新建文件<code>/out/index.html</code></p>
<figure><img src="/imgs/200611/05.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>请注意在其他的四个资源目录下，也都存在 <code>index.html</code>这个文件（根据上面优先级的描述，返回的应该是<code>/out/index.html</code>）</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/200611/06.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 2. WebMvcConfigurer 添加资源映射</h3>
<p>除了上述的配置指定之外，还有一种常见的使用姿势就是利用配置类<code>WebMvcConfigurer</code>来手动添加资源映射关系，为了简单起见，我们直接让启动类实现<code>WebMvcConfigure</code>接口</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>根据上面的配置表示将/ts目录下的资源ts.html，映射到/ts/ts，而直接访问/ts会报404（这个逻辑可能有点绕，需要仔细想一想）</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/200611/07.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> III. Jar包资源访问</h2>
<p>前面描述的静态资源访问主要都是当前包内的资源访问，如果我们的静态资源是由第三方的jar包提供（比如大名鼎鼎的Swagger UI)，这种时候使用姿势是否有不一样的呢？</p>
<h3> 1. classpath 与 classpath*</h3>
<p>在之前使用<code>SpringMVC3+/4</code>的时候，<code>classpath:/META-INF/resources/</code>表示只扫描当前包内的<code>/META-INF/resources/</code>路径，而<code>classpath*:/META-INF/resources/</code>则会扫描当前+第三方jar包中的<code>/META-INF/resources/</code>路径</p>
<p>那么在<code>SpringBoot2.2.1-RELEASE</code>版本中是否也需要这样做呢？（答案是不需要，且看后面的实例）</p>
<h3> 2. 实例</h3>
<p>新建一个工程，只提供基本的html静态资源，项目基本结构如下（具体的html内容就不粘贴了，墙裂建议有兴趣的小伙伴直接看源码，阅读效果更优雅）</p>
<figure><img src="/imgs/200611/08.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>接着在我们上面常见的工程中，添加依赖</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>添加对应资源的访问端点</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>请注意，这个时候我们是没有修改前面的<code>spring.resources.static-locations</code>配置的</p>
<figure><img src="/imgs/200611/09.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>上面的访问结果，除了说明访问第三方jar包中的静态资源与当前包的静态资源配置没有什么区别之外，还可以得出一点</p>
<ul>
<li>相同资源路径下，当前包的资源优先级高于jar包中的静态资源</li>
<li>默认配置下，第三方jar包中<code>META-INF/resources</code>下的静态资源，优先级高于当前包的<code>/resources</code>, <code>/static</code>, <code>/public</code></li>
</ul>
<h2> IV. 其他</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：<a href="https://github.com/liuyueyi/spring-boot-demo/spring-boot/204-web-static-resources" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/spring-boot/204-web-static-resources</a></li>
<li><a href="https://github.com/liuyueyi/spring-boot-demo/spring-boot/204-web-static-resources-ui" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/spring-boot/204-web-static-resources-ui</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/200611/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>7.xml传参与返回使用姿势</title>
      <link>https://liuyueyi.github.io/tutorial/spring/web/Request/200706-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B9%8Bxml%E4%BC%A0%E5%8F%82%E4%B8%8E%E8%BF%94%E5%9B%9E%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/web/Request/200706-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B9%8Bxml%E4%BC%A0%E5%8F%82%E4%B8%8E%E8%BF%94%E5%9B%9E%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">7.xml传参与返回使用姿势</source>
      <description>使用XML作为传参和返回结果，在实际的编码中可能不太常见，特别是当前json大行其道的时候；那么为什么突然来这么一出呢？源于对接微信公众号的消息接收，自动回复的开发时，惊奇的发现微信使用xml格式进行交互，所以也就不得不支持了 下面介绍一下SpringBoot中如何支持xml传参解析与返回xml文档</description>
      <category>SpringBoot</category>
      <category>WEB系列</category>
      <category>Request</category>
      <pubDate>Mon, 06 Jul 2020 07:43:45 GMT</pubDate>
      <content:encoded><![CDATA[<p>使用XML作为传参和返回结果，在实际的编码中可能不太常见，特别是当前json大行其道的时候；那么为什么突然来这么一出呢？源于对接微信公众号的消息接收，自动回复的开发时，惊奇的发现微信使用xml格式进行交互，所以也就不得不支持了</p>
<p>下面介绍一下SpringBoot中如何支持xml传参解析与返回xml文档</p>
<!-- more -->
<h2> I. 项目环境</h2>
<p>本文创建的实例工程采用<code>SpringBoot 2.2.1.RELEASE</code> + <code>maven 3.5.3</code> + <code>idea</code>进行开发</p>
<h3> 1. pom依赖</h3>
<p>具体的SpringBoot项目工程创建就不赘述了，对于pom文件中，需要重点关注下面两个依赖类</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>请注意jackson-dataformat-xml版本，不要选择太老的</strong></p>
<h2> II. 实例演示</h2>
<h3> 1. 传参Bean</h3>
<p>定义一个接受参数的bean对象，如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>请注意，我们使用<code>@JacksonXmlRootElement</code>注解来修饰这个bean，localName中的value，相当于xml的根标签；如果类中的属性成员名，和xml标签名不一样，可以使用注解<code>@JacksonXmlProperty(localName = "xxx")</code>来修饰</p>
<p>其次，请保留bean的默认无参构造函数，get/set方法 （我上面为了简洁，使用了lombok（最近看到了不少抨击lombok的文章...），不希望使用lombok的小伙伴，可以利用IDEA的自动生成，来实现相关的代码）</p>
<h3> 2. Response Bean</h3>
<p>定义返回的也是一个xml bean</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. rest服务</h3>
<p>然后像平常一样，实现一个"普通"的rest服务即可</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意三点</p>
<ul>
<li><code>@RestController</code>：返回的不是视图</li>
<li><code>@PostMapping</code>注解中的 <code>consumes</code> 和 <code>produces</code>参数，指定了"application/xml"，表示我们接收和返回的都是xml文档</li>
<li><code>@RequestBody</code>：不加这个注解时，无法获取传参哦（可以想一想why?)</li>
</ul>
<p><strong>接口测试</strong></p>
<p>我个人倾向于万能的curl进行测试，打开终端即可使用，如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/200706/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>考虑到有些小伙伴更青睐于Postman进行url测试，下面是具体的请求姿势</p>
<figure><img src="/imgs/200706/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 4. 解析异常问题</h3>
<blockquote>
<p>如果需要重新这个问题，可以参考项目: <a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/202-web-params" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/202-web-params</a></p>
</blockquote>
<p>某些场景下，直接使用上面的姿势貌似不能正常工作，会抛出一个<code>Resolved [org.springframework.web.HttpMediaTypeNotSupportedException: Content type 'application/xml;charset=UTF-8' not supported]</code>的异常信息</p>
<p>针对出现<code>HttpMediaTypeNotSupportedException</code>的场景，解决办法也很明确，增加一个xml的<code>HttpMesssageConverter</code>即可，依然是借助<code>MappingJackson2XmlHttpMessageConverter</code>，如</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> II. 其他</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/202-web-params" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/202-web-params</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/200706/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>8.xml传参与返回实战演练</title>
      <link>https://liuyueyi.github.io/tutorial/spring/web/Request/220704-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B9%8BXML%E4%BC%A0%E5%8F%82%E8%BF%94%E5%9B%9E%E5%AE%9E%E6%88%98.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/web/Request/220704-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B9%8BXML%E4%BC%A0%E5%8F%82%E8%BF%94%E5%9B%9E%E5%AE%9E%E6%88%98.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">8.xml传参与返回实战演练</source>
      <description>最近在准备使用微信公众号来做个人站点的登录，发现微信的回调协议居然是xml格式的，之前使用json传输的较多，结果发现换成xml之后，好像并没有想象中的那么顺利，比如回传的数据始终拿不到，返回的数据对方不认等 接下来我们来实际看一下，一个传参和返回都是xml的SpringBoot应用，究竟是怎样的</description>
      <category>SpringBoot</category>
      <category>WEB系列</category>
      <category>Request</category>
      <pubDate>Mon, 04 Jul 2022 21:43:45 GMT</pubDate>
      <content:encoded><![CDATA[<p>最近在准备使用微信公众号来做个人站点的登录，发现微信的回调协议居然是xml格式的，之前使用json传输的较多，结果发现换成xml之后，好像并没有想象中的那么顺利，比如回传的数据始终拿不到，返回的数据对方不认等</p>
<p>接下来我们来实际看一下，一个传参和返回都是xml的SpringBoot应用，究竟是怎样的</p>
<!-- more -->
<h2> I. 项目搭建</h2>
<p>本文创建的实例工程采用<code>SpringBoot 2.2.1.RELEASE</code> + <code>maven 3.5.3</code> + <code>idea</code>进行开发</p>
<h3> 1. pom依赖</h3>
<p>具体的SpringBoot项目工程创建就不赘述了，对于pom文件中，需要重点关注下面两个依赖类</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 接口调研</h3>
<p>我们直接使用微信公众号的回调传参、返回来搭建项目服务，微信开发平台文档如: <a href="https://developers.weixin.qq.com/doc/offiaccount/Message_Management/Receiving_standard_messages.html" target="_blank" rel="noopener noreferrer">基础消息能力</a></p>
<p>其定义的推送参数如下</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>要求返回的结果如下</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的结构看起来还好，但是需要注意的是外层标签为<code>xml</code>，内层标签都是大写开头的；而微信识别返回是大小写敏感的</p>
<h2> II. 实战</h2>
<p>项目工程搭建完毕之后，首先定义一个接口，用于接收xml传参，并返回xml对象；</p>
<p>那么核心的问题就是如何定义传参为xml，返回也是xml呢？</p>
<blockquote>
<p>没错：就是请求头 + 返回头</p>
</blockquote>
<h3> 1.REST接口</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意上面的接口定义，POST传参，请求头和返回头都是 <code>application/xml</code></p>
<h3> 2.请求参数与返回结果对象定义</h3>
<p>上面的接口中定义了<code>WxTxtMsgReqVo</code>来接收传参，定义<code>WxTxtMsgResVo</code>来返回结果，由于我们采用的是xml协议传输数据，这里需要借助<code>JacksonXmlRootElement</code>和<code>JacksonXmlProperty</code>注解；它们的实际作用与json传输时，使用<code>JsonProperty</code>来指定json key的作用相仿</p>
<p>下面是具体的实体定义</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>重点说明：</p>
<ul>
<li>JacksonXmlRootElement 注解，定义返回的xml文档中最外层的标签名</li>
<li>JacksonXmlProperty 注解，定义每个属性值对应的标签名</li>
<li>无需额外添加<code>&lt;![CDATA[...]]&gt;</code>，这个会自动添加，防转义</li>
</ul>
<h3> 3.测试</h3>
<p>然后访问测试一下，直接通过curl来发送xml请求</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>实际响应如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4.问题记录</h3>
<h4> 4.1 HttpMediaTypeNotSupportedException异常</h4>
<p>通过前面的方式搭建项目之后，在实际测试时，可能会遇到下面的异常情况<code>Resolved [org.springframework.web.HttpMediaTypeNotSupportedException: Content type 'application/xml;charset=UTF-8' not supported]</code></p>
<p>当出现这个问题时，表明是没有对应的Convert来处理<code>application/xml</code>格式的请求头</p>
<p>对应的解决方案则是主动注册上</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 4.2 其他json接口也返回xml数据</h4>
<p>另外一个场景则是配置了前面的xml之后，导致项目中其他正常的json传参、返回的接口也开始返回xml格式的数据了，此时解决方案如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 4.3 微信实际回调参数一直拿不到</h4>
<p>这个问题是在实际测试回调的时候遇到的，接口定义之后始终拿不到结果，主要原因就在于最开始没有在定义的实体类上添加 <code>@JacksonXmlProperty</code></p>
<p>当我们没有指定这个注解时，接收的xml标签名与实体对象的fieldName完全相同，既区分大小写</p>
<p>所以为了解决这个问题，就是老老实实如上面的写法，在每个成员上添加注解，如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 5.小结</h3>
<p>本文主要介绍的是SpringBoot如何支持xml格式的传参与返回，大体上使用姿势与json格式并没有什么区别，但是在实际使用的时候需要注意上面提出的几个问题，避免采坑</p>
<p>关键知识点提炼如下：</p>
<ul>
<li>Post接口上，指定请求头和返回头：
<ul>
<li><code>consumes = {"application/xml", "text/xml"},</code></li>
<li><code>produces = "application/xml;charset=utf-8"</code></li>
</ul>
</li>
<li>实体对象，通过<code>JacksonXmlRootElement</code>和<code>JacksonXmlProperty</code>来重命名返回的标签名</li>
<li>注册<code>MappingJackson2XmlHttpMessageConverter</code>解决HttpMediaTypeNotSupportedException异常</li>
<li>指定<code>ContentNegotiationConfigurer.defaultContentType</code> 避免出现所有接口返回xml文档</li>
</ul>
<h2> III. 其他</h2>
<h3> 0. 项目与源码</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/204-web-xml" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/204-web-xml</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>Web请求知识点</title>
      <link>https://liuyueyi.github.io/tutorial/spring/web/Request/</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/web/Request/</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">Web请求知识点</source>
      <description>请求参数如何解析？如何自定义参数转换器？参数校验怎么做？路由匹配又是什么？交互协议JSON还是XML？如有这些疑问，请打开这个教程</description>
      <pubDate>Fri, 10 Feb 2023 04:50:05 GMT</pubDate>
      <content:encoded><![CDATA[<p>请求参数如何解析？如何自定义参数转换器？参数校验怎么做？路由匹配又是什么？交互协议JSON还是XML？如有这些疑问，请打开这个教程</p>
]]></content:encoded>
    </item>
    <item>
      <title>1.Freemaker环境搭建</title>
      <link>https://liuyueyi.github.io/tutorial/spring/web/Response/190816-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8Bweb%E7%AF%87%E4%B9%8BFreemaker%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/web/Response/190816-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8Bweb%E7%AF%87%E4%B9%8BFreemaker%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">1.Freemaker环境搭建</source>
      <description>现在的开发现状比较流行前后端分离，使用springboot搭建一个提供rest接口的后端服务特别简单，引入spring-boot-starter-web依赖即可。那么在不分离的场景下，比如要开发一个后端使用的控制台，这时候可能并没有前端资源，由javaer自己来客串一把，我希望简单一点，前后端项目都集成在一起，一个jar包运行起来就完事，可以怎么搞呢？ 本篇将介绍一下如何使用springboot集合freemaker引擎来搭建web应用</description>
      <category>SpringBoot</category>
      <category>WEB系列</category>
      <category>Response</category>
      <pubDate>Fri, 16 Aug 2019 16:26:25 GMT</pubDate>
      <content:encoded><![CDATA[<p>现在的开发现状比较流行前后端分离，使用springboot搭建一个提供rest接口的后端服务特别简单，引入<code>spring-boot-starter-web</code>依赖即可。那么在不分离的场景下，比如要开发一个后端使用的控制台，这时候可能并没有前端资源，由javaer自己来客串一把，我希望简单一点，前后端项目都集成在一起，一个jar包运行起来就完事，可以怎么搞呢？</p>
<p>本篇将介绍一下如何使用springboot集合freemaker引擎来搭建web应用</p>
<!-- more -->
<h2> I. 准备</h2>
<blockquote>
<p>Freemaker是模板引擎，和jsp的作用差不多，对于它的不太清楚的同学可以参考一下官方文档
<a href="https://freemarker.apache.org/docs/index.html" target="_blank" rel="noopener noreferrer">https://freemarker.apache.org/docs/index.html</a></p>
</blockquote>
<h3> 1. 依赖</h3>
<p>首先我们是需要一个springboot项目，基本的pom结构大都相似</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个项目中，我们主要需要引入两个依赖包，一个web，一个freemaker</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 配置参数</h3>
<p>通常我们直接使用默认的freemaker参数配置即可，下面给出几个常用的</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>freemaker的参数，主要对应的是<code>org.springframework.boot.autoconfigure.freemarker.FreeMarkerProperties</code></p>
<h2> II. 项目搭建演示</h2>
<h3> 1. 项目结构</h3>
<p>搭建一个web项目和我们之前的纯后端项目有点不一样，前端资源放在什么地方，依赖文件怎么处理都是有讲究的，下面是一个常规的项目结构</p>
<figure><img src="/imgs/190816/00.jpg" alt="项目结构" tabindex="0" loading="lazy"><figcaption>项目结构</figcaption></figure>
<p>如上图，前端资源文件默认放在resources目录下，下面有两个目录</p>
<ul>
<li><code>templates</code>：存放模板文件，可以理解为我们编写的html，注意这个文件名不能有问题</li>
<li><code>static</code>: 存放静态资源文件，如js,css,image等</li>
</ul>
<h3> 2. Rest服务</h3>
<p>我们这里提供了三个接口，主要是为了演示三种不同的数据绑定方式</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的三种case中</p>
<ul>
<li>第一个是最好理解的，在创建<code>ModelAndView</code>时，传入viewName和数据</li>
<li>第二个是通过接口参数Model，设置传递给view的数据</li>
<li>第三种则直接使用Map来传递数据</li>
</ul>
<p>三个接口，对应的三个html文件，如下</p>
<p><strong>index.ftl</strong></p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>show1.ftl</strong></p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>show2.ft</strong></p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面的模板文件中，需要注意引用css样式文件，路径前面并没有static，我们对应的css文件</p>
<p><strong>index.css</strong></p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. 演示</h3>
<p>启动项目后，可以看到三个页面的切换，模板中的数据根据后端的返回替换，特别是主页的时间，每次刷新都会随之改变</p>
<figure><img src="/imgs/190816/01.gif" alt="demo" tabindex="0" loading="lazy"><figcaption>demo</figcaption></figure>
<h2> II. 其他</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>项目地址: <a href="https://github.com/liuyueyi/spring-boot-demo/blob/master/spring-boot/204-web-freemaker" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/blob/master/spring-boot/204-web-freemaker</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/190816/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>2.Thymeleaf环境搭建</title>
      <link>https://liuyueyi.github.io/tutorial/spring/web/Response/190820-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8Bweb%E7%AF%87%E4%B9%8BThymeleaf%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/web/Response/190820-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8Bweb%E7%AF%87%E4%B9%8BThymeleaf%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">2.Thymeleaf环境搭建</source>
      <description>上一篇博文介绍了如何使用Freemaker引擎搭建web项目，这一篇我们则看一下另外一个常见的页面渲染引擎Thymeleaf如何搭建一个web项目 推荐结合Freemaker博文一起查看，效果更佳 190816-SpringBoot系列教程web篇之Freemaker环境搭建</description>
      <category>SpringBoot</category>
      <category>WEB系列</category>
      <category>Response</category>
      <pubDate>Tue, 20 Aug 2019 21:33:19 GMT</pubDate>
      <content:encoded><![CDATA[<p>上一篇博文介绍了如何使用Freemaker引擎搭建web项目，这一篇我们则看一下另外一个常见的页面渲染引擎Thymeleaf如何搭建一个web项目</p>
<blockquote>
<p>推荐结合Freemaker博文一起查看，效果更佳 <a href="http://spring.hhui.top/spring-blog/2019/08/16/190816-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8Bweb%E7%AF%87%E4%B9%8BFreemaker%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" target="_blank" rel="noopener noreferrer">190816-SpringBoot系列教程web篇之Freemaker环境搭建</a></p>
</blockquote>
<!-- more -->
<h2> I. 准备</h2>
<blockquote>
<p>Thymeleaf 是现代化服务器端的Java模板引擎，不同与JSP和FreeMarker，Thymeleaf的语法更加接近HTML，关于它的使用说明，可以参考官方文档
<a href="https://www.thymeleaf.org/documentation.html" target="_blank" rel="noopener noreferrer">https://www.thymeleaf.org/documentation.html</a></p>
</blockquote>
<h3> 1. 依赖</h3>
<p>首先我们是需要一个springboot项目，基本的pom结构大都相似</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个项目中，我们主要需要引入两个依赖包，一个web，一个thymeleaf</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 配置参数</h3>
<p>通常我们直接使用默认的thymeleaf参数配置即可，下面给出几个常用的配置</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>thymeleaf的参数，主要对应的是<code>org.springframework.boot.autoconfigure.thymeleaf.ThymeleafProperties</code></p>
<h2> II. 项目搭建演示</h2>
<h3> 1. 项目结构</h3>
<p>搭建一个web项目和我们之前的纯后端项目有点不一样，前端资源放在什么地方，依赖文件怎么处理都是有讲究的，下面是一个常规的项目结构</p>
<figure><img src="/imgs/190820/00.jpg" alt="项目结构" tabindex="0" loading="lazy"><figcaption>项目结构</figcaption></figure>
<p>如上图，前端资源文件默认放在resources目录下，下面有两个目录</p>
<ul>
<li><code>templates</code>：存放模板文件，可以理解为我们编写的html，注意这个文件名不能有问题</li>
<li><code>static</code>: 存放静态资源文件，如js,css,image等</li>
</ul>
<h3> 2. Rest服务</h3>
<p>我们这里提供了三个接口，主要是为了演示三种不同的数据绑定方式（和Freemaker这篇博文基本一样）</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的三种case中</p>
<ul>
<li>第一个是最好理解的，在创建<code>ModelAndView</code>时，传入viewName和数据</li>
<li>第二个是通过接口参数Model，设置传递给view的数据</li>
<li>第三种则直接使用Map来传递数据</li>
</ul>
<p>三个接口，对应的三个html文件，如下</p>
<p><strong>index.html</strong></p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>show1.html</strong></p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>show2.html</strong></p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面的模板文件中，需要注意引用css样式文件，路径前面并没有static，我们对应的css文件</p>
<p><strong>index.css</strong></p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. 演示</h3>
<p>启动项目后，可以看到三个页面的切换，模板中的数据根据后端的返回替换，特别是主页的时间，每次刷新都会随之改变</p>
<figure><img src="/imgs/190820/01.gif" alt="演示" tabindex="0" loading="lazy"><figcaption>演示</figcaption></figure>
<h2> II. 其他</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>项目地址: <a href="https://github.com/liuyueyi/spring-boot-demo/blob/master/spring-boot/205-web-thymeleaf" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/blob/master/spring-boot/205-web-thymeleaf</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/190820/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>3.Beetl环境搭建</title>
      <link>https://liuyueyi.github.io/tutorial/spring/web/Response/190822-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8Bweb%E7%AF%87%E4%B9%8BBeetl%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/web/Response/190822-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8Bweb%E7%AF%87%E4%B9%8BBeetl%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">3.Beetl环境搭建</source>
      <description>前面两篇分别介绍了目前流行的模板引擎Freemaker和Thymeleaf构建web应用的方式，接下来我们看一下号称性能最好的国产模板引擎Beetl，如何搭建web环境 本文主要来自官方文档，如有疑问，推荐查看: http://ibeetl.com/guide/#beetl</description>
      <category>SpringBoot</category>
      <category>WEB系列</category>
      <category>Response</category>
      <pubDate>Thu, 22 Aug 2019 19:25:47 GMT</pubDate>
      <content:encoded><![CDATA[<p>前面两篇分别介绍了目前流行的模板引擎Freemaker和Thymeleaf构建web应用的方式，接下来我们看一下号称性能最好的国产模板引擎Beetl，如何搭建web环境</p>
<blockquote>
<p>本文主要来自官方文档，如有疑问，推荐查看: <a href="http://ibeetl.com/guide/#beetl" target="_blank" rel="noopener noreferrer">http://ibeetl.com/guide/#beetl</a></p>
</blockquote>
<!-- more -->
<h2> I. 准备</h2>
<h3> 1. 依赖</h3>
<p>首先我们是需要一个springboot项目，基本的pom结构大都相似</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个项目中，我们主要需要引入两个依赖包，一个web，一个官方提供的<code>beetl-framework-starter</code>，当前最新的版本为 <code>1.2.12.RELEASE</code></p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 配置参数</h3>
<p>通常我们直接使用默认的thymeleaf参数配置即可，下面给出几个常用的配置</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> II. 项目搭建演示</h2>
<h3> 1. 项目结构</h3>
<p>搭建一个web项目和我们之前的纯后端项目有点不一样，前端资源放在什么地方，依赖文件怎么处理都是有讲究的，下面是一个常规的项目结构</p>
<figure><img src="/imgs/190822/00.jpg" alt="项目结构" tabindex="0" loading="lazy"><figcaption>项目结构</figcaption></figure>
<p>如上图，前端资源文件默认放在resources目录下，下面有两个目录</p>
<ul>
<li><code>templates</code>：存放模板文件，可以理解为我们编写的html，注意这个文件名不能有问题</li>
<li><code>static</code>: 存放静态资源文件，如js,css,image等</li>
</ul>
<h3> 2. Rest服务</h3>
<p>我们这里提供了三个接口，主要是为了演示三种不同的数据绑定方式（和前面两篇博文基本一样）</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的三种case中</p>
<ul>
<li>第一个是最好理解的，在创建<code>ModelAndView</code>时，传入viewName和数据</li>
<li>第二个是通过接口参数Model，设置传递给view的数据</li>
<li>第三种则直接使用Map来传递数据</li>
</ul>
<p><strong>注意</strong></p>
<p>如果和前面两篇博文进行对比，会发现一个显著的区别，之前的<code>Freemaker</code>, <code>Thymeleaf</code>指定视图名的时候，都不需要后缀，但是这里，必须带上后缀，否则会500错误</p>
<hr>
<p>三个接口，对应的三个btl文件，如下</p>
<p><strong>index.btl</strong></p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>show1.btl</strong></p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>show2.btl</strong></p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面的模板文件中，需要注意引用css样式文件，路径前面并没有static，我们对应的css文件</p>
<p><strong>index.css</strong></p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. 演示</h3>
<p>启动项目后，可以看到三个页面的切换，模板中的数据根据后端的返回替换，特别是主页的时间，每次刷新都会随之改变</p>
<figure><img src="/imgs/190822/01.gif" alt="demo" tabindex="0" loading="lazy"><figcaption>demo</figcaption></figure>
<h2> II. 其他</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>项目地址: <a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/206-web-beetl" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/206-web-beetl</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/190822/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>4.返回文本、网页、图片的操作姿势</title>
      <link>https://liuyueyi.github.io/tutorial/spring/web/Response/190913-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8Bweb%E7%AF%87%E4%B9%8B%E8%BF%94%E5%9B%9E%E6%96%87%E6%9C%AC%E3%80%81%E7%BD%91%E9%A1%B5%E3%80%81%E5%9B%BE%E7%89%87%E7%9A%84%E6%93%8D%E4%BD%9C%E5%A7%BF%E5%8A%BF.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/web/Response/190913-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8Bweb%E7%AF%87%E4%B9%8B%E8%BF%94%E5%9B%9E%E6%96%87%E6%9C%AC%E3%80%81%E7%BD%91%E9%A1%B5%E3%80%81%E5%9B%BE%E7%89%87%E7%9A%84%E6%93%8D%E4%BD%9C%E5%A7%BF%E5%8A%BF.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">4.返回文本、网页、图片的操作姿势</source>
      <description>前面几篇博文介绍了如何获取get/post传参，既然是http请求，一般也都是有来有往，有请求参数传递，就会有数据返回。那么我们通过springboot搭建的web应用，可以怎样返回数据呢？ 本篇将主要介绍以下几种数据格式的返回实例 返回文本 返回数组 返回json串 返回静态网页 返回图片</description>
      <category>SpringBoot</category>
      <category>WEB系列</category>
      <category>Response</category>
      <pubDate>Fri, 13 Sep 2019 17:44:42 GMT</pubDate>
      <content:encoded><![CDATA[<p>前面几篇博文介绍了如何获取get/post传参，既然是http请求，一般也都是有来有往，有请求参数传递，就会有数据返回。那么我们通过springboot搭建的web应用，可以怎样返回数据呢？</p>
<p>本篇将主要介绍以下几种数据格式的返回实例</p>
<ul>
<li>返回文本</li>
<li>返回数组</li>
<li>返回json串</li>
<li>返回静态网页</li>
<li>返回图片</li>
</ul>
<!-- more -->
<h2> I. 环境搭建</h2>
<p>首先得搭建一个web应用才有可能继续后续的测试，借助SpringBoot搭建一个web应用属于比较简单的活;</p>
<p>创建一个maven项目，pom文件如下</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>依然是一般的流程，pom依赖搞定之后，写一个程序入口</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> II. 数据返回姿势实例</h2>
<p>以下返回实例都放在同一个Controller中，具体定义如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1. 文本返回</h3>
<p>这个属于基础功能了，发起请求，返回一串文本，在SpringMVC的体系中，要实现这种通常的写法通常是直接定义方法的返回为String；当然还有另外一种非常基础的写法，直接将返回的数据通过<code>HttpServletResponse</code>写入到输出流中</p>
<p>下面给出这两种写法的实例</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意上面的实现中，方法上面多了一个注解<code>@ResponseBody</code>，这个表示返回数据，而不是视图（后面会详细说明）</p>
<p><code>strRsp2</code>的输出借助了FastJson来实现将map序列化为json串，然后写入输出流</p>
<p>实例访问如下</p>
<figure><img src="/imgs/190913/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>从上面的输出也可以看出，第一种返回方式，<code>ResponseHeaders</code>的<code>Content-Type: text/html;charset=UTF-8</code>；而第二种方式则没有这个响应头，需要我们自己主动设置（这里注意一下即可，在后面的返回图片中有实例）</p>
<h3> 2，返回数组</h3>
<p>前面请求参数的博文中，我们看到请求参数允许传入数组，那么我们返回可以直接返回数组么？讲道理的话，应该没啥问题</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后请求输出为</p>
<figure><img src="/imgs/190913/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>注意下响应头，为<code>application/json</code>, 也就是说SpringMVC将数组当成json串进行返回了</p>
<h3> 3. Bean返回</h3>
<p>在我们实际的业务开发中，这种应该属于非常常见的使用姿势了，直接返回一个POJO，调用者接收的是一个json串，可以很容易的反序列化为需要的对象</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/190913/02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 4. 网页返回</h3>
<p>前面都是直接返回数据，但是我们平常在使用浏览器，更多的是发起一个请求，然后返回一个网页啊，难道说springmvc不能直接返回网页么？</p>
<p>当然返回网页怎么可能会不支持，（题外话：个人感觉在前后端分离逐渐流行之后，直接由后端返回网页的case不太多了，前端和后端作为独立的项目部署，两者之间通过json串进行交流；这里扯远了），我们下面看一下SpringMVC中如何返回网页</p>
<p>我们可以从上面直接返回字符串的case中，得到一个思路，如果我直接返回一个html文本，会怎样？既然返回<code>content-type</code>是<code>text/html</code>，那浏览器应该可以解析为网页的，下面实测一下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>测试如下</p>
<figure><img src="/imgs/190913/03.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>浏览器发起请求之后，将我们返回的html文本当做网页正常渲染了，所以我们如果想返回网页，就这么干，没毛病！</p>
<p>上面这种方式虽然说可以返回网页，然而在实际业务中，如果真要我们这么干，想想也是可怕，还干什么后端，分分钟全栈得了！！！</p>
<p>下面看一下更常规的写法，首先我们需要配置下返回视图的前缀、后缀, 在<code>application.yml</code>配置文件中添加如下配置</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后我们的静态网页，放在资源文件的static目录下，下面是我们实际的项目截图，index.html为我们需要返回的静态网页</p>
<figure><img src="/imgs/190913/04.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>接下来就是我们的服务接口</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意下上面的接口，没有<code>@ResponseBody</code>注解，表示这个接口返回的是一个视图，会从static目录下寻找名为<code>index.html</code>（前缀路径和后缀是上面的application.yml中定义）的网页返回</p>
<p>实测case如下</p>
<figure><img src="/imgs/190913/05.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 5. 图片返回</h3>
<p>图片返回与前面的又不太一样了，上面介绍的几种case中，要么是返回文本，要么返回视图，而返回图片呢，更多的是返回图片的字符数组，然后告诉浏览器这是个图片，老哥你按照图片渲染</p>
<p>直接返回二进制流，上面在介绍文本返回的两种方式中，有个直接通过<code>HttpServletResponse</code>向输出流中写数据的方式，我们这里是不是可以直接这么用呢？</p>
<p>下面给出一个从网络下载图片并返回二进制流的实际case</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意下上面的实例case，首先设置了返回的<code>ContentType</code>，然后借助<code>ImateIO</code>来下载图片（个人不太建议这种写法，很容易出现403；这里演示主要是为了简单...），并将图片写入到输出流</p>
<p>实例演示如下</p>
<figure><img src="/imgs/190913/06.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> III 小结</h2>
<h3> 1. 返回数据小结</h3>
<p>本篇博文主要介绍了几种常见数据格式的返回使用姿势，本文更多的是一种使用方式的实例case演示，并没有涉及到底层的支持原理，也没有过多的提及如何设置响应头，web交互中常见的cookies/session也没有说到，这些将作为下篇的内容引入，恳请关注</p>
<p>下面做一个简单的小结</p>
<p><strong>返回纯数据</strong></p>
<ul>
<li>添加<code>@ResponseBody</code>注解，则表示我们返回的是数据，而不需要进行视图解析渲染；
<ul>
<li>如果一个controller中全部都是返回数据，不会返回视图时，我们可以在添加<code>@RestController</code>注解，然后这个类中的接口都不需要添加<code>@ResponseBody</code>注解了</li>
</ul>
</li>
<li>返回视图时，我们会根据接口返回的字符串，结合定义的前缀，后缀，到资源路径的static目录下寻找对应的静态文件返回</li>
<li>可以直接通过向<code>HttpServletResponse</code>的输出流中写数据的方式来返回数据，如返回图片常用这种case</li>
</ul>
<h3> 2. 更多web系列博文</h3>
<ul>
<li><a href="http://spring.hhui.top/spring-blog/2019/09/05/190905-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8Bweb%E7%AF%87%E4%B9%8B%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/" target="_blank" rel="noopener noreferrer">190905-SpringBoot系列教程web篇之中文乱码问题解决</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2019/08/31/190831-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8Bweb%E7%AF%87%E4%B9%8B%E5%A6%82%E4%BD%95%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%E5%99%A8/" target="_blank" rel="noopener noreferrer">190831-SpringBoot系列教程web篇之如何自定义参数解析器</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2019/08/28/190828-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8Bweb%E7%AF%87%E4%B9%8BPost%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%E5%A7%BF%E5%8A%BF%E6%B1%87%E6%80%BB/" target="_blank" rel="noopener noreferrer">190828-SpringBoot系列教程web篇之Post请求参数解析姿势汇总</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2019/08/24/190824-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8Bweb%E7%AF%87%E4%B9%8BGet%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%E5%A7%BF%E5%8A%BF%E6%B1%87%E6%80%BB/" target="_blank" rel="noopener noreferrer">190824-SpringBoot系列教程web篇之Get请求参数解析姿势汇总</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2019/08/22/190822-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8Bweb%E7%AF%87%E4%B9%8BBeetl%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" target="_blank" rel="noopener noreferrer">190822-SpringBoot系列教程web篇之Beetl环境搭建</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2019/08/20/190820-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8Bweb%E7%AF%87%E4%B9%8BThymeleaf%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" target="_blank" rel="noopener noreferrer">190820-SpringBoot系列教程web篇之Thymeleaf环境搭建</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2019/08/16/190816-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8Bweb%E7%AF%87%E4%B9%8BFreemaker%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" target="_blank" rel="noopener noreferrer">190816-SpringBoot系列教程web篇之Freemaker环境搭建</a></li>
</ul>
<h2> IV. 其他</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>项目: <a href="https://github.com/liuyueyi/spring-boot-demo/blob/master/spring-boot/207-web-response" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/blob/master/spring-boot/207-web-response</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/190913/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>5.请求重定向</title>
      <link>https://liuyueyi.github.io/tutorial/spring/web/Response/190929-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8Bweb%E7%AF%87%E4%B9%8B%E9%87%8D%E5%AE%9A%E5%90%91.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/web/Response/190929-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8Bweb%E7%AF%87%E4%B9%8B%E9%87%8D%E5%AE%9A%E5%90%91.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">5.请求重定向</source>
      <description>前面介绍了spring web篇数据返回的几种常用姿势，当我们在相应一个http请求时，除了直接返回数据之外，还有另一种常见的case -&amp;gt; 重定向； 比如我们在逛淘宝，没有登录就点击购买时，会跳转到登录界面，这其实就是一个重定向。本文主要介绍对于后端而言，可以怎样支持302重定向</description>
      <category>SpringBoot</category>
      <category>WEB系列</category>
      <category>Response</category>
      <pubDate>Sun, 29 Sep 2019 19:35:48 GMT</pubDate>
      <content:encoded><![CDATA[<p>前面介绍了spring web篇数据返回的几种常用姿势，当我们在相应一个http请求时，除了直接返回数据之外，还有另一种常见的case -&gt; 重定向；</p>
<p>比如我们在逛淘宝，没有登录就点击购买时，会跳转到登录界面，这其实就是一个重定向。本文主要介绍对于后端而言，可以怎样支持302重定向</p>
<!-- more -->
<h2> I. 环境搭建</h2>
<p>首先得搭建一个web应用才有可能继续后续的测试，借助SpringBoot搭建一个web应用属于比较简单的活;</p>
<p>创建一个maven项目，pom文件如下</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>依然是一般的流程，pom依赖搞定之后，写一个程序入口</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> II. 302重定向</h2>
<h3> 1. 返回redirect</h3>
<p>这种case通常适用于返回视图的接口，在返回的字符串前面添加<code>redirect:</code>方式来告诉Spring框架，需要做302重定向处理</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面给出了一个简单的demo，当我们访问<code>/redirect/r1</code>时，会重定向到请求<code>/redirect/index?base=r1</code>，实际测试结果如下</p>
<figure><img src="/imgs/190929/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>注意上面的截图，我们实际访问的连接是 <code>http://127.0.0.1:8080/redirect/index?base=r1</code>，在浏览器中的表现则是请求url变成了<code>http://127.0.0.1:8080/redirect/index?base=r1</code>；通过控制台查看到的返回头状态码是302</p>
<p><strong>说明</strong></p>
<ul>
<li>使用这种方式的前提是不能在接口上添加<code>@ResponseBody</code>注解，否则返回的字符串被当成普通字符串处理直接返回，并不会实现重定向</li>
</ul>
<h3> 2. HttpServletResponse重定向</h3>
<p>前面一篇说到SpringMVC返回数据的时候，介绍到可以直接通过<code>HttpServletResponse</code>往输出流中写数据的方式，来返回结果；我们这里也是利用它，来实现重定向</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从上面的demo中，也可以看出这个的使用方式很简单了，直接调用<code>javax.servlet.http.HttpServletResponse#sendRedirect</code>，并传入需要重定向的url即可</p>
<figure><img src="/imgs/190929/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 3. 小结</h3>
<p>这里主要介绍了两种常见的后端重定向方式，都比较简单，这两种方式也有自己的适用场景（当然并不绝对）</p>
<ul>
<li>在返回视图的前面加上<code>redirect</code>的方式，更加适用于视图的跳转，从一个网页跳转到另一个网页</li>
<li><code>HttpServletResponse#sendRedirec</code>的方式更加灵活，可以在后端接收一次http请求生命周期中的任何一个阶段来使用，比如有以下几种常见的场景
<ul>
<li>某个接口要求登录时，在拦截器层针对所有未登录的请求，重定向到登录页面</li>
<li>全局异常处理中，如果出现服务器异常，重定向到定制的500页面</li>
<li>不支持的请求，重定向到404页面</li>
</ul>
</li>
</ul>
<h2> II. 其他</h2>
<h3> 0. 项目</h3>
<h4> a. 系列博文</h4>
<ul>
<li><a href="http://spring.hhui.top/spring-blog/2019/09/13/190913-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8Bweb%E7%AF%87%E4%B9%8B%E8%BF%94%E5%9B%9E%E6%96%87%E6%9C%AC%E3%80%81%E7%BD%91%E9%A1%B5%E3%80%81%E5%9B%BE%E7%89%87%E7%9A%84%E6%93%8D%E4%BD%9C%E5%A7%BF%E5%8A%BF/" target="_blank" rel="noopener noreferrer">190913-SpringBoot系列教程web篇之返回文本、网页、图片的操作姿势</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2019/09/05/190905-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8Bweb%E7%AF%87%E4%B9%8B%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/" target="_blank" rel="noopener noreferrer">190905-SpringBoot系列教程web篇之中文乱码问题解决</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2019/08/31/190831-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8Bweb%E7%AF%87%E4%B9%8B%E5%A6%82%E4%BD%95%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%E5%99%A8/" target="_blank" rel="noopener noreferrer">190831-SpringBoot系列教程web篇之如何自定义参数解析器</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2019/08/28/190828-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8Bweb%E7%AF%87%E4%B9%8BPost%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%E5%A7%BF%E5%8A%BF%E6%B1%87%E6%80%BB/" target="_blank" rel="noopener noreferrer">190828-SpringBoot系列教程web篇之Post请求参数解析姿势汇总</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2019/08/24/190824-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8Bweb%E7%AF%87%E4%B9%8BGet%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%E5%A7%BF%E5%8A%BF%E6%B1%87%E6%80%BB/" target="_blank" rel="noopener noreferrer">190824-SpringBoot系列教程web篇之Get请求参数解析姿势汇总</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2019/08/22/190822-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8Bweb%E7%AF%87%E4%B9%8BBeetl%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" target="_blank" rel="noopener noreferrer">190822-SpringBoot系列教程web篇之Beetl环境搭建</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2019/08/20/190820-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8Bweb%E7%AF%87%E4%B9%8BThymeleaf%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" target="_blank" rel="noopener noreferrer">190820-SpringBoot系列教程web篇之Thymeleaf环境搭建</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2019/08/16/190816-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8Bweb%E7%AF%87%E4%B9%8BFreemaker%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" target="_blank" rel="noopener noreferrer">190816-SpringBoot系列教程web篇之Freemaker环境搭建</a></li>
</ul>
<h4> b. 项目源码</h4>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>项目: <a href="https://github.com/liuyueyi/spring-boot-demo/blob/master/spring-boot/207-web-response" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/blob/master/spring-boot/207-web-response</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/190929/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>6.404、500异常页面配置</title>
      <link>https://liuyueyi.github.io/tutorial/spring/web/Response/190930-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8Bweb%E7%AF%87%E4%B9%8B404%E3%80%81500%E5%BC%82%E5%B8%B8%E9%A1%B5%E9%9D%A2%E9%85%8D%E7%BD%AE.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/web/Response/190930-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8Bweb%E7%AF%87%E4%B9%8B404%E3%80%81500%E5%BC%82%E5%B8%B8%E9%A1%B5%E9%9D%A2%E9%85%8D%E7%BD%AE.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">6.404、500异常页面配置</source>
      <description>接着前面几篇web处理请求的博文，本文将说明，当出现异常的场景下，如404请求url不存在，，403无权，500服务器异常时，我们可以如何处理</description>
      <category>SpringBoot</category>
      <category>WEB系列</category>
      <category>Response</category>
      <pubDate>Mon, 30 Sep 2019 18:17:11 GMT</pubDate>
      <content:encoded><![CDATA[<p>接着前面几篇web处理请求的博文，本文将说明，当出现异常的场景下，如404请求url不存在，，403无权，500服务器异常时，我们可以如何处理</p>
<!-- more -->
<h2> I. 环境搭建</h2>
<p>首先得搭建一个web应用才有可能继续后续的测试，借助SpringBoot搭建一个web应用属于比较简单的活;</p>
<p>创建一个maven项目，pom文件如下</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>依然是一般的流程，pom依赖搞定之后，写一个程序入口</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> II. 异常页面配置</h2>
<p>在SpringBoot项目中，本身提供了一个默认的异常处理页面，当我们希望使用自定义的404,500等页面时，可以如何处理呢？</p>
<h3> 1. 默认异常页面配置</h3>
<p>在默认的情况下，要配置异常页面非常简单，在资源路径下面，新建 <code>error</code> 目录，在下面添加<code>400.html</code>, <code>500html</code>页面即可</p>
<figure><img src="/imgs/190930/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>项目结构如上，注意这里的实例demo是没有使用模板引擎的，所以我们的异常页面放在static目录下；如果使用了如FreeMaker模板引擎时，可以将错误模板页面放在template目录下</p>
<p>接下来实际测试下是否生效, 我们先定义一个可能出现服务器500的服务</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>请求一个不存在的url，返回我们定义的<code>400.html</code>页面</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/190930/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>请求一个服务器500异常，返回我们定义的<code>500.html</code>页面</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/190930/02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 2. BasicErrorController</h3>
<p>看上面的使用比较简单，自然会有个疑问，这个异常页面是怎么返回的呢？</p>
<p>从项目启动的日志中，注意一下<code>RequestMappingHandlerMapping</code></p>
<figure><img src="/imgs/190930/03.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>可以发现里面有个<code>/error</code>的路径不是我们自己定义的，从命名上来看，这个多半就是专门用来处理异常的Controller -&gt; <code>BasicErrorController</code>， 部分代码如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个Controller中，一个返回网页的接口，一个返回Json串的接口；我们前面使用的应该是第一个，那我们什么场景下会使用到第二个呢？</p>
<ul>
<li>通过制定请求头的<code>Accept</code>，来限定我们只希望获取json的返回即可</li>
</ul>
<figure><img src="/imgs/190930/04.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 3. 小结</h3>
<p>本篇内容比较简单，归纳为两句话如下</p>
<ul>
<li>将自定义的异常页面根据http状态码命名，放在<code>/error</code>目录下</li>
<li>在异常状况下，根据返回的http状态码找到对应的异常页面返回</li>
</ul>
<h2> II. 其他</h2>
<h3> 0. 项目</h3>
<h4> a. 系列博文</h4>
<ul>
<li><a href="http://spring.hhui.top/spring-blog/2019/09/29/190929-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8Bweb%E7%AF%87%E4%B9%8B%E9%87%8D%E5%AE%9A%E5%90%91/" target="_blank" rel="noopener noreferrer">190929-SpringBoot系列教程web篇之重定向</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2019/09/13/190913-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8Bweb%E7%AF%87%E4%B9%8B%E8%BF%94%E5%9B%9E%E6%96%87%E6%9C%AC%E3%80%81%E7%BD%91%E9%A1%B5%E3%80%81%E5%9B%BE%E7%89%87%E7%9A%84%E6%93%8D%E4%BD%9C%E5%A7%BF%E5%8A%BF/" target="_blank" rel="noopener noreferrer">190913-SpringBoot系列教程web篇之返回文本、网页、图片的操作姿势</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2019/09/05/190905-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8Bweb%E7%AF%87%E4%B9%8B%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/" target="_blank" rel="noopener noreferrer">190905-SpringBoot系列教程web篇之中文乱码问题解决</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2019/08/31/190831-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8Bweb%E7%AF%87%E4%B9%8B%E5%A6%82%E4%BD%95%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%E5%99%A8/" target="_blank" rel="noopener noreferrer">190831-SpringBoot系列教程web篇之如何自定义参数解析器</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2019/08/28/190828-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8Bweb%E7%AF%87%E4%B9%8BPost%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%E5%A7%BF%E5%8A%BF%E6%B1%87%E6%80%BB/" target="_blank" rel="noopener noreferrer">190828-SpringBoot系列教程web篇之Post请求参数解析姿势汇总</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2019/08/24/190824-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8Bweb%E7%AF%87%E4%B9%8BGet%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%E5%A7%BF%E5%8A%BF%E6%B1%87%E6%80%BB/" target="_blank" rel="noopener noreferrer">190824-SpringBoot系列教程web篇之Get请求参数解析姿势汇总</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2019/08/22/190822-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8Bweb%E7%AF%87%E4%B9%8BBeetl%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" target="_blank" rel="noopener noreferrer">190822-SpringBoot系列教程web篇之Beetl环境搭建</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2019/08/20/190820-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8Bweb%E7%AF%87%E4%B9%8BThymeleaf%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" target="_blank" rel="noopener noreferrer">190820-SpringBoot系列教程web篇之Thymeleaf环境搭建</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2019/08/16/190816-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8Bweb%E7%AF%87%E4%B9%8BFreemaker%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" target="_blank" rel="noopener noreferrer">190816-SpringBoot系列教程web篇之Freemaker环境搭建</a></li>
</ul>
<h4> b. 项目源码</h4>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>项目: <a href="https://github.com/liuyueyi/spring-boot-demo/blob/master/spring-boot/207-web-response" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/blob/master/spring-boot/207-web-response</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/190930/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>7.全局异常处理</title>
      <link>https://liuyueyi.github.io/tutorial/spring/web/Response/191010-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8Bweb%E7%AF%87%E4%B9%8B%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/web/Response/191010-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8Bweb%E7%AF%87%E4%B9%8B%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">7.全局异常处理</source>
      <description>当我们的后端应用出现异常时，通常会将异常状况包装之后再返回给调用方或者前端，在实际的项目中，不可能对每一个地方都做好异常处理，再优雅的代码也可能抛出异常，那么在Spring项目中，可以怎样优雅的处理这些异常呢? 本文将介绍一种全局异常处理方式，主要包括以下知识点 @ControllerAdvice Controller增强 @ExceptionHandler 异常捕获 @ResponseStatus 返回状态码 NoHandlerFoundException处理（404异常捕获）</description>
      <category>SpringBoot</category>
      <category>WEB系列</category>
      <category>Response</category>
      <pubDate>Thu, 10 Oct 2019 18:15:16 GMT</pubDate>
      <content:encoded><![CDATA[<p>当我们的后端应用出现异常时，通常会将异常状况包装之后再返回给调用方或者前端，在实际的项目中，不可能对每一个地方都做好异常处理，再优雅的代码也可能抛出异常，那么在Spring项目中，可以怎样优雅的处理这些异常呢?</p>
<p>本文将介绍一种全局异常处理方式，主要包括以下知识点</p>
<ul>
<li>@ControllerAdvice Controller增强</li>
<li>@ExceptionHandler 异常捕获</li>
<li>@ResponseStatus 返回状态码</li>
<li>NoHandlerFoundException处理（404异常捕获）</li>
</ul>
<!-- more -->
<h2> I. 环境搭建</h2>
<p>首先得搭建一个web应用才有可能继续后续的测试，借助SpringBoot搭建一个web应用属于比较简单的活;</p>
<p>创建一个maven项目，pom文件如下</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>依然是一般的流程，pom依赖搞定之后，写一个程序入口</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> II. 异常处理</h2>
<h3> 1. @ControllerAdvice</h3>
<p>我们通常利用<code>@ControllerAdvice</code>配合注解<code>@ExceptionHandler</code>来实现全局异常捕获处理</p>
<ul>
<li><code>@ControllerAdvice</code>为所有的Controller织入增强方法</li>
<li><code>@ExceptionHandler</code>标记在方法上，表示当出现对应的异常抛出到上层时（即没有被业务捕获），这个方法会被触发</li>
</ul>
<p>下面我们通过实例进行功能演示</p>
<h4> a. 异常捕获</h4>
<p>我们定义两个异常捕获的case，一个是除0，一个是数组越界异常</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面的测试中，我们将异常堆栈返回调用方</p>
<h4> b. 示例服务</h4>
<p>增加几个测试方法</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> c. 测试说明</h4>
<p>实例测试如下，上面我们声明捕获的两种异常被拦截并输出对应的堆栈信息；</p>
<p>但是需要注意</p>
<ul>
<li><strong>404和未捕获的500异常</strong>则显示的SpringBoot默认的错误页面；</li>
<li>此外我们捕获返回的http状态码是200</li>
</ul>
<figure><img src="/imgs/191010/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 2. @ResponseStatus</h3>
<p>上面的case中捕获的异常返回的状态码是200，但是在某些case中，可能更希望返回更合适的http状态码，此时可以使用<code>ResponseStatus</code>来指定</p>
<p>使用方式比较简单，加一个注解即可</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/191010/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 3. 404处理</h3>
<p>通过<code>@ControllerAdvice</code>配合<code>@ExceptionHandler</code>可以拦截500异常，如果我希望404异常也可以拦截，可以如何处理？</p>
<p>首先修改配置文件<code>application.properties</code>，将<code>NoHandlerFoundException</code>抛出来</p>
<div class="language-properties line-numbers-mode" data-ext="properties"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其次是定义异常捕获</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>再次测试如下，404被我们捕获并返回堆栈信息</p>
<figure><img src="/imgs/191010/02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> II. 其他</h2>
<h3> 0. 项目</h3>
<h4> web系列博文</h4>
<ul>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484336&amp;idx=1&amp;sn=d70f15e77bbd219af8015f9037a167fb&amp;chksm=fce7181ccb90910aee427a3f3ed7660e8303c7460859c82622a651ce1cc3d7a97f62f80ed4e0&amp;token=2447275&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">190930-SpringBoot系列教程web篇之404、500异常页面配置</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484322&amp;idx=1&amp;sn=b18090f35b59097f78858b6609506b74&amp;chksm=fce7180ecb909118d939f3ddf741a11c0977b1213d7afa12c970590590d40441c3a085c43c52&amp;token=2447275&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">190929-SpringBoot系列教程web篇之重定向</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484310&amp;idx=1&amp;sn=f6259cf1b79db095ff2e9534993d27cf&amp;chksm=fce7183acb90912cd150f086e90ecab3eceb3464e9352853e2e722288d412dbb3eb20c6e6ae7&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190913-SpringBoot系列教程web篇之返回文本、网页、图片的操作姿势</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484309&amp;idx=1&amp;sn=33d782f7529268eef6607a1ab8d41018&amp;chksm=fce71839cb90912f6020aa9463bc0136cb57969ebe27eba865d97e212c28211435791aa874ea&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190905-SpringBoot系列教程web篇之中文乱码问题解决</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484291&amp;idx=1&amp;sn=3f7e8c92ca4d7270cc5c40cafea39683&amp;chksm=fce7182fcb90913922654a4f2f04e7029b8944d71c31741334a3235aecbe1e60babcb0c0be74&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190831-SpringBoot系列教程web篇之如何自定义参数解析器</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484287&amp;idx=1&amp;sn=44461f564d6b04cbf1a5902dcb4f23c6&amp;chksm=fce718d3cb9091c5d730e63ae954c0831d53f3dd5af5d19d9c78b6009102838efaf56f7838ff&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190828-SpringBoot系列教程web篇之Post请求参数解析姿势汇总</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484282&amp;idx=1&amp;sn=a8d236d935ae24cfbe6977e24a479caa&amp;chksm=fce718d6cb9091c0dd8a6b113236f9ae9388fb026c9403c97bdf7505f773bd7330a43e3b269c&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190824-SpringBoot系列教程web篇之Get请求参数解析姿势汇总</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484268&amp;idx=3&amp;sn=9e8a6121dce291c65bd2b3d4fab24178&amp;chksm=fce718c0cb9091d6674fb809d68ca3dc3b1695162368481abf8dc094000412116d2f9971c54b&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190822-SpringBoot系列教程web篇之Beetl环境搭建</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484268&amp;idx=2&amp;sn=f800c001061eabe74e2cad915af1921a&amp;chksm=fce718c0cb9091d682b600673a0584955783f0d339248e34323efbea9b698560c432018717ef&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190820-SpringBoot系列教程web篇之Thymeleaf环境搭建</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484268&amp;idx=1&amp;sn=acd691729488d81a94c938151d5737ce&amp;chksm=fce718c0cb9091d63ef5f12893bb835c256a18318e791a0d193d00ef767ecfd019491d02e83d&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190816-SpringBoot系列教程web篇之Freemaker环境搭建</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484217&amp;idx=1&amp;sn=9fdf45d2261cdcf2ccaccaebfb5ef598&amp;chksm=fce71895cb90918361f1afd55a2b5fc9d65508913c1d793710afa79cae38bd9d57e32ad2c187&amp;token=2447275&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">190421-SpringBoot高级篇WEB之websocket的使用说明</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484197&amp;idx=1&amp;sn=0184953527f58058ee8c2bbcfc2689ec&amp;chksm=fce71889cb90919f9be003bf2487343f7952d6b33ab5ee5fb7251ae37a631d4c32e6d8a57528&amp;token=2447275&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">190327-Spring-RestTemplate之urlencode参数解析异常全程分析</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484193&amp;idx=1&amp;sn=d8a284fe0a2b8e1fefe07d892558f563&amp;chksm=fce7188dcb90919b1f8a2408bf955e37e88b043e2dbd59b5290ac1501e3d2d303512bac6af2c&amp;token=2447275&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">190317-Spring MVC之基于java config无xml配置的web应用构建</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484186&amp;idx=1&amp;sn=18db571b670815965ae9185830c4e88f&amp;chksm=fce718b6cb9091a054e0ac4be051341d8ce38ff8e40c5911302e3d6981206c14b80770590044&amp;token=2447275&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">190316-Spring MVC之基于xml配置的web应用构建</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484139&amp;idx=1&amp;sn=b4a5f3ca6215641c6bcf5123f2bfb501&amp;chksm=fce71947cb9090511042ae97a12cc975d2b199521e17980e685cccb5e0be91a8e932cef4eb76&amp;token=2447275&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">190213-SpringBoot文件上传异常之提示The temporary upload location xxx is not valid</a></li>
</ul>
<h4> 项目源码</h4>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>项目：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/209-web-error" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/209-web-error</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/191010/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>8.自定义异常处理HandlerExceptionResolver</title>
      <link>https://liuyueyi.github.io/tutorial/spring/web/Response/191012-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8Bweb%E7%AF%87%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86HandlerExceptionResolver.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/web/Response/191012-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8Bweb%E7%AF%87%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86HandlerExceptionResolver.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">8.自定义异常处理HandlerExceptionResolver</source>
      <description>关于Web应用的全局异常处理，上一篇介绍了ControllerAdvice结合@ExceptionHandler的方式来实现web应用的全局异常管理； 本篇博文则带来另外一种并不常见的使用方式，通过实现自定义的HandlerExceptionResolver，来处理异常状态 上篇博文链接: SpringBoot系列教程web篇之全局异常处理</description>
      <category>SpringBoot</category>
      <category>WEB系列</category>
      <category>Response</category>
      <pubDate>Sat, 12 Oct 2019 19:53:50 GMT</pubDate>
      <content:encoded><![CDATA[<p>关于Web应用的全局异常处理，上一篇介绍了<code>ControllerAdvice</code>结合<code>@ExceptionHandler</code>的方式来实现web应用的全局异常管理；</p>
<p>本篇博文则带来另外一种并不常见的使用方式，通过实现自定义的<code>HandlerExceptionResolver</code>，来处理异常状态</p>
<blockquote>
<p>上篇博文链接: <a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484344&amp;idx=1&amp;sn=d4b1422a709d9540583e33443aab6fff&amp;chksm=fce71814cb9091025a960312c878ff9fc4f44fd0035aa597f55f37c90dcbac25a3e96ee2c528&amp;token=118864495&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">SpringBoot系列教程web篇之全局异常处理</a></p>
</blockquote>
<!-- more -->
<h2> I. 环境搭建</h2>
<p>首先得搭建一个web应用才有可能继续后续的测试，借助SpringBoot搭建一个web应用属于比较简单的活;</p>
<p>创建一个maven项目，pom文件如下</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> II. HandlerExceptionResolver</h2>
<h3> 1. 自定义异常处理</h3>
<p><code>HandlerExceptionResolver</code>顾名思义，就是处理异常的类，接口就一个方法，出现异常之后的回调，四个参数中还携带了异常堆栈信息</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们自定义异常处理类就比较简单了，实现上面的接口，然后将完整的堆栈返回给调用方</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>仔细观察上面的代码实现，有下面几个点需要注意</p>
<ul>
<li>为了确保中文不会乱码，我们设置了返回头 <code>response.addHeader("Content-Type", "text/html; charset=UTF-8");</code> 如果没有这一行，会出现中文乱码的情况</li>
<li>我们纯后端应用，不想返回视图，直接想Response的输出流中写入数据返回 <code>response.getWriter().append("自定义异常处理!!! \n").append(msg).flush();</code>； 如果项目中有自定义的错误页面，可以通过返回<code>ModelAndView</code>来确定最终返回的错误页面</li>
<li>上面一个代码并不会直接生效，需要注册，可以在<code>WebMvcConfigurer</code>的子类中实现注册，实例如下</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 测试case</h3>
<p>我们依然使用上篇博文的用例来测试</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>下面分别是404异常和500异常的实测情况</p>
<figure><img src="/imgs/191012/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>500异常会进入我们的自定义异常处理类, 而404依然走的是默认的错误页面，所以如果我们需要捕获404异常，依然需要在配置文件中添加</p>
<div class="language-properties line-numbers-mode" data-ext="properties"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>为什么404需要额外处理？</strong></p>
<p>下面尽量以通俗易懂的方式说明下这个问题</p>
<ul>
<li>java web应用，除了返回json类数据之外还可能返回网页，js，css</li>
<li>我们通过 <code>@ResponseBody</code>来表明一个url返回的是json数据（通常情况下是这样的，不考虑自定义实现）</li>
<li>我们的<code>@Controller</code>中通过<code>@RequestMapping</code>定义的REST服务，返回的是静态资源</li>
<li>那么js,css,图片这些文件呢，在我们的web应用中并不会定义一个REST服务</li>
<li>所以当接收一个http请求，找不到url关联映射时，默认场景下不认为这是一个<code>NoHandlerFoundException</code>，不抛异常，而是到静态资源中去找了(静态资源中也没有，为啥不抛NoHandlerFoundException呢？这个异常表示这个url请求没有对应的处理器，但是我们这里呢，给它分配到了静态资源处理器了<code>ResourceHttpRequestHandler</code>)</li>
</ul>
<p>针对上面这点，如果有兴趣深挖的同学，这里给出关键代码位置</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. 小结</h3>
<p>本篇博文虽然也介绍了一种新的全局异常处理方式，实现效果和<code>ControllerAdvice</code>也差不多，但是并不推荐用这种方法, 原因如下</p>
<ul>
<li><code>HandlerExceptionResolver</code>的方式没有<code>ControllerAdvice</code>方式简介优雅</li>
<li>官方提供的<code>DefaultHandlerExceptionResolver</code>已经非常强大了，基本上覆盖了http的各种状态码，我们自己再去定制的必要性不大</li>
</ul>
<h2> II. 其他</h2>
<h4> web系列博文</h4>
<ul>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484344&amp;idx=1&amp;sn=d4b1422a709d9540583e33443aab6fff&amp;chksm=fce71814cb9091025a960312c878ff9fc4f44fd0035aa597f55f37c90dcbac25a3e96ee2c528&amp;token=118864495&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">191010-SpringBoot系列教程web篇之全局异常处理</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484336&amp;idx=1&amp;sn=d70f15e77bbd219af8015f9037a167fb&amp;chksm=fce7181ccb90910aee427a3f3ed7660e8303c7460859c82622a651ce1cc3d7a97f62f80ed4e0&amp;token=2447275&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">190930-SpringBoot系列教程web篇之404、500异常页面配置</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484322&amp;idx=1&amp;sn=b18090f35b59097f78858b6609506b74&amp;chksm=fce7180ecb909118d939f3ddf741a11c0977b1213d7afa12c970590590d40441c3a085c43c52&amp;token=2447275&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">190929-SpringBoot系列教程web篇之重定向</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484310&amp;idx=1&amp;sn=f6259cf1b79db095ff2e9534993d27cf&amp;chksm=fce7183acb90912cd150f086e90ecab3eceb3464e9352853e2e722288d412dbb3eb20c6e6ae7&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190913-SpringBoot系列教程web篇之返回文本、网页、图片的操作姿势</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484309&amp;idx=1&amp;sn=33d782f7529268eef6607a1ab8d41018&amp;chksm=fce71839cb90912f6020aa9463bc0136cb57969ebe27eba865d97e212c28211435791aa874ea&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190905-SpringBoot系列教程web篇之中文乱码问题解决</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484291&amp;idx=1&amp;sn=3f7e8c92ca4d7270cc5c40cafea39683&amp;chksm=fce7182fcb90913922654a4f2f04e7029b8944d71c31741334a3235aecbe1e60babcb0c0be74&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190831-SpringBoot系列教程web篇之如何自定义参数解析器</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484287&amp;idx=1&amp;sn=44461f564d6b04cbf1a5902dcb4f23c6&amp;chksm=fce718d3cb9091c5d730e63ae954c0831d53f3dd5af5d19d9c78b6009102838efaf56f7838ff&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190828-SpringBoot系列教程web篇之Post请求参数解析姿势汇总</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484282&amp;idx=1&amp;sn=a8d236d935ae24cfbe6977e24a479caa&amp;chksm=fce718d6cb9091c0dd8a6b113236f9ae9388fb026c9403c97bdf7505f773bd7330a43e3b269c&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190824-SpringBoot系列教程web篇之Get请求参数解析姿势汇总</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484268&amp;idx=3&amp;sn=9e8a6121dce291c65bd2b3d4fab24178&amp;chksm=fce718c0cb9091d6674fb809d68ca3dc3b1695162368481abf8dc094000412116d2f9971c54b&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190822-SpringBoot系列教程web篇之Beetl环境搭建</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484268&amp;idx=2&amp;sn=f800c001061eabe74e2cad915af1921a&amp;chksm=fce718c0cb9091d682b600673a0584955783f0d339248e34323efbea9b698560c432018717ef&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190820-SpringBoot系列教程web篇之Thymeleaf环境搭建</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484268&amp;idx=1&amp;sn=acd691729488d81a94c938151d5737ce&amp;chksm=fce718c0cb9091d63ef5f12893bb835c256a18318e791a0d193d00ef767ecfd019491d02e83d&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190816-SpringBoot系列教程web篇之Freemaker环境搭建</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484217&amp;idx=1&amp;sn=9fdf45d2261cdcf2ccaccaebfb5ef598&amp;chksm=fce71895cb90918361f1afd55a2b5fc9d65508913c1d793710afa79cae38bd9d57e32ad2c187&amp;token=2447275&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">190421-SpringBoot高级篇WEB之websocket的使用说明</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484197&amp;idx=1&amp;sn=0184953527f58058ee8c2bbcfc2689ec&amp;chksm=fce71889cb90919f9be003bf2487343f7952d6b33ab5ee5fb7251ae37a631d4c32e6d8a57528&amp;token=2447275&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">190327-Spring-RestTemplate之urlencode参数解析异常全程分析</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484193&amp;idx=1&amp;sn=d8a284fe0a2b8e1fefe07d892558f563&amp;chksm=fce7188dcb90919b1f8a2408bf955e37e88b043e2dbd59b5290ac1501e3d2d303512bac6af2c&amp;token=2447275&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">190317-Spring MVC之基于java config无xml配置的web应用构建</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484186&amp;idx=1&amp;sn=18db571b670815965ae9185830c4e88f&amp;chksm=fce718b6cb9091a054e0ac4be051341d8ce38ff8e40c5911302e3d6981206c14b80770590044&amp;token=2447275&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">190316-Spring MVC之基于xml配置的web应用构建</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484139&amp;idx=1&amp;sn=b4a5f3ca6215641c6bcf5123f2bfb501&amp;chksm=fce71947cb9090511042ae97a12cc975d2b199521e17980e685cccb5e0be91a8e932cef4eb76&amp;token=2447275&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">190213-SpringBoot文件上传异常之提示The temporary upload location xxx is not valid</a></li>
</ul>
<h4> 项目源码</h4>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>项目：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/209-web-error" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/209-web-error</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/191012/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>9.开启GZIP数据压缩</title>
      <link>https://liuyueyi.github.io/tutorial/spring/web/Response/191120-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8BWeb%E7%AF%87%E4%B9%8B%E5%BC%80%E5%90%AFGZIP%E6%95%B0%E6%8D%AE%E5%8E%8B%E7%BC%A9.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/web/Response/191120-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8BWeb%E7%AF%87%E4%B9%8B%E5%BC%80%E5%90%AFGZIP%E6%95%B0%E6%8D%AE%E5%8E%8B%E7%BC%A9.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">9.开启GZIP数据压缩</source>
      <description>本篇可以归纳在性能调优篇，虽然内容非常简单，但效果可能出乎预料的好； 分享一个真实案例，我们的服务部署在海外，国内访问时访问服务时，响应有点夸张；某些返回数据比较大的接口，耗时在600ms+上，然而我们的服务rt却是在20ms以下，绝大部分的开销都花在了网络传输上 针对这样的场景，除了买云服务商的网络通道之外，另外一个直观的想法就是减少数据包的大小，直接在nginx层配置gzip压缩是一个方案，本文主要介绍下，SpringBoot如何开启gzip压缩</description>
      <category>SpringBoot</category>
      <category>WEB系列</category>
      <category>Response</category>
      <pubDate>Wed, 20 Nov 2019 22:11:39 GMT</pubDate>
      <content:encoded><![CDATA[<p>本篇可以归纳在性能调优篇，虽然内容非常简单，但效果可能出乎预料的好；</p>
<p>分享一个真实案例，我们的服务部署在海外，国内访问时访问服务时，响应有点夸张；某些返回数据比较大的接口，耗时在600ms+上，然而我们的服务rt却是在20ms以下，绝大部分的开销都花在了网络传输上</p>
<p>针对这样的场景，除了买云服务商的网络通道之外，另外一个直观的想法就是减少数据包的大小，直接在nginx层配置gzip压缩是一个方案，本文主要介绍下，SpringBoot如何开启gzip压缩</p>
<!-- more -->
<h2> I. gizp压缩配置</h2>
<h3> 1. 配置</h3>
<p>SpringBoot默认是不开启gzip压缩的，需要我们手动开启，在配置文件中添加两行</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意下上面配置中的<code>mime-types</code>，在spring2.0+的版本中，默认值如下，所以一般我们不需要特意添加这个配置</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 测试</h3>
<p>写一个测试的demo</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/191120/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>下面是开启压缩前后的数据报对比</p>
<figure><img src="/imgs/191120/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 3. 说明</h3>
<p>虽然加上了上面的配置，开启了gzip压缩，但是需要注意并不是说所有的接口都会使用gzip压缩，默认情况下，仅会压缩2048字节以上的内容</p>
<p>如果我们需要修改这个值，通过修改配置即可</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> II. 其他</h2>
<h3> 0. 项目</h3>
<h4> web系列博文</h4>
<ul>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484356&amp;idx=1&amp;sn=7c80f55f875f8d9ed37ef618cd7852ff&amp;chksm=fce71868cb90917ec76ed23990a287b25dfecd6e60300a215ff9b85d9d9db32b3ba1c7b549c7&amp;token=1964747263&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">191018-SpringBoot系列教程web篇之过滤器Filter使用指南扩展篇</a></li>
<li><a href="https://mp.weixin.qq.com/s/f01KWO3d2zhoN0Qa9-Qb6w" target="_blank" rel="noopener noreferrer">191016-SpringBoot系列教程web篇之过滤器Filter使用指南</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484348&amp;idx=1&amp;sn=e9b36572c721418b097396b50319d140&amp;chksm=fce71810cb9091063e810327e44f7ed07256188aecd352fa43f37e63e63dc64292b1a48b00cf&amp;token=823367253&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">191012-SpringBoot系列教程web篇之自定义异常处理HandlerExceptionResolver</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484344&amp;idx=1&amp;sn=d4b1422a709d9540583e33443aab6fff&amp;chksm=fce71814cb9091025a960312c878ff9fc4f44fd0035aa597f55f37c90dcbac25a3e96ee2c528&amp;token=118864495&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">191010-SpringBoot系列教程web篇之全局异常处理</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484336&amp;idx=1&amp;sn=d70f15e77bbd219af8015f9037a167fb&amp;chksm=fce7181ccb90910aee427a3f3ed7660e8303c7460859c82622a651ce1cc3d7a97f62f80ed4e0&amp;token=2447275&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">190930-SpringBoot系列教程web篇之404、500异常页面配置</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484322&amp;idx=1&amp;sn=b18090f35b59097f78858b6609506b74&amp;chksm=fce7180ecb909118d939f3ddf741a11c0977b1213d7afa12c970590590d40441c3a085c43c52&amp;token=2447275&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">190929-SpringBoot系列教程web篇之重定向</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484310&amp;idx=1&amp;sn=f6259cf1b79db095ff2e9534993d27cf&amp;chksm=fce7183acb90912cd150f086e90ecab3eceb3464e9352853e2e722288d412dbb3eb20c6e6ae7&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190913-SpringBoot系列教程web篇之返回文本、网页、图片的操作姿势</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484309&amp;idx=1&amp;sn=33d782f7529268eef6607a1ab8d41018&amp;chksm=fce71839cb90912f6020aa9463bc0136cb57969ebe27eba865d97e212c28211435791aa874ea&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190905-SpringBoot系列教程web篇之中文乱码问题解决</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484291&amp;idx=1&amp;sn=3f7e8c92ca4d7270cc5c40cafea39683&amp;chksm=fce7182fcb90913922654a4f2f04e7029b8944d71c31741334a3235aecbe1e60babcb0c0be74&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190831-SpringBoot系列教程web篇之如何自定义参数解析器</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484287&amp;idx=1&amp;sn=44461f564d6b04cbf1a5902dcb4f23c6&amp;chksm=fce718d3cb9091c5d730e63ae954c0831d53f3dd5af5d19d9c78b6009102838efaf56f7838ff&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190828-SpringBoot系列教程web篇之Post请求参数解析姿势汇总</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484282&amp;idx=1&amp;sn=a8d236d935ae24cfbe6977e24a479caa&amp;chksm=fce718d6cb9091c0dd8a6b113236f9ae9388fb026c9403c97bdf7505f773bd7330a43e3b269c&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190824-SpringBoot系列教程web篇之Get请求参数解析姿势汇总</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484268&amp;idx=3&amp;sn=9e8a6121dce291c65bd2b3d4fab24178&amp;chksm=fce718c0cb9091d6674fb809d68ca3dc3b1695162368481abf8dc094000412116d2f9971c54b&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190822-SpringBoot系列教程web篇之Beetl环境搭建</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484268&amp;idx=2&amp;sn=f800c001061eabe74e2cad915af1921a&amp;chksm=fce718c0cb9091d682b600673a0584955783f0d339248e34323efbea9b698560c432018717ef&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190820-SpringBoot系列教程web篇之Thymeleaf环境搭建</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484268&amp;idx=1&amp;sn=acd691729488d81a94c938151d5737ce&amp;chksm=fce718c0cb9091d63ef5f12893bb835c256a18318e791a0d193d00ef767ecfd019491d02e83d&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190816-SpringBoot系列教程web篇之Freemaker环境搭建</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484217&amp;idx=1&amp;sn=9fdf45d2261cdcf2ccaccaebfb5ef598&amp;chksm=fce71895cb90918361f1afd55a2b5fc9d65508913c1d793710afa79cae38bd9d57e32ad2c187&amp;token=2447275&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">190421-SpringBoot高级篇WEB之websocket的使用说明</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484197&amp;idx=1&amp;sn=0184953527f58058ee8c2bbcfc2689ec&amp;chksm=fce71889cb90919f9be003bf2487343f7952d6b33ab5ee5fb7251ae37a631d4c32e6d8a57528&amp;token=2447275&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">190327-Spring-RestTemplate之urlencode参数解析异常全程分析</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484193&amp;idx=1&amp;sn=d8a284fe0a2b8e1fefe07d892558f563&amp;chksm=fce7188dcb90919b1f8a2408bf955e37e88b043e2dbd59b5290ac1501e3d2d303512bac6af2c&amp;token=2447275&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">190317-Spring MVC之基于java config无xml配置的web应用构建</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484186&amp;idx=1&amp;sn=18db571b670815965ae9185830c4e88f&amp;chksm=fce718b6cb9091a054e0ac4be051341d8ce38ff8e40c5911302e3d6981206c14b80770590044&amp;token=2447275&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">190316-Spring MVC之基于xml配置的web应用构建</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484139&amp;idx=1&amp;sn=b4a5f3ca6215641c6bcf5123f2bfb501&amp;chksm=fce71947cb9090511042ae97a12cc975d2b199521e17980e685cccb5e0be91a8e932cef4eb76&amp;token=2447275&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">190213-SpringBoot文件上传异常之提示The temporary upload location xxx is not valid</a></li>
</ul>
<h4> 项目源码</h4>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>项目：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/210-web-filter" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/210-web-filter</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/191120/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>10.RestTemplate 4xx/5xx 异常信息捕获</title>
      <link>https://liuyueyi.github.io/tutorial/spring/web/Response/200104-SpringWeb%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8BRestTemplate-4xx-5xx-%E5%BC%82%E5%B8%B8%E4%BF%A1%E6%81%AF%E6%8D%95%E8%8E%B7.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/web/Response/200104-SpringWeb%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8BRestTemplate-4xx-5xx-%E5%BC%82%E5%B8%B8%E4%BF%A1%E6%81%AF%E6%8D%95%E8%8E%B7.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">10.RestTemplate 4xx/5xx 异常信息捕获</source>
      <description>近期使用RestTemplate访问外部资源时，发现一个有意思的问题。因为权限校验失败，对方返回的401的http code，此外返回数据中也会包含一些异常提示信息；然而在使用RestTemplate访问时，却是直接抛了如下提示401的异常，并不能拿到提示信息 那么RestTemplate如果希望可以获取到非200状态码返回数据时，可以怎么操作呢？</description>
      <category>SpringBoot</category>
      <category>WEB系列</category>
      <category>Response</category>
      <pubDate>Sat, 04 Jan 2020 16:25:14 GMT</pubDate>
      <content:encoded><![CDATA[<p>近期使用RestTemplate访问外部资源时，发现一个有意思的问题。因为权限校验失败，对方返回的401的http code，此外返回数据中也会包含一些异常提示信息；然而在使用RestTemplate访问时，却是直接抛了如下提示401的异常，并不能拿到提示信息</p>
<figure><img src="/imgs/200104/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>那么RestTemplate如果希望可以获取到非200状态码返回数据时，可以怎么操作呢？</p>
<!-- more -->
<h2> I. 异常捕获</h2>
<h3> 1. 问题分析</h3>
<p>RestTemplate的异常处理，是借助<code>org.springframework.web.client.ResponseErrorHandler</code>来做的，先看一下两个核心方法</p>
<ul>
<li>下面代码来自 spring-web.5.0.7.RELEASE版本</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>简单来讲，当RestTemplate发出请求，获取到对方相应之后，会交给<code>ResponseErrorHandler</code>来判断一下，返回结果是否ok</p>
<p>因此接下来将目标瞄准到RestTemplate默认的异常处理器: <code>org.springframework.web.client.DefaultResponseErrorHandler</code></p>
<h4> a. 判定返回结果是否ok</h4>
<p>从源码上看，主要是根据返回的http code来判断是否ok</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>请注意上面的实现，自定义的某些http code是不会被认为是异常的，因为无法转换为对应的<code>HttpStatus</code> （后面实例进行说明）</p>
<h4> b. 异常处理</h4>
<p>当上面的 <code>hasError</code> 返回ture的时候，就会进入异常处理逻辑</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从上面也可以看到，异常处理逻辑很简单，直接抛异常</p>
<h3> 2. 异常捕获</h3>
<p>定位到上面的问题之后，再想解决问题就相对简单了，自定义一个异常处理类，不管状态码返回是啥，全都认为正常即可</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. 实测</h3>
<p>首先写两个结果，返回的http状态码非200；针对返回非200状态码的case，有多种写法，下面演示两种常见的</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>首先来看一下自定义的525和标准的401 http code，直接通过<code>RestTemplate</code>访问的case</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/200104/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>从上面的输出结果也可以看出来，非标准http code不会抛异常（原因上面有分析），接下来看一下即便是标准的http code也不希望抛异常的case</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/200104/02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> II. 其他</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/200104/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>11.自定义返回Http Code的n种姿势</title>
      <link>https://liuyueyi.github.io/tutorial/spring/web/Response/200105-SpringBoot%E7%B3%BB%E5%88%97web%E7%AF%87%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BF%94%E5%9B%9EHttp-Code%E7%9A%84n%E7%A7%8D%E5%A7%BF%E5%8A%BF.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/web/Response/200105-SpringBoot%E7%B3%BB%E5%88%97web%E7%AF%87%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BF%94%E5%9B%9EHttp-Code%E7%9A%84n%E7%A7%8D%E5%A7%BF%E5%8A%BF.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">11.自定义返回Http Code的n种姿势</source>
      <description>虽然http的提供了一整套完整、定义明确的状态码，但实际的业务支持中，后端并不总会遵守这套规则，更多的是在返回结果中，加一个code字段来自定义业务状态，即便是后端5xx了，返回给前端的http code依然是200 那么如果我想遵守http的规范，不同的case返回不同的http code在Spring中可以做呢? 本文将介绍四种设置返回的HTTP CODE的方式 @ResponseStatus 注解方式 HttpServletResponse#sendError HttpServletResponse#setStatus ResponseEntity</description>
      <category>SpringBoot</category>
      <category>WEB系列</category>
      <category>Response</category>
      <pubDate>Sun, 05 Jan 2020 10:02:49 GMT</pubDate>
      <content:encoded><![CDATA[<p>虽然http的提供了一整套完整、定义明确的状态码，但实际的业务支持中，后端并不总会遵守这套规则，更多的是在返回结果中，加一个code字段来自定义业务状态，即便是后端5xx了，返回给前端的http code依然是200</p>
<p>那么如果我想遵守http的规范，不同的case返回不同的http code在Spring中可以做呢?</p>
<p>本文将介绍四种设置返回的HTTP CODE的方式</p>
<ul>
<li><code>@ResponseStatus</code> 注解方式</li>
<li><code>HttpServletResponse#sendError</code></li>
<li><code>HttpServletResponse#setStatus</code></li>
<li><code>ResponseEntity</code></li>
</ul>
<!-- more -->
<h2> I. 返回Http Code的n中姿势</h2>
<h3> 0. 环境</h3>
<p>进入正文之前，先创建一个SpringBoot项目，本文示例所有版本为 <code>spring-boot.2.1.2.RELEASE</code></p>
<p>(需要测试的小伙伴，本机创建一个maven项目，在<code>pom.xml</code>文件中，拷贝下面的配置即可)</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>下面所有的方法都放在ErrorCodeRest这个类中</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1. ResponseStatus使用姿势</h3>
<p>通过注解<code>@ResponseStatus</code>，来指定返回的http code, 一般来说，使用它有两种姿势，一个是直接加在方法上，一个是加在异常类上</p>
<h4> a. 装饰方法</h4>
<p>直接在方法上添加注解，并制定对应的code</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>实测一下，返回结果如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当我们发起请求时，返回的状态码为400，返回的数据为springboot默认的错误信息格式</p>
<p>虽然上面这种使用姿势可以设置http code，但是这种使用姿势有什么意义呢？</p>
<p>如果看过web系列教程中的：<a href="http://spring.hhui.top/spring-blog/2019/10/10/191010-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8Bweb%E7%AF%87%E4%B9%8B%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/" target="_blank" rel="noopener noreferrer">SpringBoot系列教程web篇之全局异常处理</a> 可能就会有一些映象，配合<code>@ExceptionHandler</code>来根据异常返回对应的状态码</p>
<p>一个推荐的使用姿势，下面表示当你的业务逻辑中出现数组越界时，返回500的状态码以及完整的堆栈信息</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> b. 装饰异常类</h4>
<p>另外一种使用姿势就是直接装饰在异常类上，然后当你的业务代码中，抛出特定的异常类，返回的httpcode就会设置为注解中的值</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>测试结果如下，在异常类上添加注解的方式，优点在于不需要配合<code>@ExceptionHandler</code>写额外的逻辑了；缺点则在于需要定义很多的自定义异常类型</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>注意</strong></p>
<ul>
<li>ResponseStatus注解的使用姿势，只支持标准的Http Code（必须是枚举类<code>org.springframework.http.HttpStatus</code>）</li>
</ul>
<h3> 2. ResponseEntity</h3>
<p>这种使用姿势就比较简单了，方法的返回结果必须是<code>ResponseEntity</code>，下面给出两个实际的case</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>实测结果</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从上面的使用实例上看，可以知道这种使用方式，不仅仅支持标准的http code，也支持自定义的code（如返回code 451)</p>
<h3> 3. HttpServletResponse</h3>
<p>这种使用姿势则是直接操作<code>HttpServletResponse</code>对象，手动录入返回的结果</p>
<h4> a. setStatus</h4>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用方式比较简单，直接设置status即可，支持自定义的Http Code返回</p>
<h4> b. sendError</h4>
<p>使用这种姿势的时候需要注意一下，只支持标准的http code，而且response body中不会有你的业务返回数据，如</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从上面的case也可以看出，当我们使用send error时，如果是标准的http code，会设置对响应头；如果是自定义的不被识别的code，那么返回的http code是500</p>
<h3> 4, 小结</h3>
<p>上面介绍了几种常见的设置响应http code的姿势，下面小结一下使用时的注意事项</p>
<p><strong>ResponseStatus</strong></p>
<ul>
<li>只支持标准的http code</li>
<li>装饰自定义异常类，使用时抛出对应的异常类，从而达到设置响应code的效果
<ul>
<li>缺点对非可控的异常类不可用</li>
</ul>
</li>
<li>结合<code>@ExceptionHandler</code>，用来装饰方法</li>
</ul>
<p><strong>ResponseEntity</strong></p>
<p>形如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul>
<li>我个人感觉是最强大的使用姿势，就是写起来没有那么简洁</li>
<li>支持自定义code，支持设置 response body</li>
</ul>
<p><strong>HttpServletResponse</strong></p>
<ul>
<li>setStatus: 设置响应code，支持自定义code，支持返回response body</li>
<li>sendError: 只支持标准的http code，如果传入自定义的code，返回的http code会是500</li>
</ul>
<h2> II. 其他</h2>
<h4> web系列博文</h4>
<ul>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484419&amp;idx=1&amp;sn=d04d591f6f3af7b594b2940febf3b5a1" target="_blank" rel="noopener noreferrer">191222-SpringBoot系列教程web篇之自定义请求匹配条件RequestCondition</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484393&amp;idx=1&amp;sn=84babe4c83fa49fe54605e156f81a18f&amp;chksm=fce71845cb9091533190e99f2928585aea56562312d087f2b2b0e5ae4f082e3393023349e903&amp;token=713643402&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">191206-SpringBoot系列教程web篇Listener四种注册姿势</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484377&amp;idx=1&amp;sn=a20ce7e5e04ede4dff5fa84a7c5c8448&amp;chksm=fce71875cb9091639124afa69d0ec7bbf8f50438fd7acaf582fb029b7a4adf2f36fa50d4f0fa&amp;token=1748723444&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">191122-SpringBoot系列教程web篇Servlet 注册的四种姿势</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484377&amp;idx=2&amp;sn=b341d12c8179ba803d5c82882d9799ee&amp;chksm=fce71875cb90916376c76a901187b396595082c8ab3bd9df699227132430b9a40d2b07b30638&amp;token=713643402&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">191120-SpringBoot系列教程Web篇之开启GZIP数据压缩</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484356&amp;idx=1&amp;sn=7c80f55f875f8d9ed37ef618cd7852ff&amp;chksm=fce71868cb90917ec76ed23990a287b25dfecd6e60300a215ff9b85d9d9db32b3ba1c7b549c7&amp;token=713643402&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">191018-SpringBoot系列教程web篇之过滤器Filter使用指南扩展篇</a></li>
<li><a href="https://mp.weixin.qq.com/s/f01KWO3d2zhoN0Qa9-Qb6w" target="_blank" rel="noopener noreferrer">191016-SpringBoot系列教程web篇之过滤器Filter使用指南</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484348&amp;idx=1&amp;sn=e9b36572c721418b097396b50319d140&amp;chksm=fce71810cb9091063e810327e44f7ed07256188aecd352fa43f37e63e63dc64292b1a48b00cf&amp;token=823367253&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">191012-SpringBoot系列教程web篇之自定义异常处理HandlerExceptionResolver</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484344&amp;idx=1&amp;sn=d4b1422a709d9540583e33443aab6fff&amp;chksm=fce71814cb9091025a960312c878ff9fc4f44fd0035aa597f55f37c90dcbac25a3e96ee2c528&amp;token=118864495&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">191010-SpringBoot系列教程web篇之全局异常处理</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484336&amp;idx=1&amp;sn=d70f15e77bbd219af8015f9037a167fb&amp;chksm=fce7181ccb90910aee427a3f3ed7660e8303c7460859c82622a651ce1cc3d7a97f62f80ed4e0&amp;token=2447275&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">190930-SpringBoot系列教程web篇之404、500异常页面配置</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484322&amp;idx=1&amp;sn=b18090f35b59097f78858b6609506b74&amp;chksm=fce7180ecb909118d939f3ddf741a11c0977b1213d7afa12c970590590d40441c3a085c43c52&amp;token=2447275&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">190929-SpringBoot系列教程web篇之重定向</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484310&amp;idx=1&amp;sn=f6259cf1b79db095ff2e9534993d27cf&amp;chksm=fce7183acb90912cd150f086e90ecab3eceb3464e9352853e2e722288d412dbb3eb20c6e6ae7&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190913-SpringBoot系列教程web篇之返回文本、网页、图片的操作姿势</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484309&amp;idx=1&amp;sn=33d782f7529268eef6607a1ab8d41018&amp;chksm=fce71839cb90912f6020aa9463bc0136cb57969ebe27eba865d97e212c28211435791aa874ea&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190905-SpringBoot系列教程web篇之中文乱码问题解决</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484291&amp;idx=1&amp;sn=3f7e8c92ca4d7270cc5c40cafea39683&amp;chksm=fce7182fcb90913922654a4f2f04e7029b8944d71c31741334a3235aecbe1e60babcb0c0be74&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190831-SpringBoot系列教程web篇之如何自定义参数解析器</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484287&amp;idx=1&amp;sn=44461f564d6b04cbf1a5902dcb4f23c6&amp;chksm=fce718d3cb9091c5d730e63ae954c0831d53f3dd5af5d19d9c78b6009102838efaf56f7838ff&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190828-SpringBoot系列教程web篇之Post请求参数解析姿势汇总</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484282&amp;idx=1&amp;sn=a8d236d935ae24cfbe6977e24a479caa&amp;chksm=fce718d6cb9091c0dd8a6b113236f9ae9388fb026c9403c97bdf7505f773bd7330a43e3b269c&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190824-SpringBoot系列教程web篇之Get请求参数解析姿势汇总</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484268&amp;idx=3&amp;sn=9e8a6121dce291c65bd2b3d4fab24178&amp;chksm=fce718c0cb9091d6674fb809d68ca3dc3b1695162368481abf8dc094000412116d2f9971c54b&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190822-SpringBoot系列教程web篇之Beetl环境搭建</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484268&amp;idx=2&amp;sn=f800c001061eabe74e2cad915af1921a&amp;chksm=fce718c0cb9091d682b600673a0584955783f0d339248e34323efbea9b698560c432018717ef&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190820-SpringBoot系列教程web篇之Thymeleaf环境搭建</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484268&amp;idx=1&amp;sn=acd691729488d81a94c938151d5737ce&amp;chksm=fce718c0cb9091d63ef5f12893bb835c256a18318e791a0d193d00ef767ecfd019491d02e83d&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190816-SpringBoot系列教程web篇之Freemaker环境搭建</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484217&amp;idx=1&amp;sn=9fdf45d2261cdcf2ccaccaebfb5ef598&amp;chksm=fce71895cb90918361f1afd55a2b5fc9d65508913c1d793710afa79cae38bd9d57e32ad2c187&amp;token=2447275&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">190421-SpringBoot高级篇WEB之websocket的使用说明</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484197&amp;idx=1&amp;sn=0184953527f58058ee8c2bbcfc2689ec&amp;chksm=fce71889cb90919f9be003bf2487343f7952d6b33ab5ee5fb7251ae37a631d4c32e6d8a57528&amp;token=2447275&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">190327-Spring-RestTemplate之urlencode参数解析异常全程分析</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484193&amp;idx=1&amp;sn=d8a284fe0a2b8e1fefe07d892558f563&amp;chksm=fce7188dcb90919b1f8a2408bf955e37e88b043e2dbd59b5290ac1501e3d2d303512bac6af2c&amp;token=2447275&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">190317-Spring MVC之基于java config无xml配置的web应用构建</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484186&amp;idx=1&amp;sn=18db571b670815965ae9185830c4e88f&amp;chksm=fce718b6cb9091a054e0ac4be051341d8ce38ff8e40c5911302e3d6981206c14b80770590044&amp;token=2447275&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">190316-Spring MVC之基于xml配置的web应用构建</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484139&amp;idx=1&amp;sn=b4a5f3ca6215641c6bcf5123f2bfb501&amp;chksm=fce71947cb9090511042ae97a12cc975d2b199521e17980e685cccb5e0be91a8e932cef4eb76&amp;token=2447275&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">190213-SpringBoot文件上传异常之提示The temporary upload location xxx is not valid</a></li>
</ul>
<p><strong>项目源码</strong></p>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>项目：<a href="https://github.com/liuyueyi/spring-boot-demo/blob/master/spring-boot/207-web-response" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/blob/master/spring-boot/207-web-response</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>12.异步请求知识点与使用姿势小结</title>
      <link>https://liuyueyi.github.io/tutorial/spring/web/Response/200329-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B9%8B%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82%E6%9C%80%E5%85%A8%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%8E%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/web/Response/200329-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B9%8B%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82%E6%9C%80%E5%85%A8%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%8E%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">12.异步请求知识点与使用姿势小结</source>
      <description>在Servlet3.0就引入了异步请求的支持，但是在实际的业务开发中，可能用过这个特性的童鞋并不多？ 本篇博文作为异步请求的扫盲和使用教程，将包含以下知识点 什么是异步请求，有什么特点，适用场景 四种使用姿势： AsyncContext方式 Callable WebAsyncTask DeferredResult</description>
      <category>SpringBoot</category>
      <category>WEB系列</category>
      <category>Response</category>
      <pubDate>Sun, 29 Mar 2020 16:47:54 GMT</pubDate>
      <content:encoded><![CDATA[<p>在Servlet3.0就引入了异步请求的支持，但是在实际的业务开发中，可能用过这个特性的童鞋并不多？</p>
<p>本篇博文作为异步请求的扫盲和使用教程，将包含以下知识点</p>
<ul>
<li>什么是异步请求，有什么特点，适用场景</li>
<li>四种使用姿势：
<ul>
<li>AsyncContext方式</li>
<li>Callable</li>
<li>WebAsyncTask</li>
<li>DeferredResult</li>
</ul>
</li>
</ul>
<!-- more -->
<h2> I. 异步请求</h2>
<p>异步对于我们而言，应该属于经常可以听到的词汇了，在实际的开发中多多少少都会用到，那么什么是异步请求呢</p>
<h3> 1. 异步请求描述</h3>
<p><strong>先介绍一下同步与异步：</strong></p>
<p>一个正常调用，吭哧吭哧执行完毕之后直接返回，这个叫同步；</p>
<p>接收到调用，自己不干，新开一个线程来做，主线程自己则去干其他的事情，等后台线程吭哧吭哧的跑完之后，主线程再返回结果，这个就叫异步</p>
<p><strong>异步请求：</strong></p>
<p>我们这里讲到的异步请求，主要是针对web请求而言，后端响应请求的一种手段，同步/异步对于前端而言是无感知、无区别的</p>
<p>同步请求，后端接收到请求之后，直接在处理请求线程中，执行业务逻辑，并返回</p>
<figure><img src="/imgs/200329/00.jpg" alt="来源于网络" tabindex="0" loading="lazy"><figcaption>来源于网络</figcaption></figure>
<p>异步请求，后端接收到请求之后，新开一个线程，来执行业务逻辑，释放请求线程，避免请求线程被大量耗时的请求沾满，导致服务不可用</p>
<figure><img src="/imgs/200329/01.jpg" alt="来源于网络" tabindex="0" loading="lazy"><figcaption>来源于网络</figcaption></figure>
<h3> 2. 特点</h3>
<p>通过上面两张图，可以知道异步请求的最主要特点</p>
<ul>
<li>业务线程，处理请求逻辑</li>
<li>请求处理线程立即释放，通过回调处理线程返回结果</li>
</ul>
<h3> 3. 场景分析</h3>
<p>从特点出发，也可以很容易看出异步请求，更适用于耗时的请求，快速的释放请求处理线程，避免web容器的请求线程被打满，导致服务不可用</p>
<p>举一个稍微极端一点的例子，比如我以前做过的一个多媒体服务，提供图片、音视频的编辑，这些服务接口有同步返回结果的也有异步返回结果的；同步返回结果的接口有快有慢，大部分耗时可能<code>&lt;10ms</code>，而有部分接口耗时则在几十甚至上百</p>
<p>这种场景下，耗时的接口就可以考虑用异步请求的方式来支持了，避免占用过多的请求处理线程，影响其他的服务</p>
<h2> II. 使用姿势</h2>
<p>接下来介绍四种异步请求的使用姿势，原理一致，只是使用的场景稍有不同</p>
<h3> 1. AsyncContext</h3>
<p>在Servlet3.0+之后就支持了异步请求，第一种方式比较原始，相当于直接借助Servlet的规范来实现，当然下面的case并不是直接创建一个servlet，而是借助<code>AsyncContext</code>来实现</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>完整的实现如上，简单的来看一下一般步骤</p>
<ul>
<li><code>javax.servlet.ServletRequest#startAsync()</code>获取<code>AsyncContext</code></li>
<li>添加监听器 <code>asyncContext.addListener(AsyncListener)</code>（这个是可选的）
<ul>
<li>用户请求开始、超时、异常、完成时回调</li>
</ul>
</li>
<li>设置超时时间 <code>asyncContext.setTimeout(3000L)</code> （可选）</li>
<li>异步任务<code>asyncContext.start(Runnable)</code></li>
</ul>
<h3> 2. Callable</h3>
<p>相比较于上面的复杂的示例，SpringMVC可以非常easy的实现，直接返回一个<code>Callable</code>即可</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>请注意上面的两种case，一个正常返回，一个业务执行过程中，抛出来异常</p>
<p>分别请求，输出如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>异常请求: <code>http://localhost:8080/call/exception</code></p>
<figure><img src="/imgs/200329/02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. WebAsyncTask</h3>
<p>callable的方式，非常直观简单，但是我们经常关注的超时+异常的处理却不太好，这个时候我们可以用<code>WebAsyncTask</code>，实现姿势也很简单，包装一下<code>callable</code>，然后设置各种回调事件即可</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4. DeferredResult</h3>
<p><code>DeferredResult</code>与<code>WebAsyncTask</code>最大的区别就是前者不确定什么时候会返回结果，</p>
<blockquote>
<p><code>DeferredResult</code>的这个特点，可以用来做实现很多有意思的东西，如后面将介绍的<code>SseEmitter</code>就用到了它</p>
</blockquote>
<p>下面给出一个实例</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面的实例中，用户如果先访问<code>http://localhost:8080/defer/get?id=yihuihui</code>，不会立马有结果，直到用户再次访问<code>http://localhost:8080/defer/pub?id=yihuihui&amp;content=哈哈</code>时，前面的请求才会有结果返回</p>
<figure><img src="/imgs/200329/03.gif" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>那么这个可以设置超时么，如果一直把前端挂住，貌似也不太合适吧</p>
<ul>
<li>在构造方法中指定超时时间: <code>new DeferredResult&lt;&gt;(3000L)</code></li>
<li>设置全局的默认超时时间</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> II. 其他</h2>
<h3> 0. 项目</h3>
<p><strong>相关博文</strong></p>
<ul>
<li><a href="https://www.cnblogs.com/bjlhx/p/10444814.html" target="_blank" rel="noopener noreferrer">007-优化web请求三-异步调用【WebAsyncTask】</a></li>
<li><a href="https://blog.csdn.net/f641385712/article/details/88692534" target="_blank" rel="noopener noreferrer">高性能关键技术之---体验Spring MVC的异步模式（Callable、WebAsyncTask、DeferredResult） 基础使用篇</a></li>
</ul>
<p><strong>系列博文</strong></p>
<ul>
<li><a href="http://spring.hhui.top/spring-blog/2020/01/05/200105-SpringBoot%E7%B3%BB%E5%88%97web%E7%AF%87%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BF%94%E5%9B%9EHttp-Code%E7%9A%84n%E7%A7%8D%E5%A7%BF%E5%8A%BF/" target="_blank" rel="noopener noreferrer">200105-SpringBoot系列web篇之自定义返回Http-Code的n种姿势</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484419&amp;idx=1&amp;sn=d04d591f6f3af7b594b2940febf3b5a1" target="_blank" rel="noopener noreferrer">191222-SpringBoot系列教程web篇之自定义请求匹配条件RequestCondition</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484393&amp;idx=1&amp;sn=84babe4c83fa49fe54605e156f81a18f&amp;chksm=fce71845cb9091533190e99f2928585aea56562312d087f2b2b0e5ae4f082e3393023349e903&amp;token=713643402&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">191206-SpringBoot系列教程web篇Listener四种注册姿势</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484377&amp;idx=1&amp;sn=a20ce7e5e04ede4dff5fa84a7c5c8448&amp;chksm=fce71875cb9091639124afa69d0ec7bbf8f50438fd7acaf582fb029b7a4adf2f36fa50d4f0fa&amp;token=1748723444&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">191122-SpringBoot系列教程web篇Servlet 注册的四种姿势</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484377&amp;idx=2&amp;sn=b341d12c8179ba803d5c82882d9799ee&amp;chksm=fce71875cb90916376c76a901187b396595082c8ab3bd9df699227132430b9a40d2b07b30638&amp;token=713643402&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">191120-SpringBoot系列教程Web篇之开启GZIP数据压缩</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484356&amp;idx=1&amp;sn=7c80f55f875f8d9ed37ef618cd7852ff&amp;chksm=fce71868cb90917ec76ed23990a287b25dfecd6e60300a215ff9b85d9d9db32b3ba1c7b549c7&amp;token=713643402&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">191018-SpringBoot系列教程web篇之过滤器Filter使用指南扩展篇</a></li>
<li><a href="https://mp.weixin.qq.com/s/f01KWO3d2zhoN0Qa9-Qb6w" target="_blank" rel="noopener noreferrer">191016-SpringBoot系列教程web篇之过滤器Filter使用指南</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484348&amp;idx=1&amp;sn=e9b36572c721418b097396b50319d140&amp;chksm=fce71810cb9091063e810327e44f7ed07256188aecd352fa43f37e63e63dc64292b1a48b00cf&amp;token=823367253&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">191012-SpringBoot系列教程web篇之自定义异常处理HandlerExceptionResolver</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484344&amp;idx=1&amp;sn=d4b1422a709d9540583e33443aab6fff&amp;chksm=fce71814cb9091025a960312c878ff9fc4f44fd0035aa597f55f37c90dcbac25a3e96ee2c528&amp;token=118864495&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">191010-SpringBoot系列教程web篇之全局异常处理</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484336&amp;idx=1&amp;sn=d70f15e77bbd219af8015f9037a167fb&amp;chksm=fce7181ccb90910aee427a3f3ed7660e8303c7460859c82622a651ce1cc3d7a97f62f80ed4e0&amp;token=2447275&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">190930-SpringBoot系列教程web篇之404、500异常页面配置</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484322&amp;idx=1&amp;sn=b18090f35b59097f78858b6609506b74&amp;chksm=fce7180ecb909118d939f3ddf741a11c0977b1213d7afa12c970590590d40441c3a085c43c52&amp;token=2447275&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">190929-SpringBoot系列教程web篇之重定向</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484310&amp;idx=1&amp;sn=f6259cf1b79db095ff2e9534993d27cf&amp;chksm=fce7183acb90912cd150f086e90ecab3eceb3464e9352853e2e722288d412dbb3eb20c6e6ae7&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190913-SpringBoot系列教程web篇之返回文本、网页、图片的操作姿势</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484309&amp;idx=1&amp;sn=33d782f7529268eef6607a1ab8d41018&amp;chksm=fce71839cb90912f6020aa9463bc0136cb57969ebe27eba865d97e212c28211435791aa874ea&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190905-SpringBoot系列教程web篇之中文乱码问题解决</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484291&amp;idx=1&amp;sn=3f7e8c92ca4d7270cc5c40cafea39683&amp;chksm=fce7182fcb90913922654a4f2f04e7029b8944d71c31741334a3235aecbe1e60babcb0c0be74&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190831-SpringBoot系列教程web篇之如何自定义参数解析器</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484287&amp;idx=1&amp;sn=44461f564d6b04cbf1a5902dcb4f23c6&amp;chksm=fce718d3cb9091c5d730e63ae954c0831d53f3dd5af5d19d9c78b6009102838efaf56f7838ff&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190828-SpringBoot系列教程web篇之Post请求参数解析姿势汇总</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484282&amp;idx=1&amp;sn=a8d236d935ae24cfbe6977e24a479caa&amp;chksm=fce718d6cb9091c0dd8a6b113236f9ae9388fb026c9403c97bdf7505f773bd7330a43e3b269c&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190824-SpringBoot系列教程web篇之Get请求参数解析姿势汇总</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484268&amp;idx=3&amp;sn=9e8a6121dce291c65bd2b3d4fab24178&amp;chksm=fce718c0cb9091d6674fb809d68ca3dc3b1695162368481abf8dc094000412116d2f9971c54b&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190822-SpringBoot系列教程web篇之Beetl环境搭建</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484268&amp;idx=2&amp;sn=f800c001061eabe74e2cad915af1921a&amp;chksm=fce718c0cb9091d682b600673a0584955783f0d339248e34323efbea9b698560c432018717ef&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190820-SpringBoot系列教程web篇之Thymeleaf环境搭建</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484268&amp;idx=1&amp;sn=acd691729488d81a94c938151d5737ce&amp;chksm=fce718c0cb9091d63ef5f12893bb835c256a18318e791a0d193d00ef767ecfd019491d02e83d&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190816-SpringBoot系列教程web篇之Freemaker环境搭建</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484217&amp;idx=1&amp;sn=9fdf45d2261cdcf2ccaccaebfb5ef598&amp;chksm=fce71895cb90918361f1afd55a2b5fc9d65508913c1d793710afa79cae38bd9d57e32ad2c187&amp;token=2447275&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">190421-SpringBoot高级篇WEB之websocket的使用说明</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484197&amp;idx=1&amp;sn=0184953527f58058ee8c2bbcfc2689ec&amp;chksm=fce71889cb90919f9be003bf2487343f7952d6b33ab5ee5fb7251ae37a631d4c32e6d8a57528&amp;token=2447275&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">190327-Spring-RestTemplate之urlencode参数解析异常全程分析</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484193&amp;idx=1&amp;sn=d8a284fe0a2b8e1fefe07d892558f563&amp;chksm=fce7188dcb90919b1f8a2408bf955e37e88b043e2dbd59b5290ac1501e3d2d303512bac6af2c&amp;token=2447275&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">190317-Spring MVC之基于java config无xml配置的web应用构建</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484186&amp;idx=1&amp;sn=18db571b670815965ae9185830c4e88f&amp;chksm=fce718b6cb9091a054e0ac4be051341d8ce38ff8e40c5911302e3d6981206c14b80770590044&amp;token=2447275&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">190316-Spring MVC之基于xml配置的web应用构建</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484139&amp;idx=1&amp;sn=b4a5f3ca6215641c6bcf5123f2bfb501&amp;chksm=fce71947cb9090511042ae97a12cc975d2b199521e17980e685cccb5e0be91a8e932cef4eb76&amp;token=2447275&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">190213-SpringBoot文件上传异常之提示The temporary upload location xxx is not valid</a></li>
</ul>
<p><strong>源码</strong></p>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>项目源码: <a href="https://github.com/liuyueyi/spring-boot-demo/blob/master/spring-boot/219-web-asyn" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/blob/master/spring-boot/219-web-asyn</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/200329/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>13.SSE服务器发送事件详解</title>
      <link>https://liuyueyi.github.io/tutorial/spring/web/Response/200401-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B9%8BSSE%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%91%E9%80%81%E4%BA%8B%E4%BB%B6%E8%AF%A6%E8%A7%A3.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/web/Response/200401-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B9%8BSSE%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%91%E9%80%81%E4%BA%8B%E4%BB%B6%E8%AF%A6%E8%A7%A3.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">13.SSE服务器发送事件详解</source>
      <description>SSE全称Server Sent Event，直译一下就是服务器发送事件，一般的项目开发中，用到的机会不多，可能很多小伙伴不太清楚这个东西，到底是干啥的，有啥用 本文主要知识点如下： SSE扫盲，应用场景分析 借助异步请求实现sse功能，加深概念理解 使用SseEmitter实现一个简单的推送示例</description>
      <category>SpringBoot</category>
      <category>WEB系列</category>
      <category>Response</category>
      <pubDate>Wed, 01 Apr 2020 19:01:42 GMT</pubDate>
      <content:encoded><![CDATA[<p>SSE全称<code>Server Sent Event</code>，直译一下就是服务器发送事件，一般的项目开发中，用到的机会不多，可能很多小伙伴不太清楚这个东西，到底是干啥的，有啥用</p>
<p>本文主要知识点如下：</p>
<ul>
<li>SSE扫盲，应用场景分析</li>
<li>借助异步请求实现sse功能，加深概念理解</li>
<li>使用<code>SseEmitter</code>实现一个简单的推送示例</li>
</ul>
<!-- more -->
<h2> I. SSE扫盲</h2>
<blockquote>
<p>对于sse基础概念比较清楚的可以跳过本节</p>
</blockquote>
<h3> 1. 概念介绍</h3>
<p>sse(<code>Server Sent Event</code>)，直译为服务器发送事件，顾名思义，也就是客户端可以获取到服务器发送的事件</p>
<p>我们常见的http交互方式是客户端发起请求，服务端响应，然后一次请求完毕；但是在sse的场景下，客户端发起请求，连接一直保持，服务端有数据就可以返回数据给客户端，这个返回可以是多次间隔的方式</p>
<h3> 2. 特点分析</h3>
<p>SSE最大的特点，可以简单规划为两个</p>
<ul>
<li>长连接</li>
<li>服务端可以向客户端推送信息</li>
</ul>
<p>了解websocket的小伙伴，可能也知道它也是长连接，可以推送信息，但是它们有一个明显的区别</p>
<p><strong>sse是单通道，只能服务端向客户端发消息；而webscoket是双通道</strong></p>
<p>那么为什么有了webscoket还要搞出一个sse呢？既然存在，必然有着它的优越之处</p>
<table>
<thead>
<tr>
<th>sse</th>
<th>websocket</th>
</tr>
</thead>
<tbody>
<tr>
<td>http协议</td>
<td>独立的websocket协议</td>
</tr>
<tr>
<td>轻量，使用简单</td>
<td>相对复杂</td>
</tr>
<tr>
<td>默认支持断线重连</td>
<td>需要自己实现断线重连</td>
</tr>
<tr>
<td>文本传输</td>
<td>二进制传输</td>
</tr>
<tr>
<td>支持自定义发送的消息类型</td>
<td>-</td>
</tr>
</tbody>
</table>
<h3> 3. 应用场景</h3>
<p>从sse的特点出发，我们可以大致的判断出它的应用场景，需要轮询获取服务端最新数据的case下，多半是可以用它的</p>
<p>比如显示当前网站在线的实时人数，法币汇率显示当前实时汇率，电商大促的实时成交额等等...</p>
<h2> II. 手动实现sse功能</h2>
<p>sse本身是有自己的一套玩法的，后面会进行说明，这一小节，则主要针对sse的两个特点<code>长连接 + 后端推送数据</code>，如果让我们自己来实现这样的一个接口，可以怎么做？</p>
<h3> 1. 项目创建</h3>
<p>借助SpringBoot <code>2.2.1.RELEASE</code>来创建一个用于演示的工程项目，核心的xml依赖如下</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 功能实现</h3>
<p>在Http1.1支持了长连接，请求头添加一个<code>Connection: keep-alive</code>即可</p>
<p>在这里我们借助异步请求来实现sse功能，至于什么是异步请求，推荐查看博文: <a href="http://spring.hhui.top/spring-blog/2020/03/29/200329-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B9%8B%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82%E6%9C%80%E5%85%A8%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%8E%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF/" target="_blank" rel="noopener noreferrer">【WEB系列】异步请求知识点与使用姿势小结</a></p>
<p>因为后端可以不定时返回数据，所以我们需要注意的就是需要保持连接，不要返回一次数据之后就断开了；其次就是需要设置请求头<code>Content-Type: text/event-stream;charset=UTF-8</code> （如果不是流的话会怎样？）</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>看一下上面的实现，基本上还是异步请求的那一套逻辑，请仔细看一下<code>callable</code>中的逻辑，有一个while循环，来保证长连接不中断</p>
<p>接下来我们新增两个接口，用来模拟后端给客户端发送消息，关闭连接的场景</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们简单的来演示下操作过程</p>
<figure><img src="/imgs/200401/00.gif" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> III. SseEmitter</h2>
<p>上面只是简单实现了sse的长连接 + 后端推送消息，但是与标准的SSE还是有区别的，sse有自己的规范，而我们上面的实现，实际上并没有管这个，导致的问题是前端按照sse的玩法来请求数据，可能并不能正常工作</p>
<h3> 1. sse规范</h3>
<p>在html5的定义中，服务端sse，一般需要遵循以下要求</p>
<p><strong>请求头</strong></p>
<p>开启长连接 + 流方式传递</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>数据格式</strong></p>
<p>服务端发送的消息，由message组成，其格式如下:</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>其中field有五种可能</p>
<ul>
<li>空: 即以<code>:</code>开头，表示注释，可以理解为服务端向客户端发送的心跳，确保连接不中断</li>
<li>data：数据</li>
<li>event: 事件，默认值</li>
<li>id: 数据标识符用id字段表示，相当于每一条数据的编号</li>
<li>retry: 重连时间</li>
</ul>
<h3> 2. 实现</h3>
<p>SpringBoot利用SseEmitter来支持sse，可以说非常简单了，直接返回<code>SseEmitter</code>对象即可；重写一下上面的逻辑</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的实现，用到了SseEmitter的几个方法，解释如下</p>
<ul>
<li><code>send()</code>: 发送数据，如果传入的是一个非<code>SseEventBuilder</code>对象，那么传递参数会被封装到data中</li>
<li><code>complete()</code>: 表示执行完毕，会断开连接</li>
<li><code>onTimeout()</code>: 超时回调触发</li>
<li><code>onCompletion()</code>: 结束之后的回调触发</li>
</ul>
<p>同样演示一下访问请求</p>
<figure><img src="/imgs/200401/01.gif" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>上图总的效果和前面的效果差不多，而且输出还待上了前缀，接下来我们写一个简单的html消费端，用来演示一下完整的sse的更多特性</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>将上面的html文件放在项目的<code>resources/static</code>目录下；然后修改一下前面的<code>SseRest</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们上面超时时间设置的比较短，用来测试下客户端的自动重连，如下，开启的日志不断增加</p>
<figure><img src="/imgs/200401/02.gif" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>其次将SseEmitter的超时时间设长一点，再试一下数据推送功能</p>
<figure><img src="/imgs/200401/03.gif" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>请注意上面的演示，当后端结束了长连接之后，客户端会自动重新再次连接，不用写外的重试逻辑了，就这么神奇</p>
<h3> 3. 小结</h3>
<p>本篇文章介绍了SSE的相关知识点，并对比websocket给出了sse的优点（至于啥优点请往上翻）</p>
<p>请注意，本文虽然介绍了两种sse的方式，第一种借助异步请求来实现，如果需要完成sse的规范要求，需要自己做一些适配，如果需要了解sse底层实现原理的话，可以参考一下；在实际的业务开发中，推荐使用<code>SseEmitter</code></p>
<h2> IV. 其他</h2>
<h3> 0. 项目</h3>
<p><strong>系列博文</strong></p>
<ul>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484567&amp;idx=1&amp;sn=de01a82e80c748aa6bb9fde8a51cae5b" target="_blank" rel="noopener noreferrer">200329-SpringBoot系列教程web篇之异步请求知识点与使用姿势小结</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484453&amp;idx=1&amp;sn=6d273ec9e6756d17e1b18dd88d322759" target="_blank" rel="noopener noreferrer">200105-SpringBoot系列教程web篇之自定义返回Http-Code的n种姿势</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484419&amp;idx=1&amp;sn=d04d591f6f3af7b594b2940febf3b5a1" target="_blank" rel="noopener noreferrer">191222-SpringBoot系列教程web篇之自定义请求匹配条件RequestCondition</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484393&amp;idx=1&amp;sn=84babe4c83fa49fe54605e156f81a18f&amp;chksm=fce71845cb9091533190e99f2928585aea56562312d087f2b2b0e5ae4f082e3393023349e903&amp;token=713643402&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">191206-SpringBoot系列教程web篇Listener四种注册姿势</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484377&amp;idx=1&amp;sn=a20ce7e5e04ede4dff5fa84a7c5c8448&amp;chksm=fce71875cb9091639124afa69d0ec7bbf8f50438fd7acaf582fb029b7a4adf2f36fa50d4f0fa&amp;token=1748723444&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">191122-SpringBoot系列教程web篇Servlet 注册的四种姿势</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484377&amp;idx=2&amp;sn=b341d12c8179ba803d5c82882d9799ee&amp;chksm=fce71875cb90916376c76a901187b396595082c8ab3bd9df699227132430b9a40d2b07b30638&amp;token=713643402&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">191120-SpringBoot系列教程Web篇之开启GZIP数据压缩</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484356&amp;idx=1&amp;sn=7c80f55f875f8d9ed37ef618cd7852ff&amp;chksm=fce71868cb90917ec76ed23990a287b25dfecd6e60300a215ff9b85d9d9db32b3ba1c7b549c7&amp;token=713643402&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">191018-SpringBoot系列教程web篇之过滤器Filter使用指南扩展篇</a></li>
<li><a href="https://mp.weixin.qq.com/s/f01KWO3d2zhoN0Qa9-Qb6w" target="_blank" rel="noopener noreferrer">191016-SpringBoot系列教程web篇之过滤器Filter使用指南</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484348&amp;idx=1&amp;sn=e9b36572c721418b097396b50319d140&amp;chksm=fce71810cb9091063e810327e44f7ed07256188aecd352fa43f37e63e63dc64292b1a48b00cf&amp;token=823367253&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">191012-SpringBoot系列教程web篇之自定义异常处理HandlerExceptionResolver</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484344&amp;idx=1&amp;sn=d4b1422a709d9540583e33443aab6fff&amp;chksm=fce71814cb9091025a960312c878ff9fc4f44fd0035aa597f55f37c90dcbac25a3e96ee2c528&amp;token=118864495&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">191010-SpringBoot系列教程web篇之全局异常处理</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484336&amp;idx=1&amp;sn=d70f15e77bbd219af8015f9037a167fb&amp;chksm=fce7181ccb90910aee427a3f3ed7660e8303c7460859c82622a651ce1cc3d7a97f62f80ed4e0&amp;token=2447275&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">190930-SpringBoot系列教程web篇之404、500异常页面配置</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484322&amp;idx=1&amp;sn=b18090f35b59097f78858b6609506b74&amp;chksm=fce7180ecb909118d939f3ddf741a11c0977b1213d7afa12c970590590d40441c3a085c43c52&amp;token=2447275&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">190929-SpringBoot系列教程web篇之重定向</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484310&amp;idx=1&amp;sn=f6259cf1b79db095ff2e9534993d27cf&amp;chksm=fce7183acb90912cd150f086e90ecab3eceb3464e9352853e2e722288d412dbb3eb20c6e6ae7&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190913-SpringBoot系列教程web篇之返回文本、网页、图片的操作姿势</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484309&amp;idx=1&amp;sn=33d782f7529268eef6607a1ab8d41018&amp;chksm=fce71839cb90912f6020aa9463bc0136cb57969ebe27eba865d97e212c28211435791aa874ea&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190905-SpringBoot系列教程web篇之中文乱码问题解决</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484291&amp;idx=1&amp;sn=3f7e8c92ca4d7270cc5c40cafea39683&amp;chksm=fce7182fcb90913922654a4f2f04e7029b8944d71c31741334a3235aecbe1e60babcb0c0be74&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190831-SpringBoot系列教程web篇之如何自定义参数解析器</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484287&amp;idx=1&amp;sn=44461f564d6b04cbf1a5902dcb4f23c6&amp;chksm=fce718d3cb9091c5d730e63ae954c0831d53f3dd5af5d19d9c78b6009102838efaf56f7838ff&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190828-SpringBoot系列教程web篇之Post请求参数解析姿势汇总</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484282&amp;idx=1&amp;sn=a8d236d935ae24cfbe6977e24a479caa&amp;chksm=fce718d6cb9091c0dd8a6b113236f9ae9388fb026c9403c97bdf7505f773bd7330a43e3b269c&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190824-SpringBoot系列教程web篇之Get请求参数解析姿势汇总</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484268&amp;idx=3&amp;sn=9e8a6121dce291c65bd2b3d4fab24178&amp;chksm=fce718c0cb9091d6674fb809d68ca3dc3b1695162368481abf8dc094000412116d2f9971c54b&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190822-SpringBoot系列教程web篇之Beetl环境搭建</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484268&amp;idx=2&amp;sn=f800c001061eabe74e2cad915af1921a&amp;chksm=fce718c0cb9091d682b600673a0584955783f0d339248e34323efbea9b698560c432018717ef&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190820-SpringBoot系列教程web篇之Thymeleaf环境搭建</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484268&amp;idx=1&amp;sn=acd691729488d81a94c938151d5737ce&amp;chksm=fce718c0cb9091d63ef5f12893bb835c256a18318e791a0d193d00ef767ecfd019491d02e83d&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190816-SpringBoot系列教程web篇之Freemaker环境搭建</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484217&amp;idx=1&amp;sn=9fdf45d2261cdcf2ccaccaebfb5ef598&amp;chksm=fce71895cb90918361f1afd55a2b5fc9d65508913c1d793710afa79cae38bd9d57e32ad2c187&amp;token=2447275&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">190421-SpringBoot高级篇WEB之websocket的使用说明</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484197&amp;idx=1&amp;sn=0184953527f58058ee8c2bbcfc2689ec&amp;chksm=fce71889cb90919f9be003bf2487343f7952d6b33ab5ee5fb7251ae37a631d4c32e6d8a57528&amp;token=2447275&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">190327-Spring-RestTemplate之urlencode参数解析异常全程分析</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484193&amp;idx=1&amp;sn=d8a284fe0a2b8e1fefe07d892558f563&amp;chksm=fce7188dcb90919b1f8a2408bf955e37e88b043e2dbd59b5290ac1501e3d2d303512bac6af2c&amp;token=2447275&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">190317-Spring MVC之基于java config无xml配置的web应用构建</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484186&amp;idx=1&amp;sn=18db571b670815965ae9185830c4e88f&amp;chksm=fce718b6cb9091a054e0ac4be051341d8ce38ff8e40c5911302e3d6981206c14b80770590044&amp;token=2447275&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">190316-Spring MVC之基于xml配置的web应用构建</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484139&amp;idx=1&amp;sn=b4a5f3ca6215641c6bcf5123f2bfb501&amp;chksm=fce71947cb9090511042ae97a12cc975d2b199521e17980e685cccb5e0be91a8e932cef4eb76&amp;token=2447275&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">190213-SpringBoot文件上传异常之提示The temporary upload location xxx is not valid</a></li>
</ul>
<p><strong>源码</strong></p>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>项目源码: <a href="https://github.com/liuyueyi/spring-boot-demo/blob/master/spring-boot/220-web-sse" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/blob/master/spring-boot/220-web-sse</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/200401/00.gif" type="image/gif"/>
    </item>
    <item>
      <title>14.thymeleaf foreach踩坑记录</title>
      <link>https://liuyueyi.github.io/tutorial/spring/web/Response/211113-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8Bthymeleaf-foreach%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/web/Response/211113-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8Bthymeleaf-foreach%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">14.thymeleaf foreach踩坑记录</source>
      <description>话说自从前后端分离之后，前后端放在一起的场景就很少了，最近写个简单的后台，突然踩坑了，使用themeleaf模板渲染时，发现th:each来遍历生成表单数据，一直抛异常，提示Property or field &amp;apos;xxx&amp;apos; cannot be found on null 接下来看一下这个问题到底是个什么情况</description>
      <category>SpringBoot</category>
      <category>WEB系列</category>
      <category>采坑记录</category>
      <pubDate>Sat, 13 Nov 2021 18:56:17 GMT</pubDate>
      <content:encoded><![CDATA[<p>话说自从前后端分离之后，前后端放在一起的场景就很少了，最近写个简单的后台，突然踩坑了，使用themeleaf模板渲染时，发现<code>th:each</code>来遍历生成表单数据，一直抛异常，提示<code>Property or field 'xxx' cannot be found on null</code></p>
<p>接下来看一下这个问题到底是个什么情况</p>
<!-- more -->
<h2> I. 项目搭建</h2>
<h3> 1. 项目依赖</h3>
<p>本项目借助<code>SpringBoot 2.2.1.RELEASE</code> + <code>maven 3.5.3</code> + <code>IDEA</code>进行开发</p>
<p>开一个web服务用于测试</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>配置文件application.yml</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> II. 问题复现与处理</h2>
<h3> 1. 场景复现</h3>
<p>一个最基础的demo，来演示一下问题</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对应的html文件如下(注意，放在资源目录 <code>templates</code> 下)</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意上面的模板，有两个each遍历，出现问题的是第二个</p>
<figure><img src="/imgs/211113/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 2. 原因说明</h3>
<p>上面提示user没有，那么是否是语法问题呢？将html改成下面这个时</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/211113/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>相同的写法，上面这个就可以，经过多方尝试，发现出现问题的原因居然是<code>&lt;p&gt;</code>这个标签</p>
<p>简单来讲，就是<code>&lt;p&gt;</code>标签不能使用<code>th:each</code>，测试一下其他的标签之后发现<code>&lt;img&gt;</code>，<code>&lt;input&gt;</code>标签也不能用</p>
<p>那么问题来了，为啥这几个标签不能使用each呢？</p>
<p>这个原因可能就需要去瞅一下实现逻辑了，有知道的小伙伴可以科普一下</p>
<h2> III. 不能错过的源码和相关知识点</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/</a></li>
</ul>
<h3> 1. 微信公众号: 一灰灰Blog</h3>
<p>尽信书则不如，以上内容，纯属一家之言，因个人能力有限，难免有疏漏和错误之处，如发现bug或者有更好的建议，欢迎批评指正，不吝感激</p>
<p>下面一灰灰的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛</p>
<ul>
<li>一灰灰Blog个人博客 <a href="https://blog.hhui.top" target="_blank" rel="noopener noreferrer">https://blog.hhui.top</a></li>
<li>一灰灰Blog-Spring专题博客 <a href="http://spring.hhui.top" target="_blank" rel="noopener noreferrer">http://spring.hhui.top</a></li>
</ul>
<figure><img src="https://spring.hhui.top/spring-blog/imgs/info/info.png" alt="一灰灰blog" tabindex="0" loading="lazy"><figcaption>一灰灰blog</figcaption></figure>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/211113/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>15.如何支持下划线驼峰互转的传参与返回</title>
      <link>https://liuyueyi.github.io/tutorial/spring/web/Response/220117-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8BWeb%E5%A6%82%E4%BD%95%E6%94%AF%E6%8C%81%E4%B8%8B%E5%88%92%E7%BA%BF%E9%A9%BC%E5%B3%B0%E4%BA%92%E8%BD%AC%E7%9A%84%E4%BC%A0%E5%8F%82%E4%B8%8E%E8%BF%94%E5%9B%9E.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/web/Response/220117-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8BWeb%E5%A6%82%E4%BD%95%E6%94%AF%E6%8C%81%E4%B8%8B%E5%88%92%E7%BA%BF%E9%A9%BC%E5%B3%B0%E4%BA%92%E8%BD%AC%E7%9A%84%E4%BC%A0%E5%8F%82%E4%B8%8E%E8%BF%94%E5%9B%9E.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">15.如何支持下划线驼峰互转的传参与返回</source>
      <description>SpringBoot系列之Web如何支持下划线驼峰互转的传参与返回 接下来介绍一个非常现实的应用场景，有些时候后端接口对外定义的传参/返回都是下划线命名风格，但是Java本身是推荐驼峰命名方式的，那么必然就存在一个传参下换线，转换成驼峰的场景；以及在返回时，将驼峰命名的转换成下划线 那么如何支持上面这种应用场景呢? 本文介绍几种常见的手段</description>
      <category>SpringBoot</category>
      <category>WEB系列</category>
      <category>Request</category>
      <pubDate>Mon, 17 Jan 2022 19:09:53 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>SpringBoot系列之Web如何支持下划线驼峰互转的传参与返回</p>
</blockquote>
<p>接下来介绍一个非常现实的应用场景，有些时候后端接口对外定义的传参/返回都是下划线命名风格，但是Java本身是推荐驼峰命名方式的，那么必然就存在一个传参下换线，转换成驼峰的场景；以及在返回时，将驼峰命名的转换成下划线</p>
<p>那么如何支持上面这种应用场景呢?</p>
<p>本文介绍几种常见的手段</p>
<!-- more -->
<h2> I. 项目搭建</h2>
<h3> 1. 项目依赖</h3>
<p>本项目借助<code>SpringBoot 2.2.1.RELEASE</code> + <code>maven 3.5.3</code> + <code>IDEA</code>进行开发</p>
<p>开一个web服务用于测试</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>配置文件application.yml</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 需求拆分</h3>
<p>接下来为了更方便的理解我们要做的事情，对上面的应用场景进行一些拆分，方便理解</p>
<h4> 2.1 请求参数解析</h4>
<p>对于请求参数，外部传递是下划线命名格式的方式，需要与项目中驼峰命名的对象进行映射，所以这里的问题点就是无法走默认的绑定规则，需要我们进行兼容处理</p>
<p>比如传参是 <code>user_name = 一灰灰</code>，但是我们接收的参数是 <code>userName</code></p>
<h4> 2.2 返回结果处理</h4>
<p>返回结果的处理，这里单指返回json对象的场景，一个普通的POJO对象，正常序列化为json字符串时，key实际上与对象的成员名是一致的，而现在则希望将key统一成下划线风格的方式</p>
<p>如，返回一个简单的实体对象</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对应期待返回的json串为</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> II. 支持方式</h2>
<p>为了简化后续的流程，我们这里的传参都确定两个userName + userId，对应项目中的实体类如</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1. 请求参数解析</h3>
<h4> 1.1 @RequestParam注解方式</h4>
<p>最简单也是最容易想到的方式自然是直接使用<code>RequestParam</code>注解，将所有的请求参数都通过它来重命名</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用上面直接来写参数映射关系的方式属于比较常见的方法了，但是存在一个问题</p>
<ul>
<li>通用性差（每个接口的每个参数都要这么整，如果工资是按照代码来付费的话，那还是可以接收的；否则这个写法，就真的有点难受了）</li>
<li>若接口参数定义的是Map、Java bean实体（POJO），这个映射关联就不太好处理了</li>
</ul>
<p>除了上面这个问题之外，有个不是问题的问题（为什么这么说，且看下面的说法）</p>
<ul>
<li>如果我的接口传参，希望同时接收驼峰和下划线命名的传参（现实中还真有这种神经病似的场景，别问我怎么知道的），上面这个是不行的</li>
</ul>
<h4> 1.2 Json传参指定命名策略</h4>
<p>上面的case，适用于常见的get请求，post表单传参，然后在接口处一一定义参数；对于post json传参时，我们可以考虑通过定义json序列化的命名策略，来支持下划线与驼峰的互转</p>
<p>比如SpringMVC默认使用的jackson来实现json序列化，那么我们可以直接通过指定jackson的PropertyNamingStrategy来完成</p>
<p>配置文件中 application.yml，添加下面这行</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对应的接口定义如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>实际请求之后，看一下效果</p>
<figure><img src="/imgs/220117/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p><strong>注意</strong></p>
<ul>
<li>使用上面这种配置的方式，需要特比注意的，如果在项目中自己定义了<code>WebMvcConfigurationSupport</code>，那么上面的配置将不会生效（至于具体的原因，后面有机会单独说明）</li>
</ul>
<p>当我们实际的项目中，无法直接使用上面这种配置时，可以考虑使用下面的方式</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用jackson的命名策略来支持驼峰下划线的转换虽好，但是存在一个非常明显的缺陷</p>
<ul>
<li>它只适用于json传参</li>
</ul>
<h4> 1.3 自定义DataBinder</h4>
<p>对于非json的传承，比如普通的get请求，post表单传参，然后在接口处通过定义一个POJO参数类来接收，此时又应该怎么处理呢?</p>
<p>比如接口定义如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对于上面这种场景，一个想法就是是否可以在ViewDo的成员上，添加一个注解，指定参数名，一如<code>RequestParam</code>，不过Spring貌似并没有提供这种支持能力</p>
<p>因此我们可以考虑自己来实现数据绑定，下面提供一个基础的实现, 来演示这种方式改怎么玩（相对完整的基于注解的映射方式，下篇博文介绍）</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后在参数解析中，使用这个DataBinder</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接着就是注册这个参数解析</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>再次请求时，可以发现下划线的传参也可以映射到ViewDo对象上(无论是get请求还是post请求，都可以正确映射)</p>
<figure><img src="/imgs/220117/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 2.返回结果</h3>
<p>对于返回结果，希望返回下划线格式的json串，除了上面介绍到的设置json序列化的命名策略之外，还有下面几种配置方式</p>
<h4> 2.1 属性注解 @JsonProperty</h4>
<p>直接在POJO对象的成员上，指定希望输出的name</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 2.2 实体类注解 @JsonNaming</h4>
<p>直接在类上添加注解，指定驼峰策略</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 2.3 全局配置</h4>
<p>上面两种缺点比较明显，不太通用；更通用的选择和前面传参的json序列化配置方式一样，两种姿势</p>
<p>配置文件指定</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>前面也说到，上面这种配置可能会失效（比如你设置了自己的WebMvcConfig)，推荐使用下面的方式</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. 小结</h3>
<p>本文主要介绍了几种实例case，用于实现传参/返回的驼峰与下划线的互转，核心策略，有下面几种</p>
<ul>
<li>传参：<code>@RequestParam</code> 指定真正的传参name</li>
<li>Json传参、返回：通过定义json序列化框架的PropertyNamingStrategy，来实现</li>
<li>普通表单传参/get传参，映射POJO时：通过自定义的DataBinder，来实现映射</li>
</ul>
<p>虽然上面几种姿势，可以满足我们的基本诉求，但是如果我希望实现一个通用的下划线/驼峰互转策略，即不管传参是下划线还是驼峰，都可以正确无误的绑定到接口的参数变量上，可以怎么实现呢？</p>
<p>最后再抛出一个问题，如果接收参数是Map，上面的几种实现姿势会生效么？又可以如何怎么处理map这种场景呢？</p>
<h2> III. 不能错过的源码和相关知识点</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/202-web-params-camel" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/202-web-params-camel</a></li>
</ul>
<h3> 1. 微信公众号: 一灰灰Blog</h3>
<p>尽信书则不如，以上内容，纯属一家之言，因个人能力有限，难免有疏漏和错误之处，如发现bug或者有更好的建议，欢迎批评指正，不吝感激</p>
<p>下面一灰灰的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛</p>
<ul>
<li>一灰灰Blog个人博客 <a href="https://blog.hhui.top" target="_blank" rel="noopener noreferrer">https://blog.hhui.top</a></li>
<li>一灰灰Blog-Spring专题博客 <a href="http://spring.hhui.top" target="_blank" rel="noopener noreferrer">http://spring.hhui.top</a></li>
</ul>
<figure><img src="https://spring.hhui.top/spring-blog/imgs/info/info.png" alt="一灰灰blog" tabindex="0" loading="lazy"><figcaption>一灰灰blog</figcaption></figure>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/220117/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>16.定义接口返回类型的几种方式</title>
      <link>https://liuyueyi.github.io/tutorial/spring/web/Response/220817-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8B%E5%AE%9A%E4%B9%89%E6%8E%A5%E5%8F%A3%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/web/Response/220817-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8B%E5%AE%9A%E4%B9%89%E6%8E%A5%E5%8F%A3%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">16.定义接口返回类型的几种方式</source>
      <description>实现一个web接口返回json数据，基本上是每一个javaer非常熟悉的事情了；那么问题来了，如果我有一个接口，除了希望返回json格式的数据之外，若也希望可以返回xml格式数据可行么？ 答案当然是可行的，接下来我们将介绍一下，一个接口的返回数据类型，可以怎么处理</description>
      <category>SpringBoot</category>
      <category>WEB系列</category>
      <category>Response</category>
      <pubDate>Tue, 16 Aug 2022 18:42:37 GMT</pubDate>
      <content:encoded><![CDATA[<p>实现一个web接口返回json数据，基本上是每一个javaer非常熟悉的事情了；那么问题来了，如果我有一个接口，除了希望返回json格式的数据之外，若也希望可以返回xml格式数据可行么？</p>
<p>答案当然是可行的，接下来我们将介绍一下，一个接口的返回数据类型，可以怎么处理</p>
<!-- more --> 
<h2> I. 项目搭建</h2>
<p>本文创建的实例工程采用<code>SpringBoot 2.2.1.RELEASE</code> + <code>maven 3.5.3</code> + <code>idea</code>进行开发</p>
<h3> 1. pom依赖</h3>
<p>具体的SpringBoot项目工程创建就不赘述了，对于pom文件中，需要重点关注下面两个依赖类</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意 <code>jackson-datafromat-xml</code>这个依赖，加上这个主要时为了支持返回xml格式的数据</p>
<h2> II. 返回类型设置的多种方式</h2>
<p>正常来讲，一个RestController的接口，默认返回的是Json格式数据，当我们引入了上面的xml包之后，会怎样呢？返回的还是json么？</p>
<h3> 1.通过produce设置返回类型</h3>
<p>如果一个接口希望返回json或者xml格式的数据，最容易想到的方式就是直接设置<code>RequestMapping</code>注解中的produce属性</p>
<p>这个值主要就是用来设置这个接口响应头中的<code>content-type</code>； 如我们现在有两个接口，一个指定返回json格式数据，一个指定返回xml格式数据，可以如下写</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的实现中</p>
<ul>
<li>xml接口，指定<code>produces = application/xml</code></li>
<li>json接口，指定<code>produces = applicatin/json</code></li>
</ul>
<p>接下来我们访问一下看看返回的是否和预期一致</p>
<figure><img src="/imgs/220817/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>从上面截图也可以看出，xml接口返回的是xml格式数据；json接口返回的是json格式数据</p>
<h3> 2. 通过请求头accept设置返回类型</h3>
<p>上面的方式，非常直观，自然我们就会有一个疑问，当接口上不指定produces属性时，直接访问会怎么表现呢？</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/220817/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>请注意上面的截图，两种访问方式返回的数据类型不一致</p>
<ul>
<li>curl请求：返回json格式数据</li>
<li>浏览器请求：返回 <code>application/xhtml+xml</code>响应头的数据（实际上还是xml格式）</li>
</ul>
<p>那么问题来了，为什么两者的表现形式不一致呢？</p>
<p>对着上面的图再看三秒，会发现主要的差别点就在于请求头<code>Accept</code>不同；我们可以通过这个请求头参数，来要求服务端返回我希望的数据类型</p>
<p>如指定返回json格式数据</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/220817/02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>从上面的执行结果也可以看出，返回的类型与预期的一致；</p>
<p><strong>说明</strong></p>
<p>请求头可以设置多种MediaType，用英文逗号分割，后端接口会根据自己定义的produce与请求头希望的mediaType取交集，至于最终选择的顺序则以accept中出现的顺序为准</p>
<p>看一下实际的表现来验证下上面的说法</p>
<figure><img src="/imgs/220817/03.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>通过请求头来控制返回数据类型的方式可以说是非常经典的策略了，（遵循html协议还有什么好说的呢！）</p>
<h3> 3. 请求参数来控制返回类型</h3>
<p>除了上面介绍的两种方式之外，还可以考虑为所有的接口，增加一个根据特定的请求参数来控制返回的类型的方式</p>
<p>比如我们现在定义，所有的接口可以选传一个参数 <code>mediaType</code>，如果值为xml，则返回xml格式数据；如果值为json，则返回json格式数据</p>
<p>当不传时，默认返回json格式数据</p>
<p>基于此，我们主要借助mvc配置中的内容协商<code>ContentNegotiationConfigurer</code>来实现</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的实现中，添加了很多注释，先别急；我来逐一进行说明</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这三行代码，主要就是说，现在可以根据传参 mediaType 来控制返回的类型，我们新增一个接口来验证一下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们来看下几个不同的传参表现</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/220817/04.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p><strong>疑问：若请求头中传递了Accept或者接口上定义了produce，会怎样?</strong></p>
<p>当指定了accept时，并且传参中指定了mediaType，则以传参为准</p>
<ul>
<li>如<code>accept: application/json,application.xml</code>， 此时<code>mediaType=json</code>, 返回json格式</li>
<li>如<code>accept: application/json</code>, 此时 <code>mediaTyep=xml</code>， 返回xml格式</li>
<li>如<code>accept: text/html</code>，此时<code>mediaType=xml</code> ，此时返回的也是xml格式</li>
<li>如<code>accept: text/html</code>，此时<code>mediaType</code>不传时 ，因为无法处理<code>text/html</code>类型，所以会出现406</li>
<li>如<code>accept: application/xml</code>， 但是<code>mediaType</code>不传，虽然默认优先是json，此时返回的也是xml格式，与请求头希望的保持一致</li>
</ul>
<p>但是若传参与produce冲突了，那么就直接406异常，不会选择mediaType设置的类型</p>
<ul>
<li>如<code>produce = applicatin/json</code>， 但是 <code>mediaType=xml</code>，此时就会喜提406</li>
</ul>
<p>细心的小伙伴可能发现了上面的配置中，注释了一行 <code>.ignoreAcceptHeader(true)</code>，当我们把它打开之后，前面说的Accept请求头可以随意传，我们完全不care，当做没有传这个参数进行处理即可开</p>
<h3> 4.小结</h3>
<p>本文介绍了三种方式，控制接口返回数据类型</p>
<p><strong>方式一</strong></p>
<p>接口上定义produce, 如 <code>@GetMapping(path = "p2", produces = {"application/xml", "application/json"})</code></p>
<p>注意produces属性值是有序的，即先定义的优先级更高；当一个请求可以同时接受xml/json格式数据时，上面这个定义会确保这个接口现有返回xml格式数据</p>
<p><strong>方式二</strong></p>
<p>借助标准的请求头accept，控制希望返回的数据类型；但是需要注意的时，使用这种方式时，要求后端不能设置<code>ContentNegotiationConfigurer.ignoreAcceptHeader(true)</code></p>
<p>在实际使用这种方式的时候，客户端需要额外注意，Accept请求头中定义的MediaType的顺序，是优于后端定义的produces顺序的，因此用户需要将自己实际希望接受的数据类型放在前面，或者干脆就只设置一个</p>
<p><strong>方式三</strong></p>
<p>借助<code>ContentNegotiationConfigurer</code>实现通过请求参数来决定返回类型，常见的配置方式形如</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>即添加这个设置之后，最终的表现为：</p>
<ol>
<li>请求参数指定的返回类型，优先级最高，返回指定参数对应的类型</li>
<li>没有指定参数时，选择defaultContentType定义的默认返回类型与接口 <code>produce</code>中支持的求交集，优先级则按照defaultContentType中定义的顺序来选择</li>
<li>没有指定参数时，若此时还有accept请求头，则请求头中定义顺序的优先级高于 defaultContentType， 高于 produce</li>
</ol>
<p>注意注意：当配置中忽略了AcceptHeader时，<code>.ignoreAcceptHeader(true)</code>，上面第三条作废</p>
<p>最后的最后，本文所有的源码可以再下面的git中获取；本文的知识点已经汇总在<a href="https://hhui.top/spring-web/02.response/" target="_blank" rel="noopener noreferrer">《一灰灰的Spring专栏》</a> 两百多篇的原创系列博文，你值得拥有；我是一灰灰，咱们下次再见</p>
<h2> III. 不能错过的源码和相关知识点</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/204-web-xml-json" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/204-web-xml-json</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/220817/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>Web花样返回</title>
      <link>https://liuyueyi.github.io/tutorial/spring/web/Response/</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/web/Response/</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">Web花样返回</source>
      <description>后端接口返回什么，json串？xml文档？html网页？文件？还是重定向？</description>
      <pubDate>Fri, 10 Feb 2023 04:50:05 GMT</pubDate>
      <content:encoded><![CDATA[<p>后端接口返回什么，json串？xml文档？html网页？文件？还是重定向？</p>
]]></content:encoded>
    </item>
    <item>
      <title>1.基础用法小结</title>
      <link>https://liuyueyi.github.io/tutorial/spring/web/RestTemplate/200617-SpringBoot%E7%B3%BB%E5%88%97RestTemplate%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95%E5%B0%8F%E7%BB%93.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/web/RestTemplate/200617-SpringBoot%E7%B3%BB%E5%88%97RestTemplate%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95%E5%B0%8F%E7%BB%93.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">1.基础用法小结</source>
      <description>在Spring项目中，通常会借助RestTemplate来实现网络请求，RestTemplate封装得很完善了，基本上可以非常简单的完成各种HTTP请求，本文主要介绍一下基本操作，最常见的GET/POST请求的使用姿势</description>
      <category>SpringBoot</category>
      <category>WEB系列</category>
      <category>RestTemplate</category>
      <pubDate>Wed, 17 Jun 2020 09:26:20 GMT</pubDate>
      <content:encoded><![CDATA[<p>在Spring项目中，通常会借助<code>RestTemplate</code>来实现网络请求，RestTemplate封装得很完善了，基本上可以非常简单的完成各种HTTP请求，本文主要介绍一下基本操作，最常见的GET/POST请求的使用姿势</p>
<!-- more -->
<h2> I. 项目搭建</h2>
<h3> 1. 配置</h3>
<p>借助SpringBoot搭建一个SpringWEB项目，提供一些用于测试的REST服务</p>
<ul>
<li>SpringBoot版本: <code>2.2.1.RELEASE</code></li>
<li>核心依赖: <code>spring-boot-stater-web</code></li>
</ul>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>为了后续输出的日志更直观，这里设置了一下日志输出格式，在配置文件<code>application.yml</code>中，添加</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. Rest服务</h3>
<p>添加三个接口，分别提供GET请求，POST表单，POST json对象，然后返回请求头、请求参数、cookie，具体实现逻辑相对简单，也不属于本篇重点，因此不赘述说明</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> II. RestTemplate示例</h2>
<h3> 1. Get请求</h3>
<p>使用RestTemplate发起GET请求，通常有两种常见的方式</p>
<ul>
<li>getForEntity: 返回的正文对象包装在<code>HttpEntity</code>实体中，适用于获取除了返回的正文之外，对返回头、状态码有需求的场景</li>
<li>getForObject: 返回正文，适用于只对正文感兴趣的场景</li>
</ul>
<p>上面这两种方法除了返回结果不同之外，其他的使用姿势基本一样，有三种</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面三个重载方法，区别仅在于GET参数如何处理，下面给出一个实例进行说明</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果如下:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. POST表单</h3>
<p>POST表单属于非常基础的请求方式了，根据返回结果，RestTemplate同样提供了两种姿势</p>
<ul>
<li>postForEntity: 返回的正文封装在HttpEntity</li>
<li>postForObject: 直接返回正文对象</li>
</ul>
<p>它的使用姿势一样有三种</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>请注意上面三个方法的前两个，后面的<code>uriVariables</code>是url参数，不是POST表单参数哦，它们之间是有区别的（虽然我们一般post提交表单时，不怎么会在url中添加参数）</p>
<p>下面还是根据实际的用例来查看</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>测试输出如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. post body</h3>
<p>post一个json串，也属于比较常见的一种case了，对于RestTemplate而言，要支持这种方式，需要额外处理一下请求头，设置<code>Content-Type</code>为<code>application/json</code></p>
<p>使用姿势和上面相差不大，只是需要注意一下请求参数的构建</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>请注意，提交的json串中文乱码了</strong></p>
<h3> 4. 小结</h3>
<p>上面主要介绍的是RestTemplate的常规用法，基础的GET/POST请求姿势，如果业务简单，不需要考虑各种复杂的异常情况，也是没有太多的问题了；那么如果需要考虑，又有哪些需要注意的呢？</p>
<ul>
<li>上面的中文乱码问题如何解决？</li>
<li>自定义的请求头如何塞入（如果是爬虫，上面的User-Agent太容易被屏蔽了）</li>
<li>cookie设置</li>
<li>REST支持Basic Auth的验证方式如何发起请求</li>
<li>超时设置</li>
<li>自定义连接池替换</li>
<li>REST返回非200状态码的情况，能否不抛异常，自定义处理？</li>
<li>ssl校验</li>
<li>...</li>
</ul>
<p>如果你对上面的这些点感兴趣，不妨关注一波，相关的文章快正热火朝天的进行中...</p>
<h2> II. 其他</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>项目: <a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/221-web-resttemplate" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/221-web-resttemplate</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>2.之自定义请求头</title>
      <link>https://liuyueyi.github.io/tutorial/spring/web/RestTemplate/200630-SpringBoot%E7%B3%BB%E5%88%97RestTemplate%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E8%AF%B7%E6%B1%82%E5%A4%B4.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/web/RestTemplate/200630-SpringBoot%E7%B3%BB%E5%88%97RestTemplate%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E8%AF%B7%E6%B1%82%E5%A4%B4.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">2.之自定义请求头</source>
      <description>上一篇介绍了RestTemplate的基本使用姿势，在文末提出了一些扩展的高级使用姿势，本篇将主要集中在如何携带自定义的请求头，如设置User-Agent，携带Cookie Get携带请求头 Post携带请求头 拦截器方式设置统一请求头</description>
      <category>SpringBoot</category>
      <category>WEB系列</category>
      <category>RestTemplate</category>
      <pubDate>Tue, 30 Jun 2020 08:20:39 GMT</pubDate>
      <content:encoded><![CDATA[<p>上一篇介绍了RestTemplate的基本使用姿势，在文末提出了一些扩展的高级使用姿势，本篇将主要集中在如何携带自定义的请求头，如设置User-Agent，携带Cookie</p>
<ul>
<li>Get携带请求头</li>
<li>Post携带请求头</li>
<li>拦截器方式设置统一请求头</li>
</ul>
<!-- more -->
<h2> I. 项目搭建</h2>
<h3> 1. 配置</h3>
<p>借助SpringBoot搭建一个SpringWEB项目，提供一些用于测试的REST服务</p>
<ul>
<li>SpringBoot版本: <code>2.2.1.RELEASE</code></li>
<li>核心依赖: <code>spring-boot-stater-web</code></li>
</ul>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>为了后续输出的日志更直观，这里设置了一下日志输出格式，在配置文件<code>application.yml</code>中，添加</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. Rest服务</h3>
<p>添加三个接口，分别提供GET请求，POST表单，POST json对象，然后返回请求头、请求参数、cookie，具体实现逻辑相对简单，也不属于本篇重点，因此不赘述说明</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> II. 使用姿势</h2>
<p>最常见的携带请求头的需求，无非是referer校验，user-agent的防爬以及携带cookie，使用RestTemplate可以借助<code>HttpHeaders</code>来处理请求头</p>
<h3> 1. Get携带请求头</h3>
<p>前一篇博文介绍了GET请求的三种方式，但是<code>getForObject</code>/<code>getForEntity</code>都不满足我们的场景，这里需要引入<code>exchange</code>方法</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>exchange的使用姿势和我们前面介绍的<code>postForEntity</code>差不多，只是多了一个指定HttpMethod的参数而已</p>
<p><strong>重点在于将请求头塞入HttpEntity</strong></p>
<p>输出结果</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. Post携带请求头</h3>
<p>post携带请求头，也可以利用上面的方式实现；当然我们一般直接借助<code>postForObject/postForEntity</code>就可以满足需求了</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. 拦截器方式</h3>
<p>如果我们可以确定每次发起请求时，都要设置一个自定义的 <code>User-Agent</code>，每次都使用上面的两种姿势就有点繁琐了，因此我们是可以通过拦截器的方式来添加通用的请求头，这样使用这个RestTemplate时，都会携带上请求头</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这个使用姿势比较适用于通用的场景，测试输出</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4. 请求头错误使用姿势</h3>
<p>在我们使用自定义请求头时，有一个需要特殊重视的地方，HttpHeaders使用不当，可能导致请求头爆炸</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面演示的关键点为</p>
<ul>
<li>希望复用 HttpHeaders</li>
<li><code>headers.add</code> 方式添加请求头；而不是前面的 <code>set</code>方式</li>
</ul>
<p>输出如下，请注意每一次请求过后，请求头膨胀了一次</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> II. 其他</h2>
<h3> 0. 项目&amp;系列博文</h3>
<p><strong>系列博文</strong></p>
<ul>
<li><a href="http://spring.hhui.top/spring-blog/2020/06/17/200617-SpringBoot%E7%B3%BB%E5%88%97RestTemplate%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95%E5%B0%8F%E7%BB%93/" target="_blank" rel="noopener noreferrer">【WEB系列】RestTemplate基础用法小结</a></li>
</ul>
<p><strong>源码</strong></p>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>项目: <a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/221-web-resttemplate" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/221-web-resttemplate</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>3.中文乱码问题fix</title>
      <link>https://liuyueyi.github.io/tutorial/spring/web/RestTemplate/200701-SpringBoot%E7%B3%BB%E5%88%97RestTemplate%E4%B9%8B%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98fix.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/web/RestTemplate/200701-SpringBoot%E7%B3%BB%E5%88%97RestTemplate%E4%B9%8B%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98fix.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">3.中文乱码问题fix</source>
      <description>在RestTemplate基础用法博文中，post json表单时，会发现存在中文乱码问题，本文主要介绍对应的解决方案</description>
      <category>SpringBoot</category>
      <category>WEB系列</category>
      <category>RestTemplate</category>
      <pubDate>Wed, 01 Jul 2020 09:14:59 GMT</pubDate>
      <content:encoded><![CDATA[<p>在RestTemplate基础用法博文中，post json表单时，会发现存在中文乱码问题，本文主要介绍对应的解决方案</p>
<!-- more -->
<h2> I. 中文乱码Fix</h2>
<h3> 1. "罪魁祸首"</h3>
<p><strong>场景复现</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果如下:</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>原因定位</strong></p>
<p>RestTemplate中存在一个<code>HttpMessageConverter</code>列表的属性成员，而<code>HttpMessageConverter</code>主要的职责就是消息转码</p>
<p>导致我们中文乱码的一个关键点在于<code>StringHttpMessageConverter</code>采用的默认编码格式为<code>StandardCharsets.ISO_8859_1</code></p>
<h3> 2. 指定StringHttpMessageConverter编码</h3>
<p>既然是因为<code>StringHttpMessageConverter</code>的默认编码不是UTF-8，那么将它手动改成utf-8不就over了么</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>测试输出如:</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. 传参POJO</h3>
<p>在看<code>RestTemplate</code>的<code>HttpMessageConvert</code>时，会看到默认提供了一个<code>MappingJackson2HttpMessageConverter</code>，那么我们直接传参POJO，走Jackson序列化，是不是也可以解决中文乱码呢?</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>说明：上面的InnerParam对象改成HashMap，也是ok的</strong></p>
<h2> II. 其他</h2>
<h3> 0. 项目&amp;系列博文</h3>
<p><strong>博文</strong></p>
<ul>
<li><a href="http://spring.hhui.top/spring-blog/2020/06/30/200630-SpringBoot%E7%B3%BB%E5%88%97RestTemplate%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E8%AF%B7%E6%B1%82%E5%A4%B4/" target="_blank" rel="noopener noreferrer">【WEB系列】RestTemplate之自定义请求头</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2020/06/30/200630-SpringBoot%E7%B3%BB%E5%88%97RestTemplate%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E8%AF%B7%E6%B1%82%E5%A4%B4/" target="_blank" rel="noopener noreferrer">【WEB系列】RestTemplate基础用法小结</a></li>
</ul>
<p><strong>源码</strong></p>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码: <a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/221-web-resttemplate" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/221-web-resttemplate</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>4.超时设置</title>
      <link>https://liuyueyi.github.io/tutorial/spring/web/RestTemplate/200702-SpringBoot%E7%B3%BB%E5%88%97RestTemplate%E4%B9%8B%E8%B6%85%E6%97%B6%E8%AE%BE%E7%BD%AE.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/web/RestTemplate/200702-SpringBoot%E7%B3%BB%E5%88%97RestTemplate%E4%B9%8B%E8%B6%85%E6%97%B6%E8%AE%BE%E7%BD%AE.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">4.超时设置</source>
      <description>一般来讲我们访问外部资源时，需要做一个保护，比如最常见的添加一个超时设置，避免一直被阻塞，RestTemplate可以通过SimpleClientHttpRequestFactory来处理超时设置</description>
      <category>SpringBoot</category>
      <category>WEB系列</category>
      <category>RestTemplate</category>
      <pubDate>Thu, 02 Jul 2020 08:03:21 GMT</pubDate>
      <content:encoded><![CDATA[<p>一般来讲我们访问外部资源时，需要做一个保护，比如最常见的添加一个超时设置，避免一直被阻塞，RestTemplate可以通过<code>SimpleClientHttpRequestFactory</code>来处理超时设置</p>
<!-- more -->
<h2> I. RestTemplate超时设置</h2>
<blockquote>
<p>博文测试项目完全基于<a href="http://spring.hhui.top/spring-blog/2020/06/17/200617-SpringBoot%E7%B3%BB%E5%88%97RestTemplate%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95%E5%B0%8F%E7%BB%93/" target="_blank" rel="noopener noreferrer">【WEB系列】RestTemplate基础用法小结</a>的项目环境，建议配合查看</p>
</blockquote>
<p>基本环境：<code>IDEA</code> + <code>maven</code> + <code>SpringBoot 2.2.1.RELEASE</code></p>
<h3> 1. 超时端点</h3>
<p>添加一个超时模拟的端点如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 超时设置</h3>
<p>主要是通过设置<code>SimpleClientHttpRequestFactory</code>来设置超时</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出如下:</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> II. 其他</h2>
<h3> 1. 源码&amp;系列博文</h3>
<p><strong>博文</strong></p>
<ul>
<li><a href="http://spring.hhui.top/spring-blog/2020/07/01/200701-SpringBoot%E7%B3%BB%E5%88%97RestTemplate%E4%B9%8B%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98fix/" target="_blank" rel="noopener noreferrer">【WEB系列】RestTemplate之中文乱码问题fix</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2020/06/30/200630-SpringBoot%E7%B3%BB%E5%88%97RestTemplate%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E8%AF%B7%E6%B1%82%E5%A4%B4/" target="_blank" rel="noopener noreferrer">【WEB系列】RestTemplate之自定义请求头</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2020/06/30/200630-SpringBoot%E7%B3%BB%E5%88%97RestTemplate%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E8%AF%B7%E6%B1%82%E5%A4%B4/" target="_blank" rel="noopener noreferrer">【WEB系列】RestTemplate基础用法小结</a></li>
</ul>
<p><strong>源码</strong></p>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码: <a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/221-web-resttemplate" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/221-web-resttemplate</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>5.代理访问</title>
      <link>https://liuyueyi.github.io/tutorial/spring/web/RestTemplate/200703-SpringBoot%E7%B3%BB%E5%88%97RestTemplate%E4%B9%8B%E4%BB%A3%E7%90%86%E8%AE%BF%E9%97%AE.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/web/RestTemplate/200703-SpringBoot%E7%B3%BB%E5%88%97RestTemplate%E4%B9%8B%E4%BB%A3%E7%90%86%E8%AE%BF%E9%97%AE.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">5.代理访问</source>
      <description>通过代理访问，对于java后端可能用得不多的，但有过爬虫开发经验的小伙伴可能一点也不会陌生，有时候不太方便直接去访问目标资源，借助代理是要给选择，对于RestTemplate而言，使用代理的姿势同样如设置超时一般，借助SimpleClientHttpRequestFactory来实现，本文演示一下具体的使用case</description>
      <category>SpringBoot</category>
      <category>WEB系列</category>
      <category>RestTemplate</category>
      <pubDate>Fri, 03 Jul 2020 08:09:12 GMT</pubDate>
      <content:encoded><![CDATA[<p>通过代理访问，对于java后端可能用得不多的，但有过爬虫开发经验的小伙伴可能一点也不会陌生，有时候不太方便直接去访问目标资源，借助代理是要给选择，对于RestTemplate而言，使用代理的姿势同样如设置超时一般，借助<code>SimpleClientHttpRequestFactory</code>来实现，本文演示一下具体的使用case</p>
<!-- more -->
<h2> I. 环境准备</h2>
<h3> 1. 项目环境</h3>
<p>借助SpringBoot搭建一个SpringWEB项目，提供一些用于测试的REST服务</p>
<ul>
<li>SpringBoot版本: <code>2.2.1.RELEASE</code></li>
<li>核心依赖: <code>spring-boot-stater-web</code></li>
</ul>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>为了后续输出的日志更直观，这里设置了一下日志输出格式，在配置文件<code>application.yml</code>中，添加</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 测试端点</h3>
<p>我们的测试端点，主要需要返回客户端主机信息，我们这里直接借助<code>HttpServletRequest#getRemoteHost</code> + <code>HttpServlet#getRemotePort</code>来实现（当然实际的业务开发中不建议直接使用它）</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. 代理服务器搭建</h3>
<p>我们这里借助tinyproxy来搭建代理服务器，详细步骤可以参考博文: <a href="https://blog.hhui.top/hexblog/2020/06/19/200619-http%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8tinyproxy%E6%90%AD%E5%BB%BA%E6%89%8B%E5%86%8C/" target="_blank" rel="noopener noreferrer">http代理服务器tinyproxy搭建手册</a></p>
<p>本文的演示中，是在<code>192.168.0.241</code>状态centos机器上安装的，步骤如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> II. 代理访问</h2>
<p>接下来进入正文演示，核心代码也比较简单</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>请注意，上面的使用姿势中</p>
<ul>
<li>Proxy的方式除了HTTP之外还有SOCKS，这个是与代理服务器的支持方式相关的</li>
<li><code>postForEntity</code>中url的ip是我本机的ip，而不是<code>127.0.0.1</code></li>
</ul>
<p>测试输出如下:</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> II. 其他</h2>
<h3> 0. 项目&amp;系列博文</h3>
<p><strong>博文</strong></p>
<ul>
<li><a href="http://spring.hhui.top/spring-blog/2020/07/02/200702-SpringBoot%E7%B3%BB%E5%88%97RestTemplate%E4%B9%8B%E8%B6%85%E6%97%B6%E8%AE%BE%E7%BD%AE/" target="_blank" rel="noopener noreferrer">【WEB系列】RestTemplate之超时设置</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2020/07/01/200701-SpringBoot%E7%B3%BB%E5%88%97RestTemplate%E4%B9%8B%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98fix/" target="_blank" rel="noopener noreferrer">【WEB系列】RestTemplate之中文乱码问题fix</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2020/06/30/200630-SpringBoot%E7%B3%BB%E5%88%97RestTemplate%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E8%AF%B7%E6%B1%82%E5%A4%B4/" target="_blank" rel="noopener noreferrer">【WEB系列】RestTemplate之自定义请求头</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2020/06/30/200630-SpringBoot%E7%B3%BB%E5%88%97RestTemplate%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E8%AF%B7%E6%B1%82%E5%A4%B4/" target="_blank" rel="noopener noreferrer">【WEB系列】RestTemplate基础用法小结</a></li>
</ul>
<p><strong>源码</strong></p>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码: <a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/221-web-resttemplate" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/221-web-resttemplate</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>6.Basic Auth授权</title>
      <link>https://liuyueyi.github.io/tutorial/spring/web/RestTemplate/200704-SpringBoot%E7%B3%BB%E5%88%97RestTemplate%E4%B9%8BBasic-Auth%E6%8E%88%E6%9D%83.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/web/RestTemplate/200704-SpringBoot%E7%B3%BB%E5%88%97RestTemplate%E4%B9%8BBasic-Auth%E6%8E%88%E6%9D%83.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">6.Basic Auth授权</source>
      <description>前面介绍的RestTemplate的所有使用姿势都是不需要鉴权的，然而实际情况可不一定都这么友好；Http Basic Auth属于非常基础的一种鉴权方式了，将用户名和密码以Base64编码之后，携带在请求头，从而实现身份校验； 本文将主要介绍RestTemplate实现Basic Auth鉴权的几种姿势</description>
      <category>SpringBoot</category>
      <category>WEB系列</category>
      <category>RestTemplate</category>
      <pubDate>Sat, 04 Jul 2020 09:53:31 GMT</pubDate>
      <content:encoded><![CDATA[<p>前面介绍的RestTemplate的所有使用姿势都是不需要鉴权的，然而实际情况可不一定都这么友好；Http Basic Auth属于非常基础的一种鉴权方式了，将用户名和密码以Base64编码之后，携带在请求头，从而实现身份校验；</p>
<p>本文将主要介绍RestTemplate实现Basic Auth鉴权的几种姿势</p>
<!-- more -->
<h2> I. 项目环境</h2>
<blockquote>
<p>博文测试项目完全基于<a href="http://spring.hhui.top/spring-blog/2020/06/17/200617-SpringBoot%E7%B3%BB%E5%88%97RestTemplate%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95%E5%B0%8F%E7%BB%93/" target="_blank" rel="noopener noreferrer">【WEB系列】RestTemplate基础用法小结</a>的项目环境，建议配合查看</p>
</blockquote>
<p>基本环境：<code>IDEA</code> + <code>maven</code> + <code>SpringBoot 2.2.1.RELEASE</code></p>
<h3> 1. 鉴权端点</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>一个简单的鉴权逻辑如上，从请求头中拿到<code>Authorization</code>对应的value，并解析用户名密码，如果满足则正确返回；如果不存在or不满足，则返回http状态码为401，并携带对应的提示信息</p>
<h2> II. Basic Auth鉴权姿势</h2>
<h3> 1. 请求头方式</h3>
<p>最基础的一种是实现方式，完全根据Basic Auth的规则来，既然是校验请求头，那么我直接在请求头中加上即可</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 拦截器方式</h3>
<p>上面的方式不太通用，借助前面的请求头设置姿势，如果有通用的需求，借助拦截器是一个好的选择</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. 标准验证拦截器</h3>
<p>上面的拦截器主要还是我们自己来设置请求头，实际上Spring已经提供了标准的<code>BasicAuthenticationInterceptor</code>来实现我们的需求</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4. RestTemplateBuilder方式创建RestTemplate</h3>
<p>RestTemplate除了使用new来构造之外，还可以借助<code>RestTemplateBuilder</code>来创建，有时候可能更加方便简洁</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 5. 反面case</h3>
<p>上面介绍的几种都是正常可以工作的，接下来给出一个不能工作的case</p>
<p>对于Basic Auth，有一种常见的方式是将用户名和密码，放在url里面，如</p>
<figure><img src="/imgs/200704/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>那么我们直接用RestTemplate这么操作呢？</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>注意直接在url里面添加用户名密码的方式是不行的，需要额外处理</strong></p>
<h2> II. 其他</h2>
<h3> 0. 项目&amp;系列博文</h3>
<p><strong>博文</strong></p>
<ul>
<li><a href="http://spring.hhui.top/spring-blog/2020/07/03/200703-SpringBoot%E7%B3%BB%E5%88%97RestTemplate%E4%B9%8B%E4%BB%A3%E7%90%86%E8%AE%BF%E9%97%AE/" target="_blank" rel="noopener noreferrer">【WEB系列】RestTemplate之代理访问</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2020/07/02/200702-SpringBoot%E7%B3%BB%E5%88%97RestTemplate%E4%B9%8B%E8%B6%85%E6%97%B6%E8%AE%BE%E7%BD%AE/" target="_blank" rel="noopener noreferrer">【WEB系列】RestTemplate之超时设置</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2020/07/01/200701-SpringBoot%E7%B3%BB%E5%88%97RestTemplate%E4%B9%8B%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98fix/" target="_blank" rel="noopener noreferrer">【WEB系列】RestTemplate之中文乱码问题fix</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2020/06/30/200630-SpringBoot%E7%B3%BB%E5%88%97RestTemplate%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E8%AF%B7%E6%B1%82%E5%A4%B4/" target="_blank" rel="noopener noreferrer">【WEB系列】RestTemplate之自定义请求头</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2020/06/30/200630-SpringBoot%E7%B3%BB%E5%88%97RestTemplate%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E8%AF%B7%E6%B1%82%E5%A4%B4/" target="_blank" rel="noopener noreferrer">【WEB系列】RestTemplate基础用法小结</a></li>
</ul>
<p><strong>源码</strong></p>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码: <a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/221-web-resttemplate" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/221-web-resttemplate</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/200704/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>7.非200状态码信息捕获</title>
      <link>https://liuyueyi.github.io/tutorial/spring/web/RestTemplate/200705-SpringBoot%E7%B3%BB%E5%88%97RestTemplate%E4%B9%8B%E9%9D%9E200%E7%8A%B6%E6%80%81%E7%A0%81%E4%BF%A1%E6%81%AF%E6%8D%95%E8%8E%B7.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/web/RestTemplate/200705-SpringBoot%E7%B3%BB%E5%88%97RestTemplate%E4%B9%8B%E9%9D%9E200%E7%8A%B6%E6%80%81%E7%A0%81%E4%BF%A1%E6%81%AF%E6%8D%95%E8%8E%B7.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">7.非200状态码信息捕获</source>
      <description>前面介绍的RestTemplate的使用，都是接口正常返回200的状态码case，当返回非200状态码时，会直接抛异常，如果我希望能捕获异常，并针对正常获取返回的message，可以如何处理呢？</description>
      <category>SpringBoot</category>
      <category>WEB系列</category>
      <category>RestTemplate</category>
      <pubDate>Sun, 05 Jul 2020 07:21:01 GMT</pubDate>
      <content:encoded><![CDATA[<p>前面介绍的RestTemplate的使用，都是接口正常返回200的状态码case，当返回非200状态码时，会直接抛异常，如果我希望能捕获异常，并针对正常获取返回的message，可以如何处理呢？</p>
<!-- more -->
<h2> I. 项目环境</h2>
<blockquote>
<p>博文测试项目完全基于<a href="http://spring.hhui.top/spring-blog/2020/06/17/200617-SpringBoot%E7%B3%BB%E5%88%97RestTemplate%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95%E5%B0%8F%E7%BB%93/" target="_blank" rel="noopener noreferrer">【WEB系列】RestTemplate基础用法小结</a>的项目环境，建议配合查看</p>
</blockquote>
<p>基本环境：<code>IDEA</code> + <code>maven</code> + <code>SpringBoot 2.2.1.RELEASE</code></p>
<p>测试的REST服务借助前一篇的鉴权，如果鉴权失败，则返回401状态码，具体实现如下</p>
<h3> 1. 鉴权端点</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>一个简单的鉴权逻辑如上，从请求头中拿到<code>Authorization</code>对应的value，并解析用户名密码，如果满足则正确返回；如果不存在or不满足，则返回http状态码为401，并携带对应的提示信息</p>
<h2> II. 异常捕获</h2>
<h3> 1. 未捕获场景</h3>
<p>当我们直接像之前一样使用RestTemplate时，看一下效果如何</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出如下，走入了catch逻辑，从异常堆栈中，也只能看到<code>401 Unauthorized</code>，拿不到返回的Response body</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 异常捕获</h3>
<blockquote>
<p>更详细原理定位请参考：<a href="http://spring.hhui.top/spring-blog/2020/01/04/200104-SpringWeb%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8BRestTemplate-4xx-5xx-%E5%BC%82%E5%B8%B8%E4%BF%A1%E6%81%AF%E6%8D%95%E8%8E%B7/" target="_blank" rel="noopener noreferrer">【WEB系列】RestTemplate 4xx/5xx 异常信息捕获</a></p>
</blockquote>
<p>为了处理上面的问题，我们可以设置自定义的<code>ResponseErrorHandler</code>来处理</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出如下, 401为返回的状态码，其中也包含了ResponseBody，然后再业务中根据状态码和返回结果进行处理即可</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> II. 其他</h2>
<h3> 0. 项目&amp;系列博文</h3>
<p><strong>博文</strong></p>
<ul>
<li><a href="http://spring.hhui.top/spring-blog/2020/07/04/200704-SpringBoot%E7%B3%BB%E5%88%97RestTemplate%E4%B9%8BBasic-Auth%E6%8E%88%E6%9D%83/" target="_blank" rel="noopener noreferrer">【WEB系列】RestTemplate之Basic Auth授权</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2020/07/03/200703-SpringBoot%E7%B3%BB%E5%88%97RestTemplate%E4%B9%8B%E4%BB%A3%E7%90%86%E8%AE%BF%E9%97%AE/" target="_blank" rel="noopener noreferrer">【WEB系列】RestTemplate之代理访问</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2020/07/02/200702-SpringBoot%E7%B3%BB%E5%88%97RestTemplate%E4%B9%8B%E8%B6%85%E6%97%B6%E8%AE%BE%E7%BD%AE/" target="_blank" rel="noopener noreferrer">【WEB系列】RestTemplate之超时设置</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2020/07/01/200701-SpringBoot%E7%B3%BB%E5%88%97RestTemplate%E4%B9%8B%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98fix/" target="_blank" rel="noopener noreferrer">【WEB系列】RestTemplate之中文乱码问题fix</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2020/06/30/200630-SpringBoot%E7%B3%BB%E5%88%97RestTemplate%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E8%AF%B7%E6%B1%82%E5%A4%B4/" target="_blank" rel="noopener noreferrer">【WEB系列】RestTemplate之自定义请求头</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2020/06/30/200630-SpringBoot%E7%B3%BB%E5%88%97RestTemplate%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E8%AF%B7%E6%B1%82%E5%A4%B4/" target="_blank" rel="noopener noreferrer">【WEB系列】RestTemplate基础用法小结</a></li>
</ul>
<p><strong>源码</strong></p>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码: <a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/221-web-resttemplate" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/221-web-resttemplate</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>8.异步非阻塞网络请求介绍篇</title>
      <link>https://liuyueyi.github.io/tutorial/spring/web/RestTemplate/200707-SpringBoot%E7%B3%BB%E5%88%97AsyncRestTemplate%E4%B9%8B%E5%BC%82%E6%AD%A5%E9%9D%9E%E9%98%BB%E5%A1%9E%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E4%BB%8B%E7%BB%8D%E7%AF%87.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/web/RestTemplate/200707-SpringBoot%E7%B3%BB%E5%88%97AsyncRestTemplate%E4%B9%8B%E5%BC%82%E6%AD%A5%E9%9D%9E%E9%98%BB%E5%A1%9E%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E4%BB%8B%E7%BB%8D%E7%AF%87.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">8.异步非阻塞网络请求介绍篇</source>
      <description>AsyncRestTemplate发起异步网络请求，由Spring4.0引入，但是在5.0就被表上了删除注解，官方推荐使用基于React的WebClient来代替。 虽然官方已经不推荐使用AsyncRestTemplate，但是如果你的web项目，并不想引入react相关的包，使用AsyncRestTemplate来实现异步网络请求也不失为一个选择，本文将主要介绍它的基本使用姿势</description>
      <category>SpringBoot</category>
      <category>WEB系列</category>
      <category>RestTemplate</category>
      <pubDate>Tue, 07 Jul 2020 08:02:35 GMT</pubDate>
      <content:encoded><![CDATA[<p>AsyncRestTemplate发起异步网络请求，由Spring4.0引入，但是在5.0就被表上了删除注解，官方推荐使用基于React的WebClient来代替。</p>
<p>虽然官方已经不推荐使用<code>AsyncRestTemplate</code>，但是如果你的web项目，并不想引入react相关的包，使用<code>AsyncRestTemplate</code>来实现异步网络请求也不失为一个选择，本文将主要介绍它的基本使用姿势</p>
<!-- more -->
<h2> I. 项目环境</h2>
<p>本文创建的实例工程采用<code>SpringBoot 2.2.1.RELEASE</code> + <code>maven 3.5.3</code> + <code>idea</code>进行开发</p>
<h3> 1. pom依赖</h3>
<p>具体的SpringBoot项目工程创建就不赘述了，对于pom文件中，需要重点关注下面两个依赖类</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>请注意我们并没有引入react相关的包，所以是没法直接使用webclient的</strong></p>
<p>简单的配置一下logback的日志输出（非必要条件）, <code>application.yml</code>文件内容如下</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 测试接口</h3>
<p>编写几个简单的用于测试的REST接口</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> II. 使用说明</h2>
<p>从接口声明上来看，AsyncRestTemplate与RestTemplate的使用姿势没有什么区别，如典型的GET/POST接口声明如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1. 使用姿势</h3>
<p>GET/POST的访问姿势就不再赘述，有兴趣的小伙伴可以查看RestTemplate的使用博文：<a href="http://spring.hhui.top/spring-blog/2020/06/17/200617-SpringBoot%E7%B3%BB%E5%88%97RestTemplate%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95%E5%B0%8F%E7%BB%93/" target="_blank" rel="noopener noreferrer">【WEB系列】RestTemplate基础用法小结</a></p>
<p>注意到不同的点在于返回的对象，<code>RestTemplate</code>是直接返回实体；而<code>AsyncRestTemplate</code>返回的则是<code>ListenerableFuture</code>包装的结果，这个类属于Spring自定义对象，继承自Future体系，而Future是我们并发编程中用于获取异步结果的一个接口</p>
<p><code>ListenerableFuture</code>的最大特点在于它可以绑定执行完成的监听器，就不需要通过get来阻塞获取结果了，一个简单的使用姿势如下, 分别演示正常返回，异常返回的回调case（两者都不会阻塞主线程的执行哦）</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>请注意下面的动图，主线程的<code>do something else!!!</code>文案会优先输出，并不会被阻塞；然后就是返回结果之后的回调，因为第一个case访问的rest服务有个sleep，所以输出也会有一个明显的滞后</p>
<figure><img src="/imgs/200707/00.gif" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 2. Guava方式的异步请求</h3>
<p>除了上面说到的AsyncRestTemplate来实现异步访问，我们也可以借助Gauva配合<code>RestTemplate</code>来实现类似的效果，下面作为扩展知识点，给出一个等效的使用说明</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>看到这里自然而然会有一个疑问，异步任务完成的回调，是怎么实现呢？</p>
<p>欢迎各位小伙伴评论给出看法</p>
<h2> II. 其他</h2>
<h3> 0. 项目&amp;系列博文</h3>
<p><strong>博文</strong></p>
<ul>
<li><a href="http://spring.hhui.top/spring-blog/2020/07/05/200705-SpringBoot%E7%B3%BB%E5%88%97RestTemplate%E4%B9%8B%E9%9D%9E200%E7%8A%B6%E6%80%81%E7%A0%81%E4%BF%A1%E6%81%AF%E6%8D%95%E8%8E%B7/" target="_blank" rel="noopener noreferrer">【WEB系列】RestTemplate之非200状态码信息捕获</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2020/07/04/200704-SpringBoot%E7%B3%BB%E5%88%97RestTemplate%E4%B9%8BBasic-Auth%E6%8E%88%E6%9D%83/" target="_blank" rel="noopener noreferrer">【WEB系列】RestTemplate之Basic Auth授权</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2020/07/03/200703-SpringBoot%E7%B3%BB%E5%88%97RestTemplate%E4%B9%8B%E4%BB%A3%E7%90%86%E8%AE%BF%E9%97%AE/" target="_blank" rel="noopener noreferrer">【WEB系列】RestTemplate之代理访问</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2020/07/02/200702-SpringBoot%E7%B3%BB%E5%88%97RestTemplate%E4%B9%8B%E8%B6%85%E6%97%B6%E8%AE%BE%E7%BD%AE/" target="_blank" rel="noopener noreferrer">【WEB系列】RestTemplate之超时设置</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2020/07/01/200701-SpringBoot%E7%B3%BB%E5%88%97RestTemplate%E4%B9%8B%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98fix/" target="_blank" rel="noopener noreferrer">【WEB系列】RestTemplate之中文乱码问题fix</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2020/06/30/200630-SpringBoot%E7%B3%BB%E5%88%97RestTemplate%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E8%AF%B7%E6%B1%82%E5%A4%B4/" target="_blank" rel="noopener noreferrer">【WEB系列】RestTemplate之自定义请求头</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2020/06/30/200630-SpringBoot%E7%B3%BB%E5%88%97RestTemplate%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E8%AF%B7%E6%B1%82%E5%A4%B4/" target="_blank" rel="noopener noreferrer">【WEB系列】RestTemplate基础用法小结</a></li>
</ul>
<p><strong>源码</strong></p>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码: <a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/221-web-resttemplate" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/221-web-resttemplate</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/200707/00.gif" type="image/gif"/>
    </item>
    <item>
      <title>9.文件上传</title>
      <link>https://liuyueyi.github.io/tutorial/spring/web/RestTemplate/200710-SpringBoot%E7%B3%BB%E5%88%97RestTemplate%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/web/RestTemplate/200710-SpringBoot%E7%B3%BB%E5%88%97RestTemplate%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">9.文件上传</source>
      <description>虽然在实际的项目中，借助RestTemplate来实现文件上传的机会不多（比如我已经开webclient的新坑了，才发现忘了这货...），但是这个知识点也还是有必要了解一下的，本文将简单介绍一下单个文件上传，多个文件上传的使用姿势</description>
      <category>SpringBoot</category>
      <category>WEB系列</category>
      <category>RestTemplate</category>
      <pubDate>Fri, 10 Jul 2020 11:53:21 GMT</pubDate>
      <content:encoded><![CDATA[<p>虽然在实际的项目中，借助RestTemplate来实现文件上传的机会不多（比如我已经开webclient的新坑了，才发现忘了这货...），但是这个知识点也还是有必要了解一下的，本文将简单介绍一下单个文件上传，多个文件上传的使用姿势</p>
<!-- more -->
<h2> I. 项目搭建</h2>
<p>本项目基于SpringBoot <code>2.2.1.RELEASE</code> + <code>maven 3.5.3</code> + <code>idea</code>进行开发</p>
<h3> 1. pom依赖</h3>
<p>核心pom依赖如下</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. Rest服务</h3>
<p>提供两个简单的上传文件的接口，下面给出两种不一样的写法，效果差不多</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. 上传文件</h3>
<p>在Resource资源目录下，新建两个用于测试上传的文本文件，内容分别如下</p>
<p>文件1 <code>test.txt</code>:</p>
<div class="language-txt line-numbers-mode" data-ext="txt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>文件2 <code>test2.txt</code>:</p>
<div class="language-txt line-numbers-mode" data-ext="txt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>简单设置一下日志格式，在<code>application.yml</code>文件中</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> II. 项目实现</h2>
<p>文件上传，依然是走的POST请求，所以基本操作知识和前面的POST差不多，唯一的区别在于传参</p>
<h3> 1. 文件上传</h3>
<p>文件上传两个核心步骤</p>
<ul>
<li>设置请求头</li>
<li>传参为Resource</li>
</ul>
<p>最基础的单文件上传姿势实例如下，主要是借助<code>FileSystemResource</code>来获取文件并上传</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当需要后端发起上传文件时，一般来讲是更多的情况下是上传二进制（or流），不太会是文件上传，所以更常见的是<code>InputStreamResource</code>的使用姿势</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>重点注意</strong></p>
<ul>
<li><code>InputStreamResource</code> 重写了<code>contentLength()</code>, <code>getFilename()</code>方法，去掉这个就没法正常的上传文件了</li>
</ul>
<p>当然除了<code>InputStreamResource</code>之外，<code>ByteArrayResource</code>也是一个比较好的选择</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>重点注意</strong></p>
<ul>
<li><code>ByteArrayResource</code>重写了<code>getFilename()</code>方法，感兴趣的小伙伴可以测试一下没有它的情况</li>
</ul>
<h3> 2. 多文件上传</h3>
<p>上面介绍的是单文件上传，当然我们也会出现一次上传多个文件的情况，使用姿势和前面基本上一样，无非是传参的时候多传两个而已</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. 输出结果</h3>
<figure><img src="/imgs/200710/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> II. 其他</h2>
<h3> 0. 项目&amp;系列博文</h3>
<p><strong>博文</strong></p>
<ul>
<li><a href="http://spring.hhui.top/spring-blog/2020/07/07/200707-SpringBoot%E7%B3%BB%E5%88%97AsyncRestTemplate%E4%B9%8B%E5%BC%82%E6%AD%A5%E9%9D%9E%E9%98%BB%E5%A1%9E%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E4%BB%8B%E7%BB%8D%E7%AF%87/" target="_blank" rel="noopener noreferrer">【WEB系列】AsyncRestTemplate之异步非阻塞网络请求介绍篇</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2020/07/05/200705-SpringBoot%E7%B3%BB%E5%88%97RestTemplate%E4%B9%8B%E9%9D%9E200%E7%8A%B6%E6%80%81%E7%A0%81%E4%BF%A1%E6%81%AF%E6%8D%95%E8%8E%B7/" target="_blank" rel="noopener noreferrer">【WEB系列】RestTemplate之非200状态码信息捕获</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2020/07/04/200704-SpringBoot%E7%B3%BB%E5%88%97RestTemplate%E4%B9%8BBasic-Auth%E6%8E%88%E6%9D%83/" target="_blank" rel="noopener noreferrer">【WEB系列】RestTemplate之Basic Auth授权</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2020/07/03/200703-SpringBoot%E7%B3%BB%E5%88%97RestTemplate%E4%B9%8B%E4%BB%A3%E7%90%86%E8%AE%BF%E9%97%AE/" target="_blank" rel="noopener noreferrer">【WEB系列】RestTemplate之代理访问</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2020/07/02/200702-SpringBoot%E7%B3%BB%E5%88%97RestTemplate%E4%B9%8B%E8%B6%85%E6%97%B6%E8%AE%BE%E7%BD%AE/" target="_blank" rel="noopener noreferrer">【WEB系列】RestTemplate之超时设置</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2020/07/01/200701-SpringBoot%E7%B3%BB%E5%88%97RestTemplate%E4%B9%8B%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98fix/" target="_blank" rel="noopener noreferrer">【WEB系列】RestTemplate之中文乱码问题fix</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2020/06/30/200630-SpringBoot%E7%B3%BB%E5%88%97RestTemplate%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E8%AF%B7%E6%B1%82%E5%A4%B4/" target="_blank" rel="noopener noreferrer">【WEB系列】RestTemplate之自定义请求头</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2020/06/30/200630-SpringBoot%E7%B3%BB%E5%88%97RestTemplate%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E8%AF%B7%E6%B1%82%E5%A4%B4/" target="_blank" rel="noopener noreferrer">【WEB系列】RestTemplate基础用法小结</a></li>
</ul>
<p><strong>源码</strong></p>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码: <a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/221-web-resttemplate" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/221-web-resttemplate</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/200710/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>10.连接池配置</title>
      <link>https://liuyueyi.github.io/tutorial/spring/web/RestTemplate/200723-SpringBoot%E7%B3%BB%E5%88%97RestTemplate%E4%B9%8B%E8%BF%9E%E6%8E%A5%E6%B1%A0%E9%85%8D%E7%BD%AE.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/web/RestTemplate/200723-SpringBoot%E7%B3%BB%E5%88%97RestTemplate%E4%B9%8B%E8%BF%9E%E6%8E%A5%E6%B1%A0%E9%85%8D%E7%BD%AE.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">10.连接池配置</source>
      <description>我又回来更新RestTemplate了，前面更完之后忽然发现还漏了两个常用的场景，连接池的配置以及错误重试，这就迅速的把这个补上；本篇主要介绍RestTemplate如何设置连接池</description>
      <category>SpringBoot</category>
      <category>WEB系列</category>
      <category>RestTemplate</category>
      <pubDate>Thu, 23 Jul 2020 08:39:19 GMT</pubDate>
      <content:encoded><![CDATA[<p>我又回来更新RestTemplate了，前面更完之后忽然发现还漏了两个常用的场景，连接池的配置以及错误重试，这就迅速的把这个补上；本篇主要介绍RestTemplate如何设置连接池</p>
<!-- more -->
<h2> I. 项目搭建</h2>
<p>本项目基于SpringBoot <code>2.2.1.RELEASE</code> + <code>maven 3.5.3</code> + <code>idea</code>进行开发</p>
<h3> 1. pom依赖</h3>
<p>核心pom依赖如下</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>请注意，我们这里引入的依赖，多了一个<code>httpclient</code>，在下面的连接池配置中，主要借助它的连接池管理来创建HttpClient对象</p>
<h2> II. 使用姿势</h2>
<h3> 1. 连接池配置</h3>
<p>一般来讲，借助<code>httpcomponents</code>这个包进行连接池配置时，可以分为三步</p>
<p><strong>初始化连接池管理类</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>HttpClient构造器</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>RestTemplate RequestFactory创建</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>到这里基本上就是前面的初始化RestTemplate的环节了</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. OkHttp方式</h3>
<p>对于RestTemplate的HttpClient执行库，除了上面的<code>httpcomponents</code>之外，还有一个OkHttp目前也是大受欢迎，如果我们使用OkHttp，那么可以怎么设置呢?</p>
<p>首先依然是引入依赖</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其次和上面三步骤差不多的设置</p>
<p><strong>初始化连接池</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>创建OkHttpClient</strong></p>
<p>注意这里和上面是有区别的，前面是构建HttpClient构造器，而这里直接生成了一个OkHttpClient，内置连接池</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>RestTemplate RequestFactory创建</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>最后就是创建<code>RestTemplate</code>了</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2> II. 其他</h2>
<h3> 0. 项目&amp;系列博文</h3>
<p><strong>博文</strong></p>
<ul>
<li><a href="http://spring.hhui.top/spring-blog/2020/07/10/200710-SpringBoot%E7%B3%BB%E5%88%97RestTemplate%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/" target="_blank" rel="noopener noreferrer">【WEB系列】RestTemplate之文件上传</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2020/07/07/200707-SpringBoot%E7%B3%BB%E5%88%97AsyncRestTemplate%E4%B9%8B%E5%BC%82%E6%AD%A5%E9%9D%9E%E9%98%BB%E5%A1%9E%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E4%BB%8B%E7%BB%8D%E7%AF%87/" target="_blank" rel="noopener noreferrer">【WEB系列】AsyncRestTemplate之异步非阻塞网络请求介绍篇</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2020/07/05/200705-SpringBoot%E7%B3%BB%E5%88%97RestTemplate%E4%B9%8B%E9%9D%9E200%E7%8A%B6%E6%80%81%E7%A0%81%E4%BF%A1%E6%81%AF%E6%8D%95%E8%8E%B7/" target="_blank" rel="noopener noreferrer">【WEB系列】RestTemplate之非200状态码信息捕获</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2020/07/04/200704-SpringBoot%E7%B3%BB%E5%88%97RestTemplate%E4%B9%8BBasic-Auth%E6%8E%88%E6%9D%83/" target="_blank" rel="noopener noreferrer">【WEB系列】RestTemplate之Basic Auth授权</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2020/07/03/200703-SpringBoot%E7%B3%BB%E5%88%97RestTemplate%E4%B9%8B%E4%BB%A3%E7%90%86%E8%AE%BF%E9%97%AE/" target="_blank" rel="noopener noreferrer">【WEB系列】RestTemplate之代理访问</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2020/07/02/200702-SpringBoot%E7%B3%BB%E5%88%97RestTemplate%E4%B9%8B%E8%B6%85%E6%97%B6%E8%AE%BE%E7%BD%AE/" target="_blank" rel="noopener noreferrer">【WEB系列】RestTemplate之超时设置</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2020/07/01/200701-SpringBoot%E7%B3%BB%E5%88%97RestTemplate%E4%B9%8B%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98fix/" target="_blank" rel="noopener noreferrer">【WEB系列】RestTemplate之中文乱码问题fix</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2020/06/30/200630-SpringBoot%E7%B3%BB%E5%88%97RestTemplate%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E8%AF%B7%E6%B1%82%E5%A4%B4/" target="_blank" rel="noopener noreferrer">【WEB系列】RestTemplate之自定义请求头</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2020/06/30/200630-SpringBoot%E7%B3%BB%E5%88%97RestTemplate%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E8%AF%B7%E6%B1%82%E5%A4%B4/" target="_blank" rel="noopener noreferrer">【WEB系列】RestTemplate基础用法小结</a></li>
</ul>
<p><strong>源码</strong></p>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码: <a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/221-web-resttemplate" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/221-web-resttemplate</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>RestTemplate</title>
      <link>https://liuyueyi.github.io/tutorial/spring/web/RestTemplate/</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/web/RestTemplate/</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">RestTemplate</source>
      <description>天天与网络打交道，那么你知道Spring中哪个工具类是最好用的么？没错就是RestTemplate，系列文章教你用好这个利器，解决网络资源访问的难点</description>
      <pubDate>Fri, 10 Feb 2023 04:50:05 GMT</pubDate>
      <content:encoded><![CDATA[<p>天天与网络打交道，那么你知道Spring中哪个工具类是最好用的么？没错就是RestTemplate，系列文章教你用好这个利器，解决网络资源访问的难点</p>
]]></content:encoded>
    </item>
    <item>
      <title>1.基础使用姿势</title>
      <link>https://liuyueyi.github.io/tutorial/spring/web/WebClient/200709-SpringBoot%E7%B3%BB%E5%88%97WebClient%E4%B9%8B%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/web/WebClient/200709-SpringBoot%E7%B3%BB%E5%88%97WebClient%E4%B9%8B%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">1.基础使用姿势</source>
      <description>前面在介绍使用AsyncRestTemplate来实现网络异步请求时，当时提到在Spring5+之后，建议通过WebClient来取代AsyncRestTemplate来实现异步网络请求； 那么WebClient又是一个什么东西呢，它是怎样替代AsyncRestTemplate来实现异步请求的呢，接下来我们将进入Spring Web工具篇中，比较重要的WebClient系列知识点，本文为第一篇，基本使用姿势一览</description>
      <category>SpringBoot</category>
      <category>WEB系列</category>
      <category>WebClient</category>
      <pubDate>Thu, 09 Jul 2020 09:22:09 GMT</pubDate>
      <content:encoded><![CDATA[<p>前面在介绍使用<code>AsyncRestTemplate</code>来实现网络异步请求时，当时提到在Spring5+之后，建议通过WebClient来取代AsyncRestTemplate来实现异步网络请求；</p>
<p>那么WebClient又是一个什么东西呢，它是怎样替代<code>AsyncRestTemplate</code>来实现异步请求的呢，接下来我们将进入Spring Web工具篇中，比较重要的WebClient系列知识点，本文为第一篇，基本使用姿势一览</p>
<!-- more -->
<h2> I. 项目环境</h2>
<p>我们依然采用SpringBoot来搭建项目，版本为 <code>2.2.1.RELEASE</code>, <code>maven3.2</code>作为构建工具，<code>idea</code>作为开发环境</p>
<h3> 1. pom依赖</h3>
<p>SpringBoot相关的依赖就不贴出来了，有兴趣的可以查看源码，下面是关键依赖</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>请注意一下上面的两个依赖包，对于使用<code>WebClient</code>，主要需要引入<code>spring-boot-starter-webflux</code>包</p>
<h3> 2. 测试REST接口</h3>
<p>接下来我们直接在这个项目中写几个用于测试的REST接口，因为项目引入的webflux的依赖包，所以我们这里也采用webflux的注解方式，新增用于测试的GET/POST接口</p>
<blockquote>
<p>对于WebFlux用法不太清楚的小伙伴也没有关系，WebClient的发起的请求，后端是基于传统的Servlet也是没有问题的；关于WebFlux的知识点，将放在WebClient系列博文之后进行介绍</p>
</blockquote>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>针对上面的两个POST方法，虽然参数都是Body，但是一个有<code>@RequestBody</code>，一个没有，这里需要额外注意</p>
<p>从下图也可以看出，两者的区别之处</p>
<figure><img src="/imgs/200709/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> II. WebClient使用说明</h2>
<p>接下来我们将进入WebClient的使用说明，主要针对最常见的GET/POST请求姿势进行实例展示，目标是看完下面的内容之后，可以愉快的进行<strong>最基本</strong>（手动加强语气）的GET/POST请求发送</p>
<p>以下所有内容，参考or启发与官方文档: <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web-reactive.html#webflux-client" target="_blank" rel="noopener noreferrer">https://docs.spring.io/spring/docs/current/spring-framework-reference/web-reactive.html#webflux-client</a></p>
<h3> 1. WebClient创建姿势</h3>
<p>一般有三种获得WebClient的方式，基于<code>WebClient#create</code>创建默认的WebClient，基于<code>WebClient#builder</code>创建有自定义需求的WebClient，基于已有的<code>webclient#mutate</code>创建</p>
<h4> a. create方式</h4>
<p>这种属于最常见，也是最基础的创建方式，通常有两种case</p>
<ul>
<li><code>WebClient.create()</code></li>
<li><code>WebClient.create(String baseUrl)</code>：与上面一个最主要的区别在于指定了baseUrl，后面再发起的请求，就不需要重复这个baseUrl了；
<ul>
<li>举例说明：baseUrl指定为<code>http://127.0.0.1:8080</code>；那么后面的请求url，直接填写<code>/get</code>, <code>/header</code>, <code>/post</code>这种path路径即可</li>
</ul>
</li>
</ul>
<p>下面给出一个实例说明</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> b. builder方式</h4>
<p>builder方式最大的区别在于它可以为<code>WebClient</code> "赋能", 比如我们希望所有的请求都有通用的请求头、cookie等，就可以通过<code>builder</code>的方式，在创建<code>WebClient</code>的时候就进行指定</p>
<p>官方支持的可选配置如下：</p>
<ul>
<li><code>uriBuilderFactory</code>: Customized UriBuilderFactory to use as a base URL.</li>
<li><code>defaultHeader</code>: Headers for every request.</li>
<li><code>defaultCookie</code>: Cookies for every request.</li>
<li><code>defaultRequest</code>: Consumer to customize every request.</li>
<li><code>filter</code>: Client filter for every request.</li>
<li><code>exchangeStrategies</code>: HTTP message reader/writer customizations.</li>
<li><code>clientConnector</code>: HTTP client library settings.</li>
</ul>
<blockquote>
<p>关于上面这些东西有啥用，怎么用，会在后续的系列博文中逐一进行介绍，这里就不详细展开；有兴趣的小伙伴可以关注收藏一波</p>
</blockquote>
<p>给出一个设置默认Header的实例</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> c. mutate方式</h4>
<p>这种方式主要是在一个已经存在的<code>WebClient</code>基础上，再创建一个满足自定义需求的<code>WebClient</code></p>
<p>为什么要这样呢？</p>
<ul>
<li>因为WebClient一旦创建，就是不可修改的</li>
</ul>
<p>下面给出一个在builder创建基础上，再添加cookie的实例</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> d. 测试输出</h4>
<p>查看项目源码的小伙伴，会看到上面三个代码片段是在同一个方法内部，测试输出如下</p>
<figure><img src="/imgs/200709/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>你会看到一个有意思的地方，第一种基础的创建方式输出在第二种之后，这个是没有问题的哈（有疑问的小伙伴可以看一下文章开头，我们介绍WebClient的起因是啥）</p>
<h3> 2. GET请求</h3>
<p>上面其实已经给出了GET的请求姿势，一般使用姿势也比较简单，我们需要重点关注一下这个传参问题</p>
<p>常见的使用姿势</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>get的传参，除了在uri中直接写死之外，还有几种常见的写法</p>
<h4> a. uri参数</h4>
<p><strong>可变参数</strong></p>
<p>查看源码的小伙伴，可以看到uri方法的接口声明为一个可变参数，所以就有一种uri用占位<code>{}</code>表示参数位置，后面的参数对应参数值的时候用方式</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>请注意，上面两个参数的case中，p1对应的是<code>一灰灰</code>，p2对应的是<code>18</code>；这里的p1和p2可以替换为任意的其他字符，它们是按照顺序进行填充的，即第一个参数值填在第一个<code>{}</code>坑位</p>
<p><strong>map参数映射</strong></p>
<p>另外一种方式就是通过map来绑定参数名与参数值之间的映射关系</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> b. 获取ResponseEntity</h4>
<p>请仔细观察上面的使用姿势，调用了<code>retrieve()</code>方法，这个主要就是用来从返回结果中“摘出”<code>responseBody</code>，那么如果我们希望后去返回的请求头，返回的状态码，则需要将这个方法替换为<code>exchange()</code></p>
<p>下面给出一个获取返回的请求头实例</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>和前面的时候姿势大同小异，至于flatMap这些知识点会放在后续的WebFlux中进行介绍，这里知道它是用来ResponseBody格式转换关键点即可</p>
<h4> c. 测试返回</h4>
<p>测试输出结果如下（当然实际输出顺序和上面定义的先后也没有什么关系）</p>
<figure><img src="/imgs/200709/02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 3. POST请求</h3>
<p>对于post请求，我们一般最长关注的就是基本的表单传参和json body方式传递，下面分别给与介绍</p>
<h4> a. 表单参数</h4>
<p>借助<code>MultiValueMap</code>来保存表单参数用于提交</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面注释了一行<code>contentType(MediaType.APPLICATION_FORM_URLENCODED)</code>，因为默认的ContentType就是这个了，所以不需要额外指定（当然手动指定也没有任何毛病）</p>
<p>除了上面这种使用姿势之外，在官方教程上，还有一种写法，特别注意下面这种写法的传参是用的<code>body</code>，而上面是<code>bodyValue</code>，千万别用错，不然...</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> b. json body传参</h4>
<p>post一个json串，可以说是比较常见的case了，在WebClient中，使用这种方式特别特别简单，感觉比前面那个还方便</p>
<ul>
<li>指定ContentType</li>
<li>传入Object对象</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> c. 测试输出</h4>
<figure><img src="/imgs/200709/03.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 4. 小结</h3>
<p>本文为WebClient系列第一篇，介绍WebClient的基本使用姿势，当然看完之后，发起GET/POST请求还是没有什么问题的；但是仅限于此嘛？</p>
<ul>
<li>builder创建方式中，那些可选的条件都是啥，有什么用，什么场景下会用呢？</li>
<li>请求超时时间可设置么？</li>
<li>可以同步阻塞方式获取返回结果嘛？</li>
<li>代理怎么加</li>
<li><code>event-stream</code>返回方式的数据怎么处理</li>
<li>如何上传文件</li>
<li>Basic Auth身份鉴权</li>
<li>异步线程池可指定么，可替换为自定义的么</li>
<li>返回非200状态码时，表现如何，又该如何处理</li>
<li>....</li>
</ul>
<p>后续的系列博文将针对上面提出or尚未提出的问题，一一进行介绍，看到的各位大佬按按鼠标点赞收藏评论关注加个好友呗</p>
<h2> II. 其他</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/222-web-client" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/222-web-client</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/200709/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>2.文件上传</title>
      <link>https://liuyueyi.github.io/tutorial/spring/web/WebClient/200713-SpringBoot%E7%B3%BB%E5%88%97WebClient%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/web/WebClient/200713-SpringBoot%E7%B3%BB%E5%88%97WebClient%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">2.文件上传</source>
      <description>在上一篇WebClient基本使用姿势中，介绍了如何借助WebClient来实现异步的GET/POST访问，接下来这篇文章则主要介绍文件上传的使用姿势</description>
      <category>SpringBoot</category>
      <category>WEB系列</category>
      <category>WebClient</category>
      <pubDate>Mon, 13 Jul 2020 08:25:38 GMT</pubDate>
      <content:encoded><![CDATA[<p>在上一篇<a href="http://spring.hhui.top/spring-blog/2020/07/09/200709-SpringBoot%E7%B3%BB%E5%88%97WebClient%E4%B9%8B%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF/" target="_blank" rel="noopener noreferrer">WebClient基本使用姿势</a>中，介绍了如何借助WebClient来实现异步的GET/POST访问，接下来这篇文章则主要介绍文件上传的使用姿势</p>
<!-- more -->
<h2> I. 项目环境</h2>
<p>本项目借助<code>SpringBoot 2.2.1.RELEASE</code> + <code>maven 3.5.3</code> + <code>IDEA</code>进行开发</p>
<h3> 1. 依赖</h3>
<p>使用WebClient，最主要的引入依赖如下（省略掉了SpringBoot的相关依赖，如对于如何创建SpringBoot项目不太清楚的小伙伴，可以关注一下我之前的博文）</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 文件上传接口</h3>
<p>借助WebFlux，写一个简单的文件上传的REST接口（关于WebFlux的使用姿势不属于本文重点，下面的代码如有不懂的地方，可以直接忽略掉或者关注一下接下来的WebFlux系列博文）</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. 待上传文件</h3>
<p>在项目的资源目录<code>resources</code>下，新建一个文本文件，用于测试上传时使用</p>
<p><code>test.txt</code></p>
<div class="language-txt line-numbers-mode" data-ext="txt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2> II. 文件上传</h2>
<blockquote>
<p>在前面介绍RestTemplate的系列博文中，同样有一篇关于<a href="http://spring.hhui.top/spring-blog/2020/07/10/200710-SpringBoot%E7%B3%BB%E5%88%97RestTemplate%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/" target="_blank" rel="noopener noreferrer">RestTemplate文件上传</a>的博文，建议两篇对照阅读，可以获取双倍的收获哦</p>
</blockquote>
<h3> 1. 单个文件上传</h3>
<p>请注意，文件上传依然是POST请求，一般来讲，请求头的<code>Content-Type</code>为<code>multipart/form-data</code></p>
<p>前面介绍WebClient的POST传参时，参数是封装在<code>MultiValueMap</code>中的，在文件上传中，依然如此，不同的是这个参数的构建方式</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>重点关注一下借助<code>MultipartBodyBuilder</code>创建请求参数的过程</strong></p>
<p>剩下的发起请求的姿势，与之前介绍的POST方式，没有什么区别</p>
<h3> 2. 流上传</h3>
<p>当然需要上传时，多半也不会是上传文件，比如一个常见的case可能是下载远程资源，并上传给内部服务；所以我们会使用<code>InputStreamResource</code>来替换<code>FileSystemResource</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>请注意：当不重写<code>InpustStreamResource</code>的<code>contentLength</code>与<code>getFilename</code>方法时，没法实现我们上传的目的哦</strong></p>
<h3> 3. 字节数组上传</h3>
<p>有流的方式，当然就不会缺少字节数组的方式，基本姿势与上面并无二样</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4. 多文件上传</h3>
<p>除了一个一个文件上传之外，某些case下也可能出现一次上传多个文件的情况，对于WebClient而言，无非就是构建上传参数的时候，多一个add而言</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 5. BodyInserters方式</h3>
<p>除了上面的<code>MultipartBodyBuilder</code>创建传参之外，还可以借助<code>BodyInserters</code>来处理，前面在接收Post传参的两种姿势中也介绍过；</p>
<p>不过不同于之前的<code>BodyInserters#fromFormData</code>，我们这里使用的是<code>BodyInserters#fromMultipartData</code> （从调用的方法签名上，也知道两者的各自应用场景）</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>请注意，我们传参是通过<code>body</code>方法，而不是前面的<code>bodyValue</code>方法；如果使用错了，将无法达到预期的目的，而且极有可能调试半天也不知道啥原因...</p>
<h3> 6. 测试输出</h3>
<p>所有上面的代码可以在文末的工程源码连接中获取，下面是执行的输出结果</p>
<figure><img src="/imgs/200713/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> II. 其他</h2>
<h3> 0. 项目</h3>
<p><strong>系列博文</strong></p>
<ul>
<li><a href="http://spring.hhui.top/spring-blog/2020/07/09/200709-SpringBoot%E7%B3%BB%E5%88%97WebClient%E4%B9%8B%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF/" target="_blank" rel="noopener noreferrer">【WEB系列】WebClient之基础使用姿势</a></li>
</ul>
<p><strong>源码</strong></p>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/222-web-client" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/222-web-client</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/200713/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>3.请求头设置</title>
      <link>https://liuyueyi.github.io/tutorial/spring/web/WebClient/200714-SpringBoot%E7%B3%BB%E5%88%97WebClient%E4%B9%8B%E8%AF%B7%E6%B1%82%E5%A4%B4%E8%AE%BE%E7%BD%AE.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/web/WebClient/200714-SpringBoot%E7%B3%BB%E5%88%97WebClient%E4%B9%8B%E8%AF%B7%E6%B1%82%E5%A4%B4%E8%AE%BE%E7%BD%AE.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">3.请求头设置</source>
      <description>在网络请求中，根据请求头的参数来做校验属于比较常见的一种case了，很多场景下我们发起的请求都需要额外的去设置请求头，本文将介绍WebClient设置请求头的两种姿势</description>
      <category>SpringBoot</category>
      <category>WEB系列</category>
      <category>WebClient</category>
      <pubDate>Tue, 14 Jul 2020 08:30:20 GMT</pubDate>
      <content:encoded><![CDATA[<p>在网络请求中，根据请求头的参数来做校验属于比较常见的一种case了，很多场景下我们发起的请求都需要额外的去设置请求头，本文将介绍WebClient设置请求头的两种姿势</p>
<!-- more -->
<h2> I. 项目环境</h2>
<p>本项目借助<code>SpringBoot 2.2.1.RELEASE</code> + <code>maven 3.5.3</code> + <code>IDEA</code>进行开发</p>
<h3> 1. 依赖</h3>
<p>使用WebClient，最主要的引入依赖如下（省略掉了SpringBoot的相关依赖，如对于如何创建SpringBoot项目不太清楚的小伙伴，可以关注一下我之前的博文）</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. REST接口</h3>
<p>基于WebFlux提供一个http接口，返回请求参数与请求头(关于webflux的用法在后续的WebFlux系列篇中给与介绍)</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> II. 设置请求头</h2>
<h3> 1. 默认请求头</h3>
<p>在第一篇介绍WebClient创建的几种姿势中，<code>WebClient.builder()</code>方式创建时，可以指定默认的请求头，因此我们可以在创建时指定</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过上面这种方式创建的webclient，所有的请求都会携带<code>User-Agent: SelfDefine Header</code>这个请求头哦</p>
<h3> 2. filter方式</h3>
<p>除了上面这种姿势之外，WebClient还支持了Filter，对于Filter你可以将它理解为Servlet中的Filter，主要用于在发起请求时，做一些过滤操作，因此我们完全可以写一个塞入自定义请求头的Filter</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>请注意上面添加<code>header</code>的用法</p>
<h3> 3. 测试&amp;小结</h3>
<p>关于详细的测试代码可以在下面的工程源码中获取，下面给出上面两种姿势的返回结果</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>小结：</strong></p>
<p>本文介绍两种请求头的设置方式</p>
<ul>
<li>通过<code>WebClient.builder</code>在创建时，通过<code>defaultHeader</code>指定默认的请求头</li>
<li>借助Filter，主动在<code>Request</code>中塞入请求头</li>
</ul>
<h2> III. 其他</h2>
<h3> 0. 项目</h3>
<p><strong>系列博文</strong></p>
<ul>
<li><a href="http://spring.hhui.top/spring-blog/2020/07/09/200709-SpringBoot%E7%B3%BB%E5%88%97WebClient%E4%B9%8B%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF/" target="_blank" rel="noopener noreferrer">【WEB系列】WebClient之基础使用姿势</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2020/07/13/200713-SpringBoot%E7%B3%BB%E5%88%97WebClient%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/" target="_blank" rel="noopener noreferrer">【WEB系列】WebClient之文件上传</a></li>
</ul>
<p><strong>源码</strong></p>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/222-web-client" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/222-web-client</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>4.Basic Auth授权</title>
      <link>https://liuyueyi.github.io/tutorial/spring/web/WebClient/200716-SpringBoot%E7%B3%BB%E5%88%97WebClient%E4%B9%8BBasic-Auth%E6%8E%88%E6%9D%83.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/web/WebClient/200716-SpringBoot%E7%B3%BB%E5%88%97WebClient%E4%B9%8BBasic-Auth%E6%8E%88%E6%9D%83.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">4.Basic Auth授权</source>
      <description>关于BasicAuth是什么，以及如何实现鉴权的知识点可以在之前的博文 【WEB系列】RestTemplate之Basic Auth授权 中已经介绍过了，因此本篇将直接进入正文，介绍一下如何在WebClient中进行Basic Auth授权</description>
      <category>SpringBoot</category>
      <category>WEB系列</category>
      <category>WebClient</category>
      <pubDate>Thu, 16 Jul 2020 08:10:23 GMT</pubDate>
      <content:encoded><![CDATA[<p>关于BasicAuth是什么，以及如何实现鉴权的知识点可以在之前的博文 <a href="http://spring.hhui.top/spring-blog/2020/07/04/200704-SpringBoot%E7%B3%BB%E5%88%97RestTemplate%E4%B9%8BBasic-Auth%E6%8E%88%E6%9D%83/" target="_blank" rel="noopener noreferrer">【WEB系列】RestTemplate之Basic Auth授权</a> 中已经介绍过了，因此本篇将直接进入正文，介绍一下如何在WebClient中进行Basic Auth授权</p>
<!-- more -->
<h2> I. 项目环境</h2>
<p>本项目借助<code>SpringBoot 2.2.1.RELEASE</code> + <code>maven 3.5.3</code> + <code>IDEA</code>进行开发</p>
<h3> 1. 依赖</h3>
<p>使用WebClient，最主要的引入依赖如下（省略掉了SpringBoot的相关依赖，如对于如何创建SpringBoot项目不太清楚的小伙伴，可以关注一下我之前的博文）</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. REST接口</h3>
<p>基于WebFlux提供一个http接口，根据请求头解析Basic Auth是否合法，一个最原始的简单实现方式如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当鉴权成功之后，正常返回；当鉴权失败之后，返回403状态码，并返回对应的提示信息</p>
<h2> II. Basic Auth鉴权</h2>
<p>理解Basic Auth实现原理的小伙伴，可以很简单的实现，比如直接设置请求头</p>
<h3> 1. 设置请求头</h3>
<p>直接在WebClient创建的时候，指定默认的请求头即可</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. filter方式</h3>
<p>在上一篇介绍WebClient请求头的使用姿势中，除了默认请求头设置之外，还有一个filter的方式，而WebClient正好提供了一个专门用于Basic Auth的Filter</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. 测试与小结</h3>
<p>以上代码可以在后文的工程源码中获取，测试输出如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>本文主要介绍了两种WebClient的Basic Auth使用姿势，其原理都是基于设置请求头的方式来实现的</p>
<ul>
<li>基于<code>WebClient.builder().defaultHeader</code>来手动设置默认请求头</li>
<li>基于<code>WebClient.builder().filter</code>与<code>ExchangeFilterFunctions.basicAuthentication</code>，通过filter来处理请求头</li>
</ul>
<h2> II. 其他</h2>
<h3> 0. 项目</h3>
<p><strong>系列博文</strong></p>
<ul>
<li><a href="http://spring.hhui.top/spring-blog/2020/07/14/200714-SpringBoot%E7%B3%BB%E5%88%97WebClient%E4%B9%8B%E8%AF%B7%E6%B1%82%E5%A4%B4%E8%AE%BE%E7%BD%AE/" target="_blank" rel="noopener noreferrer">【WEB系列】WebClient之请求头设置</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2020/07/13/200713-SpringBoot%E7%B3%BB%E5%88%97WebClient%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/" target="_blank" rel="noopener noreferrer">【WEB系列】WebClient之文件上传</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2020/07/09/200709-SpringBoot%E7%B3%BB%E5%88%97WebClient%E4%B9%8B%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF/" target="_blank" rel="noopener noreferrer">【WEB系列】WebClient之基础使用姿势</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2020/07/13/200713-SpringBoot%E7%B3%BB%E5%88%97WebClient%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/" target="_blank" rel="noopener noreferrer">【WEB系列】WebClient之文件上传</a></li>
</ul>
<p><strong>源码</strong></p>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/222-web-client" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/222-web-client</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>5.超时设置</title>
      <link>https://liuyueyi.github.io/tutorial/spring/web/WebClient/200717-SpringBoot%E7%B3%BB%E5%88%97WebClient%E4%B9%8B%E8%B6%85%E6%97%B6%E8%AE%BE%E7%BD%AE.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/web/WebClient/200717-SpringBoot%E7%B3%BB%E5%88%97WebClient%E4%B9%8B%E8%B6%85%E6%97%B6%E8%AE%BE%E7%BD%AE.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">5.超时设置</source>
      <description>为所有的第三方接口调用设置超时时间是一个比较推荐的做法，避免自己的任务被所依赖的服务给拖死；在WebClient发起的异步网络请求调用中，应该如何设置超时时间呢?</description>
      <category>SpringBoot</category>
      <category>WEB系列</category>
      <category>WebClient</category>
      <pubDate>Fri, 17 Jul 2020 08:28:12 GMT</pubDate>
      <content:encoded><![CDATA[<p>为所有的第三方接口调用设置超时时间是一个比较推荐的做法，避免自己的任务被所依赖的服务给拖死；在WebClient发起的异步网络请求调用中，应该如何设置超时时间呢?</p>
<!-- more -->
<h2> I. 项目环境</h2>
<p>本项目借助<code>SpringBoot 2.2.1.RELEASE</code> + <code>maven 3.5.3</code> + <code>IDEA</code>进行开发</p>
<h3> 1. 依赖</h3>
<p>使用WebClient，最主要的引入依赖如下（省略掉了SpringBoot的相关依赖，如对于如何创建SpringBoot项目不太清楚的小伙伴，可以关注一下我之前的博文）</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. REST接口</h3>
<p>基于WebFlux提供一个http接口，内部sleep 5s，来响应后续的超时case</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> II. 超时</h2>
<blockquote>
<p>本篇实例主要来自于官方文档: <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web-reactive.html#webflux-client-builder-reactor-timeout" target="_blank" rel="noopener noreferrer">webflux-client-builder-reactor-timeout</a></p>
</blockquote>
<h3> 1. 实例演示</h3>
<p>在WebClient的创建中，实际上并没有找到有设置超时的入口，基于之前RestTemplate的超时设置中的经验，我们可能需要将目标放在更底层实现网络请求的HttpClient上</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面虽然获取了一个带超时设置的HttpCilent，但是我们需要用它来设置WebClient，这里就需要借助<code>WebClient.builder().clientConnector</code>来实现了</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 测试与小结</h3>
<p>本文所有源码可以在后面的项目地址中获取，测试输出结果如下</p>
<figure><img src="/imgs/200717/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>虽然上面的输出提示了超时，但是奇怪的是居然不像RestTemplate的超时抛异常，上面这个流程可以正常走通，那么如何捕获这个超时异常呢，WebClient访问出现非200状态码返回的又可以如何处理呢，下篇博文将给与介绍</p>
<p><strong>小结</strong></p>
<ul>
<li>通过<code>HttpClient</code>来设置超时时间</li>
<li>借助<code>WebClient.builder().clientConnector(new ReactorClientHttpConnector(httpClient))</code>来绑定HttpClient</li>
</ul>
<h2> II. 其他</h2>
<h3> 0. 项目</h3>
<p><strong>系列博文</strong></p>
<ul>
<li><a href="http://spring.hhui.top/spring-blog/2020/07/16/200716-SpringBoot%E7%B3%BB%E5%88%97WebClient%E4%B9%8BBasic-Auth%E6%8E%88%E6%9D%83/" target="_blank" rel="noopener noreferrer">【WEB系列】WebClient之Basic Auth授权</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2020/07/14/200714-SpringBoot%E7%B3%BB%E5%88%97WebClient%E4%B9%8B%E8%AF%B7%E6%B1%82%E5%A4%B4%E8%AE%BE%E7%BD%AE/" target="_blank" rel="noopener noreferrer">【WEB系列】WebClient之请求头设置</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2020/07/13/200713-SpringBoot%E7%B3%BB%E5%88%97WebClient%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/" target="_blank" rel="noopener noreferrer">【WEB系列】WebClient之文件上传</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2020/07/09/200709-SpringBoot%E7%B3%BB%E5%88%97WebClient%E4%B9%8B%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF/" target="_blank" rel="noopener noreferrer">【WEB系列】WebClient之基础使用姿势</a></li>
</ul>
<p><strong>源码</strong></p>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/222-web-client" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/222-web-client</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/200717/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>6.retrieve与exchange的使用区别介绍</title>
      <link>https://liuyueyi.github.io/tutorial/spring/web/WebClient/200728-SpringBoot%E7%B3%BB%E5%88%97WebClient%E4%B9%8Bretrieve%E4%B8%8Eexchange%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8C%BA%E5%88%AB%E4%BB%8B%E7%BB%8D.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/web/WebClient/200728-SpringBoot%E7%B3%BB%E5%88%97WebClient%E4%B9%8Bretrieve%E4%B8%8Eexchange%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8C%BA%E5%88%AB%E4%BB%8B%E7%BB%8D.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">6.retrieve与exchange的使用区别介绍</source>
      <description>前面介绍了几篇WebCilent的使用姿势博文，其中大部分的演示case，都是使用retrieve来获取返回ResponseBody，我国我们希望获取更多的返回信息，比如获取返回头，这个时候exchange则是更好的选择； 本文将主要介绍一下，在WebClient中retrieve和exchange的各自使用场景</description>
      <category>SpringBoot</category>
      <category>WEB系列</category>
      <category>WebClient</category>
      <pubDate>Tue, 28 Jul 2020 08:52:48 GMT</pubDate>
      <content:encoded><![CDATA[<p>前面介绍了几篇WebCilent的使用姿势博文，其中大部分的演示case，都是使用<code>retrieve</code>来获取返回ResponseBody，我国我们希望获取更多的返回信息，比如获取返回头，这个时候exchange则是更好的选择；</p>
<p>本文将主要介绍一下，在WebClient中retrieve和exchange的各自使用场景</p>
<!-- more -->
<h2> I. 项目环境</h2>
<p>本项目借助<code>SpringBoot 2.2.1.RELEASE</code> + <code>maven 3.5.3</code> + <code>IDEA</code>进行开发</p>
<h3> 1. 依赖</h3>
<p>使用WebClient，最主要的引入依赖如下（省略掉了SpringBoot的相关依赖，如对于如何创建SpringBoot项目不太清楚的小伙伴，可以关注一下我之前的博文）</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. REST接口</h3>
<p>添加一个简单的Rest接口，用于后续的测试</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> II. 实例演示</h2>
<p>通过前面的几篇学习，我们知道WebClient发起请求的一般使用姿势如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>这两个方法都是用来获取返回结果的，最大的区别在于通过exchange接收完整的ResponseEntity；而retrieve接收的则是ResponseBody</p>
<h3> 1. exchange使用实例</h3>
<blockquote>
<p>The exchange() method provides more control than the retrieve method, provides access to the ClientResponse</p>
</blockquote>
<p>下面给出一个简单的，获取返回的状态码，cookies等请求头信息的case</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这段代码中，主要的核心点就是<code>ClientResponse</code>的解析，可以直接通过它获取返回头，响应状态码，其次提供了一些对ResponseBody的封装调用</p>
<p>返回结果</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果我们只关注ResponseBody，用exchange也是可以直接写的，如下，相比retrieve稍微饶了一道</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>另外一个更加推荐的写法是直接返回<code>Mono&lt;ResponseEntity&lt;?&gt;&gt;</code>，更友好的操作姿势，返回结果如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. retrieve使用实例</h3>
<blockquote>
<p>The retrieve() method is the easiest way to get a response body and decode it.</p>
</blockquote>
<p>前面已经多次演示retrieve的使用姿势，基本上是在后面带上<code>bodyToMono</code>或<code>bodyToFlux</code>来实现返回实体的类型转换</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. 小结</h3>
<p>对于retrieve与exchange来说，最简单也是最根本的区别在于，是否需要除了ResponseBody之外的其他信息</p>
<ul>
<li>如果只关注<code>ResponseBody</code>: 推荐使用<code>retrieve</code></li>
<li>如果还需要获取其他返回信息: 请选择<code>exchange</code></li>
</ul>
<h2> II. 其他</h2>
<h3> 0. 项目</h3>
<p><strong>系列博文</strong></p>
<ul>
<li><a href="http://spring.hhui.top/spring-blog/2020/07/17/200717-SpringBoot%E7%B3%BB%E5%88%97WebClient%E4%B9%8B%E8%B6%85%E6%97%B6%E8%AE%BE%E7%BD%AE/" target="_blank" rel="noopener noreferrer">【WEB系列】WebClient之超时设置</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2020/07/16/200716-SpringBoot%E7%B3%BB%E5%88%97WebClient%E4%B9%8BBasic-Auth%E6%8E%88%E6%9D%83/" target="_blank" rel="noopener noreferrer">【WEB系列】WebClient之Basic Auth授权</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2020/07/14/200714-SpringBoot%E7%B3%BB%E5%88%97WebClient%E4%B9%8B%E8%AF%B7%E6%B1%82%E5%A4%B4%E8%AE%BE%E7%BD%AE/" target="_blank" rel="noopener noreferrer">【WEB系列】WebClient之请求头设置</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2020/07/13/200713-SpringBoot%E7%B3%BB%E5%88%97WebClient%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/" target="_blank" rel="noopener noreferrer">【WEB系列】WebClient之文件上传</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2020/07/09/200709-SpringBoot%E7%B3%BB%E5%88%97WebClient%E4%B9%8B%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF/" target="_blank" rel="noopener noreferrer">【WEB系列】WebClient之基础使用姿势</a></li>
</ul>
<p><strong>源码</strong></p>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/222-web-client" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/222-web-client</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>7.非200状态码信息捕获</title>
      <link>https://liuyueyi.github.io/tutorial/spring/web/WebClient/200803-SpringBoot%E7%B3%BB%E5%88%97WebClient%E4%B9%8B%E9%9D%9E200%E7%8A%B6%E6%80%81%E7%A0%81%E4%BF%A1%E6%81%AF%E6%8D%95%E8%8E%B7.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/web/WebClient/200803-SpringBoot%E7%B3%BB%E5%88%97WebClient%E4%B9%8B%E9%9D%9E200%E7%8A%B6%E6%80%81%E7%A0%81%E4%BF%A1%E6%81%AF%E6%8D%95%E8%8E%B7.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">7.非200状态码信息捕获</source>
      <description>前面介绍的WebClient的使用姿势都是基于正常的200状态码返回，当然在实际的使用中，我们并不是总能获取到200的状态码的，在RestTemplate的学习中，我们知道如果不特殊处理，那么是无法正确获取非200状态码的ResponseBody的，会直接抛出异常，那么在WebClient中又应该怎样应对非200状态码返回的场景呢？ I. 项目环境 本项目借助SpringBoot 2.2.1.RELEASE + maven 3.5.3 + IDEA进行开发</description>
      <category>SpringBoot</category>
      <category>WEB系列</category>
      <category>WebClient</category>
      <pubDate>Mon, 03 Aug 2020 08:34:21 GMT</pubDate>
      <content:encoded><![CDATA[<p>前面介绍的WebClient的使用姿势都是基于正常的200状态码返回，当然在实际的使用中，我们并不是总能获取到200的状态码的，在RestTemplate的学习中，我们知道如果不特殊处理，那么是无法正确获取非200状态码的ResponseBody的，会直接抛出异常，那么在WebClient中又应该怎样应对非200状态码返回的场景呢？</p>
<!-- more  -->
<h2> I. 项目环境</h2>
<p>本项目借助<code>SpringBoot 2.2.1.RELEASE</code> + <code>maven 3.5.3</code> + <code>IDEA</code>进行开发</p>
<h3> 1. 依赖</h3>
<p>使用WebClient，最主要的引入依赖如下（省略掉了SpringBoot的相关依赖，如对于如何创建SpringBoot项目不太清楚的小伙伴，可以关注一下我之前的博文）</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. REST</h3>
<p>一个简单的403返回</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> II. 实例说明</h2>
<h3> 1. retrieve方式</h3>
<p>上一篇介绍retrieve与exchange区别的博文中，我们知道retrieve更适用于只希望获取ResponseBody的场景；使用retrieve时，如需要捕获其他状态码的返回，可以如下操作</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>请注意上面的 <code>onStatus</code>， 上面演示的是4xx的捕获，返回如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 2. exchange方式</h3>
<p>exchange本身就可以获取完整的返回信息，所以异常的case需要我们自己在内部进行处理</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>返回结果如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> II. 其他</h2>
<h3> 0. 项目</h3>
<p><strong>系列博文</strong></p>
<ul>
<li><a href="http://spring.hhui.top/spring-blog/2020/07/28/200728-SpringBoot%E7%B3%BB%E5%88%97WebClient%E4%B9%8Bretrieve%E4%B8%8Eexchange%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8C%BA%E5%88%AB%E4%BB%8B%E7%BB%8D/" target="_blank" rel="noopener noreferrer">【WEB系列】WebClient之retrieve与exchange的使用区别介绍</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2020/07/17/200717-SpringBoot%E7%B3%BB%E5%88%97WebClient%E4%B9%8B%E8%B6%85%E6%97%B6%E8%AE%BE%E7%BD%AE/" target="_blank" rel="noopener noreferrer">【WEB系列】WebClient之超时设置</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2020/07/16/200716-SpringBoot%E7%B3%BB%E5%88%97WebClient%E4%B9%8BBasic-Auth%E6%8E%88%E6%9D%83/" target="_blank" rel="noopener noreferrer">【WEB系列】WebClient之Basic Auth授权</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2020/07/14/200714-SpringBoot%E7%B3%BB%E5%88%97WebClient%E4%B9%8B%E8%AF%B7%E6%B1%82%E5%A4%B4%E8%AE%BE%E7%BD%AE/" target="_blank" rel="noopener noreferrer">【WEB系列】WebClient之请求头设置</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2020/07/13/200713-SpringBoot%E7%B3%BB%E5%88%97WebClient%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/" target="_blank" rel="noopener noreferrer">【WEB系列】WebClient之文件上传</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2020/07/09/200709-SpringBoot%E7%B3%BB%E5%88%97WebClient%E4%B9%8B%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF/" target="_blank" rel="noopener noreferrer">【WEB系列】WebClient之基础使用姿势</a></li>
</ul>
<p><strong>源码</strong></p>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/222-web-client" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/222-web-client</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>8.策略设置</title>
      <link>https://liuyueyi.github.io/tutorial/spring/web/WebClient/200811-SpringBoot%E7%B3%BB%E5%88%97WebClient%E4%B9%8B%E7%AD%96%E7%95%A5%E8%AE%BE%E7%BD%AE.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/web/WebClient/200811-SpringBoot%E7%B3%BB%E5%88%97WebClient%E4%B9%8B%E7%AD%96%E7%95%A5%E8%AE%BE%E7%BD%AE.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">8.策略设置</source>
      <description>在前面介绍WebClient的常见参数中，有一个exchangeStrategies参数设置，通过它我们可以设置传输数据的内存占用大小限制，避免内存问题；也可以通过它设置数据的编解码</description>
      <category>SpringBoot</category>
      <category>WEB系列</category>
      <category>WebClient</category>
      <pubDate>Tue, 11 Aug 2020 09:01:27 GMT</pubDate>
      <content:encoded><![CDATA[<p>在前面介绍WebClient的常见参数中，有一个<code>exchangeStrategies</code>参数设置，通过它我们可以设置传输数据的内存占用大小限制，避免内存问题；也可以通过它设置数据的编解码</p>
<!-- more -->
<h2> I. 项目环境</h2>
<p>本项目借助<code>SpringBoot 2.2.1.RELEASE</code> + <code>maven 3.5.3</code> + <code>IDEA</code>进行开发</p>
<h3> 1. 依赖</h3>
<p>使用WebClient，最主要的引入依赖如下（省略掉了SpringBoot的相关依赖，如对于如何创建SpringBoot项目不太清楚的小伙伴，可以关注一下我之前的博文）</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 测试接口</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> II. 使用说明</h2>
<h3> 1. MaxInMemorySize设置</h3>
<p>默认情况下，内存中接收数据的buffering data size为256KB，可以根据实际的需要进行改大or调小</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 编解码设置</h3>
<p>比如最常见的json编解码</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面两个测试之后，返回结果如下</p>
<figure><img src="/imgs/200811/00.jpg" alt="IMAGE" tabindex="0" loading="lazy"><figcaption>IMAGE</figcaption></figure>
<h2> II. 其他</h2>
<h3> 0. 项目</h3>
<p><strong>系列博文</strong></p>
<ul>
<li><a href="http://spring.hhui.top/spring-blog/2020/08/03/200803-SpringBoot%E7%B3%BB%E5%88%97WebClient%E4%B9%8B%E9%9D%9E200%E7%8A%B6%E6%80%81%E7%A0%81%E4%BF%A1%E6%81%AF%E6%8D%95%E8%8E%B7/" target="_blank" rel="noopener noreferrer">【WEB系列】WebClient之非200状态码信息捕获</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2020/07/28/200728-SpringBoot%E7%B3%BB%E5%88%97WebClient%E4%B9%8Bretrieve%E4%B8%8Eexchange%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8C%BA%E5%88%AB%E4%BB%8B%E7%BB%8D/" target="_blank" rel="noopener noreferrer">【WEB系列】WebClient之retrieve与exchange的使用区别介绍</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2020/07/17/200717-SpringBoot%E7%B3%BB%E5%88%97WebClient%E4%B9%8B%E8%B6%85%E6%97%B6%E8%AE%BE%E7%BD%AE/" target="_blank" rel="noopener noreferrer">【WEB系列】WebClient之超时设置</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2020/07/16/200716-SpringBoot%E7%B3%BB%E5%88%97WebClient%E4%B9%8BBasic-Auth%E6%8E%88%E6%9D%83/" target="_blank" rel="noopener noreferrer">【WEB系列】WebClient之Basic Auth授权</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2020/07/14/200714-SpringBoot%E7%B3%BB%E5%88%97WebClient%E4%B9%8B%E8%AF%B7%E6%B1%82%E5%A4%B4%E8%AE%BE%E7%BD%AE/" target="_blank" rel="noopener noreferrer">【WEB系列】WebClient之请求头设置</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2020/07/13/200713-SpringBoot%E7%B3%BB%E5%88%97WebClient%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/" target="_blank" rel="noopener noreferrer">【WEB系列】WebClient之文件上传</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2020/07/09/200709-SpringBoot%E7%B3%BB%E5%88%97WebClient%E4%B9%8B%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF/" target="_blank" rel="noopener noreferrer">【WEB系列】WebClient之基础使用姿势</a></li>
</ul>
<p><strong>源码</strong></p>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/222-web-client" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/222-web-client</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/200811/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>9.同步与异步</title>
      <link>https://liuyueyi.github.io/tutorial/spring/web/WebClient/200820-SpringBoot%E7%B3%BB%E5%88%97WebClient%E4%B9%8B%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/web/WebClient/200820-SpringBoot%E7%B3%BB%E5%88%97WebClient%E4%B9%8B%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">9.同步与异步</source>
      <description>回顾一下最开始介绍WebClient的使用姿势之前，我们介绍了AsyncRestTemplate来实现异步的网络请求；但是在Spring5之后，官方推荐使用WebClient来替换AsyncRestTemplate实现异步请求；所以一般来讲，WebClient适用于异步的网络访问，但是，假设我需要同步获取返回结果，可行么？</description>
      <category>SpringBoot</category>
      <category>WEB系列</category>
      <category>WebClient</category>
      <pubDate>Thu, 20 Aug 2020 15:10:42 GMT</pubDate>
      <content:encoded><![CDATA[<p>回顾一下最开始介绍WebClient的使用姿势之前，我们介绍了AsyncRestTemplate来实现异步的网络请求；但是在Spring5之后，官方推荐使用WebClient来替换AsyncRestTemplate实现异步请求；所以一般来讲，WebClient适用于异步的网络访问，但是，假设我需要同步获取返回结果，可行么？</p>
<!-- more -->
<h2> I. 项目环境</h2>
<p>本项目借助<code>SpringBoot 2.2.1.RELEASE</code> + <code>maven 3.5.3</code> + <code>IDEA</code>进行开发</p>
<h3> 1. 依赖</h3>
<p>使用WebClient，最主要的引入依赖如下（省略掉了SpringBoot的相关依赖，如对于如何创建SpringBoot项目不太清楚的小伙伴，可以关注一下我之前的博文）</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 测试接口</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> II. 同步返回</h2>
<p>需要同步返回结果还是比较简单的，获取对应的Mono/Flux之后调用一下<code>block()</code>方法即可，但是需要注意，这里也有一个潜在的坑</p>
<h3> 1. 实现方式</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>项目启动之后，我们写一个测试类来调用这个方法</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果我们换成下面这种写法，就会报错了</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/200820/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> III. 其他</h2>
<h3> 0. 项目</h3>
<p><strong>系列博文</strong></p>
<ul>
<li><a href="http://spring.hhui.top/spring-blog/2020/08/11/200811-SpringBoot%E7%B3%BB%E5%88%97WebClient%E4%B9%8B%E7%AD%96%E7%95%A5%E8%AE%BE%E7%BD%AE/" target="_blank" rel="noopener noreferrer">【WEB系列】WebClient之策略设置</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2020/08/03/200803-SpringBoot%E7%B3%BB%E5%88%97WebClient%E4%B9%8B%E9%9D%9E200%E7%8A%B6%E6%80%81%E7%A0%81%E4%BF%A1%E6%81%AF%E6%8D%95%E8%8E%B7/" target="_blank" rel="noopener noreferrer">【WEB系列】WebClient之非200状态码信息捕获</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2020/07/28/200728-SpringBoot%E7%B3%BB%E5%88%97WebClient%E4%B9%8Bretrieve%E4%B8%8Eexchange%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8C%BA%E5%88%AB%E4%BB%8B%E7%BB%8D/" target="_blank" rel="noopener noreferrer">【WEB系列】WebClient之retrieve与exchange的使用区别介绍</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2020/07/17/200717-SpringBoot%E7%B3%BB%E5%88%97WebClient%E4%B9%8B%E8%B6%85%E6%97%B6%E8%AE%BE%E7%BD%AE/" target="_blank" rel="noopener noreferrer">【WEB系列】WebClient之超时设置</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2020/07/16/200716-SpringBoot%E7%B3%BB%E5%88%97WebClient%E4%B9%8BBasic-Auth%E6%8E%88%E6%9D%83/" target="_blank" rel="noopener noreferrer">【WEB系列】WebClient之Basic Auth授权</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2020/07/14/200714-SpringBoot%E7%B3%BB%E5%88%97WebClient%E4%B9%8B%E8%AF%B7%E6%B1%82%E5%A4%B4%E8%AE%BE%E7%BD%AE/" target="_blank" rel="noopener noreferrer">【WEB系列】WebClient之请求头设置</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2020/07/13/200713-SpringBoot%E7%B3%BB%E5%88%97WebClient%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/" target="_blank" rel="noopener noreferrer">【WEB系列】WebClient之文件上传</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2020/07/09/200709-SpringBoot%E7%B3%BB%E5%88%97WebClient%E4%B9%8B%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF/" target="_blank" rel="noopener noreferrer">【WEB系列】WebClient之基础使用姿势</a></li>
</ul>
<p><strong>源码</strong></p>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/222-web-client" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/222-web-client</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/200820/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>WebClient</title>
      <link>https://liuyueyi.github.io/tutorial/spring/web/WebClient/</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/web/WebClient/</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">WebClient</source>
      <description>响应式编程大行其道的当下，WebClient大大简化了交互的复杂性，如有响应式需求场景，好好读一下这个系列绝不会有错</description>
      <pubDate>Fri, 10 Feb 2023 04:50:05 GMT</pubDate>
      <content:encoded><![CDATA[<p>响应式编程大行其道的当下，WebClient大大简化了交互的复杂性，如有响应式需求场景，好好读一下这个系列绝不会有错</p>
]]></content:encoded>
    </item>
    <item>
      <title>1.初体验</title>
      <link>https://liuyueyi.github.io/tutorial/spring/web/WebFlux/200421-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8BWebFlux%E4%B9%8B%E5%88%9D%E4%BD%93%E9%AA%8C.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/web/WebFlux/200421-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8BWebFlux%E4%B9%8B%E5%88%9D%E4%BD%93%E9%AA%8C.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">1.初体验</source>
      <description>Spring5就引入了Webflux，基于响应式编程的web框架，号称相比较于传统的SpringMVC性能更加（当然我也没测过，官方以及很多用过的小伙伴都持有这个观点），近年来响应式编程越来越主流了，作为一个紧跟时代潮流的小伙，有必要深入学习一下了 本篇作为Webflux系列教程的开篇，一个hello world的体验版</description>
      <category>SpringBoot</category>
      <category>WEB系列</category>
      <category>WebFlux</category>
      <pubDate>Tue, 21 Apr 2020 11:42:58 GMT</pubDate>
      <content:encoded><![CDATA[<p>Spring5就引入了Webflux，基于响应式编程的web框架，号称相比较于传统的SpringMVC性能更加（当然我也没测过，官方以及很多用过的小伙伴都持有这个观点），近年来响应式编程越来越主流了，作为一个紧跟时代潮流的小伙，有必要深入学习一下了</p>
<p>本篇作为Webflux系列教程的开篇，一个hello world的体验版</p>
<!-- more -->
<h2> I. 环境</h2>
<p>选择<code>SpringBoot 2.2.1.RELEASE</code>来搭建项目环境</p>
<p>pom依赖</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>webflux默认开启的端口号也是8080, 如果需要修改，和SpringMVC的配置一样，如修改配置文件<code>application.yml</code></p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2> II. WebFlux体验</h2>
<p>使用WebFlux来提供http服务，如果是熟悉SpringMVC这一套玩法的话，基本上只要一点点改动即可</p>
<h3> 1. SpringMVC写法</h3>
<p>借助<code>@Controller</code>, <code>@RequestMapping</code>注解来实现rest接口</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面提供了两个接口，请注意返回值</p>
<ul>
<li><code>Mono&lt;String&gt;</code>:  Mono 表示返回0到1个数据</li>
<li><code>Flux&lt;ServerSentEvent&lt;String&gt;&gt;</code>: Flux 表示返回0到n个数据</li>
</ul>
<p>其次对于第二个接口<code>everySayHello</code>，它实现了SSE的功能，每1s往客户端推送一个字符串</p>
<blockquote>
<p>关于sse，推荐查看<a href="http://spring.hhui.top/spring-blog/2020/03/29/200329-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B9%8B%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82%E6%9C%80%E5%85%A8%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%8E%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF/" target="_blank" rel="noopener noreferrer">【WEB系列】异步请求知识点与使用姿势小结</a> 了解基本知识点；查看 <a href="http://spring.hhui.top/spring-blog/2020/04/01/200401-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B9%8BSSE%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%91%E9%80%81%E4%BA%8B%E4%BB%B6%E8%AF%A6%E8%A7%A3/" target="_blank" rel="noopener noreferrer">【WEB系列】SSE服务器发送事件详解</a> 查看SpringMVC的用法，两相对比获取更好的体验</p>
</blockquote>
<p>接下来演示一下测试结果</p>
<figure><img src="/imgs/200421/00.gif" alt="演示" tabindex="0" loading="lazy"><figcaption>演示</figcaption></figure>
<h3> 2. 函数开发模式</h3>
<p>除了上面的写法之外，Webflux还可以通过配置Router来指定url与function之间的匹配关系，在这种写法中，我们常用的Controller被称为Handler；使用<code>RouterFunction</code>配置路由</p>
<p>重写一下上面的两个功能</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>请注意，上面的写法并没有表明什么url匹配这个方法，所以我们需要额外的配置</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>再次测试</p>
<figure><img src="/imgs/200421/01.gif" alt="演示" tabindex="0" loading="lazy"><figcaption>演示</figcaption></figure>
<h3> 3. 小结</h3>
<p>本文主要属于<code>webflux</code>的<code>hello world</code>篇，主要目的就是先对这个有一点熟悉和了解，函数式编程模式和我们一把的开发方式还是有一些区别的，这些会在后续的系列教程中逐步展开</p>
<p>下一篇将主要介绍WebFlux中的两个重要的类<code>Mono</code>,<code>Flux</code>是什么，怎么用(恳请持续关注😊😊😊)</p>
<h2> II. 其他</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：<a href="https://github.com/liuyueyi/spring-boot-demo/blob/master/spring-boot/200-webflux" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/blob/master/spring-boot/200-webflux</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/200421/00.gif" type="image/gif"/>
    </item>
    <item>
      <title>2.静态资源配置与访问</title>
      <link>https://liuyueyi.github.io/tutorial/spring/web/WebFlux/200612-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8BWebFlux%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E9%85%8D%E7%BD%AE%E4%B8%8E%E8%AE%BF%E9%97%AE.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/web/WebFlux/200612-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8BWebFlux%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E9%85%8D%E7%BD%AE%E4%B8%8E%E8%AE%BF%E9%97%AE.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">2.静态资源配置与访问</source>
      <description>上一篇博文介绍SpringMVC的静态资源访问，那么在WebFlux中，静态资源的访问姿势是否一致呢</description>
      <category>SpringBoot</category>
      <category>WEB系列</category>
      <category>WebFlux</category>
      <pubDate>Fri, 12 Jun 2020 15:51:14 GMT</pubDate>
      <content:encoded><![CDATA[<p>上一篇博文介绍SpringMVC的静态资源访问，那么在WebFlux中，静态资源的访问姿势是否一致呢</p>
<!-- more -->
<h2> I. 默认配置</h2>
<p>与SpringBoot的默认配置一样，WebFlux同样是<code>classpath:/META-INF/resources/,classpath:/resources/,classpath:/static/,classpath:/public/</code></p>
<p>即，将静态文件放在这四个目录下，可以直接访问</p>
<h3> 1. 项目演示</h3>
<p>创建一个SpringBoot项目，添加依赖(本文使用的版本为: <code>2.2.1-RELEASE</code>)</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在资源路径下添加目录 <code>static</code>，目录下添加两个html文件，如下图</p>
<figure><img src="/imgs/200612/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>实现启动类，不添加额外逻辑，既可以直接通过完整url方式访问静态资源</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/200612/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>主要观察上面三个请求，放在<code>index.html</code>是无法直接访问到的，因为它所在的目录并不在默认的四个静态资源路径中</p>
<h3> 2. Url映射</h3>
<p>上面是直接通过静态资源文件名的方式进行访问，那么WebFlux是否可以实现SpringMVC那种，根据视图名返回View的方式呢？</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>直接访问，结果发现500，找不到名为<code>a.html</code>的视图</p>
<figure><img src="/imgs/200612/02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>这种方式不行的话，改用WebFlux的路由写法</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/200612/03.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> II. 自定义配置路径</h2>
<p>如果我们希望指定一个自定义的路径，是否可以如SpringMvc那样，修改配置or代码设置映射完成呢?</p>
<p>在资源目录下，新加两个文件夹，分别是 o1, o2</p>
<figure><img src="/imgs/200612/04.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 1. 配置修改</h3>
<p>如SpringMVC，修改静态资源配置</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后访问 <code>/o1.html</code>，发现404，这种直接修改配置方式不行!!!</p>
<figure><img src="/imgs/200612/05.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 2. WebFluxConfigurer添加映射</h3>
<blockquote>
<p>参考自官方文档: <a href="https://docs.spring.io/spring-framework/docs/5.2.x/spring-framework-reference/web-reactive.html#webflux-config-static-resources" target="_blank" rel="noopener noreferrer">web-reactive.html#webflux-config-static-resources</a></p>
</blockquote>
<p>直接修改启动类，实现<code>WebFluxConfigurer</code>接口，手动添加资源映射</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接着访问 <code>/o2.html</code></p>
<figure><img src="/imgs/200612/06.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 3. @Value方式</h3>
<p>除了上述手动映射的方式之外，还有一种非主流的是方式，如</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>请注意上面的两个文件， <code>s.html</code>, <code>index.html</code>都不在默认的静态资源目录下</p>
<figure><img src="/imgs/200612/07.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> III. 小结</h2>
<p>文中给出了WebFlux的静态资源访问姿势，与SpringMVC有一些区别</p>
<ul>
<li>url映射时，直接返回视图名，会提示<code>Could not resolve view with name xxx</code></li>
<li>通过修改配置<code>spring.resources.static-locations</code> 指定新的静态资源目录无效</li>
</ul>
<p>在WebFlux中，推荐使用实现<code>WebFluxConfigure</code>接口的方式，重写<code>addResourceHandlers</code>方法来自定义资源路径映射</p>
<p>也可以针对单独的静态资源，借助<code>@Value</code>来手动路由</p>
<h2> II. 其他</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：<a href="https://github.com/liuyueyi/spring-boot-demo/blob/master/spring-boot/200-webflux" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/blob/master/spring-boot/200-webflux</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/200612/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>3.Path参数解析与url映射</title>
      <link>https://liuyueyi.github.io/tutorial/spring/web/WebFlux/200827-SpringBoot%E7%B3%BB%E5%88%97WebFlux%E4%B9%8BPath%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%E4%B8%8Eurl%E6%98%A0%E5%B0%84.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/web/WebFlux/200827-SpringBoot%E7%B3%BB%E5%88%97WebFlux%E4%B9%8BPath%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%E4%B8%8Eurl%E6%98%A0%E5%B0%84.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">3.Path参数解析与url映射</source>
      <description>异步、反应式、函数式编程，近来可以说是逐渐主流了；Spring5通过Reactor增加了对反应式编程的支持，而Spring WebFlux不同于以往的web框架，作为一个非阻塞异步web框架，可以充分的利用多核CPU硬件资源，提供更强的并发支持；Spring官方对WebFlux的支持非常友好，基本上对于惯于Spring WEB的java开发者，可以很简单的迁移过来 接下来我们将进入WebFlux系列教程，努力使用最简明的语言，来介绍一下WebFlux的基本玩法，让各位小伙伴可以顺畅的切换和使用WebFlux来体验反应式编程的魅力 本文将主要介绍WebFlux提供web接口时的url匹配，以及对应的path参数解析</description>
      <category>SpringBoot</category>
      <category>WEB系列</category>
      <category>WebFlux</category>
      <pubDate>Thu, 27 Aug 2020 08:26:56 GMT</pubDate>
      <content:encoded><![CDATA[<p>异步、反应式、函数式编程，近来可以说是逐渐主流了；Spring5通过Reactor增加了对反应式编程的支持，而Spring WebFlux不同于以往的web框架，作为一个非阻塞异步web框架，可以充分的利用多核CPU硬件资源，提供更强的并发支持；Spring官方对WebFlux的支持非常友好，基本上对于惯于Spring WEB的java开发者，可以很简单的迁移过来</p>
<p>接下来我们将进入WebFlux系列教程，努力使用最简明的语言，来介绍一下WebFlux的基本玩法，让各位小伙伴可以顺畅的切换和使用WebFlux来体验反应式编程的魅力</p>
<p>本文将主要介绍WebFlux提供web接口时的url匹配，以及对应的path参数解析</p>
<!-- more -->
<h2> I. 项目环境</h2>
<p>本项目借助<code>SpringBoot 2.2.1.RELEASE</code> + <code>maven 3.5.3</code> + <code>IDEA</code>进行开发</p>
<h3> 1. 依赖</h3>
<p>使用WebFlux，最主要的引入依赖如下（省略掉了SpringBoot的相关依赖，如对于如何创建SpringBoot项目不太清楚的小伙伴，可以关注一下我之前的博文）</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> II. Path匹配与参数解析</h2>
<blockquote>
<p>下面所有内容基于官方文档完成: <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web-reactive.html#webflux-ann-requestmapping-uri-templates" target="_blank" rel="noopener noreferrer">https://docs.spring.io/spring/docs/current/spring-framework-reference/web-reactive.html#webflux-ann-requestmapping-uri-templates</a></p>
</blockquote>
<p>下面的示例主要是基于注解的方式，基本知识点和SpringWeb没有太大的区别（至于函数式的用法，后面会专门介绍）</p>
<h3> 1. 基本path参数获取</h3>
<p>path参数，举例如: <code>http://127.0.0.1:8080/name/test</code>中<code>name</code>和<code>test</code>就算是path参数，我们主要是借助<code>@PathVariable</code>来获取</p>
<p>一个具体实例</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>针对上面的case，我们简单的设计了三个访问case，具体结果如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>请注意上面的输出，<code>/basic/{index}</code> 只能匹配单级的path路径参数，而且上面的写法中，这级path路径必须存在</p>
<p>查看<code>PathVariable</code>注解可以看到里面有一个<code>required</code>属性，如果设置为false，会怎样呢</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>测试case如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从上面的实际case，也可以看出来，级别这个属性设置为false，但是url路径依然需要正确匹配,多一级和少一级都不行</p>
<h3> 2. 多path参数</h3>
<p>上面只有一个path参数，如果有多个参数，也比较简单</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>测试case如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. 部分path参数匹配</h3>
<p>上面的两个case，都是完整的匹配某一级路径，下面介绍部分匹配的case</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>请注意上面的path路径，后缀是<code>.txt</code>，如下面的实例中<code>part/hello.txt</code>中那么对应的就是<code>hello</code></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4. 正则匹配</h3>
<p>接下来更高端的path参数匹配来了，支持一些简单的正则，如我们希望对<code>spring-web-3.0.5.jar</code>这段path路径进行解析，希望将<code>spring-web</code>作为<code>name</code>, <code>3.0.5</code>作为<code>version</code>，<code>.jar</code>作为<code>ext</code></p>
<p>因此我们的rest接口写法可以如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 5. 多级path参数匹配</h3>
<p>注意上面的所有写法，都有一个特点，那就是只能针对单级的path路径进行全/部分匹配（本文中将path路径中<code>//</code>之间作为一级），那么如果我希望我的path参数可以匹配多级，可以怎么办</p>
<ul>
<li>如 <code>/path/name/hello</code> 请求路径中，我希望将 <code>/name/hello</code> 作为一个path参数</li>
</ul>
<p>针对上面的场景，我们主要是借助<code>{*name}</code>方式来处理，注意这个参数名前面的*号</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>测试case如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 6. 路径匹配</h3>
<p>前面介绍的是path参数解析，接下来我们简单的看一下最常见的三种路径匹配方式</p>
<h4> a. *</h4>
<p>一个星号，表示匹配0个or1个单级path路径</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>实测case如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>请注意上面的实例，<code>/path/pattern3</code> 访问404, 而<code>/path/pattern3/</code>是可以的，唯一的区别就是多了一个后缀<code>/</code></p>
<ul>
<li>why?</li>
<li>是因为path路径的星号前面有一个<code>/</code>导致的么？</li>
</ul>
<p>接下来我们再设计一个case，将<code>*</code>前面的<code>/</code>干掉，再测试一下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>再次测试，结果如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>借助前面两个case，我们基本上可以看出<code>*</code>的作用</p>
<ul>
<li><code>*</code>前面的完全匹配
<ul>
<li>比如<code>/pattern3/*</code>，那么访问的path路径前缀必须是<code>/pattern3/</code></li>
</ul>
</li>
<li><code>*</code>最多表示单级路径，简单来讲就是<code>*</code>所代表的的位置中不能出现<code>/x</code>
<ul>
<li>比如<code>/pattern33**</code>，那么<code>/pattern331/</code>可以匹配，但是<code>/pattern331/1</code>不能</li>
</ul>
</li>
</ul>
<h4> b. **</h4>
<p>有别与上面的单个<code>*</code>匹配0-1级path路径，两个<code>**</code>则表示可以一直匹配到最后一层</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>测试case如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>请注意</strong></p>
<ul>
<li>直接访问<code>/pattern4</code>也是可以命中的，这个和上面是有区别的</li>
</ul>
<h4> c. ?</h4>
<p>单个字符的通配，比较简单如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>访问case</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从上面的测试输出也可以看出</p>
<ul>
<li><code>?</code> 对应的地方不能是<code>/</code>以及其他不被支持的字符（如<code>?</code>,<code>'</code>,<code>"</code>, <code>%</code>等)</li>
<li><code>?</code> 对应的地方必须存在</li>
</ul>
<h3> 7. 小结</h3>
<p>虽然本文的主题是webflux中path参数解析与url映射匹配，但是看下来我们会神奇的发现，这些知识点和SpringMVC中，貌似也没有什么区别，事实上也确实如此；对于注解的使用场景时，绝大多数，都是之前怎么玩，现在依然可以怎么玩</p>
<p>下面用一个表格针对上面的知识点进行汇总</p>
<table>
<thead>
<tr>
<th>pattern</th>
<th>描述</th>
<th>举例</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>?</code></td>
<td>匹配一个字符</td>
<td><code>pages/t?st.html</code> 匹配 <code>/pages/test.html</code> and <code>/pages/t3st.html</code></td>
</tr>
<tr>
<td><code>*</code></td>
<td>匹配单级path路径中0-多个字符</td>
<td><code>"/resources/*.png"</code> matches <code>"/resources/file.png"</code> <br> <code>"/projects/*/versions"</code> matches <code>"/projects/spring/versions"</code> but does not match <code>"/projects/spring/boot/versions"</code></td>
</tr>
<tr>
<td><code>**</code></td>
<td>匹配0-多个path路径</td>
<td><code>"/resources/**"</code> matches <code>"/resources/file.png"</code> and <code>"/resources/images/file.png"</code> <br>  而<code>"/resources/**/file.png" </code>这种写法是非法的</td>
</tr>
<tr>
<td><code>{name}</code></td>
<td>匹配单级path路径参数</td>
<td><code>"/projects/{project}/versions"</code> matches <code>"/projects/spring/versions"</code> and captures <code>project=spring</code></td>
</tr>
<tr>
<td><code>{name:[a-z]+}</code></td>
<td>正则</td>
<td><code>"/projects/{project:[a-z]+}/versions"</code> matches <code>"/projects/spring/versions"</code> but not <code>"/projects/spring1/versions"</code></td>
</tr>
<tr>
<td><code>{*path}</code></td>
<td>匹配path路径中，0-最后一级path路径参数</td>
<td><code>"/resources/{*file}"</code> matches <code>"/resources/images/file.png"</code> and captures <code>file=images/file.png</code></td>
</tr>
</tbody>
</table>
<h2> II. 其他</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码: <a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/223-webflux-params" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/223-webflux-params</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>4.header参数解析</title>
      <link>https://liuyueyi.github.io/tutorial/spring/web/WebFlux/200907-SpringBoot%E7%B3%BB%E5%88%97WebFlux%E4%B9%8Bheader%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/web/WebFlux/200907-SpringBoot%E7%B3%BB%E5%88%97WebFlux%E4%B9%8Bheader%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">4.header参数解析</source>
      <description>上一篇weblfux主要介绍了path参数的解析与映射关系，在我们进入url参数/post表单之前，先看一下另外的一种参数--请求头中的参数如何处理</description>
      <category>SpringBoot</category>
      <category>WEB系列</category>
      <category>WebFlux</category>
      <pubDate>Mon, 07 Sep 2020 08:53:04 GMT</pubDate>
      <content:encoded><![CDATA[<p>上一篇weblfux主要介绍了path参数的解析与映射关系，在我们进入url参数/post表单之前，先看一下另外的一种参数--请求头中的参数如何处理</p>
<!-- more -->
<h2> I. 项目环境</h2>
<p>本项目借助<code>SpringBoot 2.2.1.RELEASE</code> + <code>maven 3.5.3</code> + <code>IDEA</code>进行开发</p>
<h3> 1. 依赖</h3>
<p>使用WebFlux，最主要的引入依赖如下（省略掉了SpringBoot的相关依赖，如对于如何创建SpringBoot项目不太清楚的小伙伴，可以关注一下我之前的博文）</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> II. 请求头参数解析</h2>
<p>在实际的业务开发中，有几个请求头出现的频率特别高，如常用于反爬的<code>User-Agent</code>，鉴定强求来源的<code>referer</code>，跨域相关的<code>Access-Control-Allow-</code>，cookie、session自定义的请求头等</p>
<h3> 1. 请求头限制</h3>
<p>在<code>RequestMapping</code>或<code>GetMapping</code>中指定请求头参数时，表示只有请求中包含这个请求头才会匹配过去</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>实例如下:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 请求头参数解析</h3>
<p>WebFlux依然是可以通过注解<code>@RequestHeader</code>来获取对应的请求头</p>
<p>从使用姿势上来看，webflux与webmvc并没有什么区别</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>测试case如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. cookie获取</h3>
<p>利用cookie来标识用户身份可以说是非常普遍的场景了，我们通过专用的<code>CookieValue</code>来获取指定的cookies值</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的case中，标识只需要获取tid这个cookies值，其他的不care</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2> II. 其他</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码: <a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/223-webflux-params" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/223-webflux-params</a></li>
</ul>
<p><strong>系列博文</strong></p>
<ul>
<li><a href="http://spring.hhui.top/spring-blog/2020/08/27/200827-SpringBoot%E7%B3%BB%E5%88%97WebFlux%E4%B9%8BPath%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%E4%B8%8Eurl%E6%98%A0%E5%B0%84/" target="_blank" rel="noopener noreferrer">【WBE系列】WebFlux之Path参数解析与url映射</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>WebFlux</title>
      <link>https://liuyueyi.github.io/tutorial/spring/web/WebFlux/</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/web/WebFlux/</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">WebFlux</source>
      <description>WebFlux系列博文</description>
      <pubDate>Fri, 10 Feb 2023 04:50:05 GMT</pubDate>
      <content:encoded><![CDATA[<p>WebFlux系列博文</p>
]]></content:encoded>
    </item>
    <item>
      <title>1.springboot + websocket初体验</title>
      <link>https://liuyueyi.github.io/tutorial/spring/web/WebSocket/190421-SpringBoot%E9%AB%98%E7%BA%A7%E7%AF%87WEB%E4%B9%8Bwebsocket%E7%9A%84%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/web/WebSocket/190421-SpringBoot%E9%AB%98%E7%BA%A7%E7%AF%87WEB%E4%B9%8Bwebsocket%E7%9A%84%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">1.springboot + websocket初体验</source>
      <description>常见的web应用大多是提供基础的REST服务，简单来讲就是用户发起一个请求，然后给出反应，可以理解为由客户主动发起的单边操作；那么有没有一种技术是服务端主动发起，与客户端进行交互的？ 非常常见的几个需求场景，如聊天室的实现，股票的委托、成交实时刷新，信息推送机制，应用日志实时刷新等用我们传统的web交互方式，就不太容易做到了，本篇博文将介绍下HTML5中引入的WebSocket，可以如何实现客户端和服务端之间的双端通信</description>
      <category>SpringBoot</category>
      <category>WEB系列</category>
      <category>WebSocket</category>
      <pubDate>Sun, 21 Apr 2019 22:37:03 GMT</pubDate>
      <content:encoded><![CDATA[<p>常见的web应用大多是提供基础的REST服务，简单来讲就是用户发起一个请求，然后给出反应，可以理解为由客户主动发起的单边操作；那么有没有一种技术是服务端主动发起，与客户端进行交互的？</p>
<p>非常常见的几个需求场景，如聊天室的实现，股票的委托、成交实时刷新，信息推送机制，应用日志实时刷新等用我们传统的web交互方式，就不太容易做到了，本篇博文将介绍下HTML5中引入的WebSocket，可以如何实现客户端和服务端之间的双端通信</p>
<!-- more -->
<h2> I. 前期准备</h2>
<p>大环境依然是选择SpringBoot来快速构建应用</p>
<h3> 1. 配置如下</h3>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从依赖中看，最关键的就是 <code>spring-boot-starter-websocket</code> 的引入</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 辅助文档</h3>
<p>因为之前没怎么用过webscoket，所以也不知道怎么来实现一个webscoket的服务，所以就拿官方的教程进行熟悉</p>
<ul>
<li><a href="https://docs.spring.io/spring-framework/docs/5.2.0.M1/spring-framework-reference/web.html#websocket" target="_blank" rel="noopener noreferrer">Spring WebSockets 使用说明</a></li>
</ul>
<p>本文将搭建一个WebSocket的服务，那么就需要有一个对应的客户端了，目前正好在学习python，所以决定采用python来作为消费方，下文是python作为消费的教程</p>
<ul>
<li><a href="https://blog.hhui.top/hexblog/2019/04/16/190416-Python%E4%B9%8BWebscoket%E6%A8%A1%E6%8B%9F%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/" target="_blank" rel="noopener noreferrer">Python之Webscoket模拟客户端简单使用</a></li>
</ul>
<h2> II. WebSocket HelloWorld版构建</h2>
<p>接下来进入正题，开始搭建一个简单的websocket服务端</p>
<h3> 1. configuration 配置</h3>
<p>首先是添加配置文件，和我们普通的一个类上添加<code>@Configuration</code>注解不一样的是，这个配置文件要求实现接口<code>WebSocketConfigurer</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意上面的配置文件，两点</p>
<ul>
<li>添加注解 <code>@EnableWebSocket</code> 表示开启了webocket服务</li>
<li><code>registerWebSocketHandlers</code> 这个方法用来注册websocket服务，上面表示将路径 wsdemo 的请求转发到 <code>WebSocketHandler</code></li>
</ul>
<h3> 2. WebSocketHandler 处理类</h3>
<p>上面提到了WebSocketHandler，基本上也就可以确认，这个对象将是核心处理类，主要的业务逻辑就在里面，下面是我们自定义实现的一个简单的<code>TextWebSocketHandler</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个实现就简单了，重写了方法<code>handleTextMessage</code>，当接受到用户发送的数据时，凭借一个 <code>response: </code> 的头之后返回；返回数据则是借助<code>WebSocketSession</code>即与客户端之间的会话，来发送数据的</p>
<p>到这里一个基本的websocket服务端搭建完成，然后我们开始实验一下</p>
<h3> 3. 测试</h3>
<p>先完成启动类，启动应用程序</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对应的python消费核心代码如下</p>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>过程演示示意图</p>
<figure><img src="/imgs/190421/00.gif" alt="测试示意图" tabindex="0" loading="lazy"><figcaption>测试示意图</figcaption></figure>
<p>从图中的演示过程，基本上一个消费者发送数据之后，就可以获取到对应的返回数据；且消费者A不能获取消费者B返回的数据；上面的演示中，当客户端不发送数据，直接调用获取数据时，因为服务端一直没有返回数据，所以一直在等待，这样一来这个服务看起来和我们传统的rest服务没啥太大区别，都要发送请求/返回结果，并没有体现到websocket的主动推送的功能</p>
<h2> III. WebSocket 实现简单的聊天</h2>
<p>上面的例子，只是演示了最最基本的WebSocket的使用方式，然而并不能给我们带来WebScoket的优越性的既视感，下面准备基于WebSocket搭建一个简单的聊天室，当有新的连接进来时，推送所有人欢迎xxx；当有人发送消息时，同步给其他所有在线的小伙伴；当有小伙伴离开时，告诉所有小伙伴xx离开了</p>
<h3> 1. <code>RealTalkWebSocketHandler</code></h3>
<p>通过前面知道WebSocketHandler是处理websocket核心业务逻辑的类，因此我们新的实现中，需要记录每个连接的回话，创建连接时，发送给所有在线的同学一条欢迎消息；离线也一样；</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意上面的实现</p>
<ul>
<li><code>afterConnectionEstablished</code> 这个方法时在了解创立之后调用的，正好用来发送欢迎词语</li>
<li><code>afterConnectionClosed</code> 这个是断开连接时调用，用来发送离开词</li>
<li><code>handleTextMessage</code> 这个则是接收用户发送消息的方法，和前面不一样，我们接收到消息之后，把这个消息广播给所有在线的小伙伴</li>
</ul>
<h3> 2. 注册handler</h3>
<p>在前面的配置类中，注册下我们新加的Handler</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. 测试</h3>
<p>接下来进行测试环节，看下是否满足我们的需求</p>
<figure><img src="/imgs/190421/01.gif" alt="测试示意图" tabindex="0" loading="lazy"><figcaption>测试示意图</figcaption></figure>
<p>上图中，开了三个客户端，当有新的小伙伴进入时，所有人都可以收到欢迎的话语，当其中一个人说话之后，所有人也可以获取到说的内容；基本上可以实现我们前面提到的场景</p>
<h3> 4. 小结</h3>
<p>使用websocket搭建服务端，一般步骤比较简单，两步</p>
<ul>
<li>配置文件
<ul>
<li>实现接口 <code>WebSocketConfigurer</code></li>
<li>添加注解 <code>@EnableWebSocket</code></li>
<li>注册<code>WebSocketHandler</code></li>
</ul>
</li>
<li>实现自定义<code>WebSocketHandler</code>
<ul>
<li>继承 <code>AbstractWebSocketHandler</code>， 实现具体的连接/断连/接收消息的处理逻辑</li>
</ul>
</li>
</ul>
<p><strong>双端通讯</strong></p>
<p>服务端和客户端的通讯，主要借助的是<code>WebSocketSession</code>来实现，因此在我们自己实现的简易版聊天室中，需要自己来保存所有客户端的会话</p>
<p>那么问题来了，有没有更简单的方式来实现聊天室的这种场景呢，session的管理应该属于普适性的需求了，如果都需要开发者自己来处理的话，上手成本也大了点吧</p>
<p>官方教程中websocket这一节提到了STOMP，后续博文将介绍如何使用STOMP，结合websocket实现更复杂的双端通信场景</p>
<h2> II. 其他</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>项目: <a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/203-websocket" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/203-websocket</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/190421/00.gif" type="image/gif"/>
    </item>
    <item>
      <title>WebSocket</title>
      <link>https://liuyueyi.github.io/tutorial/spring/web/WebSocket/</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/web/WebSocket/</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">WebSocket</source>
      <description>长连接websocket从0到1实战</description>
      <pubDate>Fri, 10 Feb 2023 04:50:05 GMT</pubDate>
      <content:encoded><![CDATA[<p>长连接websocket从0到1实战</p>
]]></content:encoded>
    </item>
    <item>
      <title>1.Filter基本使用姿势</title>
      <link>https://liuyueyi.github.io/tutorial/spring/web/Web%E4%B8%89%E5%89%91%E5%AE%A2/190323-Spring-MVC%E4%B9%8BFilter%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/web/Web%E4%B8%89%E5%89%91%E5%AE%A2/190323-Spring-MVC%E4%B9%8BFilter%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">1.Filter基本使用姿势</source>
      <description>Java Web三大基本组件，我们知道SpringMVC主要就是构建在Servlet的基础上的，接下来我们看一下Filter的使用姿势</description>
      <category>SpringBoot</category>
      <category>WEB系列</category>
      <category>web三剑客</category>
      <pubDate>Sat, 23 Mar 2019 15:20:19 GMT</pubDate>
      <content:encoded><![CDATA[<p>Java Web三大基本组件，我们知道SpringMVC主要就是构建在Servlet的基础上的，接下来我们看一下Filter的使用姿势</p>
<!-- more -->
<h2> I. Filter说明</h2>
<p>在介绍filter的使用之前，有必要知道下什么是fitler。</p>
<figure><img src="/imgs/190323/00.jpg" alt="filter结构" tabindex="0" loading="lazy"><figcaption>filter结构</figcaption></figure>
<p>Filter称为过滤器，主要用来拦截http请求，做一些其他的事情</p>
<h3> 1. 流程说明</h3>
<p>一个http请求过来之后</p>
<ul>
<li>首先进入filter，执行相关业务逻辑</li>
<li>若判定通行，则进入Servlet逻辑，Servlet执行完毕之后，又返回Filter，最后在返回给请求方</li>
<li>判定失败，直接返回，不需要将请求发给Servlet</li>
</ul>
<h3> 2. 场景</h3>
<p>通过上面的流程，可以推算使用场景：</p>
<ul>
<li>在filter层，来获取用户的身份</li>
<li>可以考虑在filter层做一些常规的校验（如参数校验，referer校验等）</li>
<li>可以在filter层做稳定性相关的工作（如全链路打点，可以在filter层分配一个traceId；也可以在这一层做限流等）</li>
</ul>
<h2> II. 使用姿势</h2>
<h3> 1. 基本配置</h3>
<p>在前面Java Config搭建了一个简单的web应用，我们的filter测试也放在这个demo工程上继续</p>
<p>pom配置如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. filter声明</h3>
<p>创建一个filter，得首先告诉spring说，我这有个filter，你得把它用起来；使用java config的方式创建应用，干掉xml文件，我们知道Servlet容器会扫描<code>AbstractDispatcherServletInitializer</code>的实现类</p>
<p>所以我们的filter声明也放在这里</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>看上面最后一个方法，返回当前支持的fitler数组，其中 <code>MyCorsFilter</code> 就是我们自定义的fitler</p>
<h3> 3. Filter实现</h3>
<p>自定义一个filter，需要实现Filter接口，其中有三个方法，主要的是第二个</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的<code>doFilter</code>方法就是我们重点观察目标，三个参数，注意第三个</p>
<ul>
<li>执行 <code>filterChain.doFilter(servletRequest, servletResponse)</code> 表示会继续将请求执行下去；若不执行这一句，表示这一次的http请求到此为止了，后面的走不下去了</li>
</ul>
<h3> 4. 测试</h3>
<p>创建一个rest接口，用来测试下我们的filter是否生效</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>启动web之后，观察下访问 <code>hello</code> 与 <code>welcome</code> 的返回头</p>
<figure><img src="/imgs/190323/01.jpg" alt="test case" tabindex="0" loading="lazy"><figcaption>test case</figcaption></figure>
<h3> 5. 其他</h3>
<p>相关博文</p>
<ul>
<li><a href="https://blog.hhui.top/hexblog/2018/01/26/JavaWeb%E4%B8%89%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8BFilter%E5%AD%A6%E4%B9%A0%E8%AF%A6%E8%A7%A3/" target="_blank" rel="noopener noreferrer">JavaWeb三大组件之Filter学习详解</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2019/03/16/190316-Spring-MVC%E4%B9%8B%E5%9F%BA%E4%BA%8Exml%E9%85%8D%E7%BD%AE%E7%9A%84web%E5%BA%94%E7%94%A8%E6%9E%84%E5%BB%BA/" target="_blank" rel="noopener noreferrer">190316-Spring MVC之基于xml配置的web应用构建</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2019/03/17/190317-Spring-MVC%E4%B9%8B%E5%9F%BA%E4%BA%8Ejava-config%E6%97%A0xml%E9%85%8D%E7%BD%AE%E7%9A%84web%E5%BA%94%E7%94%A8%E6%9E%84%E5%BB%BA/" target="_blank" rel="noopener noreferrer">190317-Spring MVC之基于java config无xml配置的web应用构建</a></li>
</ul>
<h2> II. 其他</h2>
<h3> - 系列博文</h3>
<p>web系列:</p>
<ul>
<li><a href="http://spring.hhui.top/spring-blog/categories/SpringBoot/%E9%AB%98%E7%BA%A7%E7%AF%87/Web/" target="_blank" rel="noopener noreferrer">Spring Web系列博文汇总</a></li>
</ul>
<p>mvc应用搭建篇:</p>
<ul>
<li><a href="http://spring.hhui.top/spring-blog/2019/03/16/190316-Spring-MVC%E4%B9%8B%E5%9F%BA%E4%BA%8Exml%E9%85%8D%E7%BD%AE%E7%9A%84web%E5%BA%94%E7%94%A8%E6%9E%84%E5%BB%BA/" target="_blank" rel="noopener noreferrer">190316-Spring MVC之基于xml配置的web应用构建</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2019/03/17/190317-Spring-MVC%E4%B9%8B%E5%9F%BA%E4%BA%8Ejava-config%E6%97%A0xml%E9%85%8D%E7%BD%AE%E7%9A%84web%E5%BA%94%E7%94%A8%E6%9E%84%E5%BB%BA/" target="_blank" rel="noopener noreferrer">190317-Spring MVC之基于java config无xml配置的web应用构建</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2019/03/19/190319-SpringBoot%E9%AB%98%E7%BA%A7%E7%AF%87WEB%E4%B9%8Bdemo%E5%BA%94%E7%94%A8%E6%9E%84%E5%BB%BA/" target="_blank" rel="noopener noreferrer">190319-SpringBoot高级篇WEB之demo应用构建</a></li>
</ul>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">spring-boot-demo</a></li>
<li>项目: <a href="https://github.com/liuyueyi/spring-boot-demo/blob/master/spring/200-mvc-annotation" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/blob/master/spring/200-mvc-annotation</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/190323/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>2.过滤器Filter使用指南</title>
      <link>https://liuyueyi.github.io/tutorial/spring/web/Web%E4%B8%89%E5%89%91%E5%AE%A2/191016-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8Bweb%E7%AF%87%E4%B9%8B%E8%BF%87%E6%BB%A4%E5%99%A8Filter%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/web/Web%E4%B8%89%E5%89%91%E5%AE%A2/191016-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8Bweb%E7%AF%87%E4%B9%8B%E8%BF%87%E6%BB%A4%E5%99%A8Filter%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">2.过滤器Filter使用指南</source>
      <description>web三大组件之一Filter，可以说是很多小伙伴学习java web时最早接触的知识点了，然而学得早不代表就用得多。基本上，如果不是让你从0到1写一个web应用（或者说即便从0到1写一个web应用），在你的日常业务开发中不太可能碰到需要手写Filter的场景 本文将简单介绍写什么是Filter，以及在SpringBoot中使用Filter的一般姿势与常见问题</description>
      <category>SpringBoot</category>
      <category>WEB系列</category>
      <category>web三剑客</category>
      <pubDate>Wed, 16 Oct 2019 10:56:35 GMT</pubDate>
      <content:encoded><![CDATA[<p>web三大组件之一Filter，可以说是很多小伙伴学习java web时最早接触的知识点了，然而学得早不代表就用得多。基本上，如果不是让你从0到1写一个web应用（或者说即便从0到1写一个web应用），在你的日常业务开发中不太可能碰到需要手写Filter的场景</p>
<p>本文将简单介绍写什么是Filter，以及在SpringBoot中使用Filter的一般姿势与常见问题</p>
<!-- more -->
<h2> I. 背景</h2>
<p>在正式开始之前，有必要先简单看一下什么是Filter（过滤器），以及这个有什么用</p>
<h3> 1. Filter说明</h3>
<p>Filter，过滤器，属于Servlet规范，并不是Spring独有的。其作用从命名上也可以看出一二，拦截一个请求，做一些业务逻辑操作，然后可以决定请求是否可以继续往下分发，落到其他的Filter或者对应的Servlet</p>
<p>简单描述下一个http请求过来之后，一个Filter的工作流程：</p>
<ul>
<li>首先进入filter，执行相关业务逻辑</li>
<li>若判定通行，则进入Servlet逻辑，Servlet执行完毕之后，又返回Filter，最后在返回给请求方</li>
<li>判定失败，直接返回，不需要将请求发给Servlet</li>
</ul>
<blockquote>
<p>插播一句：上面这个过程，和AOP中的<code>@Around</code>环绕切面的作用差不多</p>
</blockquote>
<h3> 2. 项目搭建</h3>
<p>接下来我们搭建一个web应用方便后续的演示，借助SpringBoot搭建一个web应用属于比较简单的活;</p>
<p>创建一个maven项目，pom文件如下</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> II. Filter教程</h2>
<h3> 1. 使用说明</h3>
<p>在SpringBoot项目中，如果需要自定义一个Filter，并没有什么特殊的地方，直接实现接口即可，比如下面一个输出请求日志的拦截器</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>实现一个自定义的Filter容易，一般有两个步骤</p>
<ul>
<li>实现 Filter 接口</li>
<li>在<code>doFilter</code>方法中添加业务逻辑，如果允许访问继续，则执行<code>chain.doFilter(req, response);</code>； 不执行上面这一句，则访问到此为止</li>
</ul>
<p>接下来的一个问题就是如何让我们自定义的Filter生效，在SpringBoot项目中，有两种常见的使用方式</p>
<ul>
<li>@WebFilter</li>
<li>包装Bean: <code>FilterRegistrationBean</code></li>
</ul>
<h4> a. WebFilter</h4>
<p>这个注解属于Servlet3+，与Spring也没有什么关系，所以问题来了，当我在Filter上添加了这个注解之后，Spring怎么让它生效呢?</p>
<ul>
<li>配置文件中显示使用注解 <code>@ServletComponentScan</code></li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>WebFilter常用属性如下，其中<code>urlPatterns</code>最为常用，表示这个filter适用于哪些url请求（默认场景下全部请求都被拦截）</p>
<table>
<thead>
<tr>
<th>属性名</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>filterName</td>
<td>String</td>
<td>指定过滤器的 name 属性，等价于 <code>&lt;filter-name&gt;</code></td>
</tr>
<tr>
<td>value</td>
<td>String[]</td>
<td>该属性等价于 urlPatterns 属性。但是两者不应该同时使用。</td>
</tr>
<tr>
<td>urlPatterns</td>
<td>String[]</td>
<td>指定一组过滤器的 URL 匹配模式。等价于 <code>&lt;url-pattern&gt;</code> 标签。</td>
</tr>
<tr>
<td>servletNames</td>
<td>String[]</td>
<td>指定过滤器将应用于哪些 Servlet。取值是 @WebServlet 中的 name 属性的取值，或者是 web.xml 中<code>&lt;servlet-name&gt;</code> 的取值。</td>
</tr>
<tr>
<td>dispatcherTypes</td>
<td>DispatcherType</td>
<td>指定过滤器的转发模式。具体取值包括：ASYNC、ERROR、FORWARD、INCLUDE、REQUEST。</td>
</tr>
<tr>
<td>initParams</td>
<td>WebInitParam[]</td>
<td>指定一组过滤器初始化参数，等价于 <code>&lt;init-param&gt;</code> 标签。</td>
</tr>
<tr>
<td>asyncSupported</td>
<td>boolean</td>
<td>声明过滤器是否支持异步操作模式，等价于 <code>&lt;async-supported&gt;</code> 标签。</td>
</tr>
<tr>
<td>description</td>
<td>String</td>
<td>该过滤器的描述信息，等价于 <code>&lt;description&gt;</code> 标签。</td>
</tr>
<tr>
<td>displayName</td>
<td>String</td>
<td>该过滤器的显示名，通常配合工具使用，等价于 <code>&lt;display-name&gt;</code> 标签。</td>
</tr>
</tbody>
</table>
<h4> b. FilterRegistrationBean</h4>
<p>上面一种方式比较简单，后面会说到有个小问题，指定Filter的优先级比较麻烦，</p>
<p>下面是使用包装bean注册方式</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 常见问题</h3>
<p>上面整完，就可以开始测试使用过滤器了，在进入实测环节之前，先来看两个常见的问题</p>
<ul>
<li>Filter作为Servelt的组件，怎么与SpringBoot中的Bean交互</li>
<li>多个Filter之间的优先级怎么确定</li>
</ul>
<h4> a. Filter依赖Bean注入问题</h4>
<p>如果有小伙伴使用SpringMVC + web.xml方式来定义Filter，就会发现自定义的Filter中无法通过<code>@Autowired</code>方式来注入Spring的bean</p>
<blockquote>
<p>我之前使用的是spring4 Servlet2+ ，存在上面的问题，如果有不同观点请留言告诉我，感谢</p>
</blockquote>
<p>SpringBoot中可以直接注入依赖的Bean，从上面的第二种注册方式可以看到，Spring将Filter封装成了一个Bean对象，因此可以直接注入依赖的Bean</p>
<p>下面定义一个<code>AuthFilter</code>，依赖了自定义的<code>DemoBean</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> b. 优先级指定</h4>
<p>Filter的优先级指定，通过我的实际测试，<code>@Order</code>注解没有用，继承 <code>Ordered</code>接口也没有用，再不考虑web.xml的场景下，只能通过在注册Bean的时候指定优先级</p>
<p>实例如下，三个Filter，两个通过<code>@WebFilter</code>注解方式注册，一个通过<code>FilterRegistrationBean</code>方式注册</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. 测试</h3>
<p>上面定义了三个Filter，我们主要验证下优先级，如果<code>@Order</code>注解生效，那么执行的先后顺序应该是</p>
<p><code>OrderFilter -&gt; ReqFilter -&gt; AuthFilter</code></p>
<p>如果不是上面的顺序，那么说明<code>@Order</code>注解没有用</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/191016/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>（上文截图源码来自: <code>org.apache.catalina.core.ApplicationFilterFactory#createFilterChain</code>）</p>
<p>上面是测试时关键链路的断点截图，从数组中可以看出 <code>AuthFilter</code>的优先级大于<code>ReqFilter</code>， 下面实际的输出也说明了<code>@Order</code>注解不能指定Filter的优先级（不知道为什么网络上有大量使用Order来指定Filer优先级的文章!!!）</p>
<figure><img src="/imgs/191016/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>接下来我们的问题就是<code>WebFilter</code>注解来注册的Filter的优先级是怎样的呢，我们依然通过debug来看，关键代码路径为: <code>org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext#selfInitialize</code></p>
<figure><img src="/imgs/191016/02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<ul>
<li>OrderFiler是我们手动注册并设置优先级为-1</li>
<li>ReqFilter, AuthFilter通过 WebFillter方式注册，默认优先级为<code>2147483647</code>，相同优先级的情况下，根据名字先后顺序来决定</li>
</ul>
<h2> III. 小结</h2>
<p>本文主要介绍了过滤器Filter的使用方式，以及常见的两个问题解答，文中内容穿插了一点源码的分析截图，并未深入，如有兴趣的同学可以根据文中提的几个关键位置探索一番</p>
<p>下面简单小结下文中内容</p>
<h3> 1. Filter使用</h3>
<p><strong>自定义Filter的实现</strong></p>
<ul>
<li>实现Filter接口</li>
<li>doFilter方法中，显示调用<code>chain.doFilter(request, response);</code>表示请求继续；否则表示请求被过滤</li>
</ul>
<p><strong>注册生效</strong></p>
<ul>
<li><code>@ServletComponentScan</code>自动扫描带有<code>@WebFilter</code>注解的Filter</li>
<li>创建Bean: <code>FilterRegistrationBean</code> 来包装自定义的Filter</li>
</ul>
<h3> 2. IoC/DI</h3>
<p>在SpringBoot中Filter可以和一般的Bean一样使用，直接通过<code>Autowired</code>注入其依赖的Spring Bean对象</p>
<h3> 3. 优先级</h3>
<p>通过创建<code>FilterRegistrationBean</code>的时候指定优先级，如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>此外格外注意, <code>@WebFilter</code>声明的Filter，优先级为<code>2147483647</code>(最低优先级)</p>
<ul>
<li><strong>@Order注解不能指定Filter优先级</strong></li>
<li><strong>@Order注解不能指定Filter优先级</strong></li>
<li><strong>@Order注解不能指定Filter优先级</strong></li>
</ul>
<h2> IV. 其他</h2>
<h4> web系列博文</h4>
<ul>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484348&amp;idx=1&amp;sn=e9b36572c721418b097396b50319d140&amp;chksm=fce71810cb9091063e810327e44f7ed07256188aecd352fa43f37e63e63dc64292b1a48b00cf&amp;token=823367253&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">191012-SpringBoot系列教程web篇之自定义异常处理HandlerExceptionResolver</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484344&amp;idx=1&amp;sn=d4b1422a709d9540583e33443aab6fff&amp;chksm=fce71814cb9091025a960312c878ff9fc4f44fd0035aa597f55f37c90dcbac25a3e96ee2c528&amp;token=118864495&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">191010-SpringBoot系列教程web篇之全局异常处理</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484336&amp;idx=1&amp;sn=d70f15e77bbd219af8015f9037a167fb&amp;chksm=fce7181ccb90910aee427a3f3ed7660e8303c7460859c82622a651ce1cc3d7a97f62f80ed4e0&amp;token=2447275&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">190930-SpringBoot系列教程web篇之404、500异常页面配置</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484322&amp;idx=1&amp;sn=b18090f35b59097f78858b6609506b74&amp;chksm=fce7180ecb909118d939f3ddf741a11c0977b1213d7afa12c970590590d40441c3a085c43c52&amp;token=2447275&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">190929-SpringBoot系列教程web篇之重定向</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484310&amp;idx=1&amp;sn=f6259cf1b79db095ff2e9534993d27cf&amp;chksm=fce7183acb90912cd150f086e90ecab3eceb3464e9352853e2e722288d412dbb3eb20c6e6ae7&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190913-SpringBoot系列教程web篇之返回文本、网页、图片的操作姿势</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484309&amp;idx=1&amp;sn=33d782f7529268eef6607a1ab8d41018&amp;chksm=fce71839cb90912f6020aa9463bc0136cb57969ebe27eba865d97e212c28211435791aa874ea&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190905-SpringBoot系列教程web篇之中文乱码问题解决</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484291&amp;idx=1&amp;sn=3f7e8c92ca4d7270cc5c40cafea39683&amp;chksm=fce7182fcb90913922654a4f2f04e7029b8944d71c31741334a3235aecbe1e60babcb0c0be74&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190831-SpringBoot系列教程web篇之如何自定义参数解析器</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484287&amp;idx=1&amp;sn=44461f564d6b04cbf1a5902dcb4f23c6&amp;chksm=fce718d3cb9091c5d730e63ae954c0831d53f3dd5af5d19d9c78b6009102838efaf56f7838ff&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190828-SpringBoot系列教程web篇之Post请求参数解析姿势汇总</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484282&amp;idx=1&amp;sn=a8d236d935ae24cfbe6977e24a479caa&amp;chksm=fce718d6cb9091c0dd8a6b113236f9ae9388fb026c9403c97bdf7505f773bd7330a43e3b269c&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190824-SpringBoot系列教程web篇之Get请求参数解析姿势汇总</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484268&amp;idx=3&amp;sn=9e8a6121dce291c65bd2b3d4fab24178&amp;chksm=fce718c0cb9091d6674fb809d68ca3dc3b1695162368481abf8dc094000412116d2f9971c54b&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190822-SpringBoot系列教程web篇之Beetl环境搭建</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484268&amp;idx=2&amp;sn=f800c001061eabe74e2cad915af1921a&amp;chksm=fce718c0cb9091d682b600673a0584955783f0d339248e34323efbea9b698560c432018717ef&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190820-SpringBoot系列教程web篇之Thymeleaf环境搭建</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484268&amp;idx=1&amp;sn=acd691729488d81a94c938151d5737ce&amp;chksm=fce718c0cb9091d63ef5f12893bb835c256a18318e791a0d193d00ef767ecfd019491d02e83d&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190816-SpringBoot系列教程web篇之Freemaker环境搭建</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484217&amp;idx=1&amp;sn=9fdf45d2261cdcf2ccaccaebfb5ef598&amp;chksm=fce71895cb90918361f1afd55a2b5fc9d65508913c1d793710afa79cae38bd9d57e32ad2c187&amp;token=2447275&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">190421-SpringBoot高级篇WEB之websocket的使用说明</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484197&amp;idx=1&amp;sn=0184953527f58058ee8c2bbcfc2689ec&amp;chksm=fce71889cb90919f9be003bf2487343f7952d6b33ab5ee5fb7251ae37a631d4c32e6d8a57528&amp;token=2447275&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">190327-Spring-RestTemplate之urlencode参数解析异常全程分析</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484193&amp;idx=1&amp;sn=d8a284fe0a2b8e1fefe07d892558f563&amp;chksm=fce7188dcb90919b1f8a2408bf955e37e88b043e2dbd59b5290ac1501e3d2d303512bac6af2c&amp;token=2447275&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">190317-Spring MVC之基于java config无xml配置的web应用构建</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484186&amp;idx=1&amp;sn=18db571b670815965ae9185830c4e88f&amp;chksm=fce718b6cb9091a054e0ac4be051341d8ce38ff8e40c5911302e3d6981206c14b80770590044&amp;token=2447275&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">190316-Spring MVC之基于xml配置的web应用构建</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484139&amp;idx=1&amp;sn=b4a5f3ca6215641c6bcf5123f2bfb501&amp;chksm=fce71947cb9090511042ae97a12cc975d2b199521e17980e685cccb5e0be91a8e932cef4eb76&amp;token=2447275&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">190213-SpringBoot文件上传异常之提示The temporary upload location xxx is not valid</a></li>
</ul>
<h4> 项目源码</h4>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>项目：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/210-web-filter" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/210-web-filter</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/191016/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>3.过滤器Filter使用指南扩展篇</title>
      <link>https://liuyueyi.github.io/tutorial/spring/web/Web%E4%B8%89%E5%89%91%E5%AE%A2/191018-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8Bweb%E7%AF%87%E4%B9%8B%E8%BF%87%E6%BB%A4%E5%99%A8Filter%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97%E6%89%A9%E5%B1%95%E7%AF%87.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/web/Web%E4%B8%89%E5%89%91%E5%AE%A2/191018-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8Bweb%E7%AF%87%E4%B9%8B%E8%BF%87%E6%BB%A4%E5%99%A8Filter%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97%E6%89%A9%E5%B1%95%E7%AF%87.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">3.过滤器Filter使用指南扩展篇</source>
      <description>前面一篇博文介绍了在SpringBoot中使用Filter的两种使用方式，这里介绍另外一种直接将Filter当做Spring的Bean来使用的方式，并且在这种使用方式下，Filter的优先级可以直接通过@Order注解来指定；最后将从源码的角度分析一下两种不同的使用方式下，为什么@Order注解一个生效，一个不生效 本篇博文强烈推荐与上一篇关联阅读，可以get到更多的知识点: 191016-SpringBoot系列教程web篇之过滤器Filter使用指南</description>
      <category>SpringBoot</category>
      <category>WEB系列</category>
      <category>web三剑客</category>
      <pubDate>Fri, 18 Oct 2019 19:47:57 GMT</pubDate>
      <content:encoded><![CDATA[<p>前面一篇博文介绍了在SpringBoot中使用Filter的两种使用方式，这里介绍另外一种直接将Filter当做Spring的Bean来使用的方式，并且在这种使用方式下，Filter的优先级可以直接通过<code>@Order</code>注解来指定；最后将从源码的角度分析一下两种不同的使用方式下，为什么<code>@Order</code>注解一个生效，一个不生效</p>
<blockquote>
<p>本篇博文强烈推荐与上一篇关联阅读，可以get到更多的知识点: <a href="https://mp.weixin.qq.com/s/f01KWO3d2zhoN0Qa9-Qb6w" target="_blank" rel="noopener noreferrer">191016-SpringBoot系列教程web篇之过滤器Filter使用指南</a></p>
</blockquote>
<!-- more -->
<h2> I. Filter</h2>
<p>本篇博文的工程执行的环境依然是<code>SpringBoot2+</code>, 项目源码可以在文章最后面get</p>
<h3> 1. 使用姿势</h3>
<p>前面一篇博文，介绍了两种使用姿势，下面简单介绍一下</p>
<p><strong>WebFilter注解</strong></p>
<p>在Filter类上添加注解<code>@WebFilter</code>；然后再项目中，显示声明<code>@ServletComponentScan</code>，开启Servlet的组件扫描</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>FilterRegistrationBean</strong></p>
<p>另外一种方式则是直接创建一个Filter的注册Bean，内部持有Filter的实例；在SpringBoot中，初始化的是Filter的包装Bean就是这个</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>本篇将介绍另外一种方式，直接将Filter当做普通的Bean对象来使用，也就是说，我们直接在Filter类上添加注解<code>@Component</code>即可，然后Spring会将实现Filter接口的Bean当做过滤器来注册</p>
<p>而且这种使用姿势下，Filter的优先级可以通过<code>@Order</code>注解来指定;</p>
<p>设计一个case，定义两个Filter(<code>ReqFilter</code>和<code>OrderFilter</code>), 当不指定优先级时，根据名字来，OrderFilter优先级会更高；我们主动设置下，希望<code>ReqFilter</code>优先级更高</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 优先级测试</h3>
<p>上面两个Filter直接当做了Bean来写入，我们写一个简单的rest服务来测试一下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>请求之后输出结果如下， ReqFilter优先执行了</p>
<figure><img src="/imgs/191018/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> II. 源码分析</h2>
<p>当我们直接将Filter当做Spring Bean来使用时，<code>@Order</code>注解来指定Filter的优先级没有问题；但是前面一篇博文中演示的<code>@WebFilter</code>注解的方式，则并不会生效</p>
<ul>
<li>这两种方式的区别是什么？</li>
<li><code>@Order</code>注解到底有什么用，该怎么用</li>
</ul>
<h3> 1. Bean方式</h3>
<p>首先我们分析一下将Filter当做Spring bean的使用方式，我们的目标放在Filter的注册逻辑上</p>
<p>第一步将目标放在: <code>org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext#selfInitialize</code></p>
<p>下面的逻辑中包括了ServeltContext的初始化，而我们的Filter则可以看成是属于Servlet的Bean</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意上面代码中的for循环，在执行<code>getServletContextInitializerBeans()</code>的时候，Filter就已经注册完毕，所以我们需要再深入进去</p>
<p>将目标集中在<code>org.springframework.boot.web.servlet.ServletContextInitializerBeans#ServletContextInitializerBeans</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面有两行代码比较突出，下面单独捞出来了，需要我们重点关注</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>通过断点进来，发现第一个方法只是注册了<code>dispatcherServletRegistration</code>；接下来重点看第二个</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从上面调用的方法命名就可以看出，我们的Filter注册就在<code>addAsRegistrationBean(beanFactory, Filter.class, new FilterRegistrationBeanAdapter());</code></p>
<figure><img src="/imgs/191018/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>上面的截图就比较核心了，在创建<code>FilterRegistrationBean</code>的时候，根据Filter的顺序来指定最终的优先级</p>
<p>然后再回到构造方法中，根据order进行排序, 最终确定Filter的优先级</p>
<figure><img src="/imgs/191018/02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 2. WebFilter方式</h3>
<p>接下来我们看一下WebFilter方式为什么不生效，在根据我的项目源码进行测试的时候，请将需要修改一下自定义的Filter，将类上的<code>@WebFilter</code>注解打开，<code>@Component</code>注解删除，并且打开Application类上的<code>ServletComponentScan</code></p>
<p>我们这里debug的路径和上面的差别不大，重点关注下面<code>ServletContextInitializerBeans</code>的构造方法上面</p>
<p>当我们深入<code>addServletContextInitializerBeans(beanFactory);</code>这一行进去debug的时候，会发现我们自定义的Filter是在这里面完成初始化的；而前面的使用方式，则是在<code>addAdapterBeans()</code>方法中初始化的，如下图</p>
<figure><img src="/imgs/191018/03.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>在<code>getOrderedBeansOfType(beanFactory, ServletContextInitializer.class)</code>的调用中就返回了我们自定义的Bean，也就是说我们自定义的Filter被认为是<code>ServletContextInitializer</code>的类型了</p>
<p>然后我们换个目标，看一下ReqFilter在注册的时候是怎样的</p>
<p>关键代码: <code>org.springframework.beans.factory.support.DefaultListableBeanFactory#registerBeanDefinition</code></p>
<p>（因为bean很多，所以我们可以加上条件断点）</p>
<figure><img src="/imgs/191018/04.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<blockquote>
<p>通过断点调试，可以知道我们的自定义Filter是通过<code>WebFilterHandler</code>类扫描注册的, 对这一块管兴趣的可以深入看一下<code>org.springframework.boot.web.servlet.ServletComponentRegisteringPostProcessor#scanPackage</code></p>
</blockquote>
<p>上面只是声明了Bean的注册信息，但是还没有具体的实例化，接下来我们回到前面的进程，看一下Filter的实例过程</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意我们的Filter实例在<code>T bean = beanFactory.getBean(name, type);</code></p>
<p>通过这种方式获取的Filter实例，并不会将ReqFilter类上的Order注解的值，来更新<code>FilterRegistrationBean</code>的order属性，所以这个注解不会生效</p>
<p>最后我们再看一下，通过WebFilter的方式，容器类不会存在<code>ReqFilter.class</code>类型的Bean, 这个与前面的方式不同</p>
<figure><img src="/imgs/191018/05.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> III. 小结</h2>
<p>本文主要介绍了另外一种Filter的使用姿势，将Filter当做普通的Spring Bean对象进行注册，这种场景下，可以直接使用<code>@Order</code>注解来指定Filter的优先级</p>
<p>但是，这种方式下，我们的Filter的很多基本属性不太好设置，一个方案是参考SpringBoot提供的一些Fitler的写法，在Filter内部来实现相关逻辑</p>
<h3> 0. 项目</h3>
<h4> web系列博文</h4>
<ul>
<li><a href="https://mp.weixin.qq.com/s/f01KWO3d2zhoN0Qa9-Qb6w" target="_blank" rel="noopener noreferrer">191016-SpringBoot系列教程web篇之过滤器Filter使用指南</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484348&amp;idx=1&amp;sn=e9b36572c721418b097396b50319d140&amp;chksm=fce71810cb9091063e810327e44f7ed07256188aecd352fa43f37e63e63dc64292b1a48b00cf&amp;token=823367253&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">191012-SpringBoot系列教程web篇之自定义异常处理HandlerExceptionResolver</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484344&amp;idx=1&amp;sn=d4b1422a709d9540583e33443aab6fff&amp;chksm=fce71814cb9091025a960312c878ff9fc4f44fd0035aa597f55f37c90dcbac25a3e96ee2c528&amp;token=118864495&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">191010-SpringBoot系列教程web篇之全局异常处理</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484336&amp;idx=1&amp;sn=d70f15e77bbd219af8015f9037a167fb&amp;chksm=fce7181ccb90910aee427a3f3ed7660e8303c7460859c82622a651ce1cc3d7a97f62f80ed4e0&amp;token=2447275&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">190930-SpringBoot系列教程web篇之404、500异常页面配置</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484322&amp;idx=1&amp;sn=b18090f35b59097f78858b6609506b74&amp;chksm=fce7180ecb909118d939f3ddf741a11c0977b1213d7afa12c970590590d40441c3a085c43c52&amp;token=2447275&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">190929-SpringBoot系列教程web篇之重定向</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484310&amp;idx=1&amp;sn=f6259cf1b79db095ff2e9534993d27cf&amp;chksm=fce7183acb90912cd150f086e90ecab3eceb3464e9352853e2e722288d412dbb3eb20c6e6ae7&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190913-SpringBoot系列教程web篇之返回文本、网页、图片的操作姿势</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484309&amp;idx=1&amp;sn=33d782f7529268eef6607a1ab8d41018&amp;chksm=fce71839cb90912f6020aa9463bc0136cb57969ebe27eba865d97e212c28211435791aa874ea&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190905-SpringBoot系列教程web篇之中文乱码问题解决</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484291&amp;idx=1&amp;sn=3f7e8c92ca4d7270cc5c40cafea39683&amp;chksm=fce7182fcb90913922654a4f2f04e7029b8944d71c31741334a3235aecbe1e60babcb0c0be74&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190831-SpringBoot系列教程web篇之如何自定义参数解析器</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484287&amp;idx=1&amp;sn=44461f564d6b04cbf1a5902dcb4f23c6&amp;chksm=fce718d3cb9091c5d730e63ae954c0831d53f3dd5af5d19d9c78b6009102838efaf56f7838ff&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190828-SpringBoot系列教程web篇之Post请求参数解析姿势汇总</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484282&amp;idx=1&amp;sn=a8d236d935ae24cfbe6977e24a479caa&amp;chksm=fce718d6cb9091c0dd8a6b113236f9ae9388fb026c9403c97bdf7505f773bd7330a43e3b269c&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190824-SpringBoot系列教程web篇之Get请求参数解析姿势汇总</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484268&amp;idx=3&amp;sn=9e8a6121dce291c65bd2b3d4fab24178&amp;chksm=fce718c0cb9091d6674fb809d68ca3dc3b1695162368481abf8dc094000412116d2f9971c54b&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190822-SpringBoot系列教程web篇之Beetl环境搭建</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484268&amp;idx=2&amp;sn=f800c001061eabe74e2cad915af1921a&amp;chksm=fce718c0cb9091d682b600673a0584955783f0d339248e34323efbea9b698560c432018717ef&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190820-SpringBoot系列教程web篇之Thymeleaf环境搭建</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484268&amp;idx=1&amp;sn=acd691729488d81a94c938151d5737ce&amp;chksm=fce718c0cb9091d63ef5f12893bb835c256a18318e791a0d193d00ef767ecfd019491d02e83d&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190816-SpringBoot系列教程web篇之Freemaker环境搭建</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484217&amp;idx=1&amp;sn=9fdf45d2261cdcf2ccaccaebfb5ef598&amp;chksm=fce71895cb90918361f1afd55a2b5fc9d65508913c1d793710afa79cae38bd9d57e32ad2c187&amp;token=2447275&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">190421-SpringBoot高级篇WEB之websocket的使用说明</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484197&amp;idx=1&amp;sn=0184953527f58058ee8c2bbcfc2689ec&amp;chksm=fce71889cb90919f9be003bf2487343f7952d6b33ab5ee5fb7251ae37a631d4c32e6d8a57528&amp;token=2447275&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">190327-Spring-RestTemplate之urlencode参数解析异常全程分析</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484193&amp;idx=1&amp;sn=d8a284fe0a2b8e1fefe07d892558f563&amp;chksm=fce7188dcb90919b1f8a2408bf955e37e88b043e2dbd59b5290ac1501e3d2d303512bac6af2c&amp;token=2447275&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">190317-Spring MVC之基于java config无xml配置的web应用构建</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484186&amp;idx=1&amp;sn=18db571b670815965ae9185830c4e88f&amp;chksm=fce718b6cb9091a054e0ac4be051341d8ce38ff8e40c5911302e3d6981206c14b80770590044&amp;token=2447275&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">190316-Spring MVC之基于xml配置的web应用构建</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484139&amp;idx=1&amp;sn=b4a5f3ca6215641c6bcf5123f2bfb501&amp;chksm=fce71947cb9090511042ae97a12cc975d2b199521e17980e685cccb5e0be91a8e932cef4eb76&amp;token=2447275&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">190213-SpringBoot文件上传异常之提示The temporary upload location xxx is not valid</a></li>
</ul>
<h4> 项目源码</h4>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>项目：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/201-web" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/201-web</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/191018/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>4.Servlet 注册的四种姿势</title>
      <link>https://liuyueyi.github.io/tutorial/spring/web/Web%E4%B8%89%E5%89%91%E5%AE%A2/191122-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8Bweb%E7%AF%87Servlet-%E6%B3%A8%E5%86%8C%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%A7%BF%E5%8A%BF.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/web/Web%E4%B8%89%E5%89%91%E5%AE%A2/191122-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8Bweb%E7%AF%87Servlet-%E6%B3%A8%E5%86%8C%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%A7%BF%E5%8A%BF.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">4.Servlet 注册的四种姿势</source>
      <description>前面介绍了java web三要素中filter的使用指南与常见的易错事项，接下来我们来看一下Servlet的使用姿势，本篇主要带来在SpringBoot环境下，注册自定义的Servelt的四种姿势 @WebServlet 注解 ServletRegistrationBean bean定义 ServletContext 动态添加 普通的spring bean模式</description>
      <category>SpringBoot</category>
      <category>WEB系列</category>
      <category>web三剑客</category>
      <pubDate>Fri, 22 Nov 2019 09:07:58 GMT</pubDate>
      <content:encoded><![CDATA[<p>前面介绍了java web三要素中filter的使用指南与常见的易错事项，接下来我们来看一下Servlet的使用姿势，本篇主要带来在SpringBoot环境下，注册自定义的Servelt的四种姿势</p>
<ul>
<li><code>@WebServlet</code> 注解</li>
<li><code>ServletRegistrationBean</code> bean定义</li>
<li><code>ServletContext</code> 动态添加</li>
<li>普通的spring bean模式</li>
</ul>
<!-- more -->
<h2> I. 环境配置</h2>
<h3> 1. 项目搭建</h3>
<p>首先我们需要搭建一个web工程，以方便后续的servelt注册的实例演示，可以通过spring boot官网创建工程，也可以建立一个maven工程，在pom.xml中如下配置</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>特别说明：</strong></p>
<p>为了紧跟SpringBoot的最新版本，从本篇文章开始，博文对应的示例工程中SpringBoot版本升级到<code>2.2.1.RELEASE</code></p>
<h2> II. Servlet注册</h2>
<p>自定义一个Servlet比较简单，一般常见的操作是继承<code>HttpServlet</code>，然后覆盖<code>doGet</code>, <code>doPost</code>等方法即可；然而重点是我们自定义的这些Servlet如何才能被SpringBoot识别并使用才是关键，下面介绍四种注册方式</p>
<h3> 1. @WebServlet</h3>
<p>在自定义的servlet上添加Servlet3+的注解<code>@WebServlet</code>，来声明这个类是一个Servlet</p>
<p>和Fitler的注册方式一样，使用这个注解，需要配合Spring Boot的<code>@ServletComponentScan</code>，否则单纯的添加上面的注解并不会生效</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面是一个简单的测试Servlet，接收请求参数<code>name</code>, 并返回 <code>welcome xxx</code>；为了让上面的的注解生效，需要设置下启动类</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后启动测试，输出结果如:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. ServletRegistrationBean</h3>
<p>在Filter的注册中，我们知道有一种方式是定义一个Spring的Bean <code>FilterRegistrationBean</code>来包装我们的自定义Filter，从而让Spring容器来管理我们的过滤器；同样的在Servlet中，也有类似的包装bean: <code>ServletRegistrationBean</code></p>
<p>自定义的bean如下，注意类上没有任何注解</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来我们需要定义一个<code>ServletRegistrationBean</code>，让它持有<code>RegisterBeanServlet</code>的实例</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>测试请求输出如下:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. ServletContext</h3>
<p>这种姿势，在实际的Servlet注册中，其实用得并不太多，主要思路是在ServletContext初始化后，借助<code>javax.servlet.ServletContext#addServlet(java.lang.String, java.lang.Class&lt;? extends javax.servlet.Servlet&gt;)</code>方法来主动添加一个Servlet</p>
<p>所以我们需要找一个合适的时机，获取<code>ServletContext</code>实例，并注册Servlet，在SpringBoot生态下，可以借助<code>ServletContextInitializer</code></p>
<blockquote>
<p>ServletContextInitializer主要被RegistrationBean实现用于往ServletContext容器中注册Servlet,Filter或者EventListener。这些ServletContextInitializer的设计目的主要是用于这些实例被Spring IoC容器管理</p>
</blockquote>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>测试结果如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4. bean</h3>
<p>接下来的这种注册方式，并不优雅，但是也可以实现Servlet的注册目的，但是有坑，请各位大佬谨慎使用</p>
<p>看过我的前一篇博文<a href="https://mp.weixin.qq.com/s/f01KWO3d2zhoN0Qa9-Qb6w" target="_blank" rel="noopener noreferrer">191016-SpringBoot系列教程web篇之过滤器Filter使用指南</a>的同学，可能会有一点映象，可以在Filter上直接添加<code>@Component</code>注解，Spring容器扫描bean时，会查找所有实现Filter的子类，并主动将它包装到<code>FilterRegistrationBean</code>，实现注册的目的</p>
<p>我们的Servlet是否也可以这样呢？接下来我们实测一下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>现在问题来了，上面这个Servlet没有定义urlMapping规则，怎么请求呢？</p>
<p>为了确定上面的Servlet被注册了，借着前面Filter的源码分析的关键链路，我们找到了实际注册的地方<code>ServletContextInitializerBeans#addAsRegistrationBean</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从上面的源码上可以看到，这个Servlet的url要么是<code>/</code>, 要么是<code>/beanName/</code></p>
<p>接下来进行实测，全是404</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后再定义一个Servlet时</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>再次测试</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从实际的测试结果可以看出，使用这种定义方式时，这个servlet相应的url为<code>beanName + '/'</code></p>
<p><strong>注意事项</strong></p>
<p>然后问题来了，只定义一个Servlet的时候，根据前面的源码分析，这个Servlet应该会相应<code>http://localhost:8080/</code>的请求，然而测试的时候为啥是404？</p>
<p>这个问题也好解答，主要就是Servlet的优先级问题，上面这种方式的Servlet的相应优先级低于Spring Web的Servelt优先级，相同的url请求先分配给Spring的Servlet了，为了验证这个也简单，两步</p>
<ul>
<li>先注释<code>BeanServlet2</code>类上的注解<code>@Component</code></li>
<li>在<code>BeanServlet1</code>的类上，添加注解<code>@Order(-10000)</code></li>
</ul>
<p>然后再次启动测试,输出如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 5. 小结</h3>
<p>本文主要介绍了四种Servlet的注册方式，至于Servlet的使用指南则静待下篇</p>
<p>常见的两种注册case:</p>
<ul>
<li><code>@WebServlet</code>注解放在Servlet类上，然后启动类上添加<code>@ServletComponentScan</code>，确保Serlvet3+的注解可以被Spring识别</li>
<li>将自定义Servlet实例委托给bean <code>ServletRegistrationBean</code></li>
</ul>
<p>不常见的两种注册case:</p>
<ul>
<li>实现接口<code>ServletContextInitializer</code>，通过<code>ServletContext.addServlet</code>来注册自定义Servlet</li>
<li>直接将Serlvet当做普通的bean注册给Spring
<ul>
<li>当项目中只有一个此种case的servlet时，它响应url: '/', 但是需要注意不指定优先级时，默认场景下Spring的Servlet优先级更高，所以它接收不到请求</li>
<li>当项目有多个此种case的servlet时，响应的url为<code>beanName + '/'</code>， 注意后面的'/'必须有</li>
</ul>
</li>
</ul>
<h2> II. 其他</h2>
<h3> 0. 项目</h3>
<h4> web系列博文</h4>
<ul>
<li><a href="http://spring.hhui.top/spring-blog/2019/11/20/191120-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8BWeb%E7%AF%87%E4%B9%8B%E5%BC%80%E5%90%AFGZIP%E6%95%B0%E6%8D%AE%E5%8E%8B%E7%BC%A9/" target="_blank" rel="noopener noreferrer">191120-SpringBoot系列教程Web篇之开启GZIP数据压缩</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2019/10/18/191018-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8Bweb%E7%AF%87%E4%B9%8B%E8%BF%87%E6%BB%A4%E5%99%A8Filter%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97%E6%89%A9%E5%B1%95%E7%AF%87/" target="_blank" rel="noopener noreferrer">191018-SpringBoot系列教程web篇之过滤器Filter使用指南扩展篇</a></li>
<li><a href="https://mp.weixin.qq.com/s/f01KWO3d2zhoN0Qa9-Qb6w" target="_blank" rel="noopener noreferrer">191016-SpringBoot系列教程web篇之过滤器Filter使用指南</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484348&amp;idx=1&amp;sn=e9b36572c721418b097396b50319d140&amp;chksm=fce71810cb9091063e810327e44f7ed07256188aecd352fa43f37e63e63dc64292b1a48b00cf&amp;token=823367253&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">191012-SpringBoot系列教程web篇之自定义异常处理HandlerExceptionResolver</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484344&amp;idx=1&amp;sn=d4b1422a709d9540583e33443aab6fff&amp;chksm=fce71814cb9091025a960312c878ff9fc4f44fd0035aa597f55f37c90dcbac25a3e96ee2c528&amp;token=118864495&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">191010-SpringBoot系列教程web篇之全局异常处理</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484336&amp;idx=1&amp;sn=d70f15e77bbd219af8015f9037a167fb&amp;chksm=fce7181ccb90910aee427a3f3ed7660e8303c7460859c82622a651ce1cc3d7a97f62f80ed4e0&amp;token=2447275&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">190930-SpringBoot系列教程web篇之404、500异常页面配置</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484322&amp;idx=1&amp;sn=b18090f35b59097f78858b6609506b74&amp;chksm=fce7180ecb909118d939f3ddf741a11c0977b1213d7afa12c970590590d40441c3a085c43c52&amp;token=2447275&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">190929-SpringBoot系列教程web篇之重定向</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484310&amp;idx=1&amp;sn=f6259cf1b79db095ff2e9534993d27cf&amp;chksm=fce7183acb90912cd150f086e90ecab3eceb3464e9352853e2e722288d412dbb3eb20c6e6ae7&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190913-SpringBoot系列教程web篇之返回文本、网页、图片的操作姿势</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484309&amp;idx=1&amp;sn=33d782f7529268eef6607a1ab8d41018&amp;chksm=fce71839cb90912f6020aa9463bc0136cb57969ebe27eba865d97e212c28211435791aa874ea&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190905-SpringBoot系列教程web篇之中文乱码问题解决</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484291&amp;idx=1&amp;sn=3f7e8c92ca4d7270cc5c40cafea39683&amp;chksm=fce7182fcb90913922654a4f2f04e7029b8944d71c31741334a3235aecbe1e60babcb0c0be74&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190831-SpringBoot系列教程web篇之如何自定义参数解析器</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484287&amp;idx=1&amp;sn=44461f564d6b04cbf1a5902dcb4f23c6&amp;chksm=fce718d3cb9091c5d730e63ae954c0831d53f3dd5af5d19d9c78b6009102838efaf56f7838ff&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190828-SpringBoot系列教程web篇之Post请求参数解析姿势汇总</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484282&amp;idx=1&amp;sn=a8d236d935ae24cfbe6977e24a479caa&amp;chksm=fce718d6cb9091c0dd8a6b113236f9ae9388fb026c9403c97bdf7505f773bd7330a43e3b269c&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190824-SpringBoot系列教程web篇之Get请求参数解析姿势汇总</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484268&amp;idx=3&amp;sn=9e8a6121dce291c65bd2b3d4fab24178&amp;chksm=fce718c0cb9091d6674fb809d68ca3dc3b1695162368481abf8dc094000412116d2f9971c54b&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190822-SpringBoot系列教程web篇之Beetl环境搭建</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484268&amp;idx=2&amp;sn=f800c001061eabe74e2cad915af1921a&amp;chksm=fce718c0cb9091d682b600673a0584955783f0d339248e34323efbea9b698560c432018717ef&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190820-SpringBoot系列教程web篇之Thymeleaf环境搭建</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484268&amp;idx=1&amp;sn=acd691729488d81a94c938151d5737ce&amp;chksm=fce718c0cb9091d63ef5f12893bb835c256a18318e791a0d193d00ef767ecfd019491d02e83d&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190816-SpringBoot系列教程web篇之Freemaker环境搭建</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484217&amp;idx=1&amp;sn=9fdf45d2261cdcf2ccaccaebfb5ef598&amp;chksm=fce71895cb90918361f1afd55a2b5fc9d65508913c1d793710afa79cae38bd9d57e32ad2c187&amp;token=2447275&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">190421-SpringBoot高级篇WEB之websocket的使用说明</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484197&amp;idx=1&amp;sn=0184953527f58058ee8c2bbcfc2689ec&amp;chksm=fce71889cb90919f9be003bf2487343f7952d6b33ab5ee5fb7251ae37a631d4c32e6d8a57528&amp;token=2447275&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">190327-Spring-RestTemplate之urlencode参数解析异常全程分析</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484193&amp;idx=1&amp;sn=d8a284fe0a2b8e1fefe07d892558f563&amp;chksm=fce7188dcb90919b1f8a2408bf955e37e88b043e2dbd59b5290ac1501e3d2d303512bac6af2c&amp;token=2447275&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">190317-Spring MVC之基于java config无xml配置的web应用构建</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484186&amp;idx=1&amp;sn=18db571b670815965ae9185830c4e88f&amp;chksm=fce718b6cb9091a054e0ac4be051341d8ce38ff8e40c5911302e3d6981206c14b80770590044&amp;token=2447275&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">190316-Spring MVC之基于xml配置的web应用构建</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484139&amp;idx=1&amp;sn=b4a5f3ca6215641c6bcf5123f2bfb501&amp;chksm=fce71947cb9090511042ae97a12cc975d2b199521e17980e685cccb5e0be91a8e932cef4eb76&amp;token=2447275&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">190213-SpringBoot文件上传异常之提示The temporary upload location xxx is not valid</a></li>
</ul>
<h4> 项目源码</h4>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>项目：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/211-web-servlet" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/211-web-servlet</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>5.Listener四种注册姿势</title>
      <link>https://liuyueyi.github.io/tutorial/spring/web/Web%E4%B8%89%E5%89%91%E5%AE%A2/191206-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8Bweb%E7%AF%87Listener%E5%9B%9B%E7%A7%8D%E6%B3%A8%E5%86%8C%E5%A7%BF%E5%8A%BF.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/web/Web%E4%B8%89%E5%89%91%E5%AE%A2/191206-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8Bweb%E7%AF%87Listener%E5%9B%9B%E7%A7%8D%E6%B3%A8%E5%86%8C%E5%A7%BF%E5%8A%BF.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">5.Listener四种注册姿势</source>
      <description>javaw web三要素Filter, Servlet前面分别进行了介绍，接下来我们看一下Listener的相关知识点，本篇博文主要内容为SpringBoot环境下，如何自定义Listener并注册到spring容器</description>
      <category>SpringBoot</category>
      <category>WEB系列</category>
      <category>web三剑客</category>
      <pubDate>Fri, 06 Dec 2019 14:03:28 GMT</pubDate>
      <content:encoded><![CDATA[<p>javaw web三要素Filter, Servlet前面分别进行了介绍，接下来我们看一下Listener的相关知识点，本篇博文主要内容为SpringBoot环境下，如何自定义Listener并注册到spring容器</p>
<!-- more -->
<h2> I. 环境配置</h2>
<h3> 1. 项目搭建</h3>
<p>首先我们需要搭建一个web工程，以方便后续的servelt注册的实例演示，可以通过spring boot官网创建工程，也可以建立一个maven工程，在pom.xml中如下配置</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> II. Listener注册</h2>
<p>我们这里说到的Listener专指java web相关的监听器，与Spring本身的Listener并不一样。在java web中Listener的知识点为servlet规范的那一套，这里不详细展开。下面主要介绍在SpringBoot中使用Servlet Listener的四种方式</p>
<h3> 1. WebListener注解</h3>
<p><code>@WebListener</code>注解为Servlet3+提供的注解，可以标识一个类为Listener，使用姿势和前面的Listener、Filter并没有太大的区别</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>因为WebListener注解不是spring的规范，所以为了识别它，需要在启动类上添加注解<code>@ServletComponentScan</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 普通bean</h3>
<p>第二种使用方式是将Listener当成一个普通的spring bean，spring boot会自动将其包装为<code>ServletListenerRegistrationBean</code>对象</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. ServletListenerRegistrationBean</h3>
<p>通过java config来主动将一个普通的Listener对象，塞入<code>ServletListenerRegistrationBean</code>对象，创建为spring的bean对象</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面只是一个普通的类定义，下面的bean创建才是关键点</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4. ServletContextInitializer</h3>
<p>这里主要是借助在ServletContext上下文创建的实际，主动的向其中添加Filter，Servlet， Listener，从而实现一种主动注册的效果</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意ExtendServletConfigInitializer的主动注册时机，在启动时添加了这个Listenrer，所以它的优先级会是最高</p>
<h3> 5. 测试</h3>
<p>上面介绍了四种注册方式，都可以生效，在我们的实际开发中，按需选择一种即可，不太建议多种方式混合使用；</p>
<p>项目启动和关闭之后，输出日志如下</p>
<figure><img src="/imgs/191206/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> II. 其他</h2>
<h4> web系列博文</h4>
<ul>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484377&amp;idx=1&amp;sn=a20ce7e5e04ede4dff5fa84a7c5c8448&amp;chksm=fce71875cb9091639124afa69d0ec7bbf8f50438fd7acaf582fb029b7a4adf2f36fa50d4f0fa&amp;token=1748723444&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">191122-SpringBoot系列教程web篇Servlet 注册的四种姿势</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2019/11/20/191120-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8BWeb%E7%AF%87%E4%B9%8B%E5%BC%80%E5%90%AFGZIP%E6%95%B0%E6%8D%AE%E5%8E%8B%E7%BC%A9/" target="_blank" rel="noopener noreferrer">191120-SpringBoot系列教程Web篇之开启GZIP数据压缩</a></li>
<li><a href="http://spring.hhui.top/spring-blog/2019/10/18/191018-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8Bweb%E7%AF%87%E4%B9%8B%E8%BF%87%E6%BB%A4%E5%99%A8Filter%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97%E6%89%A9%E5%B1%95%E7%AF%87/" target="_blank" rel="noopener noreferrer">191018-SpringBoot系列教程web篇之过滤器Filter使用指南扩展篇</a></li>
<li><a href="https://mp.weixin.qq.com/s/f01KWO3d2zhoN0Qa9-Qb6w" target="_blank" rel="noopener noreferrer">191016-SpringBoot系列教程web篇之过滤器Filter使用指南</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484348&amp;idx=1&amp;sn=e9b36572c721418b097396b50319d140&amp;chksm=fce71810cb9091063e810327e44f7ed07256188aecd352fa43f37e63e63dc64292b1a48b00cf&amp;token=823367253&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">191012-SpringBoot系列教程web篇之自定义异常处理HandlerExceptionResolver</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484344&amp;idx=1&amp;sn=d4b1422a709d9540583e33443aab6fff&amp;chksm=fce71814cb9091025a960312c878ff9fc4f44fd0035aa597f55f37c90dcbac25a3e96ee2c528&amp;token=118864495&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">191010-SpringBoot系列教程web篇之全局异常处理</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484336&amp;idx=1&amp;sn=d70f15e77bbd219af8015f9037a167fb&amp;chksm=fce7181ccb90910aee427a3f3ed7660e8303c7460859c82622a651ce1cc3d7a97f62f80ed4e0&amp;token=2447275&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">190930-SpringBoot系列教程web篇之404、500异常页面配置</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484322&amp;idx=1&amp;sn=b18090f35b59097f78858b6609506b74&amp;chksm=fce7180ecb909118d939f3ddf741a11c0977b1213d7afa12c970590590d40441c3a085c43c52&amp;token=2447275&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">190929-SpringBoot系列教程web篇之重定向</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484310&amp;idx=1&amp;sn=f6259cf1b79db095ff2e9534993d27cf&amp;chksm=fce7183acb90912cd150f086e90ecab3eceb3464e9352853e2e722288d412dbb3eb20c6e6ae7&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190913-SpringBoot系列教程web篇之返回文本、网页、图片的操作姿势</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484309&amp;idx=1&amp;sn=33d782f7529268eef6607a1ab8d41018&amp;chksm=fce71839cb90912f6020aa9463bc0136cb57969ebe27eba865d97e212c28211435791aa874ea&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190905-SpringBoot系列教程web篇之中文乱码问题解决</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484291&amp;idx=1&amp;sn=3f7e8c92ca4d7270cc5c40cafea39683&amp;chksm=fce7182fcb90913922654a4f2f04e7029b8944d71c31741334a3235aecbe1e60babcb0c0be74&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190831-SpringBoot系列教程web篇之如何自定义参数解析器</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484287&amp;idx=1&amp;sn=44461f564d6b04cbf1a5902dcb4f23c6&amp;chksm=fce718d3cb9091c5d730e63ae954c0831d53f3dd5af5d19d9c78b6009102838efaf56f7838ff&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190828-SpringBoot系列教程web篇之Post请求参数解析姿势汇总</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484282&amp;idx=1&amp;sn=a8d236d935ae24cfbe6977e24a479caa&amp;chksm=fce718d6cb9091c0dd8a6b113236f9ae9388fb026c9403c97bdf7505f773bd7330a43e3b269c&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190824-SpringBoot系列教程web篇之Get请求参数解析姿势汇总</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484268&amp;idx=3&amp;sn=9e8a6121dce291c65bd2b3d4fab24178&amp;chksm=fce718c0cb9091d6674fb809d68ca3dc3b1695162368481abf8dc094000412116d2f9971c54b&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190822-SpringBoot系列教程web篇之Beetl环境搭建</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484268&amp;idx=2&amp;sn=f800c001061eabe74e2cad915af1921a&amp;chksm=fce718c0cb9091d682b600673a0584955783f0d339248e34323efbea9b698560c432018717ef&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190820-SpringBoot系列教程web篇之Thymeleaf环境搭建</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484268&amp;idx=1&amp;sn=acd691729488d81a94c938151d5737ce&amp;chksm=fce718c0cb9091d63ef5f12893bb835c256a18318e791a0d193d00ef767ecfd019491d02e83d&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">190816-SpringBoot系列教程web篇之Freemaker环境搭建</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484217&amp;idx=1&amp;sn=9fdf45d2261cdcf2ccaccaebfb5ef598&amp;chksm=fce71895cb90918361f1afd55a2b5fc9d65508913c1d793710afa79cae38bd9d57e32ad2c187&amp;token=2447275&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">190421-SpringBoot高级篇WEB之websocket的使用说明</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484197&amp;idx=1&amp;sn=0184953527f58058ee8c2bbcfc2689ec&amp;chksm=fce71889cb90919f9be003bf2487343f7952d6b33ab5ee5fb7251ae37a631d4c32e6d8a57528&amp;token=2447275&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">190327-Spring-RestTemplate之urlencode参数解析异常全程分析</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484193&amp;idx=1&amp;sn=d8a284fe0a2b8e1fefe07d892558f563&amp;chksm=fce7188dcb90919b1f8a2408bf955e37e88b043e2dbd59b5290ac1501e3d2d303512bac6af2c&amp;token=2447275&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">190317-Spring MVC之基于java config无xml配置的web应用构建</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484186&amp;idx=1&amp;sn=18db571b670815965ae9185830c4e88f&amp;chksm=fce718b6cb9091a054e0ac4be051341d8ce38ff8e40c5911302e3d6981206c14b80770590044&amp;token=2447275&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">190316-Spring MVC之基于xml配置的web应用构建</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247484139&amp;idx=1&amp;sn=b4a5f3ca6215641c6bcf5123f2bfb501&amp;chksm=fce71947cb9090511042ae97a12cc975d2b199521e17980e685cccb5e0be91a8e932cef4eb76&amp;token=2447275&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">190213-SpringBoot文件上传异常之提示The temporary upload location xxx is not valid</a></li>
</ul>
<h4> 项目源码</h4>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>项目：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/212-web-listener" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/212-web-listener</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/191206/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>6.拦截器Interceptor使用姿势介绍</title>
      <link>https://liuyueyi.github.io/tutorial/spring/web/Web%E4%B8%89%E5%89%91%E5%AE%A2/210804-SpringBoot%E7%B3%BB%E5%88%97Web%E7%AF%87%E4%B9%8B%E6%8B%A6%E6%88%AA%E5%99%A8Interceptor%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF%E4%BB%8B%E7%BB%8D.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/web/Web%E4%B8%89%E5%89%91%E5%AE%A2/210804-SpringBoot%E7%B3%BB%E5%88%97Web%E7%AF%87%E4%B9%8B%E6%8B%A6%E6%88%AA%E5%99%A8Interceptor%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF%E4%BB%8B%E7%BB%8D.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">6.拦截器Interceptor使用姿势介绍</source>
      <description>在SpringMVC中，拦截器与Filter两者的应用场景好像差不多，最大的区别可能是前者属于Spring的特产，而后者则是Servlert三剑客中的一个，它们本质的区别在于两者发生的时机不一致 Filter: 在执行Servlet#service方法之前，会执行过滤器；执行完毕之后也会经过过滤器 Interceptor: 对会话进行拦截，可以在调用Handler方法之前，视图渲染之前，方法返回之前三个时机触发回调 基于上面的触发时间的不同，两者可以做的事情也不尽相同 Filter: 操作Request/Response Interceptor: 操作Request/Response/handler/modelAndView/exception 接下来本文将来看一下，在SpringMVC中拦截器的使用姿势</description>
      <category>SpringBoot</category>
      <category>WEB系列</category>
      <category>Interceptor</category>
      <pubDate>Wed, 04 Aug 2021 21:50:46 GMT</pubDate>
      <content:encoded><![CDATA[<p>在SpringMVC中，拦截器与Filter两者的应用场景好像差不多，最大的区别可能是前者属于Spring的特产，而后者则是Servlert三剑客中的一个，它们本质的区别在于两者发生的时机不一致</p>
<ul>
<li>Filter: 在执行Servlet#service方法之前，会执行过滤器；执行完毕之后也会经过过滤器</li>
<li>Interceptor: 对会话进行拦截，可以在调用Handler方法之前，视图渲染之前，方法返回之前三个时机触发回调</li>
</ul>
<p>基于上面的触发时间的不同，两者可以做的事情也不尽相同</p>
<ul>
<li>Filter: 操作Request/Response</li>
<li>Interceptor: 操作Request/Response/handler/modelAndView/exception</li>
</ul>
<p>接下来本文将来看一下，在SpringMVC中拦截器的使用姿势</p>
<!-- more -->
<h2> I. 项目搭建</h2>
<h3> 1. 项目依赖</h3>
<p>本项目借助<code>SpringBoot 2.2.1.RELEASE</code> + <code>maven 3.5.3</code> + <code>IDEA</code>进行开发</p>
<p>开一个web服务用于测试</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> II. 拦截器</h2>
<h3> 1. 自定义拦截器</h3>
<p>要实现一个自定义拦截器，一般来讲，实现接口<code>HandlerInterceptor</code>即可</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个接口定义了三个方法，分别在不同的时机触发回调</p>
<h4> 1.1 preHandle</h4>
<p>在handler方法执行之前（简单理解为Controller提供的服务调用之前）会被触发，如果返回ture，表示拦截通过，可以执行；若果返回false，表示不允许往后走</p>
<p>因此在这里，通常可以用来做安全校验，用户身份处理等操作</p>
<p>特别需要注意的是，无论是拦截器/还是Filter，在使用 Request 中的请求流的时候，要警惕，通常请求参数流的读取是一次性的，如果在这里实现了一个请求参数日志输出，把请求流的数据读出来了，但是又没有写回去，就会导致请求参数丢失了</p>
<h4> 1.2 postHandler</h4>
<p>这个是在handler方法执行之后，视图渲染之前被回调，简单来说，我们在这个时候，是可以操作ModelAndView，往里面添加一下信息，并能被视图解析渲染的</p>
<p>当然鉴于现在前后端分离的趋势，这个实际上用得也不多了</p>
<h4> 1.3 afterCompletion</h4>
<p>顾名思义，该方法将在整个请求结束之后，也就是在 DispatcherServlet 渲染了对应的视图之后执行。此方法主要用来进行资源清理</p>
<h3> 2. 注册与测试</h3>
<p>接下来让我们自定义的拦截器生效</p>
<p>实现<code>WebMvcConfigurer</code>接口，重写<code>addInterceptors</code>方法，实现拦截器注册</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. 小结</h3>
<p>本文补齐了之前遗漏的SpringMVC拦截器的知识点，从使用来看，比较简单，需要注意的知识点，无非就是拦截器的三个时机</p>
<ul>
<li>preHander: controller方法执行前触发，返回ture/false, ture表示通过</li>
<li>postHandler: controller执行后，视图渲染前</li>
<li>afterCompletion: 执行完毕之后触发</li>
</ul>
<p>其次，相较于filter而言， 拦截器除了操作requset/response之外，还可以操作handler/modelAndView/exception</p>
<h2> III. 不能错过的源码和相关知识点</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/213-web-interceptor" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/213-web-interceptor</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>7.拦截器注入Bean的几种姿势</title>
      <link>https://liuyueyi.github.io/tutorial/spring/web/Web%E4%B8%89%E5%89%91%E5%AE%A2/211115-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8B%E6%8B%A6%E6%88%AA%E5%99%A8%E6%B3%A8%E5%85%A5Bean%E7%9A%84%E5%87%A0%E7%A7%8D%E5%A7%BF%E5%8A%BF.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/web/Web%E4%B8%89%E5%89%91%E5%AE%A2/211115-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8B%E6%8B%A6%E6%88%AA%E5%99%A8%E6%B3%A8%E5%85%A5Bean%E7%9A%84%E5%87%A0%E7%A7%8D%E5%A7%BF%E5%8A%BF.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">7.拦截器注入Bean的几种姿势</source>
      <description>之前介绍过一篇拦截器的基本使用姿势: 【WEB系列】SpringBoot之拦截器Interceptor使用姿势介绍 在SpringBoot中，通过实现WebMvcConfigurer的addInterceptors方法来注册拦截器，那么当我们的拦截器中希望使用Bean时，可以怎么整？</description>
      <category>SpringBoot</category>
      <category>WEB系列</category>
      <category>Interceptor</category>
      <pubDate>Mon, 15 Nov 2021 18:31:26 GMT</pubDate>
      <content:encoded><![CDATA[<p>之前介绍过一篇拦截器的基本使用姿势: <a href="https://spring.hhui.top/spring-blog/2021/08/04/210804-SpringBoot%E7%B3%BB%E5%88%97Web%E7%AF%87%E4%B9%8B%E6%8B%A6%E6%88%AA%E5%99%A8Interceptor%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF%E4%BB%8B%E7%BB%8D/" target="_blank" rel="noopener noreferrer">【WEB系列】SpringBoot之拦截器Interceptor使用姿势介绍</a></p>
<p>在SpringBoot中，通过实现<code>WebMvcConfigurer</code>的<code>addInterceptors</code>方法来注册拦截器，那么当我们的拦截器中希望使用Bean时，可以怎么整？</p>
<!-- more -->
<h2> I. 项目搭建</h2>
<p>本项目借助<code>SpringBoot 2.2.1.RELEASE</code> +  <code>maven 3.5.3</code> + <code>IDEA</code>进行开发</p>
<p>开一个web服务用于测试</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> II.拦截器</h2>
<p>实现拦截器比较简单，实现<code>HandlerInterceptor</code>接口就可以了，比如我们实现一个基础的权限校验的拦截器，通过从请求头中获取参数，当满足条件时表示通过</p>
<h3> 0.安全校验拦截器</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来是这个拦截器的注册</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来问题来了，我们希望这个用于校验的值放在配置文件中，不是在代码中写死，可以怎么整？</p>
<h3> 1. 指定配置</h3>
<p>在项目资源文件中，添加一个配置用于表示校验的请求头</p>
<p><code>application.yml</code></p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>配置的读取，可以使用 <code>Envrioment.getProperty()</code>，也可以使用 <code>@Value</code>注解</p>
<p>但是注意上面的拦截器注册，直接构造的一个方法，添加到<code>InterceptorRegistry</code>，在拦截器中，即使添加<code>@Value</code>， <code>@Autowired</code>注解也不会生效（归根结底就是这个拦截器并没有受Spring上下文管理）</p>
<h3> 2. 拦截器注入Bean</h3>
<p>那么在拦截器中如果想使用Spring容器中的bean对象，可以怎么整？</p>
<h4> 2.1 新增静态的ApplicationContext容器类</h4>
<p>一个可行的方法就是在项目中维护一个工具类，其内部持有<code>ApplicationContext</code>的引用，通过这个工具类来访问bean对象</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>基于此，在拦截器中，如果想要获取配置，直接改成下面这样既可</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这种方式来访问bean，优点就是<strong>通用性更强，适用范围广</strong></p>
<h4> 2.2 拦截器注册为bean</h4>
<p>上面的方法虽然可行，但是看起来总归不那么优雅，那么有办法直接将拦截器声明为bean对象，然后直接使用<code>@Autowired</code>注解来注入依赖的bean么</p>
<p>当然是可行的，注意bean注册的几种姿势，我们这里采用下面这种方式来注册拦截器</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面通过配置类的方式来声明bean，然后在注册拦截器的地方，不直接使用构造方法来创建实例；上面的用法表示是使用spring的bean容器来注册，基于这种方式来实现拦截器的bean声明</p>
<p>因此在拦截器中就可以注入其他依赖了</p>
<p>测试就比较简单了，如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. 小结</h3>
<p>本文虽说介绍的是如何在拦截器中注入bean，实际上的知识点依然是创建bean对象的几种姿势；上面提供了两种常见的方式，一个SpringUtil持有SpringContext，然后借助这个工具类来访问bean对象，巧用它可以省很多事；</p>
<p>另外一个就是将拦截器声明为bean，这种方式主要需要注意的点是拦截器的注册时，不能直接<code>new</code> 拦截器；当然bean的创建，除了上面这个方式之外，还有其他的case，有兴趣的小伙伴可以尝试一下</p>
<h2> III. 不能错过的源码和相关知识点</h2>
<h3> 0. 项目</h3>
<p>相关博文：</p>
<ul>
<li><a href="https://spring.hhui.top/spring-blog/2021/08/04/210804-SpringBoot%E7%B3%BB%E5%88%97Web%E7%AF%87%E4%B9%8B%E6%8B%A6%E6%88%AA%E5%99%A8Interceptor%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF%E4%BB%8B%E7%BB%8D/" target="_blank" rel="noopener noreferrer">SpringBoot之拦截器Interceptor使用姿势介绍</a></li>
</ul>
<p>项目源码：</p>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/213-web-interceptor" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/213-web-interceptor</a></li>
</ul>
<h3> 1. 微信公众号: 一灰灰Blog</h3>
<p>尽信书则不如，以上内容，纯属一家之言，因个人能力有限，难免有疏漏和错误之处，如发现bug或者有更好的建议，欢迎批评指正，不吝感激</p>
<p>下面一灰灰的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛</p>
<ul>
<li>一灰灰Blog个人博客 <a href="https://blog.hhui.top" target="_blank" rel="noopener noreferrer">https://blog.hhui.top</a></li>
<li>一灰灰Blog-Spring专题博客 <a href="http://spring.hhui.top" target="_blank" rel="noopener noreferrer">http://spring.hhui.top</a></li>
</ul>
<figure><img src="https://spring.hhui.top/spring-blog/imgs/info/info.png" alt="一灰灰blog" tabindex="0" loading="lazy"><figcaption>一灰灰blog</figcaption></figure>
]]></content:encoded>
      <enclosure url="https://spring.hhui.top/spring-blog/imgs/info/info.png" type="image/png"/>
    </item>
    <item>
      <title>Web三剑客</title>
      <link>https://liuyueyi.github.io/tutorial/spring/web/Web%E4%B8%89%E5%89%91%E5%AE%A2/</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/web/Web%E4%B8%89%E5%89%91%E5%AE%A2/</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">Web三剑客</source>
      <description>Servlet, Filter, Listener web三剑客的知识点汇总</description>
      <pubDate>Fri, 10 Feb 2023 04:50:05 GMT</pubDate>
      <content:encoded><![CDATA[<p>Servlet, Filter, Listener web三剑客的知识点汇总</p>
]]></content:encoded>
    </item>
    <item>
      <title>1.文件上传异常之提示The temporary upload location xxx is not valid（填坑篇）</title>
      <link>https://liuyueyi.github.io/tutorial/spring/web/%E5%85%B6%E4%BB%96/190213-SpringBoot%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%BC%82%E5%B8%B8%E4%B9%8B%E6%8F%90%E7%A4%BAThe-temporary-upload-location-xxx-is-not-valid.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/web/%E5%85%B6%E4%BB%96/190213-SpringBoot%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%BC%82%E5%B8%B8%E4%B9%8B%E6%8F%90%E7%A4%BAThe-temporary-upload-location-xxx-is-not-valid.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">1.文件上传异常之提示The temporary upload location xxx is not valid（填坑篇）</source>
      <description>SpringBoot搭建的应用，一直工作得好好的，突然发现上传文件失败，提示org.springframework.web.multipart.MultipartException: Failed to parse multipart servlet request; nested exception is java.io.IOException: The temporary upload location [/tmp/tomcat.6239989728636105816.19530/work/Tomcat/localhost/ROOT] is not valid目录非法，实际查看目录，结果还真没有，下面就这个问题的表现，分析下SpringBoot针对文件上传的处理过程</description>
      <category>SpringBoot</category>
      <category>WEB系列</category>
      <category>采坑记录</category>
      <pubDate>Wed, 13 Feb 2019 22:26:21 GMT</pubDate>
      <content:encoded><![CDATA[<p>SpringBoot搭建的应用，一直工作得好好的，突然发现上传文件失败，提示<code>org.springframework.web.multipart.MultipartException: Failed to parse multipart servlet request; nested exception is java.io.IOException: The temporary upload location [/tmp/tomcat.6239989728636105816.19530/work/Tomcat/localhost/ROOT] is not valid</code>目录非法，实际查看目录，结果还真没有，下面就这个问题的表现，分析下SpringBoot针对文件上传的处理过程</p>
<!-- more -->
<h2> I. 问题分析</h2>
<h3> 0. 堆栈分析</h3>
<p>问题定位，最佳的辅助手段就是堆栈分析，首先捞出核心的堆栈信息</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从堆栈内容来看，问题比较清晰，目录非法，根据path路径，进入目录，结果发现，没有这个目录，那么问题的关键就是没有目录为什么会导致异常了，这个目录到底有啥用</p>
<p>先简单描述下上面的原因，上传的文件会缓存到本地磁盘，而缓存的路径就是上面的<code>/tmp/tomcat.6239989728636105816.19530/work/Tomcat/localhost/ROOT</code>，接着引入的疑问就是：</p>
<ul>
<li>为什么上传的文件要缓存到本地</li>
<li>为什么临时目录会不存在</li>
<li>什么地方实现文件缓存</li>
</ul>
<h3> 1. 场景模拟</h3>
<p>要确认上面的问题，最直观的方法就是撸源码，直接看代码就有点蛋疼了，接下来采用debug方式来层层剥离，看下根源再哪里。</p>
<p>首先是搭建一个简单的测试项目，进行场景复现, 首先创建一个接收文件上传的Controller，如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其次就是使用curl来上传文件</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>然后在接收文件上传的方法中开启断点，注意下面红框中的 <code>location</code>, 就是文件上传的临时目录</p>
<figure><img src="/imgs/190213/00.jpg" alt="IMAGE" tabindex="0" loading="lazy"><figcaption>IMAGE</figcaption></figure>
<h3> 2. 源码定位</h3>
<p>上面的截图可以确认确实将上传的文件保存到了临时目录，验证方式就是进入那个目录进行查看，会看到一个tmp文件，接下来我们需要确定的是在什么地方，实现将数据缓存到本地的。</p>
<p>注意下图，左边红框是这次请求的完整链路，我们可以通过逆推链路，去定位可能实现文件缓存的地方</p>
<figure><img src="/imgs/190213/01.jpg" alt="IMAGE" tabindex="0" loading="lazy"><figcaption>IMAGE</figcaption></figure>
<p>如果对spring和tomcat的源码不熟的话，也没什么特别的好办法，从上面的链路中，多打一些断点，采用传说中的二分定位方法来缩小范围。</p>
<p>通过最开始的request对象和后面的request对象分析，发现一个可以作为参考标准的就是上图中右边红框的<code>request#parts</code>属性；开始是null，文件保存之后则会有数据，下面给一个最终定位的动图</p>
<figure><img src="/imgs/190213/02.gif" alt="2.gif" tabindex="0" loading="lazy"><figcaption>2.gif</figcaption></figure>
<p>所以关键就是<code>org.springframework.web.filter.HiddenHttpMethodFilter#doFilterInternal</code> 中的 <code>String paramValue = request.getParameter(this.methodParam);</code> 这一行代码</p>
<figure><img src="/imgs/190213/03.jpg" alt="IMAGE" tabindex="0" loading="lazy"><figcaption>IMAGE</figcaption></figure>
<p>到这里在单步进去，主要的焦点将集中在 <code>org.apache.catalina.connector.Request#parseParts</code></p>
<figure><img src="/imgs/190213/04.jpg" alt="IMAGE" tabindex="0" loading="lazy"><figcaption>IMAGE</figcaption></figure>
<p>进入上面方法的逻辑，很容易找到具体的实现位置 <code>org.apache.tomcat.util.http.fileupload.FileUploadBase#parseRequest</code>，这个方法的实现比较有意思，有必要贴出来看一下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>核心代码就两点，一个是文件工厂类，一个是流的拷贝；前者定义了我们的临时文件目录，也是我们解决前面问题的关键，换一个我自定义的目录永不删除，不就可以避免上面的问题了么；后面一个则是数据复用方面的</p>
<p>首先看下FileItemFactory的实例化位置，在<code>org.apache.catalina.connector.Request#parseParts</code>中，代码如下</p>
<figure><img src="/imgs/190213/05.jpg" alt="IMAGE" tabindex="0" loading="lazy"><figcaption>IMAGE</figcaption></figure>
<p>具体的location实例化代码为</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. 问题review</h3>
<h4> a. 解决问题</h4>
<p>到上面，基本上就捞到了最终的问题，先看如何解决这个问题</p>
<p><strong>方法1</strong></p>
<ul>
<li>应用重启</li>
</ul>
<p><strong>方法2</strong></p>
<ul>
<li>增加服务配置，自定义baseDir</li>
</ul>
<div class="language-properties line-numbers-mode" data-ext="properties"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>方法3</strong></p>
<ul>
<li>注入bean，手动配置临时目录</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>方法4</strong></p>
<ul>
<li>配置不删除tmp目录下的tomcat</li>
</ul>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> b. 流拷贝</h4>
<p>tomcat中实现流的拷贝代码如下，<code>org.apache.tomcat.util.http.fileupload.util.Streams#copy(java.io.InputStream, java.io.OutputStream, boolean, byte[])</code> , 看下面的实现，直观影响就是写得真特么严谨</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> c. 自问自答</h3>
<p>前面提出了几个问题，现在给一个简单的回答，因为篇幅问题，后面会单开一文，进行详细说明</p>
<h4> 什么地方缓存文件</h4>
<p>上面的定位过程给出答案，具体实现逻辑在 <code>org.apache.tomcat.util.http.fileupload.FileUploadBase#parseRequest</code></p>
<h4> 为什么目录会不存在</h4>
<p>springboot启动时会创建一个/tmp/tomcat.*/work/Tomcat/localhost/ROOT的临时目录作为文件上传的临时目录，但是该目录会在n天之后被系统自动清理掉，这个清理是由linux操作系统完成的，具体的配置如下 <code>vim /usr/lib/tmpfiles.d/tmp.conf</code></p>
<div class="language-conf line-numbers-mode" data-ext="conf"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 为什么要缓存文件</h4>
<p>因为流取一次消费之后，后面无法再从流中获取数据，所以缓存方便后续复用；这一块后面详细说明</p>
<h3> 4. 小结</h3>
<p>定位这个问题的感觉，就是对SpringBoot和tomcat的底层，实在是不太熟悉，作为一个以Spring和tomcat吃饭的码农而言，发现问题就需要改正，列入todo列表，后续需要深入一下</p>
<h2> II. 其他</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">spring-boot-demo</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/190213/00.jpg" type="image/jpeg"/>
    </item>
  </channel>
</rss>