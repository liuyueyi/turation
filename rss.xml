<?xml version="1.0" encoding="utf-8"?><?xml-stylesheet type="text/xsl" href="https://liuyueyi.github.io/tutorial/rss.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <atom:link href="https://liuyueyi.github.io/tutorial/rss.xml" rel="self" type="application/rss+xml"/>
    <title>一灰灰的站点</title>
    <link>https://liuyueyi.github.io/tutorial/</link>
    <description>一灰灰的全网知识站点</description>
    <language>zh-CN</language>
    <pubDate>Wed, 31 Jul 2024 12:35:02 GMT</pubDate>
    <lastBuildDate>Wed, 31 Jul 2024 12:35:02 GMT</lastBuildDate>
    <generator>vuepress-plugin-feed2</generator>
    <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
    <copyright>Copyright by 一灰灰blog</copyright>
    <image>
      <title>一灰灰的站点</title>
      <url>https://liuyueyi.github.io/tutorial/logo.svg</url>
      <link>https://liuyueyi.github.io/tutorial/</link>
    </image>
    <category>开源</category>
    <category>RabbitMQ</category>
    <category>开发工具</category>
    <category>Quick系列</category>
    <category>QuickAlarm</category>
    <category>QuickSpi</category>
    <category>IM</category>
    <category>技术管理</category>
    <category>Spring源码</category>
    <category>扩展点</category>
    <category>分布式</category>
    <category>设计模式</category>
    <category>高可用</category>
    <category>理论基础</category>
    <category>SpringBoot</category>
    <category>基础系列</category>
    <category>配置</category>
    <category>DB系列</category>
    <category>WEB系列</category>
    <category>Response</category>
    <category>WebSocket</category>
    <category>中间件</category>
    <category>Caffiene</category>
    <category>初始化</category>
    <category>Liquebase</category>
    <category>Mybatis</category>
    <category>email</category>
    <category>应用篇</category>
    <category>JWT</category>
    <category>DB</category>
    <category>Mongo</category>
    <item>
      <title>工具&amp;部署</title>
      <link>https://liuyueyi.github.io/tutorial/tool/</link>
      <guid>https://liuyueyi.github.io/tutorial/tool/</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">工具&amp;部署</source>
      <description>创建的软件与运维相关技术栈</description>
      <pubDate>Wed, 31 Jul 2024 12:28:49 GMT</pubDate>
      <content:encoded><![CDATA[<p>创建的软件与运维相关技术栈</p>
]]></content:encoded>
    </item>
    <item>
      <title>RabbitMq</title>
      <link>https://liuyueyi.github.io/tutorial/db/rabbitmq/</link>
      <guid>https://liuyueyi.github.io/tutorial/db/rabbitmq/</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">RabbitMq</source>
      <description>消息 RabbitMq基础教程之安装与测试 RabbitMQ基础教程之基本概念 RabbitMQ基础教程之基本使用篇 RabbitMQ基础教程之基于配置的消费者实现 RabbitMQ基础教程之使用进阶篇 RabbitMQ基础教程之Spring-JavaConfig使用篇 RabbitMQ基础教程之Spring-JavaConfig-FactoryBean使用姿势</description>
      <pubDate>Wed, 31 Jul 2024 12:28:49 GMT</pubDate>
      <content:encoded><![CDATA[<p>消息</p>
<ul class="task-list-container">
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-0" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-0"> <a href="/tutorial/db/rabbitmq/RabbitMq%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%AE%89%E8%A3%85%E4%B8%8E%E6%B5%8B%E8%AF%95/" target="blank">RabbitMq基础教程之安装与测试</a></label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-1" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-1"> <a href="/tutorial/db/rabbitmq/RabbitMQ%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/" target="blank">RabbitMQ基础教程之基本概念</a></label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-2" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-2"> <a href="/tutorial/db/rabbitmq/RabbitMQ%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E7%AF%87/" target="blank">RabbitMQ基础教程之基本使用篇</a></label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-3" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-3"> <a href="/tutorial/db/rabbitmq/RabbitMQ%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%9F%BA%E4%BA%8E%E9%85%8D%E7%BD%AE%E7%9A%84%E6%B6%88%E8%B4%B9%E8%80%85%E5%AE%9E%E7%8E%B0/" target="blank">RabbitMQ基础教程之基于配置的消费者实现</a></label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-4" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-4"> <a href="/tutorial/db/rabbitmq/RabbitMQ%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E4%BD%BF%E7%94%A8%E8%BF%9B%E9%98%B6%E7%AF%87/" target="blank">RabbitMQ基础教程之使用进阶篇</a></label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-5" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-5"> <a href="/tutorial/db/rabbitmq/RabbitMQ%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8BSpring-JavaConfig%E4%BD%BF%E7%94%A8%E7%AF%87/" target="blank">RabbitMQ基础教程之Spring-JavaConfig使用篇</a></label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-6" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-6"> <a href="/tutorial/db/rabbitmq/RabbitMQ%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8BSpring-JavaConfig-FactoryBean%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF/" target="blank">RabbitMQ基础教程之Spring-JavaConfig-FactoryBean使用姿势</a></label></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>RabbitMQ基础教程之Spring&amp;JavaConfig&amp;FactoryBean使用姿势</title>
      <link>https://liuyueyi.github.io/tutorial/db/rabbitmq/RabbitMQ%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8BSpring-JavaConfig-FactoryBean%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF.html</link>
      <guid>https://liuyueyi.github.io/tutorial/db/rabbitmq/RabbitMQ%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8BSpring-JavaConfig-FactoryBean%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">RabbitMQ基础教程之Spring&amp;JavaConfig&amp;FactoryBean使用姿势</source>
      <description>RabbitMQ基础教程之Spring使用篇 相关博文，推荐查看: RabbitMq基础教程之安装与测试 RabbitMq基础教程之基本概念 RabbitMQ基础教程之基本使用篇 RabbitMQ基础教程之使用进阶篇 RabbitMQ基础教程之Spring&amp;amp;JavaConfig使用篇</description>
      <category>开源</category>
      <category>RabbitMQ</category>
      <pubDate>Mon, 04 Jun 2018 21:10:33 GMT</pubDate>
      <content:encoded><![CDATA[<h1> RabbitMQ基础教程之Spring使用篇</h1>
<p>相关博文，推荐查看:</p>
<ol>
<li><a href="https://liuyueyi.github.io/hexblog/2018/05/24/RabbitMq%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%AE%89%E8%A3%85%E4%B8%8E%E6%B5%8B%E8%AF%95/" target="_blank" rel="noopener noreferrer">RabbitMq基础教程之安装与测试</a></li>
<li><a href="https://liuyueyi.github.io/hexblog/2018/05/27/RabbitMQ%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/" target="_blank" rel="noopener noreferrer">RabbitMq基础教程之基本概念</a></li>
<li><a href="https://liuyueyi.github.io/hexblog/2018/05/27/RabbitMQ%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E7%AF%87/" target="_blank" rel="noopener noreferrer">RabbitMQ基础教程之基本使用篇</a></li>
<li><a href="https://liuyueyi.github.io/hexblog/2018/05/29/RabbitMQ%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E4%BD%BF%E7%94%A8%E8%BF%9B%E9%98%B6%E7%AF%87/" target="_blank" rel="noopener noreferrer">RabbitMQ基础教程之使用进阶篇</a></li>
<li><a href="https://blog.hhui.top/hexblog/2018/05/31/RabbitMQ%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8BSpring-JavaConfig%E4%BD%BF%E7%94%A8%E7%AF%87/" target="_blank" rel="noopener noreferrer">RabbitMQ基础教程之Spring&amp;JavaConfig使用篇</a></li>
</ol>
<p>在前面的一篇演示了如何使用Spring来进行RabbitMQ的消息投递和消费，虽然可以实现基本的需求场景，但是使用起来却并不是特别顺手，首先是不同的消费者，得添加好多不同的配置项，加上有较多的配置（QueueName, ExchangeName, RoutingKey, autoAck...)</p>
<p>那么有没有可能借助工厂方式，来简化消费者这边的大多数配置呢？</p>
<!--more-->
<h2> I. 工厂类定义消费者信息</h2>
<p>目标比较清晰了，我们希望有一个工厂类，可以承载所有的关心的配置信息，然后在实际使用的地方，通过这个工厂类生成一个Consumer即可</p>
<h3> 1. 消费接口定义</h3>
<p>首先需要定义一个公共的消费者接口，主要用来接收并处理消息</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对于<code>ChannelAwareMessageListener</code>前面就以及用到，当有消息后，触发的监听器，这里我们增加了两个方法，其实主要就是干一件事情，优雅的关闭消费</p>
<p>当应用需要停止或者重启时，我们希望先优雅的关闭消息消费，那么就会用到 <code>org.springframework.amqp.rabbit.listener.AbstractMessageListenerContainer#stop()</code></p>
<p>因此针对这个功能，可以实现一个公共的抽象类</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的实现中，前面两个方法比较清晰，没有什么二意，需要关注的是<code>onMessage</code>方法的实现，我们默认封装了ack的逻辑，设计思路如下：</p>
<ul>
<li>当开启了手动ack之后，要求实际消费方实现 <code>process</code> 方法，并返回boolean，表示是否消费成功
<ul>
<li>消费成功，则ack</li>
<li>消费失败，则将消息重新丢回到队列</li>
</ul>
</li>
<li>若开启自动ack，则不需要关注</li>
<li>每次消费一条消息之后，需要关注下是否关闭这个状态，从而实现mq的停止消费</li>
</ul>
<p>所以每个实际消费者，实现这个抽象类的 <code>process</code> 方法即可，在内部实现自己的消息消费逻辑</p>
<h3> 2. 工厂类</h3>
<p>前面主要定义了消费的实体可以怎么玩，接下来就是重头戏了，如何声明队列，如何绑定交换器等，如何注册消息监听器（即上面的Consumer)？</p>
<p>根据前面的实现，我们需要关注的几个参数依然是下面几个:</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们最终的目标就是给每个Consumer创建一个<code>SimpleMessageListenerContainer</code>的Bean交给Spring来托管，所以可以利用Spring的FactoryBean来实现</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>具体的实现代码如上，接下来进行分块分析，首先是Exchange, 我们直到常用的有三种 Exchange：</p>
<ul>
<li>DirectExchange</li>
<li>TopicExchange</li>
<li>FanoutExchange</li>
</ul>
<p>因此，我们自定义了一个枚举，来实现不同的Exchange的绑定姿势，注意下面的实现姿势，利用了抽象类的思路</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>剩下的就是 <code>com.git.hui.rabbit.spring.component.MQContainerFactory#getObject</code> 的逻辑了，基本上和前面的思路一样</p>
<ul>
<li>定义queue</li>
<li>定义exchange</li>
<li>创建绑定</li>
<li>创建<code>SimpleMessageListenerContainer</code>，设置各种参数</li>
</ul>
<h3> 3. 配置类</h3>
<p>不可避免的需要一些配置，如何RabbitMQ的连接工厂，RabbitAmdin，这些是可以作为多个Consumer的公共Bean来使用的，因此就放在了配置类中</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> II. 测试验证</h2>
<p>从代码实现角度来看，就几个类，还是比较简单的，接下来就看实际使用的姿势，是不是变简单了</p>
<p>新建一个消费类</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后定义这个消费类的配置信息，主要是两个Bean的定义，一个是定义上面的FactoryBean，内部通过Builder模式设置了各种参数（借助lombok实现)；另外一个就是获取<code>SimpleMessageListenerContainer</code>容器了</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对应的测试类可以如下实现</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后就可以愉快的玩耍了</p>
<h2> III. 其他</h2>
<h3> 项目地址</h3>
<ul>
<li><a href="https://gitee.com/liuyueyi/study-demo/tree/master/spring-rabbit" target="_blank" rel="noopener noreferrer">六月/study-demo</a></li>
</ul>
<h3> <a href="https://liuyueyi.github.io/hexblog" target="_blank" rel="noopener noreferrer">一灰灰Blog</a>： <a href="https://liuyueyi.github.io/hexblog" target="_blank" rel="noopener noreferrer">https://liuyueyi.github.io/hexblog</a></h3>
<p>一灰灰的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛</p>
<h3> 声明</h3>
<p>尽信书则不如，已上内容，纯属一家之言，因个人能力有限，难免有疏漏和错误之处，如发现bug或者有更好的建议，欢迎批评指正，不吝感激</p>
<ul>
<li>微博地址: <a href="https://weibo.com/p/1005052169825577/home" target="_blank" rel="noopener noreferrer">小灰灰Blog</a></li>
<li>QQ： 一灰灰/3302797840</li>
</ul>
<h3> 扫描关注</h3>
<figure><img src="https://raw.githubusercontent.com/liuyueyi/Source/master/img/info/blogInfoV2.png" alt="QrCode" tabindex="0" loading="lazy"><figcaption>QrCode</figcaption></figure>
]]></content:encoded>
      <enclosure url="https://raw.githubusercontent.com/liuyueyi/Source/master/img/info/blogInfoV2.png" type="image/png"/>
    </item>
    <item>
      <title>RabbitMQ基础教程之Spring&amp;JavaConfig使用篇</title>
      <link>https://liuyueyi.github.io/tutorial/db/rabbitmq/RabbitMQ%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8BSpring-JavaConfig%E4%BD%BF%E7%94%A8%E7%AF%87.html</link>
      <guid>https://liuyueyi.github.io/tutorial/db/rabbitmq/RabbitMQ%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8BSpring-JavaConfig%E4%BD%BF%E7%94%A8%E7%AF%87.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">RabbitMQ基础教程之Spring&amp;JavaConfig使用篇</source>
      <description>RabbitMQ基础教程之Spring使用篇 相关博文，推荐查看: RabbitMq基础教程之安装与测试 RabbitMq基础教程之基本概念 RabbitMQ基础教程之基本使用篇 RabbitMQ基础教程之使用进阶篇</description>
      <category>开源</category>
      <category>RabbitMQ</category>
      <pubDate>Thu, 31 May 2018 22:03:08 GMT</pubDate>
      <content:encoded><![CDATA[<h1> RabbitMQ基础教程之Spring使用篇</h1>
<p>相关博文，推荐查看:</p>
<ol>
<li><a href="https://liuyueyi.github.io/hexblog/2018/05/24/RabbitMq%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%AE%89%E8%A3%85%E4%B8%8E%E6%B5%8B%E8%AF%95/" target="_blank" rel="noopener noreferrer">RabbitMq基础教程之安装与测试</a></li>
<li><a href="https://liuyueyi.github.io/hexblog/2018/05/27/RabbitMQ%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/" target="_blank" rel="noopener noreferrer">RabbitMq基础教程之基本概念</a></li>
<li><a href="https://liuyueyi.github.io/hexblog/2018/05/27/RabbitMQ%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E7%AF%87/" target="_blank" rel="noopener noreferrer">RabbitMQ基础教程之基本使用篇</a></li>
<li><a href="https://liuyueyi.github.io/hexblog/2018/05/29/RabbitMQ%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E4%BD%BF%E7%94%A8%E8%BF%9B%E9%98%B6%E7%AF%87/" target="_blank" rel="noopener noreferrer">RabbitMQ基础教程之使用进阶篇</a></li>
</ol>
<p>在实际的应用场景中，将RabbitMQ和Spring结合起来使用的时候可能更加频繁，网上关于Spring结合的博文中，大多都是xml的方式，这篇博文，则主要介绍下利用JavaConfig的结合，又会是怎样的</p>
<!--more-->
<h2> I. Spring中RabbitMQ的基本使用姿势</h2>
<h3> 1. 准备</h3>
<p>开始之前，首先添加上必要的依赖，主要利用 spring-rabbit 来实现，这个依赖中，内部又依赖的Spring相关的模块，下面统一改成5.0.4版本</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>流程分析</strong></p>
<p>实现主要分为两块，一个是投递服务，一个是消费服务，结合前面RabbitMQ的基本使用姿势中的流程，即便是使用Spring，我们也避免不了下面几步</p>
<ul>
<li>建立连接</li>
<li>声明Exchange ，声明Queue</li>
<li>建立Queue和Exchange之间的绑定关系</li>
<li>发送消息</li>
<li>消费消息（ack/nak)</li>
</ul>
<h3> 2. 基本case</h3>
<p>首先借助Spring，来实现一个最基本的最简单的实现方式</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. 逻辑分析</h3>
<p>上面这一段代码中，包含了消息投递和消费两块，从实现而言，基本上逻辑和前面的基础使用没有什么太大的区别，步骤如下:</p>
<ol>
<li>建立连接： <code>new CachingConnectionFactory("127.0.0.1", 5672)</code></li>
<li>声明Queue: <code>new Queue("hello", true, false, false, null)</code></li>
<li>声明Exchange: <code>new TopicExchange("topic.exchange")</code></li>
<li>绑定Queue和Exchange: <code>admin.declareBinding(BindingBuilder.bind(queue).to(exchange).with("foo.*"));</code></li>
<li>投递消息： <code>template.convertAndSend("topic.exchange", "foo.bar", "Hello, world!");</code></li>
<li>消费消息： 设置<code>MessageListenerAdapter</code></li>
</ol>
<p>这里面有几个类需要额外注意：</p>
<ul>
<li>RabbitTemplate: Spring实现的发送消息的模板，可以直接发送消息</li>
<li>SimpleMessageListenerContainer: 注册接收消息的容器</li>
</ul>
<h2> II. Spring结合JavaConfig使用RabbitMQ使用姿势</h2>
<h3> 1. 公共配置</h3>
<p>主要是将公共的ConnectionFactory 和 RabbitAdmin 抽取出来</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 消息投递</h3>
<p>发送消息的组件就比较简单了，直接利用 AmqpTemplate 即可</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. DirectExchange消息消费</h3>
<p>根据不同的Exchange类型，分别实现如下</p>
<p><strong>DirectExchange方式</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从上面的实现，基本上都是重新定义了一个Queue, Exchange, Binding, MessageListenerContainer（用来监听消息），并将消息的消费抽出了一个公共类</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4. 测试</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个测试类中，虽然主要是往MQ中投递消息，但在Spring容器启动之后，接收MQ消息并消费的实际任务，是通过前面的<code>MessageListenerContainer</code>托付给Spring容器了，上面测试执行之后，输出为</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 5. Topic &amp; Fanout策略</h3>
<p>上面的一个写出来之后，再看这两个就比较相似了</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对应的测试case</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>广播方式</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对应的测试case</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> II. 其他</h2>
<h3> 项目地址</h3>
<ul>
<li><a href="https://gitee.com/liuyueyi/study-demo/tree/master/spring-rabbit" target="_blank" rel="noopener noreferrer">六月/study-demo</a></li>
</ul>
<h3> <a href="https://liuyueyi.github.io/hexblog" target="_blank" rel="noopener noreferrer">一灰灰Blog</a>： <a href="https://liuyueyi.github.io/hexblog" target="_blank" rel="noopener noreferrer">https://liuyueyi.github.io/hexblog</a></h3>
<p>一灰灰的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛</p>
<h3> 声明</h3>
<p>尽信书则不如，已上内容，纯属一家之言，因个人能力有限，难免有疏漏和错误之处，如发现bug或者有更好的建议，欢迎批评指正，不吝感激</p>
<ul>
<li>微博地址: <a href="https://weibo.com/p/1005052169825577/home" target="_blank" rel="noopener noreferrer">小灰灰Blog</a></li>
<li>QQ： 一灰灰/3302797840</li>
</ul>
<h3> 扫描关注</h3>
<figure><img src="https://raw.githubusercontent.com/liuyueyi/Source/master/img/info/blogInfoV2.png" alt="QrCode" tabindex="0" loading="lazy"><figcaption>QrCode</figcaption></figure>
]]></content:encoded>
      <enclosure url="https://raw.githubusercontent.com/liuyueyi/Source/master/img/info/blogInfoV2.png" type="image/png"/>
    </item>
    <item>
      <title>RabbitMQ基础教程之使用进阶篇</title>
      <link>https://liuyueyi.github.io/tutorial/db/rabbitmq/RabbitMQ%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E4%BD%BF%E7%94%A8%E8%BF%9B%E9%98%B6%E7%AF%87.html</link>
      <guid>https://liuyueyi.github.io/tutorial/db/rabbitmq/RabbitMQ%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E4%BD%BF%E7%94%A8%E8%BF%9B%E9%98%B6%E7%AF%87.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">RabbitMQ基础教程之使用进阶篇</source>
      <description>RabbitMQ基础教程之使用进阶篇 相关博文，推荐查看: RabbitMq基础教程之安装与测试 RabbitMq基础教程之基本概念 RabbitMQ基础教程之基本使用篇</description>
      <category>开源</category>
      <category>RabbitMQ</category>
      <pubDate>Tue, 29 May 2018 22:12:42 GMT</pubDate>
      <content:encoded><![CDATA[<h1> RabbitMQ基础教程之使用进阶篇</h1>
<p>相关博文，推荐查看:</p>
<ol>
<li><a href="https://liuyueyi.github.io/hexblog/2018/05/24/RabbitMq%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%AE%89%E8%A3%85%E4%B8%8E%E6%B5%8B%E8%AF%95/" target="_blank" rel="noopener noreferrer">RabbitMq基础教程之安装与测试</a></li>
<li><a href="https://liuyueyi.github.io/hexblog/2018/05/27/RabbitMQ%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/" target="_blank" rel="noopener noreferrer">RabbitMq基础教程之基本概念</a></li>
<li><a href="https://liuyueyi.github.io/hexblog/2018/05/27/RabbitMQ%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E7%AF%87/" target="_blank" rel="noopener noreferrer">RabbitMQ基础教程之基本使用篇</a></li>
</ol>
<h2> I. 背景</h2>
<p>前一篇基本使用篇的博文中，介绍了rabbitmq的三种使用姿势，可以知道如何向RabbitMQ发送消息以及如何消费，但遗留下几个疑问，本篇则主要希望弄清楚这几点</p>
<ul>
<li>Exchange声明的问题（是否必须声明，如果不声明会怎样）</li>
<li>Exchange声明的几个参数（durable, autoDelete)有啥区别</li>
<li>当没有队列和Exchange绑定时，直接往队列中塞数据，好像不会有数据增加（即先塞数据，然后创建queue，建立绑定，从控制台上看这个queue里面也不会有数据）</li>
<li>消息消费的两种姿势（一个主动去拿数据，一个是rabbit推数据）对比</li>
</ul>
<!--more-->
<h2> II. 基本进阶篇</h2>
<h3> 1. Exchange默认场景</h3>
<p>将前面的消息发送代码捞出来，干掉Exchange的声明，如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在发布消息时，传入的Exchange名为“”，再到控制台查看，发现数据被投递到了(AMQP default)这个交换器，对应的截图如下</p>
<figure><img src="https://s3.mogucdn.com/mlcdn/c45406/180529_7ldfg754d4hkll48hieif795215c0_1258x554.jpg" alt="image" tabindex="0" loading="lazy"><figcaption>image</figcaption></figure>
<p>看一下上面的绑定描述内容，重点如下</p>
<ul>
<li>默认交换器选择Direct策略</li>
<li>将rountingKey绑定到同名的queue上</li>
<li>不支持显示的绑定和解绑</li>
</ul>
<p>上面的代码为了演示数据的流向，在发布消息的同时也定义了一个同名的Queue，因此可以在控制台上看到同名的 "hello" queue，且内部有20条数据</p>
<p>当我们去掉queue的声明时，会发现另一个问题，投入的数据好像并没有存下来（因为没有queue来接收这些数据，而之后再声明queue时，之前的数据也不会分配过来）</p>
<h3> 2. 绑定之后才有数据</h3>
<p>首先是将控制台中的hello这个queue删掉，然后再次执行下面的代码(相对于前面的就是注释了queue的声明）</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后从控制台上看，可以看到有数据写入Exchange，但是没有queue来接收这些数据</p>
<figure><img src="https://s3.mogucdn.com/mlcdn/c45406/180529_1g44hafbfeg8gf3g7a15ggggljgcc_718x326.jpg" alt="IMAGE" tabindex="0" loading="lazy"><figcaption>IMAGE</figcaption></figure>
<p>然后开启消费进程，然后再次执行上面的塞入数据，新后面重新塞入的数据可以被消费；但是之前塞入的数据则没有，消费消息的代码如下:</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>小结：</strong></p>
<ul>
<li>通过上面的演示得知一点</li>
<li>当没有Queue绑定到Exchange时，往Exchange中写入的消息也不会重新分发到之后绑定的queue上</li>
</ul>
<h3> 3. Durable, autoDeleted参数</h3>
<p>在定义Queue时，可以指定这两个参数，这两个参数的区别是什么呢？</p>
<h4> a. durable</h4>
<p>持久化，保证RabbitMQ在退出或者crash等异常情况下数据没有丢失，需要将queue，exchange和Message都持久化。</p>
<p>若是将queue的持久化标识durable设置为true,则代表是一个持久的队列，那么在服务重启之后，也会存在，因为服务会把持久化的queue存放在硬盘上，当服务重启的时候，会重新什么之前被持久化的queue。队列是可以被持久化，但是里面的消息是否为持久化那还要看消息的持久化设置。也就是说，重启之前那个queue里面还没有发出去的消息的话，重启之后那队列里面是不是还存在原来的消息，这个就要取决于发生着在发送消息时对消息的设置</p>
<h3> b. autoDeleted</h3>
<p>自动删除，如果该队列没有任何订阅的消费者的话，该队列会被自动删除。这种队列适用于临时队列</p>
<p>这个比较容易演示了，当一个Queue被设置为自动删除时，当消费者断掉之后，queue会被删除，这个主要针对的是一些不是特别重要的数据，不希望出现消息积累的情况</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> c. 小结</h4>
<ul>
<li>当一个Queue已经声明好了之后，不能更新durable或者autoDelted值；当需要修改时，需要先删除再重新声明</li>
<li>消费的Queue声明应该和投递的Queue声明的 durable,autoDelted属性一致，否则会报错</li>
<li>对于重要的数据，一般设置 <code>durable=true, autoDeleted=false</code></li>
<li>对于设置 <code>autoDeleted=true</code> 的队列，当没有消费者之后，队列会自动被删除</li>
</ul>
<h3> 4. ACK</h3>
<p>执行一个任务可能需要花费几秒钟，你可能会担心如果一个消费者在执行任务过程中挂掉了。一旦RabbitMQ将消息分发给了消费者，就会从内存中删除。在这种情况下，如果正在执行任务的消费者宕机，会丢失正在处理的消息和分发给这个消费者但尚未处理的消息。
但是，我们不想丢失任何任务，如果有一个消费者挂掉了，那么我们应该将分发给它的任务交付给另一个消费者去处理。</p>
<p>为了确保消息不会丢失，RabbitMQ支持消息应答。消费者发送一个消息应答，告诉RabbitMQ这个消息已经接收并且处理完毕了。RabbitMQ就可以删除它了。</p>
<p>因此手动ACK的常见手段</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>手动ack时，有个<code>multiple</code>，其含义表示:</p>
<p>可以理解为每个Channel维护一个unconfirm的消息序号集合，每publish一条数据，集合中元素加1，每回调一次handleAck方法，unconfirm集合删掉相应的一条(multiple=false)或多条(multiple=true)记录</p>
<h2> III. 其他</h2>
<h3> 1. 参考</h3>
<p><a href="http://www.rabbitmq.com/api-guide.html" target="_blank" rel="noopener noreferrer">Java Client API Guide</a></p>
<h3> 2. <a href="https://liuyueyi.github.io/hexblog" target="_blank" rel="noopener noreferrer">一灰灰Blog</a>： <a href="https://liuyueyi.github.io/hexblog" target="_blank" rel="noopener noreferrer">https://liuyueyi.github.io/hexblog</a></h3>
<p>一灰灰的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛</p>
<h3> 3. 声明</h3>
<p>尽信书则不如，已上内容，纯属一家之言，因个人能力有限，难免有疏漏和错误之处，如发现bug或者有更好的建议，欢迎批评指正，不吝感激</p>
<ul>
<li>微博地址: <a href="https://weibo.com/p/1005052169825577/home" target="_blank" rel="noopener noreferrer">小灰灰Blog</a></li>
<li>QQ： 一灰灰/3302797840</li>
</ul>
<h3> 4. 扫描关注</h3>
<figure><img src="https://raw.githubusercontent.com/liuyueyi/Source/master/img/info/blogInfoV2.png" alt="QrCode" tabindex="0" loading="lazy"><figcaption>QrCode</figcaption></figure>
]]></content:encoded>
      <enclosure url="https://s3.mogucdn.com/mlcdn/c45406/180529_7ldfg754d4hkll48hieif795215c0_1258x554.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>RabbitMQ基础教程之基于配置的消费者实现</title>
      <link>https://liuyueyi.github.io/tutorial/db/rabbitmq/RabbitMQ%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%9F%BA%E4%BA%8E%E9%85%8D%E7%BD%AE%E7%9A%84%E6%B6%88%E8%B4%B9%E8%80%85%E5%AE%9E%E7%8E%B0.html</link>
      <guid>https://liuyueyi.github.io/tutorial/db/rabbitmq/RabbitMQ%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%9F%BA%E4%BA%8E%E9%85%8D%E7%BD%AE%E7%9A%84%E6%B6%88%E8%B4%B9%E8%80%85%E5%AE%9E%E7%8E%B0.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">RabbitMQ基础教程之基于配置的消费者实现</source>
      <description>RabbitMQ基础教程之基于配置的消费者实现 相关博文，推荐查看: RabbitMq基础教程之安装与测试 RabbitMq基础教程之基本概念 RabbitMQ基础教程之基本使用篇 RabbitMQ基础教程之使用进阶篇 RabbitMQ基础教程之Spring&amp;amp;JavaConfig使用篇 RabbitMQ基础教程之Spring-JavaConfig-FactoryBean使用姿势</description>
      <category>开源</category>
      <category>RabbitMQ</category>
      <pubDate>Tue, 05 Jun 2018 19:52:51 GMT</pubDate>
      <content:encoded><![CDATA[<h1> RabbitMQ基础教程之基于配置的消费者实现</h1>
<p>相关博文，推荐查看:</p>
<ol>
<li><a href="https://liuyueyi.github.io/hexblog/2018/05/24/RabbitMq%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%AE%89%E8%A3%85%E4%B8%8E%E6%B5%8B%E8%AF%95/" target="_blank" rel="noopener noreferrer">RabbitMq基础教程之安装与测试</a></li>
<li><a href="https://liuyueyi.github.io/hexblog/2018/05/27/RabbitMQ%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/" target="_blank" rel="noopener noreferrer">RabbitMq基础教程之基本概念</a></li>
<li><a href="https://liuyueyi.github.io/hexblog/2018/05/27/RabbitMQ%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E7%AF%87/" target="_blank" rel="noopener noreferrer">RabbitMQ基础教程之基本使用篇</a></li>
<li><a href="https://liuyueyi.github.io/hexblog/2018/05/29/RabbitMQ%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E4%BD%BF%E7%94%A8%E8%BF%9B%E9%98%B6%E7%AF%87/" target="_blank" rel="noopener noreferrer">RabbitMQ基础教程之使用进阶篇</a></li>
<li><a href="https://blog.hhui.top/hexblog/2018/05/31/RabbitMQ%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8BSpring-JavaConfig%E4%BD%BF%E7%94%A8%E7%AF%87/" target="_blank" rel="noopener noreferrer">RabbitMQ基础教程之Spring&amp;JavaConfig使用篇</a></li>
<li><a href="https%3A%2F%2Fblog.hhui.top%2Fhexblog%2F2018%2F05%2F31%2FRabbitMQ%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8BSpring-JavaConfig-FactoryBean%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF%2F">RabbitMQ基础教程之Spring-JavaConfig-FactoryBean使用姿势</a></li>
</ol>
<p>前面一篇介绍了使用工厂方式创建消费者，其中一个不太友好的地方就在配置都是硬编码的方式，不太灵活，那么是否可以结合前一篇的FactoryBean来实现从配置中来灵活的创建消费者呢？</p>
<!--more-->
<h2> I. 动态配置实现消费者程序</h2>
<h3> 1. 配置文件加载</h3>
<p>首先就是需要从配置文件中获取相应的配置信息，借助JavaConfig，加一个注解即可</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>主要就是 <code>@PropertySource("classpath:dynamicConfig.properties")</code> ， 表示从dynamicConfig.properties文件中读取相应的配置，而这些配置，会存放在 <code>Environment</code> 容器内；</p>
<p>获取配置的方式，就是通过<code>org.springframework.core.env.PropertyResolver#getProperty(java.lang.String)</code>获取</p>
<h3> 2. 消费者通用实现</h3>
<p>实现一个简单的通用的消费端，主要根据前一篇博文中定义的<code>MQContainerFactory</code>，来生成<code>SimpleMessageListenerContainer</code>，然后注入消费服务，并启动容器</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面是一个非常简单的实现，针对常见的的RabbitMQ消息消费而言，也可以写一个泛型类，然后借助Spring的事件机制，实现一个通用的消费端，一种case如下:</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果message中的数据，是通过Json序列化方式存入，则使用方，只需要监听对应的Event消费数据即可，完全不用再关系消费端的情况了</p>
<h3> 3. MQContainerFactory 初始化</h3>
<p>根据配置文件中的信息，初始化factory，这个可谓是最关键的地方了，实现也和之前大致类似，只不过是将硬编码改成配置信息读取而已，完整的配置文件如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4. 测试</h3>
<p>配置文件内容：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>测试方法</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>执行之后，就可以看到正常的消费了</p>
<h3> 5. 扩充与小结</h3>
<p>看完之后，可能有一个问题，为什么要这样做，好处是什么？</p>
<p>大部分的时候，从MQ获取消息的逻辑都一样，唯一的区别在于获取到数据之后做的业务而言，如果把这一块完全的抽象出来，通过配置的方式，那么额外的新增mq的消费，就不需要再改消费端的代码了，然后就会有一个疑问，上面的配置文件中，生成dynamicConsumer的bean不也是需要额外写么？</p>
<p>如果将配置信息，以某种数组的方式定义，遍历读取这些配置，然后创建多个DynamicConsuer实例，是否就能支持动态扩展呢？</p>
<p>将配置改成下面的进行尝试</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意之前 <code>dynamicConsumer</code> 是bean的创建，改成了初始化一个实例，如果配置文件是数组，内部用一个遍历就可以全部加载，现在就需要验证上面的配置改动之后，是否依然可以消费数据</p>
<p>实测ok，部分输出如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> II. 其他</h2>
<h3> 项目地址</h3>
<ul>
<li><a href="https://gitee.com/liuyueyi/study-demo/tree/master/spring-rabbit" target="_blank" rel="noopener noreferrer">六月/study-demo</a></li>
</ul>
<h3> <a href="https://liuyueyi.github.io/hexblog" target="_blank" rel="noopener noreferrer">一灰灰Blog</a>： <a href="https://liuyueyi.github.io/hexblog" target="_blank" rel="noopener noreferrer">https://liuyueyi.github.io/hexblog</a></h3>
<p>一灰灰的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛</p>
<h3> 声明</h3>
<p>尽信书则不如，已上内容，纯属一家之言，因个人能力有限，难免有疏漏和错误之处，如发现bug或者有更好的建议，欢迎批评指正，不吝感激</p>
<ul>
<li>微博地址: <a href="https://weibo.com/p/1005052169825577/home" target="_blank" rel="noopener noreferrer">小灰灰Blog</a></li>
<li>QQ： 一灰灰/3302797840</li>
</ul>
<h3> 扫描关注</h3>
<figure><img src="https://raw.githubusercontent.com/liuyueyi/Source/master/img/info/blogInfoV2.png" alt="QrCode" tabindex="0" loading="lazy"><figcaption>QrCode</figcaption></figure>
]]></content:encoded>
      <enclosure url="https://raw.githubusercontent.com/liuyueyi/Source/master/img/info/blogInfoV2.png" type="image/png"/>
    </item>
    <item>
      <title>RabbitMQ基础教程之基本使用篇</title>
      <link>https://liuyueyi.github.io/tutorial/db/rabbitmq/RabbitMQ%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E7%AF%87.html</link>
      <guid>https://liuyueyi.github.io/tutorial/db/rabbitmq/RabbitMQ%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E7%AF%87.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">RabbitMQ基础教程之基本使用篇</source>
      <description>RabbitMQ基础教程之基本使用篇 最近因为工作原因使用到RabbitMQ，之前也接触过其他的mq消息中间件，从实际使用感觉来看，却不太一样，正好趁着周末，可以好好看一下RabbitMQ的相关知识点；希望可以通过一些学习，可以搞清楚以下几点 基础环境搭建 可以怎么使用 实现原理是怎样的 实际工程中的使用（比如结合SpringBoot可以怎么玩）</description>
      <category>开源</category>
      <category>RabbitMQ</category>
      <pubDate>Sun, 27 May 2018 22:16:11 GMT</pubDate>
      <content:encoded><![CDATA[<h1> RabbitMQ基础教程之基本使用篇</h1>
<p>最近因为工作原因使用到RabbitMQ，之前也接触过其他的mq消息中间件，从实际使用感觉来看，却不太一样，正好趁着周末，可以好好看一下RabbitMQ的相关知识点；希望可以通过一些学习，可以搞清楚以下几点</p>
<ul>
<li>基础环境搭建</li>
<li>可以怎么使用</li>
<li>实现原理是怎样的</li>
<li>实际工程中的使用（比如结合SpringBoot可以怎么玩）</li>
</ul>
<!-- more -->
<p>相关博文，欢迎查看：</p>
<ul>
<li><a href="https://liuyueyi.github.io/hexblog/2018/05/24/RabbitMq%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%AE%89%E8%A3%85%E4%B8%8E%E6%B5%8B%E8%AF%95/" target="_blank" rel="noopener noreferrer">《RabbitMq基础教程之安装与测试》</a></li>
<li><a href="https://liuyueyi.github.io/hexblog/2018/05/27/RabbitMQ%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/" target="_blank" rel="noopener noreferrer">《RabbitMq基础教程之基本概念》</a></li>
</ul>
<h2> I. 前提准备</h2>
<p>在开始之前，先得搭建基本的环境，因为个人主要是mac进行的开发，所有写了一篇mac上如何安装rabbitmq的教程，可以通过 <a href="https://liuyueyi.github.io/hexblog/2018/05/24/RabbitMq%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%AE%89%E8%A3%85%E4%B8%8E%E6%B5%8B%E8%AF%95/" target="_blank" rel="noopener noreferrer">《mac下安装和测试rabbitmq》</a> 查看</p>
<h3> 1. Centos安装过程</h3>
<p>下面简单说一下Linux系统下，可以如何安装</p>
<p>Centos 系统：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>启动和查看的命令</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 注意</h3>
<ul>
<li>安装完毕之后，可以开启控制台，主要就是 <code>rabbitmq-plugins enable rabbitmq_management</code>, 默认的端口号为15672</li>
<li>默认分配的用户/密码为: guest/guest， 只允许本地访问；如果跨应用读写数据时，请添加账号和设置对应的权限（推荐参考上面mac安装的博文，里面有介绍）</li>
</ul>
<h2> II. 基本使用篇</h2>
<p>直接使用amqp-client客户端做基本的数据读写，先不考虑Spring容器的场景，我们可以怎样进行塞数据，然后又怎样可以从里面获取数据；</p>
<p>在实际使用之前，有必要了解一下RabbitMQ的几个基本概念，即什么是Queue,Exchange,Binding，关于这些基本概念，可以参考博文：</p>
<ul>
<li><a href="https://liuyueyi.github.io/hexblog/2018/05/27/RabbitMQ%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/" target="_blank" rel="noopener noreferrer">《RabbitMq基础教程之基本概念》</a></li>
</ul>
<h3> 1. 基本使用姿势</h3>
<p>首先是建立连接，一般需要设置服务器的IP，端口号，用户名密码之类的，公共代码如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> a. 生产者</h4>
<p>要使用，基本的就需要一个消息投递和一个消息消费两方，线看消息生产者的一般写法</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>针对上面的代码，结合RabbitMQ的基本概念进行分析</p>
<figure><img src="https://s3.mogucdn.com/mlcdn/c45406/180527_7bdj5djf0ae798la210a9ila83874_927x265.jpg" alt="基本结构" tabindex="0" loading="lazy"><figcaption>基本结构</figcaption></figure>
<ul>
<li>不管是干啥，第一步都是获取连接，也就是上面的Connection</li>
<li>从<a href="https://liuyueyi.github.io/hexblog/2018/05/27/RabbitMQ%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/" target="_blank" rel="noopener noreferrer">《RabbitMq基础教程之基本概念》</a>直到，生产者消费者都是借助Channel与Exchange或者Queue打交道，接下来就是通过Connection创建数据流通信道Channel</li>
<li>Channel准备完毕之后，生产者就可以向其中投递数据</li>
<li>投递完毕之后，回收现场资源</li>
</ul>
<p><strong>疑问：</strong></p>
<ul>
<li>在声明Exchange时，是否就需要选择消息绑定策略？</li>
<li>不声明时，默认是什么策略？</li>
</ul>
<h4> b. 消费者</h4>
<p>结合上面的代码和分析，大胆的预测下消费者的流程</p>
<ul>
<li>获取连接Connection</li>
<li>创建Channel</li>
<li>将Channel与Queue进行绑定</li>
<li>创建一个Consumer，从Queue中获取数据</li>
<li>消息消费之后，ack</li>
</ul>
<p>下面给出一个mq推数据的消费过程</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. Direct方式</h3>
<h4> a. Producer</h4>
<p>直接在前面的基础上进行测试，我们定义一个新的exchange名为<code>direct.exchange</code>，并且制定ExchangeType为直接路由方式 （先不管这种写法的合理性）</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的代码执行一遍之后，看控制台会发现新增了一个Exchange</p>
<figure><img src="https://s3.mogucdn.com/mlcdn/c45406/180527_63jeb3gde7blekh0h339hh15j6g3c_776x553.jpg" alt="exchange" tabindex="0" loading="lazy"><figcaption>exchange</figcaption></figure>
<h4> b. consumer</h4>
<p>同样的我们写一下对应的消费者，一个用来消费aaa,一个消费bbb</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>执行上面的代码之后，就会多两个Queue，且增加了Exchange到Queue的绑定</p>
<figure><img src="https://s3.mogucdn.com/mlcdn/c45406/180527_380i3biee3hb952000b5likjg2dcg_822x546.jpg" alt="binding" tabindex="0" loading="lazy"><figcaption>binding</figcaption></figure>
<figure><img src="https://s3.mogucdn.com/mlcdn/c45406/180527_21e9cgd5cb89hc5el0k7139ke884e_857x132.jpg" alt="queue" tabindex="0" loading="lazy"><figcaption>queue</figcaption></figure>
<p>当上面两个代码配合起来使用时，就可以看到对于消费者而言，qa一直消费的是偶数，qb一直消费的是奇数，一次输出如下:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. Fanout方式</h3>
<p>有了上面的case之后，这个的实现和测试就比较简单了</p>
<h4> a. Producer</h4>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> b. consumer</h4>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个的输出就比较有意思了，fa,fb两个队列都可以接收到发布的消息，而且单独的执行一次上面的投递数据之后，发现fa/fb两个队列的数据都是30条</p>
<figure><img src="https://s11.mogucdn.com/mlcdn/c45406/180527_4jilj697dgfhf7fdca91a688a4gck_859x197.jpg" alt="30" tabindex="0" loading="lazy"><figcaption>30</figcaption></figure>
<p>然后消费的结果如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4. Topic方式</h3>
<p>代码和上面差不多，就不重复拷贝了，接下来卡另外几个问题</p>
<h2> III. 基础进阶</h2>
<p>在上面的基础使用中，会有几个疑问如下：</p>
<ul>
<li>Exchange声明的问题（是否必须声明，如果不声明会怎样）</li>
<li>Exchange声明的几个参数（durable, autoDelete)有啥区别</li>
<li>当没有队列和Exchange绑定时，直接往队列中塞数据，好像不会有数据增加（即先塞数据，然后创建queue，建立绑定，从控制台上看这个queue里面也不会有数据）</li>
<li>消息消费的两种姿势（一个主动去拿数据，一个是rabbit推数据）对比</li>
<li>ack/nack怎么用，nack之后消息可以怎么处理</li>
</ul>
<p>以上内容，留待下一篇进行讲解</p>
<h2> IV. 其他</h2>
<h3> 1. 相关博文</h3>
<ul>
<li><a href="https://liuyueyi.github.io/hexblog/2018/05/24/RabbitMq%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%AE%89%E8%A3%85%E4%B8%8E%E6%B5%8B%E8%AF%95/" target="_blank" rel="noopener noreferrer">《RabbitMq基础教程之安装与测试》</a></li>
<li><a href="https://liuyueyi.github.io/hexblog/2018/05/27/RabbitMQ%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/" target="_blank" rel="noopener noreferrer">《RabbitMq基础教程之基本概念》</a></li>
</ul>
<h3> 2. <a href="https://liuyueyi.github.io/hexblog" target="_blank" rel="noopener noreferrer">一灰灰Blog</a>： <a href="https://liuyueyi.github.io/hexblog" target="_blank" rel="noopener noreferrer">https://liuyueyi.github.io/hexblog</a></h3>
<p>一灰灰的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛</p>
<h3> 3. 声明</h3>
<p>尽信书则不如，已上内容，纯属一家之言，因个人能力有限，难免有疏漏和错误之处，如发现bug或者有更好的建议，欢迎批评指正，不吝感激</p>
<ul>
<li>微博地址: <a href="https://weibo.com/p/1005052169825577/home" target="_blank" rel="noopener noreferrer">小灰灰Blog</a></li>
<li>QQ： 一灰灰/3302797840</li>
</ul>
<h3> 4. 扫描关注</h3>
<figure><img src="https://raw.githubusercontent.com/liuyueyi/Source/master/img/info/blogInfoV2.png" alt="QrCode" tabindex="0" loading="lazy"><figcaption>QrCode</figcaption></figure>
]]></content:encoded>
      <enclosure url="https://s3.mogucdn.com/mlcdn/c45406/180527_7bdj5djf0ae798la210a9ila83874_927x265.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>RabbitMq基础教程之基本概念</title>
      <link>https://liuyueyi.github.io/tutorial/db/rabbitmq/RabbitMQ%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5.html</link>
      <guid>https://liuyueyi.github.io/tutorial/db/rabbitmq/RabbitMQ%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">RabbitMq基础教程之基本概念</source>
      <description>RabbitMq基础教程之基本概念 RabbitMQ是一个消息队列，和Kafka以及阿里的ActiveMQ从属性来讲，干的都是一回事。消息队列的主要目的实现消息的生产者和消费者之间的解耦，支持多应用之间的异步协调工作 由于工作原因，接触和使用rabbitmq作为生产环境下的消息队列，因此准备写一些博文，记录下这个过程中的收货；而开篇除了环境搭建之外，就是对于其内部的基本概念进行熟悉和了解了。 基础环境搭建可以参考： 《RabbitMq基础教程之安装与测试》 本文则主要集中在以下几点： 几个基本概念（Message, Publisher, Exchange, Binding, Queue, Channel, Consuer, Virtual host) 消息分发的几种策略 ACK是什么鬼</description>
      <category>开源</category>
      <category>RabbitMQ</category>
      <pubDate>Sun, 27 May 2018 11:12:23 GMT</pubDate>
      <content:encoded><![CDATA[<h1> RabbitMq基础教程之基本概念</h1>
<p>RabbitMQ是一个消息队列，和Kafka以及阿里的ActiveMQ从属性来讲，干的都是一回事。消息队列的主要目的实现消息的生产者和消费者之间的解耦，支持多应用之间的异步协调工作</p>
<p>由于工作原因，接触和使用rabbitmq作为生产环境下的消息队列，因此准备写一些博文，记录下这个过程中的收货；而开篇除了环境搭建之外，就是对于其内部的基本概念进行熟悉和了解了。</p>
<p>基础环境搭建可以参考： <a href="https://liuyueyi.github.io/hexblog/2018/05/24/RabbitMq%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%AE%89%E8%A3%85%E4%B8%8E%E6%B5%8B%E8%AF%95/" target="_blank" rel="noopener noreferrer">《RabbitMq基础教程之安装与测试》</a></p>
<p>本文则主要集中在以下几点：</p>
<ul>
<li>几个基本概念（Message, Publisher, Exchange, Binding, Queue, Channel, Consuer, Virtual host)</li>
<li>消息分发的几种策略</li>
<li>ACK是什么鬼</li>
</ul>
<!-- more -->
<h2> I. 基本概念</h2>
<h3> 1. 消息队列</h3>
<p>首先来一张消息队列的经典图，可以划分为三个角色: Producer, Queue, Consumer</p>
<figure><img src="https://s11.mogucdn.com/mlcdn/c45406/180527_6h706e73aa1f93768ie2ac83i3i72_949x221.jpg" alt="IMAGE" tabindex="0" loading="lazy"><figcaption>IMAGE</figcaption></figure>
<ul>
<li>Queue：为承载消息的容器，为什么是队列而不是栈呢？主要是因为绝大部分的场景，我们都是希望消息是先进先出，有顺序的</li>
<li>Producer：生产者，就是产生消息，并不断往队列塞的角色</li>
<li>Consumer：消费者，也就是不断从队列中获取消息的角色</li>
</ul>
<p>看到这个模型，如果对JDK的容器有一定的了解，很容易可以想到借助 <code>ArrayBlockingQueue</code> 或者 <code>ListBlockingQueue</code> 就可以实现简易的消息队列（也就是我们常说的生产者-消费者模型）</p>
<h3> 2. 实例理解消息队列</h3>
<p>其实在生活中，这种模型用得非常多，就比如我们都会接触的网购快递，可以说是一个典型的消息队列的case了：</p>
<p>商家不断的把商品扔给快递公司（注意不是直接将商品给买家），而快递公司则将商品根据地质分发对应的买家</p>
<p>对上面这个过程进行拆解，可以映射扮演的角色</p>
<ul>
<li>商品：Message，传递的消息，由商家投递给快递公司时，需要进行打包（一般Producer生产消息也会将实体数据进行封装）</li>
<li>商家：Produer 生产者</li>
<li>快递公司： Queue，消息的载体</li>
<li>买家：Consumer 消费者</li>
</ul>
<p>那么快递公司时怎么知道要把商品给对应的买家呢？根据包裹上的地址+电话</p>
<ul>
<li>同样消息队列也需要一个映射规则，实现Message和Consumer之间的路由</li>
</ul>
<h3> 3. RabbitMQ基本概念</h3>
<p>通过上面的实例对比，发现基本的消息队列定义的元素太少，这里则正好可以看一下RabbitMQ是怎么具体来实现消息队列的</p>
<figure><img src="https://s3.mogucdn.com/mlcdn/c45406/180527_7bdj5djf0ae798la210a9ila83874_927x265.jpg" alt="内部结构图" tabindex="0" loading="lazy"><figcaption>内部结构图</figcaption></figure>
<ul>
<li>Message：消息，包含消息头（即附属的配置信息）和消息体（即消息的实体内容）</li>
<li>Publisher：生产者，向交换机发布消息的主体</li>
<li>Exchange：交换机，用来接收生产者发送的消息并将这些消息路由给服务器中的队列</li>
<li>Binding：绑定，用于给Exchange和Queue建立关系，就是我们熟知的配对的红娘</li>
<li>Queue：消息队列，用来保存消息直到发送给消费者。它是消息的容器，也是消息的终点。一个消息可投入一个或多个队列。消息一直在队列里面，等待消费者连接到这个队列将其取走。</li>
<li>Connection：连接</li>
<li>Channel：通道，MQ与外部打交道都是通过Channel来的，发布消息、订阅队列还是接收消息，这些动作都是通过Channel完成；简单来说就是消息通过Channel塞进队列或者流出队列</li>
<li>Consumer：消费者，从消息队列中获取消息的主体</li>
<li>Virtual Host: 虚拟主机，表示一批交换器、消息队列和相关对象。虚拟主机是共享相同的身份认证和加密环境的独立服务器域。每个 vhost 本质上就是一个 mini 版的 RabbitMQ 服务器，拥有自己的队列、交换器、绑定和权限机制。vhost 是 AMQP 概念的基础，必须在连接时指定，RabbitMQ 默认的 vhost 是 /</li>
<li>Broker：消息队列服务器实体</li>
</ul>
<p>上面是一些专业的概念，那么可以怎么映射到前面的快递上呢？</p>
<h2> II. Exchange类型</h2>
<p>生产者，将消息投递给Exchange，然后由Exchange将消息路由到对应的Queue上，供消费者消费，那么这个路由有哪些方式呢？</p>
<h3> 1. Direct策略</h3>
<figure><img src="https://s3.mogucdn.com/mlcdn/c45406/180527_1fe0g1g39eafjdj4e0k1d8hj65bif_385x298.jpg" alt="IMAGE" tabindex="0" loading="lazy"><figcaption>IMAGE</figcaption></figure>
<p>消息中的路由键（routing key）如果和 Binding 中的 binding key 一致， 交换器就将消息发到对应的队列中</p>
<p>简单来讲，就是路由键与队列名完全匹配</p>
<ul>
<li>如果一个队列绑定到交换机要求路由键为“dog”</li>
<li>只转发 routing key 标记为“dog”的消息，</li>
<li>不会转发“dog.puppy”，也不会转发“dog.guard”等等</li>
<li>它是完全匹配、单播的模式</li>
</ul>
<p>举例说明</p>
<figure><img src="https://s11.mogucdn.com/mlcdn/c45406/180527_7h1b1g7d1ajle2ablh7gk71dd3lca_707x241.jpg" alt="IMAGE" tabindex="0" loading="lazy"><figcaption>IMAGE</figcaption></figure>
<p>Exchange和两个队列绑定在一起：</p>
<ul>
<li>Q1的bindingkey是orange</li>
<li>Q2的binding key是black和green.</li>
<li>当Producer publish key是orange时, exchange会把它放到Q1上, 如果是black或green就会到Q2上, 其余的Message被丢弃</li>
</ul>
<h3> 2. Fanout策略</h3>
<figure><img src="https://s3.mogucdn.com/mlcdn/c45406/180527_0j71hl8a1fhbjlb745hfi2d8acc6g_463x317.jpg" alt="IMAGE" tabindex="0" loading="lazy"><figcaption>IMAGE</figcaption></figure>
<p>从上图也可以看出，这种策略，将忽略所谓的routing key,将消息分发到所有绑定的Queue上，更加类似我们理解的广播模式</p>
<h3> 3. Topic策略</h3>
<figure><img src="https://s11.mogucdn.com/mlcdn/c45406/180527_1af6hb4k3ja5df983cc98db3i44j6_558x251.jpg" alt="IMAGE" tabindex="0" loading="lazy"><figcaption>IMAGE</figcaption></figure>
<p>topic 交换器通过模式匹配分配消息的路由键属性，将路由键和某个模式进行匹配，此时队列需要绑定到一个模式上</p>
<p>可以理解为直接策略的进阶版，直接策略是完全精确匹配，而topic则支持正则匹配，满足某类指定规则的（如以xxx开头的路由键），可以键消息分发过去</p>
<ul>
<li><code>#</code> 匹配0个或多个单词</li>
<li><code>*</code> 匹配不多不少一个单词</li>
</ul>
<p><strong>一个更直观的实例如下</strong></p>
<figure><img src="https://s11.mogucdn.com/mlcdn/c45406/180527_6ff26k8dh11gaeb570i055h07ba3d_731x247.jpg" alt="IMAGE" tabindex="0" loading="lazy"><figcaption>IMAGE</figcaption></figure>
<p>Producer发送消息时需要设置routing_key,</p>
<ul>
<li>Q1 的binding key 是”.orange.“</li>
<li>Q2 是 “<em>.</em>.rabbit” 和 “lazy.#”：</li>
<li>产生一个 <code>test.orange.mm</code> 消息，则会路由到Q1；而如果是 <code>test.orange</code>则无法路由到Q1,因为Q1的规则是三个单词，中间一个为orange，不满足这个规则的都无效</li>
<li>产生一个 <code>test.qq.rabbit</code> 或者 <code>lazy.qq</code> 都可以分发到Q2；即路由key为三个单词，最后一个为rabbit或者不限制单词个数，主要第一个是lazy的消息，都可以分发过来</li>
<li>如果产生的是一个 <code>test.orange.rabbit</code>消息，则Q1和Q2都可以满足</li>
</ul>
<h3> 4. Headers策略</h3>
<p>这个实际上用得不多，它是根据Message的一些头部信息来分发过滤Message，忽略routing key的属性，如果Header信息和message消息的头信息相匹配</p>
<h3> 5. 小结</h3>
<p>主要使用的消息分发策略有三个，直接，路由和扇形，简单的小结下应用场景和区别</p>
<h4> a. Direct Exchange</h4>
<p>直接完全匹配模式，适用于精准的消息分发</p>
<h4> b. Topic Exchange</h4>
<p>Routing Key的匹配模式，支持Routing Key的模糊匹配方式，更适用于多类消息的聚合</p>
<h4> c. Fanout Exchange</h4>
<p>忽略Routing Key, 将消息分配给所有的Queue，广播模式，适用于消息的复用场景</p>
<h2> III. ACK</h2>
<p>消息队列的一个重要指标，当有消费者获取了消息之后，对这个消息我应该怎么办？是直接删除还是等某个合适的机会再删除？又或者是干脆不删除，就留着了？</p>
<p>在实际的应用场景中，消息正常消费之后，我们希望的是这个消息就不要了，但是消费的过程中如果出现了bug，则希望不要删除消息，等我修复这个bug后，可以把这个消息重新的投递给我</p>
<h3> 1. ack机制</h3>
<p>Consumer接收到了消息之后，必须返回一个ack的标志，表示消息是否成功消费，如果返回true，则表示消费成功了，然后这个消息就会从RabbitMQ的队列中删掉；如果返回false，且设置为重新入队，则这个消息可以被重新投递进来</p>
<p>通常实际编码中，默认是自动ACK的，如果消息的重要性程度较高，我们应该设置为主动ACK，在接收到消息之后，自主的返回对应的ACK信息</p>
<p>这一块更多地内容可以查看实际使用篇</p>
<h2> IV. 其他</h2>
<h3> 1. 参考</h3>
<ul>
<li><a href="http://www.rabbitmq.com/confirms.html" target="_blank" rel="noopener noreferrer">Consumer Acknowledgements and Publisher Confirms</a></li>
<li><a href="http://www.rabbitmq.com/getstarted.html" target="_blank" rel="noopener noreferrer">RabbitMQ Tutorials</a></li>
<li><a href="https://blog.csdn.net/ww130929/article/details/72842234" target="_blank" rel="noopener noreferrer">RabbitMQ】三种Exchange模式——订阅、路由、通配符模式</a></li>
</ul>
<h3> 2. <a href="https://liuyueyi.github.io/hexblog" target="_blank" rel="noopener noreferrer">一灰灰Blog</a>： <a href="https://liuyueyi.github.io/hexblog" target="_blank" rel="noopener noreferrer">https://liuyueyi.github.io/hexblog</a></h3>
<p>一灰灰的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛</p>
<h3> 3. 声明</h3>
<p>尽信书则不如，已上内容，纯属一家之言，因个人能力有限，难免有疏漏和错误之处，如发现bug或者有更好的建议，欢迎批评指正，不吝感激</p>
<ul>
<li>微博地址: <a href="https://weibo.com/p/1005052169825577/home" target="_blank" rel="noopener noreferrer">小灰灰Blog</a></li>
<li>QQ： 一灰灰/3302797840</li>
</ul>
<h3> 4. 扫描关注</h3>
<figure><img src="https://raw.githubusercontent.com/liuyueyi/Source/master/img/info/blogInfoV2.png" alt="QrCode" tabindex="0" loading="lazy"><figcaption>QrCode</figcaption></figure>
]]></content:encoded>
      <enclosure url="https://s11.mogucdn.com/mlcdn/c45406/180527_6h706e73aa1f93768ie2ac83i3i72_949x221.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>RabbitMQ基础教程之安装与测试</title>
      <link>https://liuyueyi.github.io/tutorial/db/rabbitmq/RabbitMQ%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%AE%89%E8%A3%85%E4%B8%8E%E6%B5%8B%E8%AF%95.html</link>
      <guid>https://liuyueyi.github.io/tutorial/db/rabbitmq/RabbitMQ%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%AE%89%E8%A3%85%E4%B8%8E%E6%B5%8B%E8%AF%95.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">RabbitMQ基础教程之安装与测试</source>
      <description>RabbitMq基础教程之安装与测试 Installing on Mac I. 安装 brew install rabbitmq ## 进入安装目录 cd /usr/local/Cellar/rabbitmq/3.7.5 # 启动 brew services start rabbitmq # 当前窗口启动 rabbitmq-server</description>
      <category>开源</category>
      <category>RabbitMQ</category>
      <pubDate>Thu, 24 May 2018 21:25:16 GMT</pubDate>
      <content:encoded><![CDATA[<h1> RabbitMq基础教程之安装与测试</h1>
<blockquote>
<p><a href="http://www.rabbitmq.com/install-standalone-mac.html" target="_blank" rel="noopener noreferrer">Installing on Mac</a></p>
</blockquote>
<h2> I. 安装</h2>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><!-- more -->
<p>启动控制台之前需要先开启插件</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>进入控制台: <a href="http://localhost:15672/" target="_blank" rel="noopener noreferrer">http://localhost:15672/</a></p>
<p>用户名和密码：<code>guest,guest</code></p>
<h2> II. 配置与测试</h2>
<h3> 1. 添加账号</h3>
<p>首先是得启动mq</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 编码实测</h3>
<p>pom引入依赖</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>开始写代码</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>需要注意的一点是：</p>
<ul>
<li>生产消息: <code>channel.queueDeclare(QUEUE_NAME, true, false, false, null);</code></li>
<li>消费消息: <code>channel.queueDeclare(QUEUE_NAME, true, false, false, null);</code></li>
<li>生产和消费都声明channel，要求两者的配置参数一致，否则无法消费数据</li>
</ul>
<h3> 3. 输出说明</h3>
<p>首先执行塞入数据，执行完毕之后，可以到控制台进行查看:</p>
<figure><img src="https://s3.mogucdn.com/mlcdn/c45406/180524_4khh6fe70jb46jc1dci56kj703ga0_731x471.png" alt="out" tabindex="0" loading="lazy"><figcaption>out</figcaption></figure>
<p>可以看到多出了一个Queue，对列名为hello，总共有10条数据</p>
<hr>
<p>接下来就是消费数据了，执行consumer方法，输出日志</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>回头去查看queue，发现总得数据量为0了</p>
<h3> 4. ACK问题</h3>
<p>对于ack的问题，如果在消费数据的时候，出现异常，而我不希望数据丢失，这个时候就需要考虑手动ack的机制来保证了</p>
<p>首先需要设置手动ack</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>其次在消费数据完毕之后，主动ack/nack</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> III. 其他</h2>
<h3> <a href="https://liuyueyi.github.io/hexblog" target="_blank" rel="noopener noreferrer">一灰灰Blog</a>： <a href="https://liuyueyi.github.io/hexblog" target="_blank" rel="noopener noreferrer">https://liuyueyi.github.io/hexblog</a></h3>
<p>一灰灰的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛</p>
<h3> 声明</h3>
<p>尽信书则不如，以上内容，纯属一家之言，因个人能力有限，如发现bug或者有更好的建议，随时欢迎批评指正</p>
<ul>
<li>微博地址: <a href="https://weibo.com/p/1005052169825577/home" target="_blank" rel="noopener noreferrer">小灰灰Blog</a></li>
<li>QQ： 一灰灰/3302797840</li>
</ul>
<h3> 扫描关注</h3>
<figure><img src="https://raw.githubusercontent.com/liuyueyi/Source/master/img/info/blogInfoV2.png" alt="QrCode" tabindex="0" loading="lazy"><figcaption>QrCode</figcaption></figure>
]]></content:encoded>
      <enclosure url="https://s3.mogucdn.com/mlcdn/c45406/180524_4khh6fe70jb46jc1dci56kj703ga0_731x471.png" type="image/png"/>
    </item>
    <item>
      <title>Docker</title>
      <link>https://liuyueyi.github.io/tutorial/tool/Docker/</link>
      <guid>https://liuyueyi.github.io/tutorial/tool/Docker/</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">Docker</source>
      <pubDate>Wed, 31 Jul 2024 12:28:49 GMT</pubDate>
    </item>
    <item>
      <title>Git</title>
      <link>https://liuyueyi.github.io/tutorial/tool/GIT/</link>
      <guid>https://liuyueyi.github.io/tutorial/tool/GIT/</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">Git</source>
      <pubDate>Wed, 31 Jul 2024 12:28:49 GMT</pubDate>
    </item>
    <item>
      <title>Linux</title>
      <link>https://liuyueyi.github.io/tutorial/tool/Linux/</link>
      <guid>https://liuyueyi.github.io/tutorial/tool/Linux/</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">Linux</source>
      <pubDate>Wed, 31 Jul 2024 12:28:49 GMT</pubDate>
    </item>
    <item>
      <title>01.IDEA2024全家桶激活图文手册</title>
      <link>https://liuyueyi.github.io/tutorial/tool/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/IDEA2024%E5%85%A8%E5%AE%B6%E6%A1%B6%E6%BF%80%E6%B4%BB%E8%87%AA%E5%8A%A9%E6%89%8B%E5%86%8C.html</link>
      <guid>https://liuyueyi.github.io/tutorial/tool/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/IDEA2024%E5%85%A8%E5%AE%B6%E6%A1%B6%E6%BF%80%E6%B4%BB%E8%87%AA%E5%8A%A9%E6%89%8B%E5%86%8C.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">01.IDEA2024全家桶激活图文手册</source>
      <description>jetbrain全家桶激活自助手册，适用于 2020-2024 版本的idea全家桶，win/linux/mac三系统通配 使用姿势 1. 安装 首先下载安装jetbarin对应的工具 官网地址： https://www.jetbrains.com/zh-cn/ 下载企业版</description>
      <category>开发工具</category>
      <pubDate>Wed, 31 Jul 2024 09:27:46 GMT</pubDate>
      <content:encoded><![CDATA[<p>jetbrain全家桶激活自助手册，适用于 2020-2024 版本的idea全家桶，win/linux/mac三系统通配</p>
<h2> 使用姿势</h2>
<h3> 1. 安装</h3>
<p>首先下载安装jetbarin对应的工具</p>
<p>官网地址： <a href="https://www.jetbrains.com/zh-cn/" target="_blank" rel="noopener noreferrer">https://www.jetbrains.com/zh-cn/</a></p>
<p>下载企业版</p>
<figure><img src="/imgs/240731/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>下载完毕之后，双击，本地直接默认安装</p>
<h3> 2. 激活</h3>
<p>下载破解脚本</p>
<ul>
<li>破解脚本链接: <a href="https://pan.baidu.com/s/1BjghBgpvUkhS6gccXkEYTQ?pwd=6a1k" target="_blank" rel="noopener noreferrer">https://pan.baidu.com/s/1BjghBgpvUkhS6gccXkEYTQ?pwd=6a1k</a></li>
</ul>
<figure><img src="/imgs/240731/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>下载到本地之后进行解压，根据自己的操作系统，选择进入不同的文件夹进行激活</p>
<figure><img src="/imgs/240731/02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>如以windows为例，进入 <code>win2020-2024(一键激活)</code></p>
<figure><img src="/imgs/240731/03.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>然后双击你需要激活的软件对应的vbs脚本，如我现在想激活 <code>PyCharm</code> ，那么就双击 <code>PyCharm激活.vbs</code></p>
<figure><img src="/imgs/240731/04.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>点击打开，然后回弹出一个提示框，告诉你已经激活成功</p>
<figure><img src="/imgs/240731/05.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>接下来就可以打开PyCharm验证一下是否 已经激活成功</p>
<ul>
<li>菜单栏 -&gt; help -&gt; about</li>
</ul>
<figure><img src="/imgs/240731/06.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>当出现上面的提示，那么恭喜你，已经激活成功，可以开始愉快的使用JetBrain的全家桶进行编程了</p>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/240731/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>开发工具</title>
      <link>https://liuyueyi.github.io/tutorial/tool/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/</link>
      <guid>https://liuyueyi.github.io/tutorial/tool/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">开发工具</source>
      <pubDate>Wed, 31 Jul 2024 12:28:49 GMT</pubDate>
    </item>
    <item>
      <title>0. 报警系统QuickAlarm使用手册</title>
      <link>https://liuyueyi.github.io/tutorial/column/app/alarm/00.%E6%8A%A5%E8%AD%A6%E7%B3%BB%E7%BB%9FQuickAlarm%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C.html</link>
      <guid>https://liuyueyi.github.io/tutorial/column/app/alarm/00.%E6%8A%A5%E8%AD%A6%E7%B3%BB%E7%BB%9FQuickAlarm%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">0. 报警系统QuickAlarm使用手册</source>
      <description>本文将主要说明QuickAlarm该如何使用，以及使用时需要注意事项</description>
      <category>Quick系列</category>
      <category>QuickAlarm</category>
      <pubDate>Sun, 11 Feb 2018 18:53:33 GMT</pubDate>
      <content:encoded><![CDATA[<p>本文将主要说明QuickAlarm该如何使用，以及使用时需要注意事项</p>
<!-- more -->
<h2> 1. 基本使用姿势</h2>
<p>首先我们不做任何的自定义操作，全部依靠系统默认的实现，我们的使用步骤如下</p>
<h3> 1. 添加注册文件</h3>
<p>首先在项目的资源目录下，添加注册文件 <code>alarm.properties</code>，文件内容如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>具体存放的位置，可以参考下图，放在resources目录下（源码中，是放在测试资源目录下的）</p>
<figure><img src="https://s3.mogucdn.com/mlcdn/c45406/180211_19i0ckjaic6f22i7hlai52ja471gc_1988x1178.jpg" alt="IMAGE" tabindex="0" loading="lazy"><figcaption>IMAGE</figcaption></figure>
<h3> 2. 添加报警规则</h3>
<p>根据注册文件中指定的路径，设置报警规则文件，如我们的报警规则文件</p>
<p>内容为json串格式，支持格式化的json串解析，为了节省篇幅，下面压缩成一行，点击获取<a href="https://github.com/liuyueyi/PopClip#4-json" target="_blank" rel="noopener noreferrer">json格式化小工具</a></p>
<p><strong>/tmp/alarmConig:</strong></p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 3. 测试类</h3>
<p>一个简单的使用测试</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> II. 报警执行机器扩展</h2>
<p>前面的报警规则配置中，有WEIXIN, SMS, EMAIL的报警，但是系统只提供了两个NONE和LOG，所以我们可以看下如何自定义实现上面的三个</p>
<h3> 1. 实现IExecute接口</h3>
<p>邮件报警</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>短信报警</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>微信报警</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>说明，因为没有具体的实现，所以我们直接用日志输出来模拟，所以就都继承了LogExecute, 实际使用中，可以在上面补上相应的实现代码</p>
<h3> 2. 添加SPI定义</h3>
<p>在 resources 目录下，新增</p>
<ul>
<li>目录：META-INF/services/</li>
<li>文件：com.hust.hui.alarm.core.execut.api.IExecute</li>
</ul>
<p>文件内容为上面几个实现类的全路径</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>目录结构如：</p>
<figure><img src="https://s3.mogucdn.com/mlcdn/c45406/180211_39e88dgb9c5f1h1ggdae85dde89ii_938x266.jpg" alt="IMAGE" tabindex="0" loading="lazy"><figcaption>IMAGE</figcaption></figure>
<h3> 3. 测试</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>实测输出结果如下:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> III. 报警规则加载自定义</h2>
<h3> 1. 实现IConfLoader接口</h3>
<p>自定义加载器，给了一个最基本的</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 添加SPI配置</h3>
<p>在resources目录下新增</p>
<ul>
<li>目录： META-INF/services</li>
<li>文件： com.hust.hui.alarm.core.loader.api.IConfLoader</li>
</ul>
<p>文件内容</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 3. 测试</h3>
<p>同样是上面的代码，输出结果</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4. 说明</h3>
<p>系统默认的order是10，所以如果在测试上面的第二步时，不妨把<code>com.hust.hui.alarm.core.test.loader.SelfAlarmConfLoader#order</code>返回值，改成大于10，这样就会走到默认的配置加载类</p>
<p>采用 <code>SelfAlarmConfLoader</code> 时，前面说的两个基础配置文件，是可以没有的，完全不会有任何影响，因为对应的注册类和报警规则，都是右这个类内部提供了</p>
<h2> IV. 小结</h2>
<p>所有测试相关数据，均可以在测试工程中获取，请主要关注:</p>
<ul>
<li><a href="https://github.com/liuyueyi/quick-alarm/blob/master/core/src/test/java/com/hust/hui/alarm/core/test/" target="_blank" rel="noopener noreferrer">测试case</a></li>
<li>注册文件：<a href="https://github.com/liuyueyi/quick-alarm/blob/master/core/src/test/resources/alarm.properties" target="_blank" rel="noopener noreferrer">alarmConfig</a></li>
<li>报警规则配置文件：<a href="https://github.com/liuyueyi/quick-alarm/blob/master/core/src/main/resources/alarmConfig" target="_blank" rel="noopener noreferrer">alarm.properties</a></li>
</ul>
<h3> 项目: QuickAlarm</h3>
<ul>
<li>项目地址： <a href="https://github.com/liuyueyi/quick-alarm" target="_blank" rel="noopener noreferrer">Quick-Alarm</a></li>
<li>博客地址： <a href="https://liuyueyi.github.io/hexblog/" target="_blank" rel="noopener noreferrer">小灰灰Blog</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://s3.mogucdn.com/mlcdn/c45406/180211_19i0ckjaic6f22i7hlai52ja471gc_1988x1178.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>1. 报警系统QuickAlarm设计总纲</title>
      <link>https://liuyueyi.github.io/tutorial/column/app/alarm/01.%E6%8A%A5%E8%AD%A6%E7%B3%BB%E7%BB%9FQuickAlarm%E6%80%BB%E7%BA%B2.html</link>
      <guid>https://liuyueyi.github.io/tutorial/column/app/alarm/01.%E6%8A%A5%E8%AD%A6%E7%B3%BB%E7%BB%9FQuickAlarm%E6%80%BB%E7%BA%B2.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">1. 报警系统QuickAlarm设计总纲</source>
      <description>背景 日常的系统中，报警是不可缺少的一环，目前报警方式很多，最常见的有直接打日志，微信报警，短信报警，邮件报警等；而涉及到报警，一般不可避免的需要提前设置一些基本信息，如报警方式，报警频率，报警用户，开关等； 另外一个常见的问题是一般采用的是单一的报警方式，比如不管什么类型的报警全部都用短信方式触达，然后就会发现手机时常处于被淹没的状态了，久而久之对报警短信就不会敏感了</description>
      <category>Quick系列</category>
      <category>QuickAlarm</category>
      <pubDate>Fri, 09 Feb 2018 19:37:29 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 背景</h2>
<p>日常的系统中，报警是不可缺少的一环，目前报警方式很多，最常见的有直接打日志，微信报警，短信报警，邮件报警等；而涉及到报警，一般不可避免的需要提前设置一些基本信息，如报警方式，报警频率，报警用户，开关等；</p>
<p>另外一个常见的问题是一般采用的是单一的报警方式，比如不管什么类型的报警全部都用短信方式触达，然后就会发现手机时常处于被淹没的状态了，久而久之对报警短信就不会敏感了</p>
<!-- more -->
<h2> 目标</h2>
<p>因此我们准备设计一个通用的报警框架</p>
<ul>
<li>可以自由选择报警方式，</li>
<li>支持用户自定义报警方式拓展</li>
<li>支持动态的报警配置，</li>
<li>支持用户自定义报警规则拓展</li>
<li>支持报警方式自动切换规则设定</li>
<li>支持报警方式自定义自动切换规则拓展</li>
</ul>
<h2> 设计</h2>
<p>整体来说，报警主要可以划分为三个步骤，如下：</p>
<figure><img src="https://s17.mogucdn.com/mlcdn/c45406/180209_3f276k99cb3k1kec5g184f6c4hb7f_2030x996.jpg" alt="IMAGE" tabindex="0" loading="lazy"><figcaption>IMAGE</figcaption></figure>
<ul>
<li>提交报警：对外部使用者提供的接口</li>
<li>选择报警：根据报警相关信息，选择具体的报警执行单元</li>
<li>执行报警：实现具体的报警逻辑</li>
</ul>
<p>从任务划分上来看，比较清晰简单，但是每一块的内容又必须可以拓展，</p>
<ul>
<li>
<p>选择报警：</p>
<ul>
<li>报警规则的制定</li>
<li>报警规则加载器  <code>ConfLoader</code></li>
<li>报警规则变更的触发器 <code>ConfChangeTrigger</code></li>
<li>报警规则解析器
<ul>
<li><code>ConfParse</code> ： 解析文本格式报警规则为业务对象</li>
<li><code>AlarmSelector</code> ：根据报警规则和报警类型，选择具体报警执行器 <code>AlarmExecute</code></li>
</ul>
</li>
</ul>
</li>
<li>
<p>执行报警：</p>
<ul>
<li>线程池执行（以防止影响主业务流程）</li>
<li>AlarmExecute的动态拓展（支持用户自定义的报警器实现）</li>
<li>实际的报警逻辑</li>
</ul>
</li>
</ul>
<p>根据上面的拆解，在应用启动的时候，就有一些事情必须去做了</p>
<ol>
<li>ConfLoader的选择</li>
<li>报警规则加载</li>
<li>AlarmExecute的加载（包括默认的+自定义实现的）</li>
</ol>
<p>下图显示在应用启动时，报警规则解析的相关步骤</p>
<figure><img src="https://s17.mogucdn.com/mlcdn/c45406/180209_41ccjhcg1ag35i36ikel3jekf8ld9_868x608.png" alt="应用启动.png" tabindex="0" loading="lazy"><figcaption>应用启动.png</figcaption></figure>
<p>至于报警执行器的加载就比较简单了，如下图</p>
<figure><img src="https://s17.mogucdn.com/mlcdn/c45406/180209_5jii7f1ed2j3f8e0di3aalhgji114_1666x402.jpg" alt="IMAGE" tabindex="0" loading="lazy"><figcaption>IMAGE</figcaption></figure>
<p>因此，整个的工作流程如下图</p>
<figure><img src="https://s17.mogucdn.com/mlcdn/c45406/180209_5eh16796bg6gk4622dj44diaa09bd_1078x620.jpg" alt="alarm-arch.jpg" tabindex="0" loading="lazy"><figcaption>alarm-arch.jpg</figcaption></figure>
<h2> 任务拆解</h2>
<p>通过前面的任务设计之后，对需要做的东西有了一个大概的脉络了，因此在正式操刀实现之前，下对整个架构进行任务拆解，看下可以具体的执行步骤可以怎么来</p>
<ul>
<li>最直接的就是设计报警执行器<code>AlarmExecute</code>
<ul>
<li>定义基本接口</li>
<li>制定自定义扩展规则</li>
</ul>
</li>
<li>接下来就是设计报警规则
<ul>
<li>如何加载报警规则？</li>
<li>报警规则具体的定义细则</li>
<li>报警规则的解析：即根据报警类型来获取报警执行器</li>
<li>报警规则动态更新支持</li>
</ul>
</li>
<li>报警线程池
<ul>
<li>维护报警队列</li>
<li>报警的计数与频率控制</li>
</ul>
</li>
<li>封装对外使用接口</li>
</ul>
<p>所以，通过上面的分析可以看出，这个系统的结构还是蛮简单的，整个只需要四个部分就可以搞定，其中最主要的就是前面两个了，后面将分别说明</p>
<h2> 小结</h2>
<p>做一个东西，当然是希望可以带来一些用处，或者能学习到什么东西，才不枉花费精力来折腾一下，那么我们这个报警系统，究竟有什么用，或者可以从中学习到什么东西呢？</p>
<p><strong>用途：</strong></p>
<ul>
<li>支持灵活可配的报警规则，以及具体报警业务的自定义拓展</li>
<li>目标就是统一报警的使用姿势，也就是不管什么报警，都一个姿势，但是内部可以玩出各种花样，对使用者而言就方便简洁了</li>
</ul>
<p><strong>学习：</strong></p>
<p>抛开特有的知识点，可以抽象一些公共可用的地方，大概就下面这两点了</p>
<ul>
<li>我们可以如何支持功能的动态可拓展</li>
<li>线程池的使用</li>
</ul>
]]></content:encoded>
      <enclosure url="https://s17.mogucdn.com/mlcdn/c45406/180209_3f276k99cb3k1kec5g184f6c4hb7f_2030x996.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>2. 报警系统QuickAlarm之报警执行器的设计与实现</title>
      <link>https://liuyueyi.github.io/tutorial/column/app/alarm/02.%E6%8A%A5%E8%AD%A6%E7%B3%BB%E7%BB%9FQuickAlarm%E4%B9%8B%E6%8A%A5%E8%AD%A6%E6%89%A7%E8%A1%8C%E5%99%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0.html</link>
      <guid>https://liuyueyi.github.io/tutorial/column/app/alarm/02.%E6%8A%A5%E8%AD%A6%E7%B3%BB%E7%BB%9FQuickAlarm%E4%B9%8B%E6%8A%A5%E8%AD%A6%E6%89%A7%E8%A1%8C%E5%99%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">2. 报警系统QuickAlarm之报警执行器的设计与实现</source>
      <description>根据前面一篇总纲的博文，将整体结构划分为了四大块，本文则主要目标集中在第一块，报警执行器（AlarmExecute）的设计与加载上了 主要的关注点无外乎 定义-》加载-》实现逻辑三块了： AlarmExecute 的接口定义 如何加载用户自定义的AlarmExecute AlarmExecute的内部实现</description>
      <category>Quick系列</category>
      <category>QuickAlarm</category>
      <pubDate>Fri, 09 Feb 2018 19:38:59 GMT</pubDate>
      <content:encoded><![CDATA[<p>根据前面一篇总纲的博文，将整体结构划分为了四大块，本文则主要目标集中在第一块，报警执行器（AlarmExecute）的设计与加载上了</p>
<p>主要的关注点无外乎 定义-》加载-》实现逻辑三块了：</p>
<ul>
<li>AlarmExecute 的接口定义</li>
<li>如何加载用户自定义的AlarmExecute</li>
<li>AlarmExecute的内部实现</li>
</ul>
<!-- more -->
<h2> I. AlarmExecute接口定义</h2>
<p>在定义接口之前，先来根据几个问题来加深下这个概念的理解：</p>
<h3> 1. 基础知识</h3>
<ol>
<li>说一下这个报警执行器到底是干嘛的？</li>
</ol>
<ul>
<li>执行具体的报警逻辑（感觉说了依据废话）</li>
<li>因此不同的报警方式，可以选择不同的实现，这个强业务关联的逻辑可以交由适用方自己来把控</li>
</ul>
<ol start="2">
<li>多个alarmExecute之间如何区分？</li>
</ol>
<ul>
<li>给一个类似身份证的标识，将标识与alarmExecute绑定，则可以报警规则中，用这个标识来表示对应的报警执行器</li>
<li>标识要求全局唯一，否则就没法找到对应的执行器</li>
</ul>
<h3> 2. 接口定义</h3>
<p>根据上面的基础知识，那么很容易给出接口的定义了</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>第一个方法<code>sendMsg</code>也就是需要使用者来实现的具体执行报警代码的核心模块了，比较清晰，其中用户是列表，因此，支持同时报警给多个用户（但是报警内容都是相同的）</li>
<li>第二个方法<code>getName</code>表示获取标识，默认给了一个实现，规则如下
<ul>
<li>获取类的 SimpleName</li>
<li>干掉类名后面的 <code>Execute</code> （如果不是以这个结尾的就不需要了）</li>
<li>剩下的全部转大写</li>
<li>实例： <code>SmsExecute -&gt; SMS;  LogExecute -&gt; LOG;</code></li>
</ul>
</li>
</ul>
<h3> 3. 额外说明</h3>
<p>上面接口定义中的<code>sendMsg</code>中，支持给多个用户发送报警信息，如果要求每个报警信息都不同，比如最常见的是:</p>
<ul>
<li>发送一段文本，其中通知人地方根据报警人来替换，其他的不变</li>
</ul>
<p>当然这样的场景完全可以自己在实现中来做</p>
<ul>
<li>传入的content作为一个话术模板</li>
<li>然后利用 String#format() 来实现参数代替</li>
</ul>
<p>当然更激进一点就是，穿进来的title或者content作为一个key，然后我可以通过这个key，到其他的地方（如db，缓存等）获取报警内容，甚至我连传进来的报警人都不care，直接从其他地方来获取</p>
<p>简单来说，这个实现委托给用户自己实现，你完全可以随意的控制，做任何你想做的事情</p>
<h2> II. AlarmExecute的加载</h2>
<h3> 1. 问题分析</h3>
<p>加载AlarmExecut，貌似没有什么特别复杂的东西，一般的思路是创建一个简单工厂类，然后实例化对应的Executor返回，（再多一点确保只有一个实例对象，加以缓存）</p>
<p><strong>这样有什么问题？</strong></p>
<p>很简单的实现，但是我们需要加载用户自定义的执行器，要怎么支持呢？</p>
<p><strong>几种可行的解决手段</strong></p>
<h4> 1. 开放一个注册接口</h4>
<p>这个可算是最容易想到的了，直接让用户把自己的Executor实例，主动的扔进来</p>
<h4> 2. 抽象工厂</h4>
<p>将前面说的简单工厂，改成抽象工厂类，让后具体的加载委托给用户自己来做</p>
<h4> 3. 借助Spring容器来加载</h4>
<p>如果所有的AlarmExecute都委托给Spring容器来管理，那么就很简单了，直接通过<code>ApplicationContext#getBean</code>来获取所有的执行器即可</p>
<h4> 4. SPI加载方式</h4>
<p>通过JDK的spi机制来实现（详细后面来说）</p>
<p>针对上面的几个手段，首先排除掉前面两个，因为不满足我们的设计目标一：</p>
<ul>
<li>简单 （只有报警这个接口进行交互，不需要额外的接口调用）</li>
</ul>
<p>然后也排除掉spring容器，因为我们希望这个东西，可以较独立的被引用到java工程中，后面可以看情况实现一个spring版</p>
<p>从使用来讲，由spring容器来托管的方式，对使用者而言，是最简单，成本最低的，因为不需要额外添加SPI配置</p>
<hr>
<h3> 2. 实现</h3>
<p>我们采用SPI方式来实现加载，对于SPI是什么东西，这里不详细展看，有兴趣的童鞋可以看我之前的一个系类博文：<a href="https://my.oschina.net/u/566591/blog/911054" target="_blank" rel="noopener noreferrer">自定义SPI框架设计</a></p>
<p>实现方式，可说是非常简单了</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面对外就暴露一个方法，内部比较简单，如果传入标识对应的报警器没有，则返回一个默认的，确保不会因此挂掉</p>
<p>通过SPI加载所有的执行器的逻辑就一行</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>然后需要关注的是循环内部，做了name的唯一性判断，不满足就直接抛出异常了</p>
<h2> III. AlarmExecute内部实现</h2>
<p>内部提供了两个基本的报警实现，比较简单</p>
<p>日志报警执行器</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>空报警执行器</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> IV. 小结</h2>
<p>AlarmExecute 的定义，加载以及实现规则目前都已经完成</p>
<ul>
<li>定义：两个方法，一个执行报警方法，一个返回唯一标识方法</li>
<li>加载：通过SPI方式加载所有定义的alarmExecute</li>
<li>实现：由用户自定义实现<code>IExecute</code>接口，内部逻辑无任务特殊要求，只是需要确保每个executor的name唯一</li>
</ul>
<p>整个系统的第一步已经迈出，但是有个问题就是什么时候，才会来调用 <code>com.hust.hui.alarm.core.execut.SimpleExecuteFactory#getExecute</code> 从而触发执行器的加载呢？</p>
<figure><img src="https://s17.mogucdn.com/mlcdn/c45406/180209_5jii7f1ed2j3f8e0di3aalhgji114_1666x402.jpg" alt="IMAGE" tabindex="0" loading="lazy"><figcaption>IMAGE</figcaption></figure>
]]></content:encoded>
      <enclosure url="https://s17.mogucdn.com/mlcdn/c45406/180209_5jii7f1ed2j3f8e0di3aalhgji114_1666x402.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>3. 报警系统QuickAlarm之报警规则的设定与加载</title>
      <link>https://liuyueyi.github.io/tutorial/column/app/alarm/03.%E6%8A%A5%E8%AD%A6%E7%B3%BB%E7%BB%9FQuickAlarm%E4%B9%8B%E6%8A%A5%E8%AD%A6%E8%A7%84%E5%88%99%E7%9A%84%E8%AE%BE%E5%AE%9A%E4%B8%8E%E5%8A%A0%E8%BD%BD.html</link>
      <guid>https://liuyueyi.github.io/tutorial/column/app/alarm/03.%E6%8A%A5%E8%AD%A6%E7%B3%BB%E7%BB%9FQuickAlarm%E4%B9%8B%E6%8A%A5%E8%AD%A6%E8%A7%84%E5%88%99%E7%9A%84%E8%AE%BE%E5%AE%9A%E4%B8%8E%E5%8A%A0%E8%BD%BD.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">3. 报警系统QuickAlarm之报警规则的设定与加载</source>
      <description>前面一篇是报警执行器的定义与加载已经完成，但与之对应的报警规则有是如何定义和加载的呢？ 此外，既然命名为规则，那么就需要有对应的解析器，以根据报警规则和报警类型等相关输入条件，来选择对应的报警执行器，因此本文主要包括的内容就比较清晰了 报警规则的定义 报警规则的加载 报警规则的解析以及报警执行器选择</description>
      <category>Quick系列</category>
      <category>QuickAlarm</category>
      <pubDate>Fri, 09 Feb 2018 19:39:43 GMT</pubDate>
      <content:encoded><![CDATA[<p>前面一篇是报警执行器的定义与加载已经完成，但与之对应的报警规则有是如何定义和加载的呢？</p>
<p>此外，既然命名为规则，那么就需要有对应的解析器，以根据报警规则和报警类型等相关输入条件，来选择对应的报警执行器，因此本文主要包括的内容就比较清晰了</p>
<ul>
<li>报警规则的定义</li>
<li>报警规则的加载</li>
<li>报警规则的解析以及报警执行器选择</li>
</ul>
<!-- more -->
<h2> I. 报警规则定义</h2>
<blockquote>
<p>目前针对报警规则没有给出自定义配置的入口，即完全采用了默认的方案，后续可以考虑支持适用方来自定义报警规则以及解析器，这样扩展性就更强了</p>
</blockquote>
<p>首先说明下我们的设计规则，我们针对不同的AlarmExecute定义了一个优先级，我们的目标是</p>
<ul>
<li>针对报警频率设置不同区间，每个区间对应一种报警类型</li>
<li>当实际调用的报警频率达到这个区间，就选择这种报警类型</li>
<li>同时也允许关闭根据频率选择报警器的功能，全程用一个默认</li>
<li>每种报警类型的用户都可以自定义</li>
</ul>
<p>针对上面的目标，我们设计的类就比较明确了</p>
<p>阀值类：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>配置类：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>一个报警类型对应一个<code>AlarmConfig</code>，这样当执行报警时，就可以很容易的获取对应的规则</p>
<p>同样根据定义，也可以看出报警规则比较简单，直接根据阀值区间来选择</p>
<h2> II. 报警规则加载</h2>
<p>关于如何加载报警规则，想了很久，选择把这块放开，因为我们无法确定，使用方的配置是存在什么地方的，而且使用的配置是否能和我们的设计的DO兼容也是个问题，因此干脆放手，同样是通过SPI的方式来做的</p>
<p>我们定义规则加载接口： IConfLoader</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的方法，可以划分为两类:</p>
<ul>
<li>加载时使用
<ul>
<li>load 为具体的执行加载配置到内存的方法，返回true表示加载成功</li>
<li>order 排序</li>
<li>getRegisterInfo 获取基础的配置信息（包括应用名等相关配置）</li>
</ul>
</li>
<li>业务运行时使用
<ul>
<li>alarmEnable ： 是否开启报警 （当大量报警时，可以先关闭报警，然后再查问题）</li>
<li>getAlarmConfig：核心方法，根据报警类型，返回对应的报警规则</li>
</ul>
</li>
</ul>
<p>系统默认提供一个从配置文件中加载报警规则的方案，主要会依赖两个配置文件</p>
<ul>
<li>alarm.properties : 初始化注册信息，内部保存 RegisterInfo 所需要的属性</li>
<li>alarmConfig : 保存具体的报警规则，json格式</li>
</ul>
<h3> 1. 配置加载</h3>
<p>配置加载的实现逻辑，如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>主要查看默认的load方法即可, alarmEnable 和 getAlarmConfig还是比较简单的，看一下就知道怎么玩的</p>
<h3> 2. RegisterInfo 加载</h3>
<p>上面的实现中，第一步就是从 alarm.properteis 文件中读取对应的配置，然后初始化 RegisterInfo对象</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>一个配置文件实例</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从配置文件中读取信息，然后初始化对象的过程就比较简单了，我这里做了一个小简化，使用反射的方式实现对象拷贝</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的实现目前比较简单，没有考虑父类的情况，没有考虑复杂的数据类型转换，目前只支持了基本类型的转换，后续可考虑抽象</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 3. 报警规则加载</h4>
<p>注册信息加载完毕之后，就可以获取报警规则的文件地址了，因此首先是读取配置规则的内容（我们要求是JSON格式），然后反序列化即可</p>
<p>将json串格式配置，反序列化为 BaseAlarmConf 对象</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>需要额外说明一下，json串并没有直接的映射我们前面定义的 <code>AlarmConfig</code> 对象，因为在原型版本的设计的过程中，考虑到配置与内部的使用对象，可能不是特别匹配，最初的设计中，是希望直接将AlarmConfig中的alarmLevel直接替换成 <code>AlarmExecute</code> 实例对象的，然而在实际实现中没有这么干...，所以看源码时，这里就有点奇怪，后面完全可以干掉这个无用的逻辑</p>
<p>此外，就是需要给一个默认的配置项，当报警类型匹配不到对应的报警规则时，就选择默认的了</p>
<p>下面是一个报警配置的demo</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> III. ConfLoader选择并初始化</h2>
<p>前面说明，为了确保报警规则的多样性存储与加载，我们支持用户自定义加载类，所以就会有这么个ConfLoaderFactory, 来创建系统中使用的ConfLoader</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>实现逻辑依旧采取了SPI机制，不够我们定义了一个优先级，默认从最高优先级的开始加载，加载成功之后，就选择这个东西了；否则继续加载下一个，当所有的ConfLoader加载完毕，都没有一个成功的，就抛出一个异常</p>
<h2> IV. 小结</h2>
<p>鉴于篇幅问题，关于报警规则与报警执行器之间的关系，对应的解释器放在下一篇进行说明，简要小结一下本文内容</p>
<ul>
<li>报警规则： 采用阀值区间方式，将报警频率与报警执行器关联起来</li>
<li>规则加载： 支持SPI方式注入用户加载器，默认提供基于配置文件的加载器，且优先级最低</li>
</ul>
<p>基本上本文说的就是下面这张图的内容了</p>
<figure><img src="https://s17.mogucdn.com/mlcdn/c45406/180209_41ccjhcg1ag35i36ikel3jekf8ld9_868x608.png" alt="应用启动.png" tabindex="0" loading="lazy"><figcaption>应用启动.png</figcaption></figure>
<h3> 项目</h3>
<ul>
<li>项目地址： <a href="https://github.com/liuyueyi/quick-alarm" target="_blank" rel="noopener noreferrer">Quick-Alarm</a></li>
<li>博客地址： <a href="https://liuyueyi.github.io/hexblog/" target="_blank" rel="noopener noreferrer">小灰灰Blog</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://s17.mogucdn.com/mlcdn/c45406/180209_41ccjhcg1ag35i36ikel3jekf8ld9_868x608.png" type="image/png"/>
    </item>
    <item>
      <title>4. 报警系统QuickAlarm之报警规则解析</title>
      <link>https://liuyueyi.github.io/tutorial/column/app/alarm/04.%E6%8A%A5%E8%AD%A6%E7%B3%BB%E7%BB%9FQuickAlarm%E4%B9%8B%E6%8A%A5%E8%AD%A6%E8%A7%84%E5%88%99%E8%A7%A3%E6%9E%90.html</link>
      <guid>https://liuyueyi.github.io/tutorial/column/app/alarm/04.%E6%8A%A5%E8%AD%A6%E7%B3%BB%E7%BB%9FQuickAlarm%E4%B9%8B%E6%8A%A5%E8%AD%A6%E8%A7%84%E5%88%99%E8%A7%A3%E6%9E%90.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">4. 报警系统QuickAlarm之报警规则解析</source>
      <description>前面两篇分别说了报警执行器和报警规则的定义及用户扩展加载，接下来就是比较核心的一块了，如何将报警规则和报警执行器关联起来，即当发生报警时，应该call哪一个报警执行器</description>
      <category>Quick系列</category>
      <category>QuickAlarm</category>
      <pubDate>Sun, 11 Feb 2018 16:08:04 GMT</pubDate>
      <content:encoded><![CDATA[<p>前面两篇分别说了报警执行器和报警规则的定义及用户扩展加载，接下来就是比较核心的一块了，如何将报警规则和报警执行器关联起来，即当发生报警时，应该call哪一个报警执行器</p>
<!-- more -->
<h2> I. 背景知识点</h2>
<h3> 0. 声明</h3>
<p>在正式进入之前，有必要额外声明一下，因为目前的v1版本，没有开放报警规则的自定义，也就是说，目前只支持默认的报警规则，所以接下来的主要内容将集中在</p>
<ul>
<li>系统默认的报警规则的解析</li>
<li>即基于报警频率阀值，自动选择报警执行器的规则解析</li>
</ul>
<h3> 1. 报警规则</h3>
<p>如果对于报警规则，依然不是很清晰的，可以阅读一下<a href="https://liuyueyi.github.io/hexblog/2018/02/09/%E6%8A%A5%E8%AD%A6%E7%B3%BB%E7%BB%9FQuickAlarm%E4%B9%8B%E6%8A%A5%E8%AD%A6%E8%A7%84%E5%88%99%E7%9A%84%E8%AE%BE%E5%AE%9A%E4%B8%8E%E5%8A%A0%E8%BD%BD/" target="_blank" rel="noopener noreferrer">《报警系统QuickAlarm之报警规则的设定与加载》</a></p>
<p>这里简单的进行说明，系统中默认的报警规则结构为：</p>
<ul>
<li>key为报警类型（即用户执行报警时，传进来的报警类型参数）</li>
<li>value为具体报警规则
<ul>
<li>每个报警执行器拥有一个报警频率区间，通过报警频率映射到报警执行器的区间来选择对应的AlarmExecutor，这就是系统定义的报警规则</li>
</ul>
</li>
</ul>
<h2> II. 报警规则解析</h2>
<p>通过前面的报警规则的简单说明，基本上也可以捞出报警规则的解析原则了</p>
<ul>
<li>每种报警类型，对应一个报警规则</li>
<li>每个报警规则中，可以有多个报警执行器</li>
<li>每个报警执行器都有一个对应的报警频率的阀值</li>
<li>根据阀值对所有的报警执行器排序</li>
<li>计算报警频率，映射到哪个区间，则选择哪个报警执行器</li>
</ul>
<p>上面是一个简单的解析规则，当然实际上和这个差不多，但有一些问题需要额外注意</p>
<ol>
<li>只想选择一种报警方式，是否可以支持？</li>
<li>多重报警方式同时调用怎么处理？（如我希望用短信提示说有问题，同时用邮件包含详细的异常堆栈）</li>
<li>频率限制</li>
<li>报警类型没有设置报警规则如何处理？</li>
<li>报警规则中使用了一个未注册的报警执行器会怎样？</li>
</ol>
<h3> 1. 实现方案说明</h3>
<p>再次将报警规则类拿出来看一下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>针对上面的问题，逐一说明</p>
<ul>
<li>首先是 <code>autoIncEmergency</code> 这个参数，如果为true，则表示可以走上面的哪个区间映射的规则；否则就全部走AlarmConfig中默认的报警类型了</li>
<li>minLimit : 表示发生报警的频率下限值，小于这个值就不会执行具体的报警逻辑</li>
<li>maxLimit : 最大的报警频率，超过了也不报警（简单的频率控制）</li>
<li>alarmLevel: 对应的就是具体的报警类型</li>
<li>alarmThreshold: 这个只有在<code>autoIncEmergency=true</code>时，才有小，也就是我们前面说的不同的报警执行器，根据阀值区间进行排序，开启之后，遍历，判断频率是否在这个区间内，若在，则表示可以选择它了</li>
<li>如果不存在报警规则，则采用默认的兜底规则</li>
<li>若报警执行器也不存在，就直接采用系统定义的日志报警执行器</li>
</ul>
<h3> 2. 实现</h3>
<p>基本上前面已经将整个逻辑都说了，所以实际的编码反而比较清晰了</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>具体的实现基本和我们前面分析的一样，但有一个地方需要额外注意</strong></p>
<ul>
<li>默认报警阀值，可以直接决定是否需要报警</li>
<li>因此定义的其他报警方式的阀值，应该在默认的阀值区间内</li>
<li>当然<code>AlarmThreshold</code>中不包含默认报警方式时，优先选择阀值区间的报警方式</li>
<li>当然<code>AlarmThreshold</code>中包含默认报警方式时，根据新的规则做处理</li>
</ul>
<p>（吐槽：上面这个实现有点绕，后面想办法规避下，搞得不太好理解了）</p>
<p><strong>另外一个问题就是，上面的实现没有支持可以同时选择多个报警执行器的情况</strong></p>
<p>因为考虑到后面肯定会对报警规则的定义和解析放开，所以先实现了一个简单的场景，具体的放在后面处理</p>
<h2> III. 小结</h2>
<p>到这里报警规则和报警执行器之间的解析关系已确定，剩下的东西就简单了，一个维持报警频率计数，一个报警线程池，再加上一个对外接口的封装而言</p>
<p>基本上，到这里主要的核心逻辑已经完成，小结一下本系统中的核心设计理念 -- 一切可自定义（当然目前差得有点远）</p>
<h3> 1. 报警执行器</h3>
<ul>
<li>通过SPI机制支持用户自定义扩展</li>
<li>要求 Executor 拥有唯一标识</li>
<li>因为报警执行器支持扩展，所以Executor的内部实现，完全可以由用户决定</li>
</ul>
<h3> 2. 报警规则</h3>
<ul>
<li>目前报警规则只提供默认的基于频率区间的选择方案</li>
<li>报警规则通过报警执行器的name与之唯一对应，若对应不上，则选择默认执行器</li>
<li>报警规则的加载同样基于SPI，支持自定义，因此报警规则可以存在任何地方</li>
<li>报警规则加载器，提供一个报警规则变动的钩子(load()),若采用自定义的加载类，则确保规则变动时，主动回调这个方法</li>
<li>默认的报警规则加载类，是基于系统的配置文件实现，内部托管了文件的变动更新事件（使用commons-io实现）</li>
</ul>
<h3> 项目: QuickAlarm</h3>
<ul>
<li>项目地址： <a href="https://github.com/liuyueyi/quick-alarm" target="_blank" rel="noopener noreferrer">Quick-Alarm</a></li>
<li>博客地址： <a href="https://liuyueyi.github.io/hexblog/" target="_blank" rel="noopener noreferrer">小灰灰Blog</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>5. 报警系统QuickAlarm之频率统计及接口封装</title>
      <link>https://liuyueyi.github.io/tutorial/column/app/alarm/05.%E6%8A%A5%E8%AD%A6%E7%B3%BB%E7%BB%9FQuickAlarm%E4%B9%8B%E9%A2%91%E7%8E%87%E7%BB%9F%E8%AE%A1%E5%8F%8A%E6%8E%A5%E5%8F%A3%E5%B0%81%E8%A3%85.html</link>
      <guid>https://liuyueyi.github.io/tutorial/column/app/alarm/05.%E6%8A%A5%E8%AD%A6%E7%B3%BB%E7%BB%9FQuickAlarm%E4%B9%8B%E9%A2%91%E7%8E%87%E7%BB%9F%E8%AE%A1%E5%8F%8A%E6%8E%A5%E5%8F%A3%E5%B0%81%E8%A3%85.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">5. 报警系统QuickAlarm之频率统计及接口封装</source>
      <description>前面将报警规则的制定加载解析，以及报警执行器的定义加载和扩展进行了讲解，基本上核心的内容已经完结，接下来剩下内容就比较简单了 报警频率的统计 报警线程池 对外封装统一可用的解耦</description>
      <category>Quick系列</category>
      <category>QuickAlarm</category>
      <pubDate>Sun, 11 Feb 2018 16:59:47 GMT</pubDate>
      <content:encoded><![CDATA[<p>前面将报警规则的制定加载解析，以及报警执行器的定义加载和扩展进行了讲解，基本上核心的内容已经完结，接下来剩下内容就比较简单了</p>
<ul>
<li>报警频率的统计</li>
<li>报警线程池</li>
<li>对外封装统一可用的解耦</li>
</ul>
<!-- more -->
<h2> I. 报警频率统计</h2>
<h3> 1. 设计</h3>
<p>前面在解析报警规则时，就有一个count参数，用来确定具体选择什么报警执行器的核心参数，我们维护的方法也比较简单：</p>
<ul>
<li>针对报警类型，进行计数统计，没调用一次，则计数+1</li>
<li>每分钟清零一次</li>
</ul>
<h3> 2. 实现</h3>
<p>因为每种报警类型，都维护一个独立的计数器</p>
<p><strong>定义一个map来存储对应关系</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>每分钟执行一次清零</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意上面的实现，就有什么问题？</p>
<p>有没有可能因为map中的数据过大（或者gc什么原因），导致每次清零花不少的时间，而导致计数不准呢？ （先不给出回答）</p>
<p><strong>计数加1操作</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> II. 报警线程池</h2>
<p>目前也只是提供了一个非常简单的线程池实现，后面的考虑是抽象一个基于forkjoin的并发框架来处理（主要是最近接触到一个大神基于forkjoin写的并发器组件挺厉害的，所以等我研究透了，山寨一个）</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>任务提交执行</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> III. 接口封装</h2>
<p>这个就没什么好说的了</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接口封装完毕之后如何使用呢？</p>
<p>我们使用单例模式封装了唯一对外使用的类AlarmWrapper，使用起来也比较简单，下面就是一个测试case</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用起来比较简单，就那么一行即可，从这个使用也可以知道，整个初始化，就是在这个对象首次被访问时进行</p>
<p>构造函数内容如下:</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>所有如果你希望在自己的应用使用之前就加载好所有的配置，不妨提前执行一下 <code>AlarmWrapper.getInstance()</code></p>
<h2> IV. 小结</h2>
<p>基于此，整个系统设计基本上完成，当然代码层面也ok了，剩下的就是使用手册了</p>
<p>再看一下我们的整个逻辑，基本上就是下面这个流程了</p>
<figure><img src="https://s17.mogucdn.com/mlcdn/c45406/180209_3f276k99cb3k1kec5g184f6c4hb7f_2030x996.jpg" alt="IMAGE" tabindex="0" loading="lazy"><figcaption>IMAGE</figcaption></figure>
<ol>
<li>提交报警</li>
</ol>
<ul>
<li>封装报警内容（报警类型，报警主题，报警内容）</li>
<li>维护报警计数（每分钟计数清零，每个报警类型对应一个报警计数）</li>
</ul>
<ol start="2">
<li>选择报警</li>
</ol>
<ul>
<li>根据报警类型选择报警规则</li>
<li>根据报警规则，和当前报警频率选择报警执行器
<ul>
<li>若不开启区间映射，则返回默认执行器</li>
<li>否则遍历所有执行器的报警频率区间，选择匹配的报警规则</li>
</ul>
</li>
</ul>
<ol start="3">
<li>执行报警</li>
</ol>
<ul>
<li>封装报警任务，提交线程池</li>
<li>报警执行器内部实现具体报警逻辑</li>
</ul>
<h3> 项目: QuickAlarm</h3>
<ul>
<li>项目地址： <a href="https://github.com/liuyueyi/quick-alarm" target="_blank" rel="noopener noreferrer">Quick-Alarm</a></li>
<li>博客地址： <a href="https://liuyueyi.github.io/hexblog/" target="_blank" rel="noopener noreferrer">小灰灰Blog</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://s17.mogucdn.com/mlcdn/c45406/180209_3f276k99cb3k1kec5g184f6c4hb7f_2030x996.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>6. 报警系统QuickAlarm之默认报警规则扩展</title>
      <link>https://liuyueyi.github.io/tutorial/column/app/alarm/06.%E6%8A%A5%E8%AD%A6%E7%B3%BB%E7%BB%9FQuickAlarm%E4%B9%8B%E9%BB%98%E8%AE%A4%E6%8A%A5%E8%AD%A6%E8%A7%84%E5%88%99%E6%89%A9%E5%B1%95.html</link>
      <guid>https://liuyueyi.github.io/tutorial/column/app/alarm/06.%E6%8A%A5%E8%AD%A6%E7%B3%BB%E7%BB%9FQuickAlarm%E4%B9%8B%E9%BB%98%E8%AE%A4%E6%8A%A5%E8%AD%A6%E8%A7%84%E5%88%99%E6%89%A9%E5%B1%95.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">6. 报警系统QuickAlarm之默认报警规则扩展</source>
      <description>本篇主要是扩展默认的报警规则，使其能更加友好的支持同时选择多种报警方式 扩展遵循两个原则 不影响原有的配置文件格式 简化规则解析复杂度</description>
      <category>Quick系列</category>
      <category>QuickAlarm</category>
      <pubDate>Mon, 05 Mar 2018 12:25:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>本篇主要是扩展默认的报警规则，使其能更加友好的支持同时选择多种报警方式</p>
<p>扩展遵循两个原则</p>
<ul>
<li>不影响原有的配置文件格式</li>
<li>简化规则解析复杂度</li>
</ul>
<!-- more -->
<h2> I. 配置文件的扩展</h2>
<p>先看一下原有的配置文件</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们希望是能够支持多重报警方式同时选中，那么上面的配置中， threshold中只定义了一个阀值参数显然是不合适的，主要问题在于</p>
<ul>
<li>单一阀值，不允许不同报警方式存在交叉</li>
<li>两个报警方式的threshold值相等时，选中的具体是哪个不可预期</li>
</ul>
<p>所以我们的目标是将上面的参数中，新增一个指定上限的值max</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>向上面这般改动之后，相当于每个报警方式都可以定义自己的区间，因此允许多重报警方式存在区间的交叉，计数在交叉区间即表示选中这多重方式</p>
<h2> II. 扩展的实现支持</h2>
<p>从配置文件的变动来看，改动很小，只是新增一个参数而已，且这个参数不是必填的，那么对应的do应该为</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后顺带着，优化一把我们的映射规则，将配置规则的DO对象，映射为业务对象</p>
<p>主要的映射规则如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在映射为业务对象的逻辑中，直接保障了<code>AlarmThreshold</code>列表中的顺序为最终的需求顺序，映射规则为</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>相应的就可以干掉原来不太好懂的Executor选择逻辑，对应的代码为</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 项目: QuickAlarm</h3>
<ul>
<li>项目地址： <a href="https://github.com/liuyueyi/quick-alarm" target="_blank" rel="noopener noreferrer">Quick-Alarm</a></li>
<li>博客地址： <a href="https://liuyueyi.github.io/hexblog/" target="_blank" rel="noopener noreferrer">小灰灰Blog</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>7. 报警系统QuickAlarm之钉钉报警支持</title>
      <link>https://liuyueyi.github.io/tutorial/column/app/alarm/07.%E6%8A%A5%E8%AD%A6%E7%B3%BB%E7%BB%9FQuickAlarm%E4%B9%8B%E9%92%89%E9%92%89%E6%8A%A5%E8%AD%A6%E6%94%AF%E6%8C%81.html</link>
      <guid>https://liuyueyi.github.io/tutorial/column/app/alarm/07.%E6%8A%A5%E8%AD%A6%E7%B3%BB%E7%BB%9FQuickAlarm%E4%B9%8B%E9%92%89%E9%92%89%E6%8A%A5%E8%AD%A6%E6%94%AF%E6%8C%81.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">7. 报警系统QuickAlarm之钉钉报警支持</source>
      <description>Quick-Alarm时隔一年半，新增钉钉报警支持，在原有的项目基础上，新增报警规则比较简单；下面介绍一下实现与使用姿势</description>
      <category>Quick系列</category>
      <category>QuickAlarm</category>
      <pubDate>Wed, 25 Dec 2019 19:39:22 GMT</pubDate>
      <content:encoded><![CDATA[<p>Quick-Alarm时隔一年半，新增钉钉报警支持，在原有的项目基础上，新增报警规则比较简单；下面介绍一下实现与使用姿势</p>
<!-- more -->
<h3> 1. 钉钉报警支持</h3>
<p>Quick-Alarm系统提供基于SPI方式进行报警方式的扩展，当我们需要新增一种报警方式时，实现接口<code>IExecute</code>，并注册spi文件即可</p>
<p>所以我们的<code>DingdingExecute</code>实现如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>具体的钉钉推送，抽象了一个辅助类，关于钉钉机器人的使用姿势，可以参考一下官方文档: <a href="https://ding-doc.dingtalk.com/doc#/serverapi2/qf2nxq" target="_blank" rel="noopener noreferrer">获取自定义机器人webhook</a></p>
<p>从官方文档中，调用钉钉机器人，实际上就是向一个特定的url，发送post请求；http请求工具这里选择了 <code>OkHttp</code> 这个库，具体实现代码如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面基本上就完成了一个报警器的代码实现，接下来别忘了需要注册，在资源目录下，新建文件夹 <code>META-INF/services</code>（注意上面是两层目录）, 添加文件<code>com.hust.hui.alarm.core.execut.api.IExecute</code>， 文件内容如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 2. 测试使用</h3>
<p>使用钉钉报警时，需要先有一个自定义的钉钉机器人，可以在一个群里面申请，会获得一个token；然后将这个token 配置到我们的预警规则里面</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面的配置中，所以我们需要在users里面填写你的机器人token，这个需要额外注意；</p>
<p>此外新版的钉钉机器人有三种安全校验方式</p>
<ul>
<li>关键词：需要你的报警内容中，包含对应的关键字</li>
<li>加签：暂时不支持这种场景，感觉意义不大</li>
<li>ip白名单：确保使用的机器ip在白名单内部</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>项目源码</strong></p>
<ul>
<li><a href="https://github.com/liuyueyi/quick-alarm" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/quick-alarm</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>SPI</title>
      <link>https://liuyueyi.github.io/tutorial/column/app/spi/</link>
      <guid>https://liuyueyi.github.io/tutorial/column/app/spi/</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">SPI</source>
      <description>应用专栏</description>
      <pubDate>Wed, 31 Jul 2024 12:28:49 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 应用专栏</h1>
]]></content:encoded>
    </item>
    <item>
      <title>1. SPI框架实现之旅一：背景介绍</title>
      <link>https://liuyueyi.github.io/tutorial/column/app/spi/SPI%E6%A1%86%E6%9E%B6%E5%AE%9E%E7%8E%B0%E4%B9%8B%E6%97%85%E4%B8%80%EF%BC%9A%E8%83%8C%E6%99%AF%E4%BB%8B%E7%BB%8D.html</link>
      <guid>https://liuyueyi.github.io/tutorial/column/app/spi/SPI%E6%A1%86%E6%9E%B6%E5%AE%9E%E7%8E%B0%E4%B9%8B%E6%97%85%E4%B8%80%EF%BC%9A%E8%83%8C%E6%99%AF%E4%BB%8B%E7%BB%8D.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">1. SPI框架实现之旅一：背景介绍</source>
      <description>背景介绍 SPI的全名为Service Provider Interface，简单的总结下java spi机制的思想。我们系统里抽象的各个模块，往往有很多不同的实现方案，比如日志模块的方案，xml解析模块、jdbc模块的方案等。面向的对象的设计里，我们一般推荐模块之间基于接口编程，模块之间不对实现类进行硬编码。一旦代码里涉及具体的实现类，就违反了可拔插的原则，如果需要替换一种实现，就需要修改代码。为了实现在模块装配的时候能不在程序里动态指明，这就需要一种服务发现机制。 java spi就是提供这样的一个机制：为某个接口寻找服务实现的机制</description>
      <category>Quick系列</category>
      <category>QuickSpi</category>
      <pubDate>Fri, 26 May 2017 10:46:42 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 背景介绍</h1>
<blockquote>
<p>SPI的全名为Service Provider Interface，简单的总结下java spi机制的思想。我们系统里抽象的各个模块，往往有很多不同的实现方案，比如日志模块的方案，xml解析模块、jdbc模块的方案等。面向的对象的设计里，我们一般推荐模块之间基于接口编程，模块之间不对实现类进行硬编码。一旦代码里涉及具体的实现类，就违反了可拔插的原则，如果需要替换一种实现，就需要修改代码。为了实现在模块装配的时候能不在程序里动态指明，这就需要一种服务发现机制。 java spi就是提供这样的一个机制：为某个接口寻找服务实现的机制</p>
</blockquote>
<!--more-->
<h2> 1. 背景</h2>
<p>上面摘抄了一下spi的概念，接着以个人的理解，简单的谈一下为什么会用到SPI， 什么场景下可以用到这个， 以及使用了SPI机制后有什么优越性</p>
<h3> 什么是SPI</h3>
<p>虽然最开始就引用了spi的解释，这里浅谈一下个人理解。<code>Service Provider Interface</code> 以接口方式提供服务， 和API不同，spi的机制是定义一套标准规范的接口，实现交给其他人来做。</p>
<p>所以一个接口，可以有很多的实现，你完全可以根据自己的需要去选择具体的实现方式，因为是面向接口的开发，所以你的业务代码基本上就不用修改，就可以切到另一个实现了</p>
<h3> 什么场景可以用</h3>
<blockquote>
<p>分别从框架层面和业务层面，给出一个我认为比较合适的场景</p>
</blockquote>
<h4> 1. 日志输出 <code>SLF4j</code></h4>
<p>SLF4j：大名鼎鼎的日志输出接口，这个jar包里面提供的都只是接口方式，具体的实现需要自己去实现，当然比较常用的 <code>logback</code> 就是一个具体的实现包了， 在项目中使用 <code>slf4j</code> 的api进行日志的输出， 通过简单的配置，引入logback， 就可以使用logback来实现具体的日志输出； 也可以换一个日志实现 <code>commons-logging</code>，业务上不需要任何的改动，就可以用不同的实现来输出日志</p>
<h4> 2. 业务场景</h4>
<p>假设你现在有个用户注册成功后的欢迎用户的业务，不同渠道（微信，qq，微博等）注册的，显示的欢迎不同，对此有两种不同的实现方式</p>
<ul>
<li>如果每个不同的渠道进来的，都有一个独立的应用来响应  （因为绝大多数的业务都一样，可能就欢迎词不同，如果做到代码最大程度的复用）</li>
<li>只有一个应用，来处理所有的这些场景</li>
</ul>
<h3> 可以怎么用</h3>
<blockquote>
<p>结合上面的业务场景，来描述下可以怎么用</p>
</blockquote>
<h4> 1. 代码复用</h4>
<p>为了实现代码最大程度的复用，那么可以将不同的地方，抽象成一个SPI接口，在业务层通过接口来代替具体的实现类实现业务逻辑；</p>
<p>每个渠道，都有个独立的应用，那么在微信渠道，创建一个 WeixinSpiImpl来实现接口</p>
<p>在qq渠道，实现 QQSpiImpl；那么在具体的接口调用处，实际上就是执行的spi实现类方法</p>
<h4> 2. 业务场景的选择区分</h4>
<p>这个与上面不同，同一个服务接口，根据不同的业务场景，选择不同的实现来执行；当然你是完全可以使用 if， else来实现这种场景，唯一的问题就是扩展比较麻烦；</p>
<p>这种场景下，我们希望的就是这个接口，能自动的根据业务场景，来选择最合适的实现类来执行</p>
<p><strong>简单来讲，就是spi接口执行之前，其实需要有一个自动选择匹配的实现类的前置过程；</strong></p>
<p>通常这种业务场景下，具体的spi实现会有多个，但是需要有一个选择的策略</p>
<hr>
<h2> 2. 小目标</h2>
<blockquote>
<p>在具体的实现之前，先定义一个小目标，我们想要实现一个什么样子的东西出来</p>
</blockquote>
<p>通过上面的背景描述，我们的小目标也就很明确了，我们的实现至少需要满足两个场景</p>
<ol>
<li>静态选择SPI实现， 即在选择完成之后，所有对这个spi接口的引用都是确定由这个实现来承包</li>
<li>动态选择SPI实现， 不到运行之时，你都不知道会是哪个spi实现来干这件事</li>
</ol>
<hr>
<h2> 3. 技术储备</h2>
<blockquote>
<p>java本身就提供了一套spi的支持方式: <code>ServiceLoader</code>，我们后续的开发，也会在这个基础之上进行</p>
</blockquote>
<p>利用java的 <code>ServiceLoader</code> 找到服务接口的实现类，有一些约定，下面给出要求说明和一个测试case</p>
<p><strong>一般实现流程</strong></p>
<ul>
<li>定义spi接口 ： <code>IXxx</code></li>
<li>具体的实现类:  <code>AXxx</code>,  <code>BXxx</code></li>
<li>在jar包的<code>META-INF/services/</code>目录下新建一个文件，命名为 spi接口的完整类名，内容为spi接口实现的完整类名，一个实现类占一行</li>
</ul>
<p><strong>测试case如下</strong></p>
<p>spi接口  <code>com.hust.hui.quicksilver.commons.spi.HelloInterface</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>spi接口的两个实现类</p>
<p><code>com.hust.hui.quicksilver.commons.spi.impl.ImageHello.java</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>com.hust.hui.quicksilver.commons.spi.impl.TextHello.java</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>配置文件  <code>com.hust.hui.quicksilver.commons.spi.HelloInterface</code></p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>测试类</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出如下:</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>测试类演示如下图:</p>
<figure><img src="https://static.oschina.net/uploads/img/201705/26171232_e3Hb.gif" alt="演示图" tabindex="0" loading="lazy"><figcaption>演示图</figcaption></figure>
<hr>
<h2> 4. 设计思路</h2>
<p>画了一下结构图，方便理解, 下面的核心是  <code>SpiLoader</code> 类， 负责加载spi接口的所有实现类， 初始化所有定义的选择器， 返回一个spi接口的实现类初始化用户自定义的spi对象，然后用户持有此对象调用spi接口中提供的方法即可</p>
<figure><img src="https://static.oschina.net/uploads/img/201705/26185143_ULnL.png" alt="https://static.oschina.net/uploads/img/201705/26185143_ULnL.png" tabindex="0" loading="lazy"><figcaption><a href="https://static.oschina.net/uploads/img/201705/26185143_ULnL.png" target="_blank" rel="noopener noreferrer">https://static.oschina.net/uploads/img/201705/26185143_ULnL.png</a></figcaption></figure>
<h2> 5. 其他</h2>
<h3> 博客系列链接：</h3>
<ul>
<li><a href="/hexblog/2018/05/30/SPI%E6%A1%86%E6%9E%B6%E5%AE%9E%E7%8E%B0%E4%B9%8B%E6%97%85%E5%9B%9B%EF%BC%9A%E4%BD%BF%E7%94%A8%E6%B5%8B%E8%AF%95/" target="_blank" rel="noopener noreferrer">SPI框架实现之旅四：使用测试</a></li>
<li><a href="/hexblog/2018/05/30/SPI%E6%A1%86%E6%9E%B6%E5%AE%9E%E7%8E%B0%E4%B9%8B%E6%97%85%E4%B8%89%EF%BC%9A%E5%AE%9E%E7%8E%B0%E8%AF%B4%E6%98%8E/" target="_blank" rel="noopener noreferrer">SPI框架实现之旅三：实现说明</a></li>
<li><a href="/hexblog/2018/05/30/SPI%E6%A1%86%E6%9E%B6%E5%AE%9E%E7%8E%B0%E4%B9%8B%E6%97%85%E4%BA%8C%EF%BC%9A%E6%95%B4%E4%BD%93%E8%AE%BE%E8%AE%A1/" target="_blank" rel="noopener noreferrer">SPI框架实现之旅二：整体设计</a></li>
<li><a href="/hexblog/2017/05/29/SPI%E6%A1%86%E6%9E%B6%E5%AE%9E%E7%8E%B0%E4%B9%8B%E6%97%85%E4%B8%80%EF%BC%9A%E8%83%8C%E6%99%AF%E4%BB%8B%E7%BB%8D/" target="_blank" rel="noopener noreferrer">SPI框架实现之旅一：背景介绍</a></li>
</ul>
<h3> 项目: QuickAlarm</h3>
<ul>
<li>项目地址： <a href="https://github.com/liuyueyi/quick-spi" target="_blank" rel="noopener noreferrer">Quick-SPI</a></li>
<li>博客地址： <a href="https://liuyueyi.github.io/hexblog/" target="_blank" rel="noopener noreferrer">小灰灰Blog</a></li>
</ul>
<h3> 个人博客： <a href="https://liuyueyi.github.io/hexblog" target="_blank" rel="noopener noreferrer">Z+|blog</a></h3>
<p>基于hexo + github pages搭建的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛</p>
<h3> 声明</h3>
<p>尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见识有限，如发现bug或者有更好的建议，随时欢迎批评指正，我的微博地址: <a href="https://weibo.com/p/1005052169825577/home" target="_blank" rel="noopener noreferrer">小灰灰Blog</a></p>
<h3> 扫描关注</h3>
<figure><img src="https://s17.mogucdn.com/mlcdn/c45406/180209_74fic633aebgh5dgfhid2fiiggc99_1220x480.png" alt="QrCode" tabindex="0" loading="lazy"><figcaption>QrCode</figcaption></figure>
]]></content:encoded>
      <enclosure url="https://static.oschina.net/uploads/img/201705/26171232_e3Hb.gif" type="image/gif"/>
    </item>
    <item>
      <title>3. SPI框架实现之旅三：实现说明</title>
      <link>https://liuyueyi.github.io/tutorial/column/app/spi/SPI%E6%A1%86%E6%9E%B6%E5%AE%9E%E7%8E%B0%E4%B9%8B%E6%97%85%E4%B8%89%EF%BC%9A%E5%AE%9E%E7%8E%B0%E8%AF%B4%E6%98%8E.html</link>
      <guid>https://liuyueyi.github.io/tutorial/column/app/spi/SPI%E6%A1%86%E6%9E%B6%E5%AE%9E%E7%8E%B0%E4%B9%8B%E6%97%85%E4%B8%89%EF%BC%9A%E5%AE%9E%E7%8E%B0%E8%AF%B4%E6%98%8E.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">3. SPI框架实现之旅三：实现说明</source>
      <description>实现说明 前一篇 《SPI框架实现之旅二：整体设计》中，介绍了几个定义的接口，注解；叙述了实现流程；并简单的介绍了 SpiLoader中的部分实现； 本篇则主要介绍SpiLoader类的实现 类图结构如下： https://static.oschina.net/uploads/img/201705/27183336_TOny.png</description>
      <category>Quick系列</category>
      <category>QuickSpi</category>
      <pubDate>Mon, 29 May 2017 10:50:37 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 实现说明</h1>
<blockquote>
<p>前一篇 《SPI框架实现之旅二：整体设计》中，介绍了几个定义的接口，注解；叙述了实现流程；并简单的介绍了 <code>SpiLoader</code>中的部分实现； 本篇则主要介绍<code>SpiLoader</code>类的实现</p>
</blockquote>
<p>类图结构如下：</p>
<figure><img src="https://static.oschina.net/uploads/img/201705/27183336_TOny.png" alt="https://static.oschina.net/uploads/img/201705/27183336_TOny.png" tabindex="0" loading="lazy"><figcaption><a href="https://static.oschina.net/uploads/img/201705/27183336_TOny.png" target="_blank" rel="noopener noreferrer">https://static.oschina.net/uploads/img/201705/27183336_TOny.png</a></figcaption></figure>
<!-- more -->
<h2> SpiLoader 全解析</h2>
<blockquote>
<p>spiImpl选择的核心类，包括初始化选择器，初始化spiImpl实现列表，解析spiImpl的选择条件，返回具体的实现类等</p>
</blockquote>
<h3> 1. 获取spiLoader对象</h3>
<blockquote>
<p><code>SpiLoader</code> 是一个泛型对象，每个SPI接口，对应一个<code>SpiLoader&lt;T&gt;</code> 对象，我们提供了一个静态方法来获取这个对象</p>
</blockquote>
<h4> 实现</h4>
<p>优先从缓存中获取， 如果缓存没有，则新建一个；缓存中有， 则直接返回</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 说明</h4>
<ul>
<li>上面有几个校验，前一篇已经说明，不再赘述</li>
<li>上面新建对象，不是线程安全的</li>
</ul>
<h3> 2. 新建 <code>SpiLoader</code>对象</h3>
<blockquote>
<p>创建对象，主要会初始化选择器</p>
</blockquote>
<h4> 实现</h4>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 说明</h4>
<ul>
<li>持有一个选择器缓存列表，<code>selectorInstanceCacheMap</code>
<ul>
<li>保证每种类型的选择器，在这个SpiLoader中，只会有一个实例存在</li>
<li>不做成全局唯一的原因是尽量隔离, 比如  <code>ParamsSelector</code> 内部缓存了spi实现的列表，如果全局公用的话，就会混掉，导致这个列表中就出现非这个spi接口的实现类</li>
</ul>
</li>
<li>类选择器 + 方法选择器
<ul>
<li><code>currentSelector</code> ： 类选择器, 解析 <code>@Spi</code> 注解获取，适用于静态选择 + 动态选择两种使用方式</li>
<li><code>currentMethodSelector</code> : 方法选择器，解析 <code>@SpiAdaptive</code> 注解获取， 仅适用于动态选择SPI实现的方式</li>
<li>优先级： 方法上定义的选择器 由于  类上定义的选择器； 方法上未定义时，默认使用类定义的选择器</li>
</ul>
</li>
</ul>
<h3> 3. 静态使用</h3>
<blockquote>
<p>静态使用方式，表示根据传入的条件，选择一个满足条件的实现返回</p>
</blockquote>
<h4> 实现</h4>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 说明</h4>
<ol>
<li>
<p><code>spiImplClassCacheMap</code></p>
<p>spi实现的缓存映射表，优先判断缓存映射表是否存在，不存在时需要初始化；存在时，则进入校验逻辑</p>
</li>
<li>
<p>校验</p>
<p>校验传入的参数，是否匹配当前的选择器参数类型，为了保证选择器可以正常运行</p>
<p>当不匹配时，会有一个兼容逻辑，判断传参类型是否为String， 是则采用默认的选择器，根据name来选择spi实现 （这种实现可能造成选择的实现不是预期的）</p>
</li>
<li>
<p>静态使用方式，使用类定义选择器 : <code>currentSelector</code></p>
<ul>
<li>
<p>静态使用的方式，目标就是事前就确认使用这个实现了，不会出现变动了； 相当于一次确认，所有的调用都是确认的</p>
</li>
<li>
<p>静态使用，方法注解的选择器无效。这个我们从逆向的思路进行解释</p>

</li>
</ul>
</li>
<li>
<p>loadService 的逻辑后面详细说明</p>
</li>
</ol>
<h3> 4. 动态使用</h3>
<blockquote>
<p>动态使用区别于静态的直接确定实现类， 通过<code>getService</code> 获取的并不是某个特定对的实现类，而是一个动态生成的代理，每次具体执行之前，会去判断一下，应该选择哪一个实现来执行</p>
</blockquote>
<h4> 设计的出发点</h4>
<p>可以考虑下，我们的目标是在执行方法之前，需要判断一下哪个实现类满足要求，选择这个实现类来执行这个方法，那么我们可以怎么去做？</p>
<p>考虑到切面的方式，如果有一种手段，在方法执行之前，织入一段业务逻辑，就可以达到上面的目的</p>
<p>最开始虽然是怎么想的，但是有点尴尬的是，不知道怎么去实现；因此换了一个思路，我自己新生成一个接口的实现类，在这个实现类里面做选择逻辑，然后把这个实现类对象返回</p>
<h4> 实现如下</h4>
<p>和静态实现的逻辑差不多，一般流程如下:</p>
<ul>
<li>判断spi实现类的映射关系表是否初始化，若没有则初始化</li>
<li>获取选择器
<ul>
<li>优先从方法选择器中查找， 若存在，则直接选中；</li>
<li>不存在，则使用类选择器</li>
</ul>
</li>
<li>校验：判断传入条件参数类型是否满足选择器的参数类型匹配（将方法的第一个参数，作为选择器的选择条件）</li>
<li>返回实现类</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 说明</h4>
<ol>
<li>
<p>这个方法通常是由框架生成的代理实现类来调用（后面会说明动态生成代理类的逻辑）</p>
</li>
<li>
<p>区别与静态使用方式， 优先根据方法名，查找对应的选择器；当未定义时，使用类选择器</p>
</li>
<li>
<p>默认选择器，根据name来查询实现时，传入的参数特殊处理下，主要是因为 <code>spiImplMethodCacheMap</code> 中key的生成，有一个小转换</p>

<p>这一点单独看可能不太好理解，因此可以和下面的spi实现类映射关系的初始化结合起来</p>
</li>
<li>
<p>动态生成代理类的逻辑，放在最后进行说明</p>
</li>
</ol>
<h3> 5. spi实现类映射关系表初始化</h3>
<blockquote>
<p>为了避免每次选择具体的实现类时，都去加载一遍，耗时耗力好性能，因此加一个缓存是很有必要的，这里主要说下这个实现逻辑，以及为啥这么干</p>
</blockquote>
<h4> 缓存结构</h4>
<p>使用了两个Map：</p>
<ul>
<li>一个是类级别的映射关系 <code>spiImplClassCacheMap</code>
<ul>
<li>静态使用时，只会用搞这个</li>
<li>动态适配时，当下面的映射关系中无法获取满足条件的实现时，会再次从这里进行判断</li>
<li>key：  <code>@SpiConf</code> 注解中定义的name； 或者spi实现类的简单类名</li>
</ul>
</li>
<li>一个是方法的映射关系 <code>spiImplMethodCacheMap</code>
<ul>
<li>动态适配时， 选择器优先从这里进行判断</li>
<li>key:   <code>@SpiConf</code> 注解中定义的name； 或者是 实现类的 name + "_" + 方法名</li>
</ul>
</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 实现</h4>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的逻辑可以分为两块，一块是上半边的初始化，获取<code>spiImplClassCacheMap</code>;
下一块则是扫描实现类的所有方法，将方法上标有<code>@SpiConf</code>注解的捞出来，用于初始化 <code>spiImplMethodCacheMap</code></p>
<h4> 说明</h4>
<ol>
<li>
<p>缓存结构中value为  <code>SpiImplWrapper</code></p>
<ul>
<li>
<p>缓存value并不是简单的实现类，封装类的定义如下，将条件和排序也同时封装进去了</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>name 的定义，类与方法两个纬度的缓存中，定义规则不同，具体可以看《缓存结构》这里的说明</p>
</li>
</ul>
</li>
<li>
<p>采用 <code>ParamsSelector</code> 时， 要求  <code>@SpiConf</code> 注解必须存在</p>
</li>
<li>
<p>注意扫描所有方法对应的注解, spi实现类，如果存在继承则会出现问题</p>

</li>
</ol>
<h2> 动态代码生成</h2>
<blockquote>
<p>上面在谈论动态使用的时候，采用的方案是，生成一个代理类，实现spi接口， 在具体的实现逻辑中，使用选择器来获取满足条件的实现类，然后执行相应的方法</p>
</blockquote>
<h3> 1. 代理类格式</h3>
<p>采用倒推方式，先给出一个实际的代理类如下，具体的实现中其实只有两行代码</p>
<ol>
<li>获取具体的实现类 （调用上面的 <code>SpiLoader.getService(conf, methodName</code>）</li>
<li>执行实现类的接口</li>
</ol>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面给出了一个代理类的演示，那么剩下两个问题，一个是如何生成代理类； 一个是如何运行代理类（上面是java代码，我们知道运行得是字节码才行）</p>
<h4> 代理类生成</h4>
<p>对着上面的实现，反推代码生成，其实比较简单了，无非就是生成一大串的String罢了，这里真没什么特殊的，贴下实现，逻辑省略</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 动态编译运行</h4>
<p>动态编译，最开始想的是利用jdk的动态编译方式，试来试去没搞成功，然后选择了一个折中的方案，把代理类看成是groovy代码，利用 GroovyEngine 来实现动态运行, 这一块的逻辑也超级简单，下面的短短几行代码即可； 后面有空单独研究下java的动态编译</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 小结</h2>
<p>至此，核心的东西基本上都过了一遍，主要的设计思路，实现逻辑，执行流程都说完了</p>
<h3> 博客系列链接：</h3>
<ul>
<li><a href="/hexblog/2018/05/30/SPI%E6%A1%86%E6%9E%B6%E5%AE%9E%E7%8E%B0%E4%B9%8B%E6%97%85%E5%9B%9B%EF%BC%9A%E4%BD%BF%E7%94%A8%E6%B5%8B%E8%AF%95/" target="_blank" rel="noopener noreferrer">SPI框架实现之旅四：使用测试</a></li>
<li><a href="/hexblog/2018/05/30/SPI%E6%A1%86%E6%9E%B6%E5%AE%9E%E7%8E%B0%E4%B9%8B%E6%97%85%E4%B8%89%EF%BC%9A%E5%AE%9E%E7%8E%B0%E8%AF%B4%E6%98%8E/" target="_blank" rel="noopener noreferrer">SPI框架实现之旅三：实现说明</a></li>
<li><a href="/hexblog/2018/05/30/SPI%E6%A1%86%E6%9E%B6%E5%AE%9E%E7%8E%B0%E4%B9%8B%E6%97%85%E4%BA%8C%EF%BC%9A%E6%95%B4%E4%BD%93%E8%AE%BE%E8%AE%A1/" target="_blank" rel="noopener noreferrer">SPI框架实现之旅二：整体设计</a></li>
<li><a href="/hexblog/2017/05/29/SPI%E6%A1%86%E6%9E%B6%E5%AE%9E%E7%8E%B0%E4%B9%8B%E6%97%85%E4%B8%80%EF%BC%9A%E8%83%8C%E6%99%AF%E4%BB%8B%E7%BB%8D/" target="_blank" rel="noopener noreferrer">SPI框架实现之旅一：背景介绍</a></li>
</ul>
<h3> 项目: QuickAlarm</h3>
<ul>
<li>项目地址： <a href="https://github.com/liuyueyi/quick-spi" target="_blank" rel="noopener noreferrer">Quick-SPI</a></li>
<li>博客地址： <a href="https://liuyueyi.github.io/hexblog/" target="_blank" rel="noopener noreferrer">小灰灰Blog</a></li>
</ul>
<h3> 个人博客： <a href="https://liuyueyi.github.io/hexblog" target="_blank" rel="noopener noreferrer">Z+|blog</a></h3>
<p>基于hexo + github pages搭建的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛</p>
<h3> 声明</h3>
<p>尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见识有限，如发现bug或者有更好的建议，随时欢迎批评指正，我的微博地址: <a href="https://weibo.com/p/1005052169825577/home" target="_blank" rel="noopener noreferrer">小灰灰Blog</a></p>
<h3> 扫描关注</h3>
<figure><img src="https://s17.mogucdn.com/mlcdn/c45406/180209_74fic633aebgh5dgfhid2fiiggc99_1220x480.png" alt="QrCode" tabindex="0" loading="lazy"><figcaption>QrCode</figcaption></figure>
]]></content:encoded>
      <enclosure url="https://static.oschina.net/uploads/img/201705/27183336_TOny.png" type="image/png"/>
    </item>
    <item>
      <title>2. SPI框架实现之旅二：整体设计</title>
      <link>https://liuyueyi.github.io/tutorial/column/app/spi/SPI%E6%A1%86%E6%9E%B6%E5%AE%9E%E7%8E%B0%E4%B9%8B%E6%97%85%E4%BA%8C%EF%BC%9A%E6%95%B4%E4%BD%93%E8%AE%BE%E8%AE%A1.html</link>
      <guid>https://liuyueyi.github.io/tutorial/column/app/spi/SPI%E6%A1%86%E6%9E%B6%E5%AE%9E%E7%8E%B0%E4%B9%8B%E6%97%85%E4%BA%8C%EF%BC%9A%E6%95%B4%E4%BD%93%E8%AE%BE%E8%AE%A1.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">2. SPI框架实现之旅二：整体设计</source>
      <description>整体设计 上一篇简单的说了一下spi相关的东西， 接下来我们准备开动，本篇博文主要集中在一些术语，使用规范的约定和使用方式 设计思路 下图围绕 SpiLoader 为中心，描述了三个主要的流程： load所有的spi实现 初始化选择器 selector 获取spi实现类 （or一个实现类代理） https://static.oschina.net/uploads/img/201705/26185143_ULnL.png</description>
      <category>Quick系列</category>
      <category>QuickSpi</category>
      <pubDate>Sun, 28 May 2017 10:50:37 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 整体设计</h1>
<blockquote>
<p>上一篇简单的说了一下spi相关的东西， 接下来我们准备开动，本篇博文主要集中在一些术语，使用规范的约定和使用方式</p>
</blockquote>
<!--more-->
<h2> 设计思路</h2>
<p>下图围绕 <code>SpiLoader</code> 为中心，描述了三个主要的流程：</p>
<ol>
<li>load所有的spi实现</li>
<li>初始化选择器 selector</li>
<li>获取spi实现类 （or一个实现类代理）</li>
</ol>
<figure><img src="https://static.oschina.net/uploads/img/201705/26185143_ULnL.png" alt="https://static.oschina.net/uploads/img/201705/26185143_ULnL.png" tabindex="0" loading="lazy"><figcaption><a href="https://static.oschina.net/uploads/img/201705/26185143_ULnL.png" target="_blank" rel="noopener noreferrer">https://static.oschina.net/uploads/img/201705/26185143_ULnL.png</a></figcaption></figure>
<hr>
<h2> 基础类说明</h2>
<blockquote>
<p>主要介绍一下框架中涉及到的接口和注解，并指出需要注意的点</p>
</blockquote>
<h3> 1. <code>Selector</code> 选择器</h3>
<blockquote>
<p>为了最大程度的支持业务方对spi实现类的选择，我们定义了一个选择器的概念，用于获取spi实现类</p>
</blockquote>
<h4> 接口定义如下:</h4>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 结合上面的接口定义，我们可以考虑下，选择器应该如何工作？</h4>
<ul>
<li>根据传入的条件，从所有的实现类中，找到一个最匹配的实现类返回</li>
<li>如果查不到，则抛一个异常<code>NoSpiMatchException</code>出去</li>
</ul>
<p>所以传入的参数会是两个， 一个是所有的实现类列表<code>map</code>（至于上面为什么用map，后续分析），一个是用于判断的输入条件<code>conf</code></p>
<h4> 框架中会提供两种基本的选择器实现，</h4>
<ul>
<li><code>DefaultSelector</code> ， 对每个实现类赋予唯一的name，默认选择器则表示根据name来查找实现类</li>
<li><code>ParamsSelector</code>， 在实现类上加上 <code>@SpiConf</code> 注解，定义其中的 <code>params</code>，当传入的参数(<code>conf</code>)， 能完全匹配定义的params，表示这个实现类就是你所需要的</li>
</ul>
<h4> 自定义实现</h4>
<p>自定义实现比较简单，实现上面的接口即可</p>
<h3> 2. <code>Spi</code> 注解</h3>
<blockquote>
<p>要求所有的spi接口，都必须有这个注解；</p>
</blockquote>
<h4> 定义如下</h4>
<p>主要是有一个参数，用于指定是选择器类型，定义spi接口的默认选择器，</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 说明</h4>
<p>在上一篇《SPI框架实现之旅一》中，使用jdk的spi方式中，并没有使用注解依然可以正常工作，我们这里定义这个注解且要求必需有，出于下面几个考虑</p>
<ul>
<li>醒目，告诉开发者，这个接口是声明的spi接口， 使用的时候注意下</li>
<li>加入选择器参数，方便用户扩展自己的选择方式</li>
</ul>
<h3> 3. <code>SpiAdaptive</code> 注解</h3>
<blockquote>
<p>对需要自适应的场景，为了满足一个spi接口，应用多重不同的选择器场景，可以加上这个注解；
如果不加这个注解，则表示采用默认的选择器来自适应</p>
</blockquote>
<h4> 接口说明</h4>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 说明</h4>
<p>这个注解内容和 @Spi 基本上一模一样，唯一的区别是一个放在类上，一个放在方法上，那么为什么这么考虑？</p>
<ul>
<li><code>@Spi</code> 注解放在类上，更多的表名这个接口是我们定义的一个SPI接口，但是使用方式可以有两种（静态 + 动态确认）</li>
<li><code>@SpiAdaptive</code> 只能在自适应的场景下使用，用于额外指定spi接口中某个方法的选择器 （如果一个spi接口全部只需要一个选择器即可，那么可以不使用这个注解）</li>
</ul>
<p>如下面的这个例子，print方法和 echo方法其实是等价的，都是采用 <code>DefaultSelector</code> 来确认具体的实现类；而 <code>write</code> 和 <code>pp</code> 方法则是采用  <code>ParamsSelector</code> 选择器;</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4. <code>SpiConf</code> 注解</h3>
<blockquote>
<p>这个主键主要是用在实现类上（或实现类的方法上），里面存储一些选择条件，通常是和<code>Selector</code>搭配使用</p>
</blockquote>
<h4> 定义如下</h4>
<p>定义了三个字段:</p>
<ul>
<li>name 唯一标识，用于 <code>DefaultSelector</code>；</li>
<li>params 参数条件， 用于 <code>ParamsSelector</code>；</li>
<li>order : 优先级， 主要是为了解决多个实现类都满足选择条件时， 应该选择哪一个 （谈到这里就有个想法， 通过一个参数，来选择是否让满足条件的全部返回）</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 说明</h4>
<p><code>SpiConf</code> 注解可以修饰类，也可以修饰方法，因此当一个实现类中，类和方法都有这个注解时， 怎么处理 ？</p>
<p>以下面的这个测试类进行说明</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在设计中，遵循下面几个原则：</p>
<ul>
<li>类上的<code>SpiConf</code>注解， 默认适用与类中的所有方法</li>
<li>方法上有<code>SpiConf</code>注解，采取下面的规则
<ul>
<li>方法注解声明name时，两个会同时生效，即想调用上面的echo方法， 通过传入 <code>ConsoleCode</code>（类注解不显示赋值时，采用类名代替） 和 <code>consoleEcho</code> 等价</li>
<li>方法注解未声明name时，只能通过类注解上定义的name（or默认的类名）来选择</li>
<li>order，取最高优先级，如上面的 <code>write</code> 方法的优先级是 1;   当未显示定义order时，以定义的为准</li>
<li>params: 取并集，即要求类上 + 方法上的条件都满足</li>
</ul>
</li>
</ul>
<h2> SPI加载器</h2>
<blockquote>
<p>spi加载器的主要业务逻辑集中在  <code>SpiLoader</code> 类中，包含通过spi接口，获取所有的实现类； 获取spi接口对应的选择器 （包括类对应的选择器， 方法对应的选择器）； 返回Spi接口实现类（静态确认的实现类，自适应的代理类）</p>
</blockquote>
<p>从上面的简述，基本上可以看出这个类划分为三个功能点， 下面将逐一说明，本篇博文主要集中在逻辑的设计层，至于优化（如懒加载，缓存优化等） 放置下一篇博文单独叙述</p>
<h3> 1. 加载spi实现类</h3>
<blockquote>
<p>这一块比较简单，我们直接利用了jdk的 <code>ServiceLoader</code> 来根据接口，获取所有的实现类；因此我们的spi实现，需要满足jdk定义的这一套规范</p>
</blockquote>
<p>具体的代码业务逻辑非常简单，大致流程如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 注意</h4>
<ul>
<li>因为使用了jdk的标准，因此每定义一个spi接口，必须在  <code>META_INF.services</code> 下新建一个文件， 文件名为包含包路径的spi接口名， 内部为包含包路径的实现类名</li>
<li>每个spi接口，要求必须有 <code>@Spi</code> 注解</li>
<li>Spi接口必须是 <code>interface</code> 类型， 不支持抽象类和类的方式</li>
</ul>
<h4> 拓展</h4>
<p>虽然这里直接使用了spi的规范，我们其实完全可以自己定义标准的，只要能将这个接口的所有实现类找到， 怎么实现都可以由你定义</p>
<p>如使用spring框架后，可以考虑通过   <code>applicationContext.getBeansOfAnnotaion(xxx )</code> 来获取所有的特定注解的bean，这样就可以不需要自己新建一个文件，来存储spi接口和其实现类的映射关系了</p>
<h4> 构建spi实现的关系表</h4>
<p>上面获取了spi实现类，显然我们的目标并不局限于简单的获取实现类，在获取实现类之后，还需要解析其中的 <code>@SpiConf</code> 注解信息，用于表示要选择这个实现，必须满足什么样的条件</p>
<p><code>SpiImplWrapper</code> :  spi实现类，以及定义的各种条件的封装类</p>
<p>注解的解析过程流程如下:</p>
<ul>
<li>name:    注解定义时，采用定义的值； 否则采用简单类名 （因此一个系统中不允许两个实现类同名的情况）</li>
<li>order： 优先级， 注解定义时，采用定义的值；未定义时采用默认；</li>
<li>params: 参数约束条件， 会取类上和方法上的并集（原则上要求类上的约束和方法上的约束不能冲突）</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 初始化选择器</h3>
<blockquote>
<p>我们的选择器会区分为两类，一个是类上定义的选择器， 一个是方法上定义的选择器； 在自适应的使用方式中，方法上定义的优先级 &gt; 类上定义</p>
</blockquote>
<p>简单来讲，初始化选择器，就是扫一遍SPI接口中的注解，实例化选择器后，缓存住对应的结果, 实现如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 说明</h4>
<ol>
<li>
<p><code>SeectorWrapper</code> 选择器封装类</p>
<p>这里我们在获取选择器时，特意定义了一个封装类，其中包含具体的选择器对象，以及所匹配的参数类型，因此可以在下一步通过选择器获取实现类时，保证传入的参数类型合法</p>
</li>
<li>
<p><code>private SelectorWrapper initSelector(Class&lt;? extends ISelector&gt; clz)</code>  具体的实例化选择器的方法</p>
<p>从实现来看，优先从选择器缓存中获取选择器对象，这样的目的是保证一个spi接口，每种类型的选择器只有一个实例；因此在自定义选择器中，你完全可以做一些选择判断的缓存逻辑，如 <code>ParamsSelector</code> 中的spi实现类的有序缓存列表</p>
</li>
<li>
<p><code>currentSelector</code> , <code>currentMethodSelector</code>, <code>selectorInstanceCacheMap</code></p>

</li>
</ol>
<h3> 3. 获取实现类</h3>
<blockquote>
<p>对使用者而言，最关注的就是这个接口，这里会返回我们需要的实现类（or代理）；内部的逻辑也比较清楚，首先确定选择器，然后通过选择器便利所有的实现类，把满足条件的返回即可</p>
</blockquote>
<p>从上面的描述可以看到，主要分为两步</p>
<ol>
<li>获取选择器</li>
<li>根据选择器，遍历所有的实现类，找出匹配的返回</li>
</ol>
<h4> 获取选择器</h4>
<p>初始化选择器之后，我们会有 <code>currentSelector</code> , <code>currentMethodSelector</code> 两个缓存</p>
<ul>
<li>静态确定spi实现时，直接用  <code>currentSelector</code> 即可 （spi接口中所有方法都公用类定义选择器）</li>
<li>动态适配时， 根据方法名在 <code>currentMethodSelector</code> 中获取选择器，如果没有，则表示该方法没有<code>@SpiAdaptive</code>注解，直接使用类的选择器 <code>currentMethodSelector</code> 即可</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 选择实现类</h4>
<p>这个的主要逻辑就是遍历所有的实现类，判断是否满足选择器的条件，将第一个找到的返回即可，所有的业务逻辑都在 <code>ISelector</code> 中实现，如下面给出的默认选择器，根据name来获取实现类</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h2> 流程说明</h2>
<blockquote>
<p>上面主要就各个点单独的进行了说明，看起来可能比较分散，看完之后可能没有一个清晰的流程，这里就整个实现的流程顺一遍，主要从使用者的角度出发，当定义了一个SPI接口后，到获取spi实现的过程中，上面的这些步骤是怎样串在一起的</p>
</blockquote>
<h3> 流程图</h3>
<p>先拿简单的静态获取SPI实现流程说明（动态的其实差不多，具体的差异下一篇说明），先看下这种用法的使用姿势</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <code>SpiLoader&lt;IPrint&gt; spiLoader = SpiLoader.load(IPrint.class);</code></h4>
<p>这行代码触发的action 主要是初始化所有的选择器, 如下图</p>
<ul>
<li>首先从缓存中查</li>
<li>是否已经初始化过了有则直接返回；</li>
<li>缓存中没有，则进入new一个新的对象出来
<ul>
<li>解析类上注解 <code>@Spi</code>，初始化 <code>currentSelector</code></li>
<li>解析所有方法的注解 <code>@SpiAdaptive</code> ， 初始化 <code>currentMethodSelector</code></li>
</ul>
</li>
<li>塞入缓存，并返回</li>
</ul>
<figure><img src="https://static.oschina.net/uploads/img/201705/27140821_19ee.png" alt="https://static.oschina.net/uploads/img/201705/27140821_19ee.png" tabindex="0" loading="lazy"><figcaption><a href="https://static.oschina.net/uploads/img/201705/27140821_19ee.png" target="_blank" rel="noopener noreferrer">https://static.oschina.net/uploads/img/201705/27140821_19ee.png</a></figcaption></figure>
<h4> <code>IPrint print = spiLoader.getService("ConsolePrint");</code></h4>
<p>根据name获取实现类，具体流程如下</p>
<ul>
<li>判断是否加载过所有实现类 <code>spiImplClassCacheMap</code></li>
<li>没有加载，则重新加载所有的实现类
<ul>
<li>通过jdk的 <code>ServiceLoader.load()</code> 方法获取所有的实现类</li>
<li>遍历实现类，根据 <code>@SpiConf</code> 注解初始化参数，封装 <code>SpiImplWrapper </code>对象</li>
<li>保存封装的 <code>SpiImplWrapper</code>对象到缓存</li>
</ul>
</li>
<li>执行 <code>currentSelector.select()</code> 方法，获取匹配的实现类</li>
</ul>
<figure><img src="https://static.oschina.net/uploads/img/201705/27150620_EOUL.png" alt="https://static.oschina.net/uploads/img/201705/27150620_EOUL.png" tabindex="0" loading="lazy"><figcaption><a href="https://static.oschina.net/uploads/img/201705/27150620_EOUL.png" target="_blank" rel="noopener noreferrer">https://static.oschina.net/uploads/img/201705/27150620_EOUL.png</a></figcaption></figure>
<h2> 其他</h2>
<h3> 博客系列链接：</h3>
<ul>
<li><a href="/hexblog/2018/05/30/SPI%E6%A1%86%E6%9E%B6%E5%AE%9E%E7%8E%B0%E4%B9%8B%E6%97%85%E5%9B%9B%EF%BC%9A%E4%BD%BF%E7%94%A8%E6%B5%8B%E8%AF%95/" target="_blank" rel="noopener noreferrer">SPI框架实现之旅四：使用测试</a></li>
<li><a href="/hexblog/2018/05/30/SPI%E6%A1%86%E6%9E%B6%E5%AE%9E%E7%8E%B0%E4%B9%8B%E6%97%85%E4%B8%89%EF%BC%9A%E5%AE%9E%E7%8E%B0%E8%AF%B4%E6%98%8E/u" target="_blank" rel="noopener noreferrer">SPI框架实现之旅三：实现说明</a></li>
<li><a href="/hexblog/2018/05/30/SPI%E6%A1%86%E6%9E%B6%E5%AE%9E%E7%8E%B0%E4%B9%8B%E6%97%85%E4%BA%8C%EF%BC%9A%E6%95%B4%E4%BD%93%E8%AE%BE%E8%AE%A1/" target="_blank" rel="noopener noreferrer">SPI框架实现之旅二：整体设计</a></li>
<li><a href="/hexblog/2017/05/29/SPI%E6%A1%86%E6%9E%B6%E5%AE%9E%E7%8E%B0%E4%B9%8B%E6%97%85%E4%B8%80%EF%BC%9A%E8%83%8C%E6%99%AF%E4%BB%8B%E7%BB%8D/" target="_blank" rel="noopener noreferrer">SPI框架实现之旅一：背景介绍</a></li>
</ul>
<h3> 项目: QuickAlarm</h3>
<ul>
<li>项目地址： <a href="https://github.com/liuyueyi/quick-spi" target="_blank" rel="noopener noreferrer">Quick-SPI</a></li>
<li>博客地址： <a href="https://liuyueyi.github.io/hexblog/" target="_blank" rel="noopener noreferrer">小灰灰Blog</a></li>
</ul>
<h3> 个人博客： <a href="https://liuyueyi.github.io/hexblog" target="_blank" rel="noopener noreferrer">Z+|blog</a></h3>
<p>基于hexo + github pages搭建的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛</p>
<h3> 声明</h3>
<p>尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见识有限，如发现bug或者有更好的建议，随时欢迎批评指正，我的微博地址: <a href="https://weibo.com/p/1005052169825577/home" target="_blank" rel="noopener noreferrer">小灰灰Blog</a></p>
<h3> 扫描关注</h3>
<figure><img src="https://s17.mogucdn.com/mlcdn/c45406/180209_74fic633aebgh5dgfhid2fiiggc99_1220x480.png" alt="QrCode" tabindex="0" loading="lazy"><figcaption>QrCode</figcaption></figure>
]]></content:encoded>
      <enclosure url="https://static.oschina.net/uploads/img/201705/26185143_ULnL.png" type="image/png"/>
    </item>
    <item>
      <title>4. SPI框架实现之旅四：使用测试</title>
      <link>https://liuyueyi.github.io/tutorial/column/app/spi/SPI%E6%A1%86%E6%9E%B6%E5%AE%9E%E7%8E%B0%E4%B9%8B%E6%97%85%E5%9B%9B%EF%BC%9A%E4%BD%BF%E7%94%A8%E6%B5%8B%E8%AF%95.html</link>
      <guid>https://liuyueyi.github.io/tutorial/column/app/spi/SPI%E6%A1%86%E6%9E%B6%E5%AE%9E%E7%8E%B0%E4%B9%8B%E6%97%85%E5%9B%9B%EF%BC%9A%E4%BD%BF%E7%94%A8%E6%B5%8B%E8%AF%95.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">4. SPI框架实现之旅四：使用测试</source>
      <description>使用测试 前面三篇主要是介绍如何设计的，如何实现的，这一篇，则主要集中在如何使用。实现得再好，如果不好用，也白搭 本篇介绍几个简单的使用case，包括静态使用，动态适配，自定义选择器等</description>
      <category>Quick系列</category>
      <category>QuickSpi</category>
      <pubDate>Tue, 30 May 2017 20:50:37 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 使用测试</h1>
<blockquote>
<p>前面三篇主要是介绍如何设计的，如何实现的，这一篇，则主要集中在如何使用。实现得再好，如果不好用，也白搭</p>
</blockquote>
<p>本篇介绍几个简单的使用case，包括静态使用，动态适配，自定义选择器等</p>
<!-- more -->
<h2> 1. 简单的静态使用</h2>
<p>定义一个SPI接口  <code>IPrint</code>,  两个实现  <code>FilePrint</code>, <code>ConsolePrint</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>添加配置文件 <code>com.hust.hui.quicksilver.spi.test.print.IPrint</code>, 内容如下</p>

<p>测试代码如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>演示如下</p>
<figure><img src="http://s2.mogucdn.com/mlcdn/c45406/170531_308geabej59hh3hegbf2cdkb0e8kj_1224x718.gif" alt="http://s2.mogucdn.com/mlcdn/c45406/170531_308geabej59hh3hegbf2cdkb0e8kj_1224x718.gif" tabindex="0" loading="lazy"><figcaption><a href="http://s2.mogucdn.com/mlcdn/c45406/170531_308geabej59hh3hegbf2cdkb0e8kj_1224x718.gif" target="_blank" rel="noopener noreferrer">http://s2.mogucdn.com/mlcdn/c45406/170531_308geabej59hh3hegbf2cdkb0e8kj_1224x718.gif</a></figcaption></figure>
<h2> 2. 动态适配</h2>
<p>与静态的使用有点区别，主要的区别点在于接口的定义（需要注意第一个参数是作为选择器选择SPI实现的参数），同样是上面这个spi接口</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>主要是新增了一个接口 <code>adaptivePrint</code>,  其他的没有啥区别，测试代码如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>演示图</p>
<figure><img src="http://s2.mogucdn.com/mlcdn/c45406/170531_54f638fkcl58c6lihl92adei31c78_1222x718.gif" alt="http://s2.mogucdn.com/mlcdn/c45406/170531_54f638fkcl58c6lihl92adei31c78_1222x718.gif" tabindex="0" loading="lazy"><figcaption><a href="http://s2.mogucdn.com/mlcdn/c45406/170531_54f638fkcl58c6lihl92adei31c78_1222x718.gif" target="_blank" rel="noopener noreferrer">http://s2.mogucdn.com/mlcdn/c45406/170531_54f638fkcl58c6lihl92adei31c78_1222x718.gif</a></figcaption></figure>
<h2> 3. 自定义选择器</h2>
<blockquote>
<p>上面两个很简单的演示了下使用方式，最基本的方法， 没有加上 @SpiConf 注解， 没有显示指定选择器类
型，下面则演示下，如何自定义选择器</p>
</blockquote>
<p><strong>SPI接口</strong></p>
<p>有一个欢迎方法，我们需求根据用户的来源显示不同的欢迎至此， 下面定义了一个 <code>UserSelector</code>选择器，这个就是我们自定义的选择器</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>spi实现类</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>META-INF/services/</code> 目录下的配置如下 <code>com.hust.hui.quicksilver.spi.def.spi.IUser</code></p>

<p>选择器实现如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从上面的选择器逻辑可以看出，我们是根据 UserDO的market参数来进行选择的， UserDO的定义如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>测试代码如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果:</p>

<p>演示如下:</p>
<figure><img src="http://s2.mogucdn.com/mlcdn/c45406/170531_8af3ek900d8c783031lc7h375a0b8_1222x718.gif" alt="http://s2.mogucdn.com/mlcdn/c45406/170531_8af3ek900d8c783031lc7h375a0b8_1222x718.gif" tabindex="0" loading="lazy"><figcaption><a href="http://s2.mogucdn.com/mlcdn/c45406/170531_8af3ek900d8c783031lc7h375a0b8_1222x718.gif" target="_blank" rel="noopener noreferrer">http://s2.mogucdn.com/mlcdn/c45406/170531_8af3ek900d8c783031lc7h375a0b8_1222x718.gif</a></figcaption></figure>
<h2> 3. 其他</h2>
<h3> 博客系列链接：</h3>
<ul>
<li><a href="/hexblog/2018/05/30/SPI%E6%A1%86%E6%9E%B6%E5%AE%9E%E7%8E%B0%E4%B9%8B%E6%97%85%E5%9B%9B%EF%BC%9A%E4%BD%BF%E7%94%A8%E6%B5%8B%E8%AF%95/" target="_blank" rel="noopener noreferrer">SPI框架实现之旅四：使用测试</a></li>
<li><a href="/hexblog/2018/05/30/SPI%E6%A1%86%E6%9E%B6%E5%AE%9E%E7%8E%B0%E4%B9%8B%E6%97%85%E4%B8%89%EF%BC%9A%E5%AE%9E%E7%8E%B0%E8%AF%B4%E6%98%8E/" target="_blank" rel="noopener noreferrer">SPI框架实现之旅三：实现说明</a></li>
<li><a href="/hexblog/2018/05/30/SPI%E6%A1%86%E6%9E%B6%E5%AE%9E%E7%8E%B0%E4%B9%8B%E6%97%85%E4%BA%8C%EF%BC%9A%E6%95%B4%E4%BD%93%E8%AE%BE%E8%AE%A1/" target="_blank" rel="noopener noreferrer">SPI框架实现之旅二：整体设计</a></li>
<li><a href="/hexblog/2017/05/29/SPI%E6%A1%86%E6%9E%B6%E5%AE%9E%E7%8E%B0%E4%B9%8B%E6%97%85%E4%B8%80%EF%BC%9A%E8%83%8C%E6%99%AF%E4%BB%8B%E7%BB%8D/" target="_blank" rel="noopener noreferrer">SPI框架实现之旅一：背景介绍</a></li>
</ul>
<h3> 项目: QuickAlarm</h3>
<ul>
<li>项目地址： <a href="https://github.com/liuyueyi/quick-spi" target="_blank" rel="noopener noreferrer">Quick-SPI</a></li>
<li>博客地址： <a href="https://liuyueyi.github.io/hexblog/" target="_blank" rel="noopener noreferrer">小灰灰Blog</a></li>
</ul>
<h3> 个人博客： <a href="https://liuyueyi.github.io/hexblog" target="_blank" rel="noopener noreferrer">Z+|blog</a></h3>
<p>基于hexo + github pages搭建的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛</p>
<h3> 声明</h3>
<p>尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见识有限，如发现bug或者有更好的建议，随时欢迎批评指正，我的微博地址: <a href="https://weibo.com/p/1005052169825577/home" target="_blank" rel="noopener noreferrer">小灰灰Blog</a></p>
<h3> 扫描关注</h3>
<figure><img src="https://s17.mogucdn.com/mlcdn/c45406/180209_74fic633aebgh5dgfhid2fiiggc99_1220x480.png" alt="QrCode" tabindex="0" loading="lazy"><figcaption>QrCode</figcaption></figure>
]]></content:encoded>
      <enclosure url="http://s2.mogucdn.com/mlcdn/c45406/170531_308geabej59hh3hegbf2cdkb0e8kj_1224x718.gif" type="image/gif"/>
    </item>
    <item>
      <title>QuickAlarm</title>
      <link>https://liuyueyi.github.io/tutorial/column/app/alarm/</link>
      <guid>https://liuyueyi.github.io/tutorial/column/app/alarm/</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">QuickAlarm</source>
      <description>应用专栏</description>
      <pubDate>Mon, 29 Jul 2024 11:14:32 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 应用专栏</h1>
]]></content:encoded>
    </item>
    <item>
      <title>应用专栏</title>
      <link>https://liuyueyi.github.io/tutorial/column/app/</link>
      <guid>https://liuyueyi.github.io/tutorial/column/app/</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">应用专栏</source>
      <description>应用专栏 一个可扩展的报警系统Quick-Alarm 实现一个自定义的SPI框架 从0到1实现一个聊天应用</description>
      <pubDate>Mon, 29 Jul 2024 08:58:55 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 应用专栏</h1>
<ul class="task-list-container">
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-0" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-0"> <a href="/tutorial/column/app/alarm/" target="blank">一个可扩展的报警系统Quick-Alarm</a></label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-1" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-1"> <a href="/tutorial/column/app/spi/" target="blank">实现一个自定义的SPI框架</a></label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-2" disabled="disabled"><label class="task-list-item-label" for="task-item-2"> <a href="/tutorial/column/app/im/" target="blank">从0到1实现一个聊天应用</a></label></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>技术架构</title>
      <link>https://liuyueyi.github.io/tutorial/column/arch/</link>
      <guid>https://liuyueyi.github.io/tutorial/column/arch/</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">技术架构</source>
      <description>架构专栏 分布式专栏 《分布式高可用》</description>
      <pubDate>Mon, 29 Jul 2024 08:58:55 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 架构专栏</h1>
<h2> 分布式专栏</h2>
<ul>
<li><a href="/tutorial/column/arch/distribute/" target="blank">《分布式高可用》</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>技术管理</title>
      <link>https://liuyueyi.github.io/tutorial/column/tech/</link>
      <guid>https://liuyueyi.github.io/tutorial/column/tech/</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">技术管理</source>
      <description>从0到1做技术管理</description>
      <pubDate>Mon, 29 Jul 2024 08:58:55 GMT</pubDate>
      <content:encoded><![CDATA[<h2> <a href="/tutorial/column/tech/manager/" target="blank">从0到1做技术管理</a></h2>
]]></content:encoded>
    </item>
    <item>
      <title>01.实时聊天应用简介</title>
      <link>https://liuyueyi.github.io/tutorial/column/app/im/01.%E5%AE%9E%E6%97%B6%E8%81%8A%E5%A4%A9%E5%BA%94%E7%94%A8%E7%AE%80%E4%BB%8B.html</link>
      <guid>https://liuyueyi.github.io/tutorial/column/app/im/01.%E5%AE%9E%E6%97%B6%E8%81%8A%E5%A4%A9%E5%BA%94%E7%94%A8%E7%AE%80%E4%BB%8B.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">01.实时聊天应用简介</source>
      <description>1. IM简介 1.1 什么是实时聊天应用？ 实时聊天应用，又称即时通讯（Instant Messaging，简称IM），是一个允许两人或多人通过网络实时聊天应用，又称即时通讯（Instant Messaging，简称IM），是一个允许两人或多人通过网络实时传递文字消息、文件、语音与视频交流的系统。这类应用软件有两种架构形式：C/S架构和B/S架构。在C/S架构中，用户需要下载并安装客户端软件才能使用，例如微信、QQ等；而在B/S架构中，用户只需通过浏览器就可以进行聊天。 实时聊天应用具有极高的&amp;quot;实时性&amp;quot;和&amp;quot;可靠性&amp;quot;，消息的传递几乎没有延迟，且不会丢失。因此，这类应用被广泛应用于各种社交互动领域，如个人通信、商务沟通、企业协作等。</description>
      <category>IM</category>
      <pubDate>Wed, 27 Dec 2023 10:06:46 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 1. IM简介</h2>
<h3> 1.1 什么是实时聊天应用？</h3>
<p>实时聊天应用，又称即时通讯（Instant Messaging，简称IM），是一个允许两人或多人通过网络实时聊天应用，又称即时通讯（Instant Messaging，简称IM），是一个允许两人或多人通过网络实时传递文字消息、文件、语音与视频交流的系统。这类应用软件有两种架构形式：C/S架构和B/S架构。在C/S架构中，用户需要下载并安装客户端软件才能使用，例如微信、QQ等；而在B/S架构中，用户只需通过浏览器就可以进行聊天。</p>
<p>实时聊天应用具有极高的"实时性"和"可靠性"，消息的传递几乎没有延迟，且不会丢失。因此，这类应用被广泛应用于各种社交互动领域，如个人通信、商务沟通、企业协作等。</p>
<h3> 1.2 实时聊天应用的应用场景</h3>
<p>实时聊天应用的应用场景非常广泛，以下是一些常见的应用场景：</p>
<ol>
<li>
<p>社交沟通：即时通信 IM 为应用于社交沟通提供能力支持，可实现单聊、群聊、弹幕等多种聊天模式，支持文字、图片、语音、短视频等多种消息类型。实时消息推送满足消息到达率的要求，并可与实时音视频 TRTC 共同实现实时音视频通话，有效提升用户粘性与活跃度。</p>
</li>
<li>
<p>在线协作和协同编辑：对于需要多用户协同工作的应用，如协同编辑文档或绘图，WebSocket 的实时性使得用户能够看到其他用户的操作。</p>
</li>
<li>
<p>视频会议和聊天：视频会议、聊天等高实时性的场景，都适合使用IM来做。</p>
</li>
<li>
<p>抽奖和互动游戏：这些需要高实时性反馈的活动，也是实时聊天应用的典型应用场景。</p>
</li>
<li>
<p>股票基金实时报价、体育实况更新：这些需要实时信息更新的场景，可以利用实时聊天应用的特性，快速准确地将信息传递给用户。</p>
</li>
<li>
<p>基于位置的应用：例如Uber、滴滴等打车软件，可以利用实时聊天应用获取司机的位置信息，提高服务的便捷性和效率。</p>
</li>
</ol>
<h2> 2. WebSocket简介</h2>
<h3> 2.1 什么是WebSocket</h3>
<p>WebSocket是一种在单个TCP连接上进行全又向通信的协议。它是建立在TCP/IP协议之上，独立于HTTP协议，可以允许客户端和服务器之间进行双向通信。这种持久化的协议能够大幅度减少网络延迟和数据传输的开销，并提高资源利用率。</p>
<p>WebSocket的工作原理是，首先，客户端和服务端需要通过握手来建立连接。在握手成功之后，就会形成一条持久的连接通道，使得数据可以双向实时传输，一旦连接建立，服务端可以在任何时候将数据主动推送到客户端。这种方式不仅减少了频繁请求导致的网络延迟，还提高了用户体验。</p>
<p>此外，WebSocket还支持跨域通信，使得不同的域名、端口或协议之间的数据交换变得更容易。并且，WebSocket协议的端口是80，这使得其能够在大多数网络环境中顺利工作。</p>
<h3> 2.2 WebSocket与HTTP的区别</h3>
<p>WebSocket和HTTP是两种完全不同的网络协议，它们在通信方式、连接方式以及应用场景上都存在显著的差异。</p>
<p>首先，两者的通信方式不同。WebSocket是一种双向通信协议，能够实现客户端与服务器间实时双向信息传输。这意味着，服务器可以在任何时候将数据“推送”到客户端。而HTTP协议则是单向的，信息传送总是从客户端发起，服务器对请求做出响应。</p>
<p>其次，两者的连接方式也有所不同。WebSocket在建立连接时，需要经历一次由服务器和客户端进行的握手过程。一旦连接建立，该连接就会持续保持，直到被明确终止。这与HTTP的无状态连接方式形成了鲜明的对比，后者的每次数据传输都需要建立新的TCP连接。</p>
<p>此外，WebSocket和HTTP在应用场景上也各有所长。WebSocket由于其双向通信和长连接的特性，常被用于如聊天应用、实时通知等需要频繁、实时交互的场景；而HTTP协议则更多地用在需要获取或提交资源（如网页、图片等）的信息交换中。</p>
<h3> 2.3 WebSocket协议</h3>
<blockquote>
<p><a href="https://datatracker.ietf.org/doc/html/rfc6455" target="_blank" rel="noopener noreferrer">RFC 6455 - The WebSocket Protocol</a></p>
</blockquote>
<h4> 2.3.1 WebSocket的工作原理</h4>
<p>WebSocket是一种在单个TCP连接上进行全双工通信的协议，它允许服务端与客户端之间进行实时数据交互，且信息传递的方式可以是服务端主动向客户端推送。这种协议是建立在TCP协议之上的，能够实现双向通讯。</p>
<p>WebSocket协议的工作流程包括以下几个步骤：</p>
<ol>
<li>
<p>握手阶段：这是建立连接时的第一个阶段。客户端向服务端发送一个HTTP请求；然后，服务器在响应头中添加一些特殊的字段，表明愿意将当前的HTTP连接升级为WebSocket连接；当客户端收到这个响应后，也会在请求头中添加类似的字段，同时，客户端还会将<code>Sec-WebSocket-Key</code>对应的值通过SHA-1算法进行编码，将编码后的值作为<code>Sec-WebSocket-Accept</code>放在请求头中；最后，服务器对<code>Sec-WebSocket-Key</code>对应的值进行同样的SHA-1编码。</p>
</li>
<li>
<p>数据传输阶段：一旦连接建立，数据就可以在客户端和服务器之间双向流动。这个阶段是全双工的，意味着数据可以同时从客户端发送到服务器，也可以从服务器发送到客户端。</p>
</li>
</ol>
<p>此外，WebSocket协议还具有以下特点：</p>
<ul>
<li>信息传输的开销较小，因为其数据帧相较于HTTP请求报文小；</li>
<li>较低的服务器资源占用。由于WebSocket的长连接特性，服务器能处理更多的并发连接。</li>
</ul>
<h4> 2.3.2 WebSocket协议的握手过程</h4>
<p>WebSocket协议的握手过程是建立WebSocket连接前的重要步骤，主要包括以下步骤：</p>
<ol>
<li>客户端通过TCP连接到服务器。</li>
<li>客户端向服务器发送HTTP/1.1协议的GET请求，这个请求通常被称为握手请求。</li>
<li>握手请求中包含了几个特定的头信息，这些信息用于指示客户端希望升级到WebSocket协议。具体来说，这些头信息包括：</li>
</ol>
<ul>
<li>Upgrade: websocket，这表示客户端希望升级到WebSocket协议。</li>
<li>Connection: Upgrade，这表示客户端希望建立持久连接。</li>
<li>Sec-WebSocket-Key: 这是一个随机的Base64编码密钥，用于安全验证。</li>
<li>Sec-WebSocket-Version: 这指示了客户端使用的WebSocket协议版本。</li>
</ul>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="4">
<li>一旦服务器接收到并验证了这些头信息，它就会返回一个响应给客户端。这个响应也是一个HTTP/1.1协议的响应，对应的HTTP状态码为101，此外还包含了一些特定的头信息，例如Upgrade和Connection头信息，指示连接已经升级到了WebSocket协议。同时，响应的正文中包含了由服务器生成的Base64编码的握手响应。</li>
</ol>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="5">
<li>一旦客户端收到服务器的响应，它就会检查响应中的头信息以及正文中的握手响应。如果一切验证无误，那么WebSocket连接就建立起来了。</li>
</ol>
<p>对应的校验机制如下：</p>
<ul>
<li>客户端应首先检查服务端返回的状态码是否为 101, 只有在 HTTP 状态码为 101 时才代表服务端同意了协议升级, 对于其它类型的状态码, 客户端应根据 HTTP 状态码的语义做相应的处理</li>
<li>客户端应检查服务端返回的响应是否包含 Upgrade 字段, 若缺失, 代表 Upgrade 未成功, 客户端应终止 WebSocket 握手</li>
<li>客户端应检查 Upgrade 字段的值是否为 websocket (该字段是大小写不敏感的, 如 websocket, WebSocket, webSocket 等都是合法的), 若不是, 客户端应终止 WebSocket 握手</li>
<li>客户端应采用如上所表述的方式校验服务端返回的 Sec-WebSocket-Accept 字段的值是否合法, 若该字段不存在或值不符合预期, 则客户端应终止 WebSocket 握手</li>
<li>若服务端返回的 Header 中包含 Sec-WebSocket-Extensions, 但其字段的值并不在客户端最初向服务端发起握手时传递的 Sec-WebSocket-Extensions 的值列表中, 则客户端应终止 WebSocket 握手</li>
<li>若服务端返回的 Header 中包含 Sec-WebSocket-Protocol, 但该字段的值并不在客户端最初向服务端发起握手时传递的 Sec-WebSocket-Protocol 的值列表中, 则客户端应终止 WebSocket 握手</li>
</ul>
<p>以上就是WebSocket协议的握手过程，这个过程确保了客户端和服务器都明确彼此将使用WebSocket协议进行通信，并且已经完成了必要的安全验证。</p>
<h4> 2.3.3 WebSocket协议的消息格式</h4>
<p>WebSocket 以 frame 为单位传输数据, frame 是客户端和服务端数据传输的最小单元, 当一条消息过长时, 通信方可以将该消息拆分成多个 frame 发送, 接收方收到以后重新拼接、解码从而还原出完整的消息, 在 WebSocket 中, frame 有多种类型, frame 的类型由 frame 头部的 Opcode 字段指示, WebSocket frame 的结构如下所示:</p>
<figure><img src="/imgs/column/im/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>Frame由两部分组成：头部和数据部分。</p>
<p>头部是一个二进制字节流，包含以下几部分内容：</p>
<ul>
<li>Fin: 这是一个1比特的标志位，用于指示当前的frame是不是消息的最后一个分段。如果一个消息被切分为多个frame进行发送，那么除了最后一个frame，其他所有frame的Fin字段都会被设置为0，而最后一个frame的Fin字段则被设置为1。当然，如果一条消息没有被切分，那么一个frame就会包含完整的消息，此时该frame的Fin字段值就为1。</li>
<li>Rsv1, Rsv2, Rsv3: 这三个标志位各占1比特，目前还没有定义具体的含义，保留给后续的应用。</li>
<li>Opcode: 这是4比特的操作码，用于指示客户端和服务器之间要执行的具体操作。比如连接建立、关闭连接、文本消息、二进制消息等。</li>
<li>Mask: 这是一个1比特的标志位，用于指示是否需要对数据进行掩码处理。如果需要掩码处理，那么在数据字段中就会出现一个4字节的掩码键。</li>
<li>Payload length: 这是16比特的长度字段，表示接下来的数据长度。因为WebSocket协议支持传输的数据长度可以是任意的，所以这个字段是必要的。</li>
<li>Masking-key: 如果Mask标志位为1，那么这个字段就会出现。它是一个4字节的字段，用于对数据进行掩码处理。</li>
</ul>
<p>数据部分就是根据Payload length字段确定的具体数据内容。</p>
<h2> 3. 实时聊天技术方案</h2>
<p>实时聊天的通讯协议主要有以下几种：</p>
<ol>
<li>
<p>XMPP（可扩展消息与存在协议）：这是一个成熟且开源的即时聊天协议，基于XMPP的开源技术有openfire(后台端)、spark(客户端)等。它的优势在于比较成熟的聊天协议，已在XMPP协议内支持单聊、群聊、加好友等功能。</p>
</li>
<li>
<p>WebSocket：它是一种在单个TCP连接上进行全双工通讯的协议，可以实现客户端与服务器之间的实时数据交互。</p>
</li>
<li>
<p>MQTT（轻量级发布/订阅消息传输协议）：它是一种轻量级的发布/订阅模式的消息传输协议，适用于低带宽、不稳定网络环境下的通信。</p>
</li>
<li>
<p>CoAP（受限应用协议）：它是一种专为受限设备设计的应用层协议，适用于物联网等场景。</p>
</li>
</ol>
<p>其中WebSocket在实时聊天应用中的优势主要体现在以下几个方面：</p>
<ol>
<li>
<p>实时性：WebSocket提供了双向通信，服务器可以主动向客户端推送数据，实现的实时性非常高，适用于实时聊天、在线协作等应用。</p>
</li>
<li>
<p>减少网络延迟：与轮询和长轮询相比，WebSocket可以显著减少网络延迟，因为不需要在每个请求之间建立和关闭连接。</p>
</li>
<li>
<p>较小的数据传输开销：WebSocket的数据帧相比于HTTP请求报文较小，减少了在每个请求中传输的开销，特别适用于需要频繁通信的应用。</p>
</li>
<li>
<p>较低的服务器资源占用：由于WebSocket的长连接特性，服务器可以处理更多的并发连接，相较于短连接有更低的资源占用。</p>
</li>
<li>
<p>跨域通信：与一些其他跨域通信方法相比，WebSocket更容易实现跨域通信。</p>
</li>
<li>
<p>效率和可扩展性：WebSocket技术提供了一种在各种应用程序中实现实时通信的强大高效手段，包括聊天应用程序、协作工具、实时通知和多人游戏。</p>
</li>
</ol>
<p>接下来我们将基于WebSocket来实现一个实时聊天应用的开发搭建</p>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/column/im/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>QuickIM聊天专栏</title>
      <link>https://liuyueyi.github.io/tutorial/column/app/im/</link>
      <guid>https://liuyueyi.github.io/tutorial/column/app/im/</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">QuickIM聊天专栏</source>
      <description>WebSocket实现实时聊天应用专栏 实时聊天应用简介 什么是实时聊天应用？ 实时聊天应用的应用场景 WebSocket在实时聊天应用中的优势 WebSocket实时聊天应用架构设计 客户端架构设计 服务器端架构设计 数据库设计 使用WebSocket实现实时聊天功能 创建WebSocket连接 发送和接收消息 处理用户加入、退出和断开连接事件 优化实时聊天应用性能 心跳机制和重连机制 消息缓存和离线消息推送 数据压缩和合并 实现实时聊天应用的附加功能 表情和图片消息的发送与显示 消息记录和历史消息查询 消息通知和提醒 WebSocket实时聊天应用的安全性考虑 WebSocket的安全性问题及解决方案 防止恶意攻击和保护用户隐私 WebSocket实时聊天应用的跨平台支持 适配不同浏览器和设备 兼容多种操作系统和网络环境 WebSocket实时聊天应用的未来发展 WebSocket在移动互联网中的应用前景 WebSocket与其他新兴技术的融合 WebSocket的标准化和规范化进展</description>
      <pubDate>Mon, 29 Jul 2024 08:58:55 GMT</pubDate>
      <content:encoded><![CDATA[<h1> WebSocket实现实时聊天应用专栏</h1>
<ol>
<li>
<p>实时聊天应用简介</p>
<ul>
<li>什么是实时聊天应用？</li>
<li>实时聊天应用的应用场景</li>
<li>WebSocket在实时聊天应用中的优势</li>
</ul>
</li>
<li>
<p>WebSocket实时聊天应用架构设计</p>
<ul>
<li>客户端架构设计</li>
<li>服务器端架构设计</li>
<li>数据库设计</li>
</ul>
</li>
<li>
<p>使用WebSocket实现实时聊天功能</p>
<ul>
<li>创建WebSocket连接</li>
<li>发送和接收消息</li>
<li>处理用户加入、退出和断开连接事件</li>
</ul>
</li>
<li>
<p>优化实时聊天应用性能</p>
<ul>
<li>心跳机制和重连机制</li>
<li>消息缓存和离线消息推送</li>
<li>数据压缩和合并</li>
</ul>
</li>
<li>
<p>实现实时聊天应用的附加功能</p>
<ul>
<li>表情和图片消息的发送与显示</li>
<li>消息记录和历史消息查询</li>
<li>消息通知和提醒</li>
</ul>
</li>
<li>
<p>WebSocket实时聊天应用的安全性考虑</p>
<ul>
<li>WebSocket的安全性问题及解决方案</li>
<li>防止恶意攻击和保护用户隐私</li>
</ul>
</li>
<li>
<p>WebSocket实时聊天应用的跨平台支持</p>
<ul>
<li>适配不同浏览器和设备</li>
<li>兼容多种操作系统和网络环境</li>
</ul>
</li>
<li>
<p>WebSocket实时聊天应用的未来发展</p>
<ul>
<li>WebSocket在移动互联网中的应用前景</li>
<li>WebSocket与其他新兴技术的融合</li>
<li>WebSocket的标准化和规范化进展</li>
</ul>
</li>
</ol>
]]></content:encoded>
    </item>
    <item>
      <title>分布式</title>
      <link>https://liuyueyi.github.io/tutorial/column/arch/distribute/</link>
      <guid>https://liuyueyi.github.io/tutorial/column/arch/distribute/</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">分布式</source>
      <description>分布式系列专题 分布式设计理论基础 高可用介绍</description>
      <pubDate>Mon, 29 Jul 2024 08:58:55 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 分布式系列专题</h2>
<ul>
<li><a href="/tutorial/column/arch/distribute/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" target="blank">分布式设计理论基础</a></li>
<li><a href="/tutorial/column/arch/distribute/%E9%AB%98%E5%8F%AF%E7%94%A8/" target="blank">高可用介绍</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>01.契机</title>
      <link>https://liuyueyi.github.io/tutorial/column/tech/manager/01.%E5%BA%8F%20%E8%BD%AC%E7%AE%A1%E7%90%86%E7%9A%84%E5%A5%91%E6%9C%BA.html</link>
      <guid>https://liuyueyi.github.io/tutorial/column/tech/manager/01.%E5%BA%8F%20%E8%BD%AC%E7%AE%A1%E7%90%86%E7%9A%84%E5%A5%91%E6%9C%BA.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">01.契机</source>
      <description>在职业发展的旅程中，每位技术人员都会面临一个关键性的选择：是继续深耕技术领域，还是转向管理岗位。这一选择不仅关乎个人的职业路径，也涉及到如何最有效地发挥自身才能的问题。 我们必须承认，人的精力和时间是有限的资源。在技术领域达到高深境界的专家，其管理能力未必同样出色，反之亦然。管理与技术，虽然同为职场上的重要角色，但它们的要求和侧重点却大相径庭。技术的焦点在于解决与机器相关的具体问题，而管理的重心则在于协调人与人的关系，优化团队的整体效能。两者之间的差异，使得在两者间寻求平衡成为一项挑战。 在过去的一年里，我深刻体会到了这一难题。我面临的困境是：我应继续深化我的技术专长，还是应该转型，投身于管理岗位。</description>
      <category>技术管理</category>
      <pubDate>Wed, 31 Jan 2024 08:53:46 GMT</pubDate>
      <content:encoded><![CDATA[<p>在职业发展的旅程中，每位技术人员都会面临一个关键性的选择：是继续深耕技术领域，还是转向管理岗位。这一选择不仅关乎个人的职业路径，也涉及到如何最有效地发挥自身才能的问题。</p>
<p>我们必须承认，人的精力和时间是有限的资源。在技术领域达到高深境界的专家，其管理能力未必同样出色，反之亦然。管理与技术，虽然同为职场上的重要角色，但它们的要求和侧重点却大相径庭。技术的焦点在于解决与机器相关的具体问题，而管理的重心则在于协调人与人的关系，优化团队的整体效能。两者之间的差异，使得在两者间寻求平衡成为一项挑战。</p>
<p>在过去的一年里，我深刻体会到了这一难题。我面临的困境是：我应继续深化我的技术专长，还是应该转型，投身于管理岗位。</p>
<p>经过一年多的实践和深思，我积累了一些关于技术和管理融合的经验和反思。我希望通过分享这些经验，能够为同行们提供一些参考，特别是那些在技术和管理之间徘徊不决的同仁。</p>
<p>以下是我个人对技术与管理结合的总结与思考，希望能够对大家有所启发，也期待与各位共同探讨，以促进我们在这一复杂领域中的成长和进步。</p>
<h2> 谈一谈职业规划</h2>
<p>关于程序员的职业规划，下面有一张网图，感觉还是很有代表性分享给大家</p>
<figure><img src="/imgs/column/manager/职业发展路线图.jpg" alt="网图来源: https://baijiahao.baidu.com/s?id=1719180248008940422" tabindex="0" loading="lazy"><figcaption>网图来源: <a href="https://baijiahao.baidu.com/s?id=1719180248008940422" target="_blank" rel="noopener noreferrer">https://baijiahao.baidu.com/s?id=1719180248008940422</a></figcaption></figure>
<p>从上图可以看出，当你实际干了几年之后，通常会出现一个分支，继续走技术，往专家、架构的方向走，还是往技术管理、项目经理的路线发展</p>
<p>就个人职业发展规划而言，我的性格倾向较为内向，并不擅长或特别偏好与人频繁互动。鉴于此，我的初步规划是沿着技术路线发展。</p>
<p>在技术路线上，我们可以进一步细分为两个方向：</p>
<ol>
<li>纯粹的技术方向，这一路径要求深厚的技术功底，专注于解决技术难题、构建系统架构，例如成为Redis、消息队列（MQ）等领域的技术专家。</li>
<li>业务专家方向，这要求深入理解业务领域，更侧重于实际业务问题的解决方案和架构能力，成为业务线中的核心力量。</li>
</ol>
<p>在我国的职场环境中，纯粹技术路径的机会相对有限。对于大多数程序员来说，成为业务专家可能是一个更加现实和贴切的选择。以下是我对于职业规划的一些思考，这些观点主要适用于面试环节或是与上级领导讨论职业发展规划时的情况。</p>
<h3> 如何谈自己的职业规划</h3>
<ol>
<li>技术路线</li>
</ol>
<p>比如我个人比较喜欢搞技术，因此想在技术这一条路线上继续往下周，通常有两个方向，一个是业务架构、一个技术架构；</p>
<p>1.1 针对业务架构方向：</p>
<p>业务架构可能更看重实际的业务解决能力，然后结合自己的实际工作经验说一下
比如：我想成为某个领域的业务专家，梳理复杂的业务模型、制定业务标准解决方案，我的规划是先希望能成为某个业务的负责人，然后再往上负责一条业务线，最后希望可以成为行业类的专家</p>
<ul>
<li>为了往这个方向发展，我做了哪些尝试，比如不仅仅局限开发的角色，会主动反推产品优化业务模型等、不断地学习相关的业务知识点，比如学习了xxxx，参加了xxx会议分享，组织了xxx业务共创会等;</li>
</ul>
<p>1.2 针对技术架构方向</p>
<p>技术架构，则可以从纯技术的角度出发，比如个人还是有很强的技术崇拜，更喜欢做一些技术上的东西，因此希望朝着主程，高级开发，系统架构的方向进行发展</p>
<ul>
<li>对于此，自己做了xxx，比如先成为团队的技术骨干，掌握日常工作的所有技术栈，时刻关心新的技术架构、技术演进，经常参加一些xxx技术会议，平时遇到问题都追本溯源，深挖原理细节，做完之后也会输出相关的复盘给别人分享； 经常思考现在工作项目的架构设计、为什么这么设计，可以怎么优化，组织技术方案评审、架构评审等等都可以谈 （当然重点突出自己做过的事情，不然一问深就露馅了）</li>
</ul>
<ol start="2">
<li>管理路线</li>
</ol>
<p>如果想做技术管理，则可以从职业的生涯规划来说，谈一下什么一个人可以走的很快，但不一定能走的很远；一个团队则可以走的更稳、更远，也希望能结合自己的技术能力 + 加上团队的力量，最大的发挥出自己的特长</p>
<p>2.1 技术管理
先简单说一下为什么想做技术管理，以及个人的忧思：比如一个人的影响范围有限，更希望能依托自己技术的优势，充分发挥一拨人的潜能，干一些有意思、有挑战、有成就感的事情</p>
<ul>
<li>基于此，平时除了做技术的事情之外，也会额外关心team leader是怎么带领团队的，然后从他身上学习xxx</li>
<li>平时也会带一些实习生、应届生，增加自己的带人能力</li>
<li>在一些日常的项目需求中，主动承担牵头人角色，积累自己项目管理的经验，比如具体的有xxx</li>
<li>经常和一些小组长、管理者聊，怎么样来调动大家的积极性，自己也经常学习一些相关视频、文章，提升自己的人际处理能力等</li>
</ul>
<p>2.2 项目经理
对技术人员而言，这条路线相当于转行了，因此要先说一下为什么想做这个：</p>
<ul>
<li>一个供参考的回答
比如说自己有很多的想法，想去充分发挥自己的才能，更喜欢做一些落地事情；或者非常擅长人际关系，资源协调。想充分体验一下不同的风景</li>
</ul>
<p>对于此，自己的努力尝试：</p>
<ul>
<li>个人性格外向，社牛，很会和被人打交道，很会维护人际关系，很会协调资源等 (优势)</li>
<li>做了xxx项目管理的学习，从一些大牛身上学到了xxx  （说明自己有在持续学习）</li>
<li>平时有提高自己的汇报、文档能力 （PM基本功）</li>
<li>在平时的项目管控中，有意思的加强自己的节奏控制能力，比如之前负责xxx项目，经过了xxx步骤，最终完美交付</li>
</ul>
<h2> 转管理的契机</h2>
<p>在我的职业生涯中，目前我正担任技术管理的职位，这已是我第二次承担此类角色。初次尝试管理职位是在一家初创公司，当时的技术负责人离职后，我便接替了他的位置。与许多人的首次管理经历相似，我缺乏管理经验，经历了一段时间的摸索和努力，最终效果却是一般。而现在，我面临着第二次管理的机会。</p>
<p>在2022年底，我转至一家新公司，这里的团队更重视管理经验而非单纯的技术能力。公司的运作模式与IT行业常见的持续迭代和维护的项目有所不同，主要是周期性项目。通常，一个项目的生命周期并不长，项目交付并回款后，主要的工作便是运维，这与外包工作的性质比较相似。加入公司后，感受很深的一点是，在现在的这个环境中，技术研发的地位非常低，一条路走技术是不长久的。</p>
<p>在这样的背景下，我在入职一个月后遇到了转变的契机。公司有一个企业电商项目需要从外部合作方转回内部进行研发和运营。可能是考虑到公司内部具备电商背景的人员较少，我就被选中参与这个项目。当然，对于这个项目，我最初是持怀疑态度，不太愿意接手，主要原因有两点：</p>
<ol>
<li>这是一个已在线运行的项目，每日成交额超过1亿，代码量达千万级别，除了代码外几乎没有任何有效文档，而我需要在半年内完全接手；并且在项目经理与我交谈时，团队的基本框架尚未建立，整个项目看起来比较不靠谱</li>
<li>当时我所在的项目组工作相对轻松，工作量小，压力不大，下班时间早，这是我从业以来经历过的最轻松的工作，按照内心想法，确实不太愿意离开现在的神仙项目组。</li>
</ol>
<p>在选择的过程中，发生了一个小插曲。我个人更倾向于留在原项目组，也与原项目组的项目经理（PM）讨论其对2023年的规划以及我能发挥的作用。PM建议我若不想加入新项目组，应尽快向公司高层表达我的立场。然而，由于高层领导忙碌，我未能找到合适的机会表达我的想法。而直接负责这个新项目的负责人先行与我交谈，然后我便加入了这个新项目。</p>
<p>之前阅读《知行》一书时，作者提到“超过80%的技术管理者，都是在没有明确表达管理意愿的情况下，被公司推到管理岗位的。”，就我个人的感受而言，在IT行业，突然被推上管理岗位的情况确实比其他行业更为常见。那么，当这样的机会来临时，我们是否真的做好了准备呢？</p>
<h2> 预设目标</h2>
<p>随着新的征程的开启，设定明确的目标对于成功至关重要。在23年初，我即将踏入新项目组并面对即将到来的挑战时，为自己设定了以下目标：</p>
<ol>
<li>迅速融入新项目，建立团队成员之间的信任，并组建一个高效的团队。</li>
<li>顺利接手项目任务，确保工作的连续性和项目的顺利交付。</li>
<li>完成从技术专家到管理角色的转变，培养出一个具有强大战斗力的团队。</li>
</ol>
<p>这些目标在当时看来可能显得有些抽象，缺乏具体的衡量指标。为了在接下来的系列分享中能够对这些目标进行详细分析，我计划在最后的总结中对它们进行深入拆解。 接下来，让我们正式开始这一段项目管理的旅程。</p>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/column/manager/职业发展路线图.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>02.准备工作</title>
      <link>https://liuyueyi.github.io/tutorial/column/tech/manager/02.%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C.html</link>
      <guid>https://liuyueyi.github.io/tutorial/column/tech/manager/02.%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">02.准备工作</source>
      <description>在中国传统文化中，有一句古老的谚语：“凡事预则立，不预则废”，这句话强调了在任何事务中，事前的规划和准备的重要性。对于我这样管理经验尚待提升，且未能拥有显著天赋优势的个体，面对新的挑战，提前进行细致的规划和准备显得尤为重要。 当前，我们正面临一个崭新的项目挑战，这个项目不仅要求我们团队展现出卓越的专业能力，更要求我们在组织和协调上达到新的高度。值得注意的，是甲方对我们团队的组长角色（包括产品、前端、后端、测试）提出了面试考核的要求，这无疑对团队的专业素质和综合能力提出了更高的标准。 在此，我必须指出，尽管这一要求在初次提出时，可能给人带来了一种被质疑或不被信任的错觉，但从专业角度看，这实际上是对项目成功完成的一种保障，也是对团队成员能力的一次全面审视。通过这样的面试考核，我们能够确保团队的每一个成员都具备足够的能力和专业知识，以应对项目中可能出现的各种挑战。</description>
      <category>技术管理</category>
      <pubDate>Thu, 01 Feb 2024 08:53:46 GMT</pubDate>
      <content:encoded><![CDATA[<p>在中国传统文化中，有一句古老的谚语：“凡事预则立，不预则废”，这句话强调了在任何事务中，事前的规划和准备的重要性。对于我这样管理经验尚待提升，且未能拥有显著天赋优势的个体，面对新的挑战，提前进行细致的规划和准备显得尤为重要。</p>
<p>当前，我们正面临一个崭新的项目挑战，这个项目不仅要求我们团队展现出卓越的专业能力，更要求我们在组织和协调上达到新的高度。值得注意的，是甲方对我们团队的组长角色（包括产品、前端、后端、测试）提出了面试考核的要求，这无疑对团队的专业素质和综合能力提出了更高的标准。</p>
<p>在此，我必须指出，尽管这一要求在初次提出时，可能给人带来了一种被质疑或不被信任的错觉，但从专业角度看，这实际上是对项目成功完成的一种保障，也是对团队成员能力的一次全面审视。通过这样的面试考核，我们能够确保团队的每一个成员都具备足够的能力和专业知识，以应对项目中可能出现的各种挑战。</p>
<p>作为项目团队的一员，我们应该（但是我并不想）积极地接受这一挑战。 为了应对这次的面试，我提前做了一些准备，当然并不算充分；对于技术上倒是没有什么好担心的，个人则主要从项目背景和管理方法论上做一些调研。</p>
<h2> 1. 背景调研</h2>
<p>原先，我并未打算详细阐述项目背景，因为目前我参与的这个项目，与典型的IT项目存在显著差异，并且涌现出许多意料之外的挑战。鉴于这些挑战在后续的分享中可能会以各种形式不断显现，我认为有必要阐明下此项目的具体形态。当然由于某些特殊原因，我将对于项目的相关背景会做一些脱敏处理;</p>
<p>业务类型： 垂直行业的ToB领域的电子商城</p>
<p>项目归属： 我所在的公司的兄弟企业的核心支柱</p>
<p>原运营方： 外部分供方</p>
<p>任务目标： 将项目从外部分供方完整的迁移到新的项目组，并按约定实现合同约定的各专项任务</p>
<p>当然再开始之初，上面这些背景中我只知道上面的业务类型 + 任务目标，其他的就不太清楚了；从现在往回看，这个背景中，最值得说的是这个项目的多方关系</p>
<h3> 项目组织关系</h3>
<figure><img src="/imgs/column/manager/02_项目关系图.jpg" alt="项目关系图" tabindex="0" loading="lazy"><figcaption>项目关系图</figcaption></figure>
<p>这个组织关系看起来有点怪，商城这个项目的所有权在<code>孙公司B-1</code>手中，他们自己又有产研团队，为啥不自己接，而是让我所在<code>孙公司A-1</code>来接产研呢？</p>
<p>两方面原因：</p>
<ol>
<li><code>孙公司B-1</code> 尝试自己承接，没接下来（题外话：这个项目业务及代码的复杂性确实有些离谱）</li>
<li>集团总部的直接任务下发，我所在的<code>孙公司A-1</code>的使命就是承接集团的信息化工作</li>
</ol>
<p>再说句题外话，我所在的<code>孙公司A-1</code>愿意接这个项目吗？ 答案是否订的，核心原因就一点，没有利益（即不赚钱，还责任多）</p>
<p>从项目的组织关系就可以看出，这个项目的工作模式好不起来，如何协调多方利益是个非常大挑战（还好我不是项目经理，不然我就直接投降了），对于技术管理而言，难受的就是外部协作沟通，后面会准备一篇专文来说我这一年的愉(bie)快(qu)体验</p>
<h3> 项目业务背景</h3>
<p>一个垂直领域面向企业端的电子商城，再开始之处，对于这个商城我所有能获取到的信息就是借助搜索引擎找到的商城主站，本想体验一下这个商城有哪些功能板块，具体的业务形态，结果不让注册、未登录的用户只能看到商品详情，连价格也看不到...，所以再实际进场这个项目之前，我对它的了解两个概念 “TOB" + “电子商城”</p>
<p>以我个人的实际体会来说，建议大家再到一个新的项目组做技术管理之前，做好背景调研是一个非常重要的前置工作，比如大家都是这个领域的新手、你怎么快速脱颖而出？ 若只有你是新来的、你怎么让别人信服你？ 很，但是又很幸运，项目组内了解过这个项目的产研不过两三人，且了解得都不算多，所以我的小白表现并不算突出</p>
<p>基于我个人的实际经历，我强烈建议在加入一个新的项目团队并担任技术管理职责之前，进行充分的背景调研是至关重要的。这一步骤对于项目的顺利进行和您的个人发展都至关重要。</p>
<ol>
<li>
<p><strong>行业知识储备</strong>：在进入一个全新的领域时，首要任务是积累相关的行业知识和术语。这可以通过阅读行业报告、研究市场趋势、分析竞争对手以及与行业专家交流来实现。</p>
</li>
<li>
<p><strong>项目历史了解</strong>：深入了解项目的历史发展，包括之前的成功案例和遇到的挑战，可以帮助您更好地理解项目的现状和未来的方向。</p>
</li>
<li>
<p><strong>技术栈掌握</strong>：熟悉项目所使用的技术和工具，这对于技术管理者来说是基础。您需要了解这些技术的优缺点，以及它们如何适应项目需求。</p>
</li>
<li>
<p><strong>团队动态分析</strong>：了解团队成员的技能、经验和工作风格，以及他们在项目中的角色和责任，有助于建立有效的沟通和合作。</p>
</li>
<li>
<p><strong>业务流程理解</strong>：深入理解企业端电子商城的业务流程，包括供应链管理、库存控制、订单处理等，这是确保技术解决方案与业务需求相匹配的关键。</p>
</li>
<li>
<p><strong>风险评估</strong>：识别潜在的风险点，并为可能出现的问题制定应对策略。</p>
</li>
<li>
<p><strong>建立信任</strong>：作为新加入的成员，您需要通过展示您的专业知识、沟通能力和领导才能来赢得团队的信任。这可能包括提供有价值的见解、积极参与讨论和决策过程，以及在必要时提供指导和支持。</p>
</li>
</ol>
<p>显然这一块我的工作做的并不合格，但幸运的是，团队中对该项目有深入了解的成员并不多。这意味着，尽管我是新手，但我的不足并没有立即凸显出来。然而，这并不意味着可以忽视背景调研的重要性。</p>
<h2> 2. 技术管理方法论学习</h2>
<p>由于之前的管理经验不够成熟，或者说不成体系，因此再面对这个新的转机时，求助一下外援楼仔（他的公众号就是“楼仔”，干货满满），学习下相关的方法论，当时的目的比较简单，一个是应付甲方爸爸的面试，另外一个则是规划一下后面怎么带队</p>
<figure><img src="/imgs/column/manager/02_管理经验图谱.png" alt="项目关系图" tabindex="0" loading="lazy"><figcaption>项目关系图</figcaption></figure>
<p>上图是之前准备的管理经验图谱，接下来会从两个方面进行细说</p>
<h3> 2.1 团队管理方法论</h3>
<blockquote>
<p>事先声明：市面上有很多的团队管理书籍及相关理论，以下内容仅个人看法、一家之谈，由于我个人经验有限、知识储备不足，如有错漏，误导之处，还请海涵</p>
</blockquote>
<p>首先这里明确一点，团队管理并不局限于自己所在团队内的相关工作，从我们自己所处的阶层来说，可以区分为向上汇报、横向沟通以及向下管理，还有一个对外的沟通这里没有提及，后续补上</p>
<figure><img src="/imgs/column/manager/02_团队管理.png" alt="团队管理" tabindex="0" loading="lazy"><figcaption>团队管理</figcaption></figure>
<h4> 向上汇报</h4>
<p>向上沟通对我个人而言是一个非常有挑战的事情，但是它又是对每一个技术管理者而言，不得不面对的事情</p>
<p>就我个人的感触而言，向上沟通主要有下面几个困扰：</p>
<ol>
<li>对上层的天然敬畏，就像我们小时候怕家长、老师一样，能绕着就绕着，能不沟通就不沟通</li>
<li>不知道怎么聊，纯业务/技术的聊天会很干，聊闲话的又不会找主题，拿捏不好尺度和分寸</li>
<li>听不懂潜台词，这感觉是好多技术人的通病</li>
<li>不懂如何拒绝或影响上级的决策</li>
</ol>
<p>上面是一些向上汇报的实际问题，前期的准备也不可能把所有的答案都搞到，或者说即便有标准答案在手，我也不一定执行得起来</p>
<p>因此再这一环节，准备先抓核心，为什么要向上汇报，目的是什么，以什么形式展开，有什么可以注意的事项，所以我准备的方法论比较简单，主要用于规范自己的行为</p>
<ul>
<li>目的：阶段性成果上报--邀功，寻求上级协助--请外援，大事拍板--不想背锅，获取上级才知道的信息--不当傻子</li>
<li>形式：汇报时以PPT, 简明扼要的文档，准备充分的演讲方式进行； 闲聊时，没啥形式可说了</li>
<li>注意：
<ul>
<li>大方向的汇报，不拘泥于细节</li>
<li>提问题时，梳理现状，问题是什么，我们给出的解决方案，希望得到的资源是什么</li>
<li>汇报成绩时，有条理的列成绩，有数据效果支撑，有总结，有规划</li>
<li>找老板关系的点汇报，而不是你关心的点</li>
</ul>
</li>
</ul>
<h4> 横向沟通</h4>
<p>横向沟通主要是指和你同层级的技术管理、另外的团队之间的沟通协作，对于研发团队而言，跨团队的交流非常普遍，比如前后端协作，研发测试，研发产品都属于这一类</p>
<p>横向沟通的目的比较存粹，<code>信息同步、目标拉齐</code></p>
<p>对于技术管理者而言，我们需要提前了解业务动向，知道产品准备做哪些规划，我们现在的资源是否足以应对产品接下来的计划，协作的团队是否可以跟上等等问题；切记在自己啥也不了解的情况下，接了需求，给团队带来无法交付的任务</p>
<p>其次对于技术管理者而言，横向沟通这里还有一个常见的场景就是帮助团队内的小伙伴和其他团队人员的协作，由于身份地位的问题，你组内成员的话语权没有你的大，他们在跨团队的推动中往往会遇到很多他们解决不了的问题，作为一个靠谱的领导者，不应对此视而不见、全部视为他们自己应该解决的问题，该站出来时就得站出来，能抗得住事、帮团队解决困难是建立个人领导力必不可少的要求</p>
<h4> 向下管理</h4>
<p>团队内管理，可以说是技术管理的任务重心，从方法论中学到的核心点在于：</p>
<ul>
<li>
<p>建立权威：让人信服</p>
<ul>
<li>常见的形式: 早会、日报/周报等机制</li>
<li>目的： 掌握团队的整体情况，了解每个人的工作饱和度，盯紧项目进度，提前评估风险</li>
</ul>
</li>
<li>
<p>维持信任关系：</p>
<ul>
<li>形式：通过1v1的聊天，了解团队内成员的诉求</li>
<li>以身作则，言必行</li>
<li>平等交流，信息透明</li>
<li>日常活动中拉近关系</li>
</ul>
</li>
<li>
<p>培养备份</p>
<ul>
<li>找一个自己的backup，实现互助</li>
<li>多认可，争取权益</li>
</ul>
</li>
</ul>
<h3> 2.2 项目管理方法论</h3>
<p>关于项目管理的方法论将主要从项目流程管理与风险进度管理进行说明，关于这块的内容就不进行展开，有兴趣的小伙伴请关注第六篇</p>
<figure><img src="/imgs/column/manager/02_项目管理.png" alt="项目管理" tabindex="0" loading="lazy"><figcaption>项目管理</figcaption></figure>
<h4> 项目流程管理</h4>
<ol>
<li>建立需求池机制</li>
</ol>
<p>主要目的是方便管理者了解短期、长期的产品项目规划，提前做好资源准备</p>
<p>其次需要针对需求池中的任务进行优先级划分，根据不同优先级来安排研发计划</p>
<ol start="2">
<li>做好提前沟通</li>
</ol>
<p>对于技术管理而言，最好是提前与产品沟通需求说明书，判断是否再团队的可承受范围内，需求是否可以进行拆解，是否合理</p>
<p>这里对于技术管理提了一个要求，有足够的精力识别这些任务，可以判断它的合理性以及预估大致的工期，然后对大方向的讨论控制在私下的与产品的沟通中，避免在需求评审中发生争执，给团队内同学造成不好的影响</p>
<ol start="3">
<li>评审机制</li>
</ol>
<p>建立研发流程中的通用评审机制，如需求方案评审，研发的反串讲，技术方案评审，代码review</p>
<p>通常而言，上面的几个评审中，需求方案评审不可缺少（除非是非常简单，显示样式的小调整，改个显示字段等），反串讲和技术方案的评审，一般是面向业务/技术复杂的多人协作的需求，一般来讲，有技术方案评审的需求，代码review也不建议省略</p>
<p>评审必然拉会，当会议一多，就会占据研发人员的工作时间，牢记一条  "小事大会，大事小会，重要的事不开会"</p>
<ol start="4">
<li>排期</li>
</ol>
<p>需求评审之后，通常我们就需要出排期，但是我们往往只会将开发时间安排进来，一个完整的排期，正常需要</p>
<ul>
<li>开发</li>
<li>自测</li>
<li>联调</li>
<li>上线</li>
<li>回归验证</li>
</ul>
<p>一个合理的任务排期，请确保要给自己预留足够的缓冲时间来应付各种突发状况（如请假、临时任务插入打断等）</p>
<p>除了上面排期需要考虑的事项之外，我们在安排进度计划时，需要考虑需求的优先级，将高优先级的先做，往前排，尽量优先保障</p>
<ol start="5">
<li>开发上线</li>
</ol>
<p>发测试 -&gt; 预发 -&gt; 生产</p>
<ol start="6">
<li>效果追踪</li>
</ol>
<p>这一环节通常是我们研发关注的较少的一点，需求上线之后，不出问题我们基本上就不会再花时间留意关注；但是作为一个技术管理而言，如何评估我们的产出、衡量我们的工作价值呢？</p>
<ul>
<li>再需求or项目上线之后，再跟踪一段时间，看下具体表现情况如何，收集相关数据指标</li>
<li>通过效果的追踪反馈，一方面让我们能更清晰的了解业务，另一方面也可以认识到自己的工作价值</li>
</ul>
<h4> 风险管控</h4>
<p>风险管理是每位管理者必须面对的挑战，尤其是当遇到理解深度和合作态度各异的业务方时，这一挑战尤为显著。</p>
<p><strong>1. 交付进度风险</strong></p>
<ul>
<li>时间管理：在项目排期阶段，应当预留合理的时间缓冲，以应对潜在的延误。同时，需实施持续的项目进度监控，确保研发迭代按计划推进，从而降低整体交付风险。</li>
</ul>
<p>若在项目执行过程中，发现由于评估过于乐观导致无法按期交付，应立即与业务方进行沟通，探讨是否可能调整交付时间表或简化需求。在极端情况下，可能需要重新分配资源或采取加班措施以确保项目按期完成。</p>
<ul>
<li>倒排期需求处理：对于具有严格时限的需求，需要细致地进行任务拆分和优先级排序。</li>
</ul>
<p>优先保障高优先级任务的完成，而低优先级任务则相应推迟。确保至少具备最小功能集的按时上线交付能力，以便在意外情况发生时，能够有备选方案减轻损失。</p>
<ol start="2">
<li>交付质量风险</li>
</ol>
<ul>
<li>功能质量保证：确保交付的功能无重大缺陷，且不会对主流程造成影响，这需要与测试团队建立良好的合作关系。</li>
<li>安全保障：确保交付的功能不存在安全漏洞，保护系统免受潜在威胁。</li>
</ul>
<ol start="3">
<li>其他非预期风险</li>
</ol>
<p>在项目管理中，总存在不可预测的风险。对此，没有固定的应对策略，但需要提前做好心理准备，并制定灵活的应急计划。</p>
<ul>
<li>人员变动风险：如裁员或团队重组等情况，需提前规划人力资源的备份计划。</li>
<li>需求变更风险：对于需求的变化，需要保持灵活性，及时调整项目计划以适应新的要求。</li>
<li>突发事件应对：如员工请假、更高优先级任务的插入、多任务并行开发等情况，需制定相应的风险管理策略，以确保项目的顺利进行。</li>
</ul>
<h3> 小结</h3>
<p>程序员转型为技术管理者是一个重大的职业发展步骤，它要求你不仅要精通技术，还要掌握管理技能。 以下是一些来自于网络的建议，也风险给阅读本文的小伙伴</p>
<ol>
<li>
<p><strong>提升沟通技巧</strong>：</p>
<ul>
<li>学习如何清晰、有效地与团队成员和其他部门沟通。</li>
<li>练习将复杂的技术问题解释给非技术人员听。</li>
</ul>
</li>
<li>
<p><strong>培养团队领导能力</strong>：</p>
<ul>
<li>主动承担更多责任，比如领导小型项目或指导新员工。</li>
<li>阅读领导力相关书籍，参加相关的工作坊或研讨会。</li>
</ul>
</li>
<li>
<p><strong>了解管理理论和实践</strong>：</p>
<ul>
<li>阅读有关管理的书籍，学习不同的管理风格和理论。</li>
<li>考虑报名参加管理类课程或获得相关证书。</li>
</ul>
</li>
<li>
<p><strong>掌握项目管理知识</strong>：</p>
<ul>
<li>学习项目管理的基础知识，包括如何制定计划、监控进度和管理预算。</li>
<li>熟悉使用项目管理工具，如Microsoft Project、JIRA等。</li>
</ul>
</li>
<li>
<p><strong>增强商业意识</strong>：</p>
<ul>
<li>理解公司的商业模式、市场定位以及产品战略。</li>
<li>学习基础的商业和财务知识。</li>
</ul>
</li>
<li>
<p><strong>人员管理技能</strong>：</p>
<ul>
<li>学习如何激励团队成员，进行绩效评估和职业规划。</li>
<li>了解如何处理工作中的冲突和建立有效的团队文化。</li>
</ul>
</li>
<li>
<p><strong>关注技术和行业趋势</strong>：</p>
<ul>
<li>持续学习新技术、工具和方法论，了解它们对团队和业务的潜在影响。</li>
</ul>
</li>
<li>
<p><strong>扩展人际网络</strong>：</p>
<ul>
<li>与其他技术管理人员建立联系，交流经验和观点。</li>
<li>加入专业组织和参与行业会议。</li>
</ul>
</li>
<li>
<p><strong>时间管理和优先级设定</strong>：</p>
<ul>
<li>学习如何高效地管理自己的时间，平衡管理职责和技术工作。</li>
<li>练习确定任务优先级，以有效达成目标。</li>
</ul>
</li>
<li>
<p><strong>获取反馈和自我反思</strong>：</p>
<ul>
<li>定期向同事和上级寻求关于你管理和领导能力的反馈。</li>
<li>定期进行自我反思，识别改进空间。</li>
</ul>
</li>
<li>
<p><strong>实践经验</strong>：</p>
<ul>
<li>在当前的编程职位上寻找机会承担更多管理职责。</li>
<li>参与跨部门的项目，增加管理经验。</li>
</ul>
</li>
<li>
<p><strong>心理准备</strong>：</p>
<ul>
<li>准备好接受从纯技术角色到更多涉及协调和人际关系的工作的转变。</li>
<li>调整心态，接受你可能不再有太多时间亲自编码的现实。</li>
</ul>
</li>
</ol>
<p>在项目管理的准备工作中，确实存在众多需要考虑的因素。对于初学者而言，试图同时关注所有细节可能会造成注意力分散，导致无法在任何方面达到最佳状态。因此，识别自己的弱点并集中力量突破最为关键。</p>
<p>基于此，我的准备策略聚焦于两个核心领域：项目背景的熟悉度以及管理方法论的掌握。</p>
<ul>
<li>项目背景熟悉</li>
</ul>
<p>提前了解项目的业务环境、组织关系，能迅速发挥自己的能量</p>
<ul>
<li>管理方法论</li>
</ul>
<p>掌握项目管理的核心原则和方法论，如敏捷管理、水平瀑布模型或混合方法等项目管理方法（上面没有细说），团队人员管理、梯度建设等</p>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/column/manager/02_项目关系图.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>03.入职新项目</title>
      <link>https://liuyueyi.github.io/tutorial/column/tech/manager/03.%E5%85%A5%E8%81%8C%E6%96%B0%E9%A1%B9%E7%9B%AE.html</link>
      <guid>https://liuyueyi.github.io/tutorial/column/tech/manager/03.%E5%85%A5%E8%81%8C%E6%96%B0%E9%A1%B9%E7%9B%AE.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">03.入职新项目</source>
      <description>在职业生涯中，从研发岗位转向技术管理职位，通常有以下几种路径：或是在现有团队中逐步晋升，自然而然地承担起领导职责；或是把握时机，接受上级的任命，实现角色的转变；亦或是通过跳槽，以空降的形式进入新的组织。而我的情况则是跳槽到新的公司，再一个项目组苟了一段时间，突然被调到一个新的项目组，作为十人左右的后端研发组长，结合了上面的二三两种途径；再真实入项之前，首先面临的挑战是接受业务方的面试和评估，以确定我是否满足他们对于该岗位的专业要求。 因此，在这篇文章中，我们将从两个关键的角度出发，深入探讨加入新项目时需要关注的各项事宜。 1. 入项面试 在上一篇文章中，我们概述了新项目的背景情况。这是一个从零开始组建的全新项目组，由项目经理（PM）负责从无到有地构建团队。该团队的服务对象是兄弟单位，其首要任务是将整个项目的产品研发工作，从委托的第三方外部公司，完全迁移至这个新成立的项目组来承担。</description>
      <category>技术管理</category>
      <pubDate>Wed, 07 Feb 2024 09:27:46 GMT</pubDate>
      <content:encoded><![CDATA[<p>在职业生涯中，从研发岗位转向技术管理职位，通常有以下几种路径：或是在现有团队中逐步晋升，自然而然地承担起领导职责；或是把握时机，接受上级的任命，实现角色的转变；亦或是通过跳槽，以空降的形式进入新的组织。而我的情况则是跳槽到新的公司，再一个项目组苟了一段时间，突然被调到一个新的项目组，作为十人左右的后端研发组长，结合了上面的二三两种途径；再真实入项之前，首先面临的挑战是接受业务方的面试和评估，以确定我是否满足他们对于该岗位的专业要求。</p>
<p>因此，在这篇文章中，我们将从两个关键的角度出发，深入探讨加入新项目时需要关注的各项事宜。</p>
<h2> 1. 入项面试</h2>
<p>在上一篇文章中，我们概述了新项目的背景情况。这是一个从零开始组建的全新项目组，由项目经理（PM）负责从无到有地构建团队。该团队的服务对象是兄弟单位，其首要任务是将整个项目的产品研发工作，从委托的第三方外部公司，完全迁移至这个新成立的项目组来承担。</p>
<p>对于团队的配置，标准构成包括产品组、前端组、测试组以及后台组，其中后台组进一步细分为业务、中台和订单处理三个关键部分。</p>
<p>此次参与的面试者则主要是产品组长、前端组长、测试组长以及后端组长。而面试官则由上级公司的分管领导以及业务方公司的高层管理人员共同组成。他们不仅评估面试者的专业能力，还会考察我们是否能够与各小组长协作，推动项目的整体研发工作。</p>
<h3> 1.1 面试准备</h3>
<p>本次面试与常规的求职简历投递所经历的面试环节相比，存在显著的差异。它主要倾向于对应聘者进行岗位胜任能力的评估，即一场以任职资格考核为主导的面试。不论是面对哪一种面试类型，我们的基本目标始终不变，即全面而准确地展现自身所具备的专业能力，并在此基础上，通过有效的沟通和展示，提升面试官对我们与目标职位匹配程度的认识和评价。</p>
<p>那么怎样才能增强我们的表现力呢？ 俗话说 “三军未动，粮草先行”，做一件事情的前期准备工作，非常重要；同样的我们需要做一些面试准备，但是这次的面试主题与形式不是很确定，我们的准备工作很难做到有的放矢，那么这种情况下，我该做什么？</p>
<h4> a. 确定主题</h4>
<p>在大多数情况下，成熟个体所展现的行为和动作。都带有明确的目标导向；作为参与的一方，我们有必要提前深入理解并掌握这一目标的本质。</p>
<p>简单来讲，就是我们需要尽可能的去搞清楚，这次面试的面试官是哪些人，目的是什么，怎么样的表现才是对方希望看到的</p>
<p>以我们常见的求职面试为例，通常会有技术面、领导面、HR面等几个环节，那么每个面试环节的目的就相对明确了</p>
<ol>
<li>技术面：这一阶段的主要目的是评估求职者的技术实力，以确定他们是否具备满足岗位要求的能力。因此，对于求职者来说，他们需要在这个阶段充分展示自己的技术能力，包括解决实际问题的能力，以证明自己具备完成工作的技术能力。</li>
<li>领导面：这一阶段的主要目的是评估求职者的综合能力，包括技术能力和领导潜力，以及他们的价值观是否与公司的文化相匹配。因此，求职者需要在这一阶段展示自己的项目管理能力、跨团队协作能力、沟通能力、逻辑思维能力和表达能力等软实力，以给领导者留下自己是一个可靠、能抗压的员工的印象。</li>
<li>HR面：这一阶段的主要目的是评估求职者的稳定性，以及他们对薪资等待遇的期望是否合理。在这一阶段，求职者需要表达自己的职业规划和期望，同时也需要合理地争取自己的权益。</li>
</ol>
<p>总的来说，每个面试阶段都有其特定的目的，求职者需要根据这些目的来准备和表现，以便更好地通过面试，获得理想的工作机会。</p>
<p>那么以本次述职面试来说，面临这种信息不明确的述职面试时，理解面试的目标至关重要。从提供的内容来看，此次面试的核心目标似乎在于评估参与者是否具备承担特定项目产研（产品研发）工作的能力。因此，组织方可能会专注于以下几个方面：</p>
<ol>
<li>技术能力：评估参与者是否具有完成项目所需的专业技术和实践经验。</li>
<li>项目管理：考察参与者是否有策划和管理整个产品研发过程的能力。</li>
<li>团队协作：判断参与者在团队合作中的沟通、协调能力以及领导力。</li>
<li>问题解决：测试参与者面对研发过程中可能出现的问题的应对策略和解决问题的能力。</li>
<li>适应性和学习能力：了解参与者适应新挑战的能力和学习新技术的速度。</li>
<li>压力管理：评估参与者在面对紧张工期或高难度任务时的抗压能力和稳定性。</li>
</ol>
<p>鉴于此，为了在面试中表现出色，我们可以做以下努力：</p>
<ul>
<li>准备充分，确保对相关技术和项目细节有深入的理解；</li>
<li>能够举例说明过往成功管理和执行项目的实例；</li>
<li>展示出良好的团队精神和领导潜力；</li>
<li>准备好针对可能遇到的技术或管理挑战的解决方案；</li>
<li>证明自己的学习能力和适应变化的能力；</li>
<li>显示出在压力下保持冷静和效率的能力。</li>
</ul>
<h4> b. 预设问题及回答</h4>
<p>基于上面的分析，结合我自己在这个项目组的定位，这个面试过程大概率会问两方面的内容</p>
<ol>
<li>技术能力评估</li>
</ol>
<p>对于技术问题，更多的应该是一些场景类、或者实际应用难点的解决方案之类的问题，不太会出现零散的知识点</p>
<p>这个就没什么好准备的，因为没啥方向，只能靠自身积累与临场发挥</p>
<ol start="2">
<li>团队管理评估</li>
</ol>
<p>这方面的问题大概率也是跑不了，核心就在于是否有自己的管理方法论，如何发挥出团队内1+1 &gt; 2的能力；在这里我们就可以提前给自己预设一些相关问题</p>
<ul>
<li>
<p><strong>如何保证你们的团队战斗力？</strong></p>
</li>
<li>
<p><strong>这一次的项目迁移，你准备怎么做？</strong></p>
</li>
<li>
<p><strong>跨团队部门的项目推进怎么进行？</strong></p>
</li>
<li>
<p><strong>如果有临时的、非常紧急的需求，怎么保障？</strong></p>
</li>
</ul>
<p>（在面试过程中，有两个问题确实比较相关，后面详细再说）</p>
<h4> c. 准备提问</h4>
<p>一般来说，面试的最后都会预留给面试者提问机会，请把握这个机会，在每次的面试过程中都准备几个问题，面对不同的面试官抛出不同的问题，这种时候，对方的答案其实并不重要，重要的是你想借助这个问题，表现出来的个人特质</p>
<p>还是以找工作的面试为例，给出几个通用的问题示例</p>
<p>技术面问题可以是</p>
<ol>
<li>咱们这个项目除了平时日常的需求交付之外，还会有一些性能优化、重构迭代、技术瓶颈之类的问题么？</li>
<li>团队的技术氛围怎么样，有没有一些技术分享之类的活动</li>
</ol>
<p>领导面的问题可以是</p>
<ol>
<li>日常的需求交付主要是项目内就可以完成交付了么？会出现跨团队、跨部门的交流么？</li>
<li>团队规模怎么样，今年的主要目标是什么，现在达成了多少，如果我来可以在这里扮演什么样的角色，有什么可以发挥的地方？</li>
</ol>
<h3> 1.2 面试过程</h3>
<p>这一次的面试，算是我职业生涯中的一个特殊的经历了，面试官有六位，还有一位主持... （这么多人，说不紧张是真有点虚）</p>
<p>抛开一些无关痛痒的细节，对一些有意思的问题下面进行一个复盘</p>
<h4> 1.2.1 技术问题</h4>
<p>所有的面试官中，只有一个是技术出身，问了两个相对常见的技术问题</p>
<p><strong>电商的超售问题怎么解决</strong></p>
<blockquote>
<p>比较常见的一个技术面问题，那么这个问题怎么回答呢？ 首先再回答这个问题之前，认清自己的定位，我来是并不是只做一个高级码农的，所以这个问题的回答就不应该仅局限再技术的解决方案上，不妨站在更高的角度，从业务视角来看这个问题</p>
</blockquote>
<p>下面是我针对这个问题的回答：</p>
<p>超售在电商系统中是一个相对常见的问题，但是怎么处理这个问题，一般根据实际的业务场景可以区分为两种，一类是我货就这么多，超卖的这些我发不了，因此不允许出现超售；另外一类则没有严格的库存限制，多卖一些也没关系，今天没货，明天可以有，因此允许超售卖一些</p>
<p>对于第一种情况，属于存粹的技术问题，对库存卡得比较严，比如秒杀，本来就是活动价卖，如果超售我就亏了；所以我们先从技术角度出发，来看一下如何杜绝超售这种问题</p>
<p>超售问题在电商系统中确实是一个常见的挑战，需要根据实际的业务场景来选择合适的解决方案。以下是对四种方案的简要解释：</p>
<ol>
<li>
<p><strong>方案1 - 数据库写锁</strong>：</p>
<ul>
<li>这是最直接的方法，通过在数据库添加写锁来确保库存扣减操作的串行执行。</li>
<li><strong>优点</strong>：实现简单，逻辑清晰。</li>
<li><strong>缺点</strong>：在高并发情况下，性能和用户体验可能较差。</li>
</ul>
</li>
<li>
<p><strong>方案2 - 分布式锁</strong>：</p>
<ul>
<li>使用分布式锁机制来控制并发操作，减少数据库长时间锁竞争带来的压力。</li>
<li><strong>优点</strong>：减轻了数据库的压力。</li>
<li><strong>缺点</strong>：实现相对复杂，需要考虑锁的管理和维护。</li>
</ul>
</li>
<li>
<p><strong>方案3 - 乐观锁+事务</strong>：</p>
<ul>
<li>结合乐观锁和事务机制来替换数据库写锁，实现库存扣减。</li>
<li><strong>优点</strong>：相比直接使用数据库写锁，性能更好。</li>
<li><strong>缺点</strong>：实现方式更复杂，需要处理冲突解决和回滚。</li>
</ul>
</li>
<li>
<p><strong>方案4 - Redis计数器</strong>：</p>
<ul>
<li>利用Redis的高性能特性，使用其自增/减计数器功能来进行库存管理。</li>
<li><strong>优点</strong>：可以提供更高的性能和吞吐量。</li>
<li><strong>缺点</strong>：需要额外的后台任务进行库存校准，或者在低库存时进行事前校准。</li>
</ul>
</li>
</ol>
<p>对于第二种情况，即允许一定程度的超售，商家需要从业务角度出发进行库存管理和超售处理，我作为商家应该如何做自己的库存管理</p>
<ol>
<li>
<p><strong>Case 1 - 充足库存</strong>：</p>
<ul>
<li>如果商家拥有充足的库存，超售一些不会对运营造成影响，可以正常处理订单。</li>
</ul>
</li>
<li>
<p><strong>Case 2 - 预留余量</strong>：</p>
<ul>
<li>在设置库存时，预留一定的余量，允许出现一些超售。这样即使发生超售，也不会立即导致缺货问题。</li>
</ul>
</li>
<li>
<p><strong>Case 3 - 多平台库存调拨</strong>：</p>
<ul>
<li>如果商家同时在多个平台上销售商品，可以在不同平台之间进行库存调拨。例如，当一个平台发生超售时，可以从其他平台的库存中调拨商品来补充。</li>
</ul>
</li>
<li>
<p><strong>Case 4 - 多层库存模型设计</strong>：</p>
<ul>
<li>设计多层库存模型，如三层库存模型：销售库存、可售库存和实物库存。通过区分不同层次的库存，可以更好地管理库存和预测需求。</li>
</ul>
</li>
</ol>
<p>在这个场景中，商家采用了一种动态的库存管理策略，这种策略考虑了实物库存、预计到货数量以及在不同销售平台上的销售需求。以下是对这种策略的详细说明：</p>
<p><strong>实物库存</strong>：</p>
<ul>
<li>这是指在全国范围内各个仓库中实际存储的商品数量。实物库存是商家当前可用的库存，可以直接用于满足顾客订单的需求。</li>
</ul>
<p><strong>预计到货数量</strong>：</p>
<ul>
<li>这是指商家根据生产计划或供应链信息预计在将来某个时间点会到达仓库的商品数量。这部分库存虽然还未到货，但商家有信心它将在未来成为可用库存。</li>
</ul>
<p><strong>可售库存</strong>：</p>
<ul>
<li>可售库存是实物库存和预计到货数量的总和。它代表了商家认为可以用于销售的总库存量。这个数字是商家愿意对外承诺的销售数量，它考虑了未来一段时间内库存的补充情况。</li>
</ul>
<p><strong>平台销售库存</strong>：</p>
<ul>
<li>商家会根据不同电商平台的销售渠道和市场需求，将可售库存分配到各个平台。例如，京东分配800个，天猫分配600个，拼多多分配1000个。这些数字反映了商家在各个平台上愿意销售的库存量，并且可以根据实际销售情况进行调整。</li>
</ul>
<p>通过这种多层次的库存模型，商家能够更灵活地管理库存，应对超售风险，并优化跨平台的库存分配。这种策略使得商家能够在保证服务质量的同时，最大化销售机会和利润。</p>
<p><strong>电商系统，与很多的三方系统交互，怎么确保交互一定会成功呢</strong></p>
<p>回答这个问题时，很多小伙伴会会不自觉地将自身定位于接口调用方的角色，这样就容易导致回答不够全面；除了扮演接口调用方的角色之外，我们在多方系统交互中，同样可能充当接口提供方的角色；因此，对于这一问题的回应，应当从接口调用方和接口提供方这两个不同的维度进行深入分析</p>
<p>一个简单的回答如下：</p>
<p>与外部系统的交互非常常见，站在自身的角度，通常有两种类型，一个是我们的服务依赖外部提供的接口，还有一类则是别人依赖我们的接口；下面我们将分别进行说明</p>
<p><strong>对于外部的接口依赖场景：</strong></p>
<p>在实际的业务场景中，对外部接口的依赖程度不同，可能对业务连续性产生重大影响。特别是在强依赖的情况下，外部接口的可靠性直接关系到我们自身业务的稳定运行。以下是针对强依赖场景的一些常见管理和应对策略：</p>
<ol>
<li>
<p><strong>冗余设计</strong>：建立备份系统或服务，以便在主服务不可用时切换。这可以包括部署多个外部服务实例或使用不同的服务提供商。</p>
</li>
<li>
<p><strong>故障转移（Failover）机制</strong>：实现自动故障转移到备用系统或服务，以减少停机时间。这要求有快速的故障检测和恢复机制。</p>
</li>
<li>
<p><strong>重试策略</strong>：为失败的请求实现自动重试逻辑，特别是在临时性问题（如网络抖动）引起的失败情况下。</p>
</li>
<li>
<p><strong>限流与熔断</strong>：通过限流防止系统过载，以及使用熔断器模式来预防系统性故障传播，一旦检测到异常行为，熔断器会“断开”，避免进一步的调用。</p>
</li>
<li>
<p><strong>服务降级</strong>：在外部服务不可用时，提供有限的或后备的功能，保证核心业务的持续运行。</p>
</li>
<li>
<p><strong>接口缓存</strong>：对于外部接口的结果进行缓存，减少外部接口的调用次数，降低出现问题的概率</p>
</li>
</ol>
<p>对于弱依赖，也有多种处理策略可以采用，以降低外部接口不稳定对业务的影响。以下是几种常见的处理方式：</p>
<ol>
<li><strong>降级策略</strong>：在弱依赖的情境下，当外部接口出现问题或访问延迟较高时，可以选择不调用该接口，或者使用备份方案来替代原有的服务。这种策略通常不会影响核心业务流程的进行，因为弱依赖通常不是完成业务流程所必需的。</li>
<li><strong>同步改异步</strong>：将同步的阻塞调用改为异步的非阻塞调用，可以提升系统的响应速度和用户体验。例如，在用户购票成功后，而不是立即执行推送消息的操作，系统可以在后台发送一个推送消息的异步任务，由消息队列消费这个任务来实现用户消息的推送。这样即使推送服务暂时不可用，也不会影响主要的购票流程。</li>
<li><strong>限流与熔断</strong>：对于可能引起系统不稳定的弱依赖服务，实行限流措施可以避免过多的请求压力传递到下游服务。而熔断机制则可以在检测到异常行为时自动中断服务调用，避免系统被进一步拖垮。</li>
<li><strong>监控与预警</strong>：通过实时监控系统的健康状况和性能指标，一旦检测到问题，可以及时触发警报并采取相应措施，比如启动备用系统或执行其他应急计划。</li>
<li><strong>依赖治理</strong>：建立一套强弱依赖治理机制，通过科学手段持续稳定地获取应用间的依赖关系、流量和强弱数据。这些数据可以用于指导系统改造、故障应对决策等场景，提前发现潜在的依赖问题，避免它们影响用户体验。</li>
</ol>
<p><strong>对于提供接口给外部的场景：</strong></p>
<p>这种主要是别人依赖我们的接口，当然也属于三方系统交互；常见有两种方式，一个是外部主动调用接口的<code>拉模式</code>，另外一个则是我们回调通知对方的<code>推模式</code></p>
<p>对于"拉模式"，问题就演变成如何保证我们接口的可用性，那么我们可以采用的策略有：</p>
<ul>
<li>集群模式提供，解决单点问题</li>
<li>接口熔断限流，防刷，避免被外部方无节制的调用打挂</li>
<li>通过缓存、并发、代码优化等方式，提高接口的性能</li>
<li>设置降级策略，当接口不可用时，切换降级方案对外提供支持</li>
<li>添加报警监控，实时感知异常，减少故障时长</li>
</ul>
<p>对于"推模式"，这个对于接口设计方而言，一个设计重点是<code>尽最大努力通知对方</code>，因此我们需要重点考虑的是；</p>
<ul>
<li>确保不漏推： 如将回调的任务持久化，当回调成功之后才将这个任务标记完成； 通过后台任务不断的扫描这些需要回调通知的任务，确保都会推送到</li>
<li>设置最大重试次数：不应该因为一个任务永不成功，导致无限重试，每个任务设置一个阶梯的重试时间间隔，超过最大次数之后不再回调</li>
</ul>
<p>最后再对上面的回答做一个总结，对于三方系统的交互，无法保障100%的成功率，对于系统设计本身，我们应该通过实际的业务场景、重要层级，设置不同接口的可用性，如我们常说的四个9，五个9；我们的设计理念应该是最大程度的保证可用，并且再真的出现问题时，及时发现，立马相应，快速修复，减少问题的影响范围</p>
<h4> 1.2.2 其他问题</h4>
<p><strong>为什么从互联网企业跳槽到现在这里？ 对现在公司的企业信息化怎么看</strong></p>
<p>出乎预料的一个问题，再面试当前这个公司时都没人问这个，结果这次居然被问道了；再听到这个问题时，有一些懵，也有些措手不及。已经回忆不起当时怎么回答的，当然从事后的反馈来看，应该答得还可以。</p>
<p>这个问题本身的答案并不重要，我更想说一下面对这种没有固定答案、且自己之前没有思考准备过的问题时，我们应该怎么处理</p>
<p>首先，遇到意料之外的问题时，不要着急回答，现在脑子里简单过一下，大致想一下回答框架；当然在实际的面试过程中，不可能留给我们很多空白时间来思考，因此一个简单实用的应对方案即，再缓慢的将问题复述一遍，一边拖延时间，一边找这个问题中的关键词</p>
<p>接着将上面的关键词进行拆分，将一个问题拆分成多个子问题，分别进行回复；再这个过程中，我们需要重点注意回复的技巧，正如我们写文不可能通篇一个大段一样，我们的回复也需要分个一二三，不管这个一二三条的逻辑关系是否合适，但是我们重点需要的就是给人一个条理清晰的认知</p>
<p>其次，再回答时，注意避重就轻，将问题转移到自己熟悉的领域，可以通过自问自答的方式来转移话题，比如上面问题中，我一直是搞互联网的对企业信息化没有了解过，那么我就可以这样回答</p>
<p>我为什么会从互联网行业转到这里呢？因为我个人之前一直再互联网内的公司工作，可以简单的从我的过往履历中说一下我对互联网的看法，我再xxx干的xxx .... 最后再提一下，对于企业信息化，这块由于之前没怎么接触过，但是我个人又比较喜欢接触新事务，从之前的服务人、到现在的服务企业，感觉是一个非常有意思、有挑战的事情，也正好可以打开我个人的视角</p>
<p><strong>对即将接受的这个项目了解多少</strong></p>
<p>回答套路如上，具体结果省略</p>
<p><strong>项目的产研迁移，怎么保证不出问题的同时，又能支持任务的迭代交付？</strong></p>
<p>这个问题虽然看着比较具体化，但实际上，是一个相对通用的问题模板；对于考核一个人，能否完成我们的要求时，比较常见，就是看一下这个事情交给你之后，准备怎么干，有没有目标计划，有没有行动章法</p>
<p>回答这样的问题，首先就是认清自己的定位，小兵还是攻坚，百夫长or统帅？</p>
<p>以我个人的实际场景来说，本身是来当研发组长角色，因此更多的需要站在能否以技术leader的角色，带领大家完成这个系统的迁移，那么这个过程中对我的要求是什么呢？</p>
<ul>
<li>再团队内培养他人对自己的信任感</li>
<li>能攻坚、能做任务分配拆解</li>
<li>发挥团队力量，完成任务目标</li>
</ul>
<p>对于这个项目的开展，我们首先需要搭建对应的成员班底，因为这个项目毕竟是将一个生产运行的系统，从外部迁移到新组建的项目团队，因此对于我们的人员要求较高，所以我们会优先从公司内抽调一些资深靠谱的小伙伴，来作为前期的攻坚手； 对于我们个人而言，需要做的事情则主要围绕在目标制定、任务拆解、结果校验上，大家前期以事驱动，新逐渐的团队，不存在明显的责任划分，根据大家的实际表现，来动态调整职责任务的分配。再团队内部，第一阶段目标主要是以磨合为主，养成大家的配合默契，同时也是对我个人的挑战，一个是再这个过程中充分的展现自己的能力，让别人可以信服自己，其次则需要再这个阶段认清团队成员的梯度情况，然后根据不同的人来制定不同的目标，以小步快跑的方式，实现一个一个目标，从而完成最后的项目迁移</p>
<p>针对这个工作展开，之前有准备一个思维导图如下，可以按照这个进行回复</p>
<figure><img src="/imgs/column/manager/03_工作展开.jpg" alt="工作展开思维导图" tabindex="0" loading="lazy"><figcaption>工作展开思维导图</figcaption></figure>
<p><strong>领导的临时紧急任务，如何支撑？再有限的时间内，确实完成不了，怎么处理？</strong></p>
<p>在实际工作中，我们经常会遇到领导突然下达的紧急任务。在这种情况下，我们首先需要考虑的不仅仅是如何去完成这个任务，更重要的是要理解这个任务的重要性和合理性，以及领导的核心诉求和他期望的结果。我们需要从结果出发，逆向思考这个任务的合理性，以及是否有更合适的方法来实现这个结果。在技术层面，往往有多种方法可以达到相同的效果，但它们的成本可能会有很大的差异。</p>
<p>一旦我们确定了这个任务必须被处理，我们就需要开始分析并拆解这个任务，识别出哪些部分是核心的，哪些部分是耗时的。我们可以优先处理那些核心且容易实现的任务，并将这些任务交给能力强的同事。对于那些既核心又难以处理的任务，我们可以专门指派人员来处理。这里所说的任务拆解，实际上更像是我们常说的任务优先级设定，我们需要优先保证高优先级的需求得到满足。</p>
<p>当我们在分配任务优先级和人力资源之后，如果发现时间仍然不够，我们应该如何处理呢？</p>
<ul>
<li>针对这种情况，我们首先需要考虑是否是人力资源不足。如果是，我们可以通过协调人力，增加人手来解决。如果可以通过加班来赶进度，那么我们可以牺牲一些个人的休息时间，加班赶工。</li>
<li>如果增加人力无法解决问题，我们可以考虑将任务分为多个阶段，按照最小的迭代单元进行分批交付。在截止日期之前，我们可以先上线部分功能，确保整体功能的可用性，然后再逐步完善。</li>
<li>如果我们在有限的时间内连最小的迭代单元都无法完成，那么我们可以考虑使用临时方案进行交付。例如，我们可以先用模拟数据或者静态页面来暂时替代。</li>
</ul>
<p>以上是基于任务工作量评估的处理策略。当然，在执行过程中，我们也需要关注每日的进度同步，及时上报问题和风险。除了保证功能的交付，我们还需要关注交付的质量，上线后需要密切关注，并进行长期的跟踪和优化。</p>
<h3> 1.3 小结</h3>
<p>在面试过程中，无论是入职新项目的面试还是一般的面试，以下几点是非常重要的：</p>
<ol>
<li><strong>前期准备</strong>：了解公司背景、职位要求和面试流程。研究可能的面试问题并准备好回答。确保自己的简历和求职信准确无误，突出自己的优势和与职位相关的经验。</li>
<li><strong>条理性回答</strong>：在回答问题时，尽量按照一二三四的分段式回答，清晰地表达自己的观点和想法。</li>
<li><strong>语速与语调</strong>：注意回答的语速，不要过快也不要过慢，确保清晰可懂。语调要自然，避免单调。</li>
<li><strong>减少小动作</strong>：保持良好的身体语言，减少不必要的手势或面部表情，以提高个人的印象分。</li>
</ol>
<p>对于重要的面试，如年终/中述职或晋级答辩，可以采取以下策略：</p>
<ul>
<li><strong>模拟面试</strong>：找一些小伙伴充当面试官，进行多次模拟面试，以便熟悉面试流程和提高应对能力。</li>
<li><strong>自我录音</strong>：如果找不到人进行模拟面试，可以通过手机录音的方式记录自己的回答过程，之后回放并分析，找出不足之处进行针对性的改进。</li>
<li><strong>持续练习</strong>：面试技巧的提升需要时间和练习，不断练习总会带来进步。</li>
</ul>
<p>下面也是我再面试完毕之后，主持这场面试的项目经理给我的反馈，整体评价是再几个面试者中最高的（通过这一次的面试，我本人再PM这里也刷了一波存在感，留下了非常好的印象，后续的工作展开也确实得到了很多的优待帮助）</p>
<figure><img src="/imgs/column/manager/03_面试反馈.jpg" alt="面试结果反馈" tabindex="0" loading="lazy"><figcaption>面试结果反馈</figcaption></figure>
<h2> 2. 职责认知</h2>
<p>进入新的项目组之后，很容易想到的就是如何融入团队，但是在这里，对于技术管理而言，我则更想说一下，如何对自己做好角色认知和角色定位</p>
<p>如果我们是以研发的角色进入一个新的团队，那么我们的自我定位则比较明确，快速熟悉项目、能迅速上手，做需求交付；那么做技术管理而言呢？</p>
<p>同样的对于我个人而言，面对即将进入的项目组，同样面临这些问题。我来干什么？ 上面的领导希望我干什么？ 我又能干什么？</p>
<p>接下来我将从角色定位、职责要求说一下我个人对这些的理解</p>
<h3> 2.1 角色定位</h3>
<p>从研发到管理，必然是存在一些改变的，假定看我这些水文的都是资深的研发小伙伴，接下来的视角将重点放在从“研发工程师”到“技术管理”的角色转变上</p>
<blockquote>
<p>以下内容，主要摘抄于 《知行-技术人的管理之路 by 刘建国》</p>
</blockquote>
<h4> 2.1.1 职责使命</h4>
<p>对于研发而言，我们的职责就是干好上级分配的活，或者更进一步，对于一些资深的小伙伴而言，老板有一个想法，我们可以从技术的视角来做拆解、、分配、落地、执行/亦或者判断是否有必要做这个事情</p>
<p>对于管理者而言，不是自己来做这些任务的研发执行，更多的则是让其他的小伙伴来做最终的落地，比如上面资深小伙伴的任务拆解、分配、推进等大多都是技术管理的工作要求。这通常也意味着，上级只是帮我们设定一个目标，剩下做什么、怎么做，都是我们需要考虑的</p>
<h4> 2.1.2 负责对象</h4>
<p>对于研发而言，通常我们只需要对自己负责，做好自己的工作内容即可</p>
<p>对于管理者而言，向下需要对自己的团队负责，整体团队的成长、绩效、输出、口碑都是需要自己来维护与经营打造；向上则需要对自己的领导负责，有没有浪费公司资源，顺利完成公司分配的任务，达成or超出既定的目标</p>
<h4> 2.1.3 关注焦点</h4>
<p>对于研发而言，一般是过程导向，关注脚下，是否有一步一步将工作执行到位</p>
<p>对于管理者而言，通常则是目标和结果导向，我们有没有完成既定的目标，后面准备做什么</p>
<h4> 2.1.4 工作内容与能力要求</h4>
<p>对于研发而言，主要是靠个人的专业能力作为产出，做需求、任务的实现交付，项目系统的运营维护；因此技术专业性通常是核心且最重要的衡量指标</p>
<p>对于管理者而言，出了技术判断力之外，还需要目标管理能力、团队规划能力、项目管理能力、沟通协调能力、团队建设能力等等，需要看方向的、带人的、做事的更加多维和立体的能力</p>
<h4> 2.1.5 任务来源</h4>
<p>对于研发而言，任务一般来自于上级安排，主要是听指挥</p>
<p>对于管理者而言，出了上级安排的任务之外，更多的需要自己筹划、然后再主动去与上级沟通确认，从被动接活到主动“找事”</p>
<h4> 2.1.6 实施手段</h4>
<p>对于研发而言，通常都是动手实干，亲力亲为，主要的贡献就来自于自己的专业产出</p>
<p>对于管理者而言，更多的是统筹，靠整个团队一起来完成</p>
<h4> 2.1.7 合作维度</h4>
<p>对于研发而言，合作的通常是和平级的小伙伴，一起做好研发工作，常见的合作对象是共同参与的研发、测试、产品、ui等</p>
<p>对于管理者而言，合作的对象就比较丰富了，如需要和上级合作规划好整个团队的目标，和下级合作做好落地执行，和平级管理者合作完成联合项目，有时候还需要和平级的上、下级去一起协调资源和进度</p>
<h4> 2.1.8 合作关系</h4>
<p>从团队成员的合作关系来看，对于研发者而言，与团队内成员是“竞争与合作”的关系，日常的工作大多需要共同协作推进，但是大家应该也都经历过资源的竞争、绩效的争取</p>
<p>对于管理者而言，在团队内一个显著的区别则是不应再有竞争的关系了，我们和团队应该处于全面合作的关系，对于管理者的评价标准更多的是看整个团队的产出</p>
<h4> 2.1.9 思维方式</h4>
<p>对于研发而言，通常是执行的思维方式，如何将一件事情落地，更关注过程与实时细节； 通常研发的估算排期比较保守，因为他们需要确保能完成才愿意答应</p>
<p>对于管理者而言，虽然也考虑风险和成本，但是更习惯于去关注做一件事能带来的可能性收益，并以此来判断是否值得投入资源去做，这种更多的是“规划思维”</p>
<p>由于管理者总是在盘算和筹划一些可能会对公司和团队有价值的事情，而没有仔细考虑风险和成本，所以在工程师的眼中，管理者时不时会提出一些“不靠谱”的期望和需求，但这正是两个角色关注的东西不同造成的。而这恰恰是一种很好的合作与互补</p>
<h4> 2.1.10 技术视角</h4>
<p>对于研发而言，技术是核心生产力，用来保障我们做好实施的主要手段，更多的是以运用的角度来看待技术</p>
<p>对于管理者而言，技术是达成目标的手段之一，通常是结合实际场景，判断这个技术是否合理，当前最优，经常需要做一些技术决策。对于技术管理者而言，切忌技术崇拜，不能为了追求时髦而引入各种没什么用的技术栈</p>
<h4> 2.1.11 小结</h4>
<p>接下来以表格的方式将上面的对比进行小结如下</p>
<table>
<thead>
<tr>
<th>维度</th>
<th>工程师</th>
<th>管理者</th>
</tr>
</thead>
<tbody>
<tr>
<td>职责使命</td>
<td>拉好车-做好自己手头的工作就无咎</td>
<td>驾好车-引领整个团队往前走</td>
</tr>
<tr>
<td>负责对象</td>
<td>对自己负责 , "管好自己就可以了"</td>
<td>对公司(上级)和团队(下级)都负责</td>
</tr>
<tr>
<td>关注焦点</td>
<td>过程导向:脚下的路</td>
<td>目标和结果导向:是否达成目标</td>
</tr>
<tr>
<td>工作内容</td>
<td>内容单纯 , 主要靠专业能力</td>
<td>多维立体 , 所需能力维度大幅增加</td>
</tr>
<tr>
<td>任务来源</td>
<td>上级安排</td>
<td>自己主动规划&amp;向上沟通</td>
</tr>
<tr>
<td>实施手段</td>
<td>主要靠自己</td>
<td>主要靠团队</td>
</tr>
<tr>
<td>合作维度</td>
<td>平级合作为主, 维度单一</td>
<td>360 度合作, 维度立体</td>
</tr>
<tr>
<td>合作关系</td>
<td>和团队成员是平级竞合关系</td>
<td>和团队成员是全面合作关系</td>
</tr>
<tr>
<td>思维方式</td>
<td>执行思维, 习惯关注确定性风险</td>
<td>规划思维, 习惯关注可能性收益</td>
</tr>
<tr>
<td>技术视角</td>
<td>技术实施视角</td>
<td>技术评估视角</td>
</tr>
</tbody>
</table>
<p>角色认知的改变，并不是一蹴而就的，需要你我们不断的自我审视和有意识的纠偏，这也是我们做转变的第一道门槛。</p>
<h3> 2.2 职责要求</h3>
<p>上面是认识到角色的定位，我们知道应该往什么样的方向进行转变自己，但是接下来我们应该做些什么呢？</p>
<p>简单来讲，我来这个项目，到底是让我来干嘛的!</p>
<p>接下来我将以个人实际的体验，来反推一下，一个技术管理的职责要求</p>
<h4> 2.2.1 任务清单</h4>
<p>因为这是一个新组建的项目团队，初期目标就是将系统从外部团队接手到项目内，所以给我的任务就比较清晰了</p>
<ol>
<li>人员招聘，团队组建</li>
<li>研发管理流程规范制定</li>
<li>项目迁移，外部对接</li>
<li>需求交付，任务实施</li>
</ol>
<p>对于项目前期，需要干的事情实际上比较明显，无非就是 <code>团队建设</code> + <code>标准规范</code> + <code>任务交付</code>，至于接下来怎么来做些事情，我会再之后的文章中分段说明</p>
<h4> 2.2.2 管理图谱</h4>
<p>下面是一个我个人感觉很有收获的图谱，同样分享给各位小伙伴，当然由于我个人能力有限，以下图谱的内容，再后续的阐释中，可能会有一些偏差谬误之处，还请多批评指正</p>
<figure><img src="/imgs/column/manager/03_管理图谱.png" alt="管理图谱" tabindex="0" loading="lazy"><figcaption>管理图谱</figcaption></figure>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/column/manager/03_工作展开.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>04. 团队组建</title>
      <link>https://liuyueyi.github.io/tutorial/column/tech/manager/04.%E5%9B%A2%E9%98%9F%E7%BB%84%E5%BB%BA.html</link>
      <guid>https://liuyueyi.github.io/tutorial/column/tech/manager/04.%E5%9B%A2%E9%98%9F%E7%BB%84%E5%BB%BA.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">04. 团队组建</source>
      <description>接下来我们将进入第二章节内容，如何进行团队搭建。 既然是作为技术管理，那必然还是有几个小兵再自己手下的，如果自己管理自己，那也算不上是管理了。 团队搭建的第一篇，当然是找人，填充团队空缺了。 通常一个团队的对外表现形式，与团队负责人本身有很强的关系，如果让你来组建你的团队班底，你会怎么做呢？ 正好我现在的团队成员都是我从0到1拉起来的人头，接下来我将从招人和带人两块来说一下如何做团队成员的搭建</description>
      <category>技术管理</category>
      <pubDate>Fri, 01 Mar 2024 09:27:46 GMT</pubDate>
      <content:encoded><![CDATA[<p>接下来我们将进入第二章节内容，如何进行团队搭建。 既然是作为技术管理，那必然还是有几个小兵再自己手下的，如果自己管理自己，那也算不上是管理了。</p>
<p>团队搭建的第一篇，当然是找人，填充团队空缺了。 通常一个团队的对外表现形式，与团队负责人本身有很强的关系，如果让你来组建你的团队班底，你会怎么做呢？</p>
<p>正好我现在的团队成员都是我从0到1拉起来的人头，接下来我将从招人和带人两块来说一下如何做团队成员的搭建</p>
<!-- more -->
<h2> 1. 招人</h2>
<p>一二线的技术管理，一般不会有完整的人事权，即想招多少人、招什么样的人、决定要不要某一个候选人都不是我们能拍板的。通常来说，我们拥有建议权，那么对于招人，我们可以怎么做呢？</p>
<p>当由我们来执行团队搭建时，首先需要定好基调，想好我想要什么样的人，解决什么样的问题，截止时间是什么时候，下面是我再团队搭建之初，思考的几个维度</p>
<figure><img src="/imgs/column/manager/04_团队成员招聘.png" alt="团队成员招聘思维导图" tabindex="0" loading="lazy"><figcaption>团队成员招聘思维导图</figcaption></figure>
<h3> 1.1 团队规划，定人力要求</h3>
<p>当一项事情交给我们时，我们首要需要考虑的就是这个事情的目标是什么，有没有什么限制要求，结果的考核标准是什么。对于招人这件事呢，同样如此</p>
<p>首先需要搞清楚，上级领导给我的团队规划，准备了几个人头，团队成员配比是什么（资深高中初级别各多少人），另外还得摸清楚给了我们多长时间来完成这件事</p>
<p>请注意，上面说的这些，可能会遇到上面无法给出准确结论的场景，对于上级管理而言，他更清楚的是要干什么事情，我能投入多少资源。 因此对于我们来说，上面这几个指标则是由我们来提供，具体的输出呢，则由目标+预算来进行推测</p>
<p>下面是我个人的一点认识，不一定完全准确，仅供参考</p>
<ul>
<li>一个重要且紧急的活，优先是达成目标，资源没有明显限制时
<ul>
<li>找一批基础能力过硬，协作能力强的小伙伴</li>
</ul>
</li>
<li>一个重要且紧急的活，资源预算有限时：
<ul>
<li>找一两个能力强，剩下的选择靠谱基础扎实，听指挥的小伙伴</li>
</ul>
</li>
<li>一个重要不紧急的活，会持续建设，合理的预算
<ul>
<li>按金字塔的梯度模型搭建团队</li>
</ul>
</li>
</ul>
<p>还是以我所在的团队定位来看，上面的几个指标要求：</p>
<ol>
<li>团队人员14人（含我, 内分两组），在途3人，待招 10 人，预留一人补充名额</li>
<li>PM要求，全部是能独挡一面的研发，优选高级</li>
<li>一个月内完成团队组建</li>
</ol>
<p>从上面的指标来看，要求并不算低，再新一线城市，找一个高级研发都不太容易，更何况是在一个月内找十来个</p>
<p>所以我们需要适当调整上级的预期，领导需要来即能迅速干活的人，那么是不是非高级不可呢？ 从干活这个视角来看，实际上一些能做好交付的中级研发同样可以胜任，那么完全而已和领导沟通一下，再有限的时间内，全找高级的难度太大，可以通过预留一些中级的名额来降低人员招聘进度不利的风险</p>
<blockquote>
<p>在这里需要简单说一下我们对高中初的定位（研发最高定位就是高级，再往上就是技术经理和架构）</p>
<p>高级: 可胜任新系统的搭建，能实现复杂任务的拆解、分配、交付，独立负责一到多个独立的系统
中级: 交付的任务可独立自主完成，做一些简单的任务拆解与实现交付
初级: 再告知如何做的基础上，可以实现独立自主的开发</p>
</blockquote>
<h3> 1.2 团队标签，定人员基调</h3>
<p>建立人设，打造个人标签这个事情最近这些年可以说非常流行了，对人如此，同样的对于团队依然适用。 一个成熟且成功的团队，再外人的眼中一定会有一些显著的特色，如果我们有机会构建一个自己的团队，那么再这个团队标签的打造上，请多花一点时间和精力</p>
<p>打造人设/标签这个对我们研发而言，通常来说属于比较朝纲的问题，对于个人，出了有意的经营之外，更多的是个人特质的外在表现，给人的印象和感觉；对于团队，作为领头羊，如果不主动经营，基本上这个事情很难实现，关于这一块我没有什么值得说到的成功经验，浅述一下个人的尝试路径</p>
<p><strong>确定团队定位</strong></p>
<p>首先要知晓打造团队标签，主要是给其他的团队、上级领导看的，从结果来反向看过程，要想做好这件事情，当然必须先摸清楚上级对我们团队的定位和预期；</p>
<p>如果上面要求我们响应迅速、机动能力强，那就把团队往“敏捷”的代名词上靠</p>
<p>如果上面要求我们稳定、高质量，那就重点关注每个任务的交付质量，让“靠谱”这个属性贯彻到底</p>
<p>如果上面要求我们自主、积极创新，那就需要关注团队的活跃性以及主管能动性了</p>
<p>总的来说，再职场，对于非创造性的岗位要求来说，盯着目标往前冲的路线带来的好处是远大于飘散的随机发挥的</p>
<p><strong>明确团队使命</strong></p>
<p>明确团队的使命，这个命题感觉有点大，一个刚搭建的团队，说实话又能有使命感呢？ 我们又不是组建复仇者联盟！</p>
<p>这里说的明确使命，务实一点可以理解为明确责任，可以直接从项目的责任书、上级的规划蓝图、团队定位等方面来明确责任与义务，提炼使命口号； 特别是对于团队leader而言，这一点较为重要，当我们弄清楚这一点之后，才会更好的去把握，我们招的这一拨人，应该满足什么样的特质，用什么的方式来凝聚团队战斗力</p>
<p>比如以我现在的团队来看，目前对外营造的标签，主要为 “专业” + “攻坚” + “和谐”，当然这些结论都是再日后的协作过程中，逐渐给其他人留下的印象，我最开始希望打造的只有“专业”这一点，所以我再招人的时候，设置了几个基础的要求</p>
<ul>
<li>有相关的行业背景</li>
<li>五年+的工作经验</li>
<li>沟通表达简洁、顺畅</li>
</ul>
<h3> 1.3 团队相性，定协作模式</h3>
<p>人有相性，团队当然也有。 由于我们是团队leader，那我能不能融入这个团队，或者这个团队的氛围和我的管理方式、个人习惯是否有不可调和的冲突，这些是需要我们重点考虑的</p>
<p>既然是搭建自己的团队，那这一点就很比较好执行了，首选的肯定是组建一个符合自己性格特点的团队，增加自己的舒适感也可以有效的减少管理的成本。</p>
<p>所以，再开始之前，先深刻认识一下自己，我是什么样的人，我想要什么样的人，我得团队应该是什么样的一个表现</p>
<p>同样以我个人举例，我本人属于偏技术侧，不喜欢与人battler，推崇简洁、高效，为人相对随和，因此我希望我一起合作的小伙伴 “有技术追求、做事高效、且性格同样温和”，技术牛批但是性格比较刚的不要，容易产生负面情绪的不要，容易急躁的不要，做事毛糙粗心大意的不要</p>
<blockquote>
<p>在这里自我申辩一下，由于我个人不希望我将有限的精力放在人事之上，因此很迅速的定下了我不想合作的特质，从现实来讲，这同样可以减少我们筛人的成本</p>
</blockquote>
<h3> 1.4 人员招聘</h3>
<p>以上都属于招人的前置过程，当明确我要招一些什么样的人之后，自然的就将进入真实的招聘过程； 有一说一，招人实际上一个非常耗时间、精力的一件事情，如何再短短的半小时、一小时之内，选择你今后战斗的小伙伴，这并不容易，当然每个资深的面试官都有自己的心得，简单说一下我个人的准备及执行过程</p>
<p><strong>准备阶段</strong></p>
<ul>
<li>提前准备几个通用的面试问题
<ul>
<li>技术方面：高级和中级，设置不同的面试题</li>
<li>工作习惯：是否养成良好的工作习惯，可以通过日常的工作流程中识别</li>
</ul>
</li>
<li>设定最低的过线标准
<ul>
<li>技术基本线： 基本功，实际解决问题能力，碰到未遇到的问题的处理思路</li>
<li>协作基本线： 沟通 + 工作习惯 + 性格</li>
</ul>
</li>
</ul>
<p><strong>执行过程</strong></p>
<blockquote>
<p>为了提高效率，再具体的执行过程中，我的一些操作有点为难面试者的嫌疑😂</p>
<p>下面是我之前招人的一般流程，并不带有普适性，谨慎参考</p>
</blockquote>
<ol>
<li>让面试者自我定位，属于初中高那一级</li>
<li>根据自我衡量，抛出准备的面试题
<ul>
<li>能基本回答完整的，继续下一轮</li>
<li>回答得比较差的，就准备两个简单的问题，走个流程迅速解决战斗</li>
</ul>
</li>
<li>工作习惯的交流
<ul>
<li>日常的需求交付模式、怎么和其他人协同开发</li>
<li>一个紧急的任务交过来了，怎么落地？</li>
</ul>
</li>
<li>了解对方的诉求，判断是否可以满足</li>
</ol>
<h3> 1.5 小结</h3>
<p>总的来说，招人是一个累活，我个人非常不喜欢干这件事情，主要原因在于我并不善于识人，再短短的交流时间内，很难说到底是遗漏了一个千里马/还是放入了一个滥竽充数的南郭先生</p>
<p>我个人的一些理论经验不一定行之有效，这里仅供一个参考，三步规划，一步执行</p>
<ol>
<li>明确团队规划，确定人员招聘计划</li>
<li>打造团队标签，明确人员组成</li>
<li>确定团队相性，制定候选人标准基线</li>
<li>面试过程：准备面试题库 + 设定达标底线</li>
</ol>
<h2> 2. 带人</h2>
<p>一个成熟的团队，除了健全的工作机制之外，还需要具备较低的融入成本。对于技术管理而言，无论是否实际带领团队，如何打造一个新人友好的环境都是我们的职责之一。</p>
<figure><img src="/imgs/column/manager/04_带人.png" alt="带人思维导图" tabindex="0" loading="lazy"><figcaption>带人思维导图</figcaption></figure>
<p>上面是我个人对带人的一点看法，除了建立良好的融入机制之外，这里也分别对新人初级小伙伴以及中高级成熟的职场人做了一些区分，由于层级不同，我们投入的时间、精力以及重点当然也会有侧重</p>
<h3> 2.1 初级成员融入</h3>
<p>对于初级的小伙伴，他们的实际经验、技术背景、工作习惯方面可能都存在欠缺，因此对于引领他们快速融入团队的“导师”，需要投入更多的时间关注</p>
<ol>
<li>首先，通过交流和交付任务来评估他们的真实能力水平。这有助于我们了解他们的基线，并为他们提供个性化的指导</li>
<li>制定节点计划
<ul>
<li>业务熟悉计划表：帮助他们逐步了解和熟悉业务领域</li>
<li>技术栈学习计划表：确保他们能够快速掌握当前项目的技术栈基础知识点，目标是能够无障碍地使用这些技术</li>
</ul>
</li>
<li>项目工作方式宣贯
<ul>
<li>提前告知项目的协作规范和开发规范</li>
<li>在初期，重点关注成员的工作模式执行情况，及时进行纠正和指导</li>
</ul>
</li>
<li>任务需求试点
<ul>
<li>从简单的任务开始，逐渐分配更具挑战性的任务</li>
<li>前期聚焦于特定的业务或系统，待熟悉后再进行扩展</li>
</ul>
</li>
<li>定期进行一对一沟通
<ul>
<li>通过面对面的交流，了解他们的团队融入情况，解答个人的疑惑，并根据他们的反馈动态调整任务分配</li>
<li>前期可以增加沟通的频率（如每天下班后聊5分钟，每周进行半小时的深入交流），随着他们的成长，可以逐渐降低沟通的频率</li>
</ul>
</li>
</ol>
<h3> 2.2 高级成员融入</h3>
<p>针对中高级研发人员，凭借多年的工作经验，通常都已经形成了自己独特的工作习惯。因此，在引导他们融入团队的过程中，我们的目标是加速这一融入过程，并最大限度地减少他们的疏离感和陌生感，驯熟的熟悉当前团队的工作习惯和协作模式。以下是我的一些看法：</p>
<ol>
<li>在入职初期，进行一次全面的业务和架构介绍 (这种方式比单纯地阅读文档和代码更为高效)
<ul>
<li>首先，通过整体的介绍，让新成员对业务和架构有一个宏观的认识</li>
<li>然后再让他们自主地熟悉细节</li>
</ul>
</li>
<li>明确业务领域，并优先进行掌握熟悉
<ul>
<li>为新成员明确他们即将负责的主要系统，并鼓励他们重点熟悉和掌握。</li>
<li>如果没有特定的业务需求，那么可以以修复bug为主</li>
<li>再次过程中，收集他们对业务的整体认知，包括优化建议和遇到的问题。 （从新人的视角，往往可以得到一些我们看不到的优化点）</li>
</ul>
</li>
<li>快速实现任务交付。
<ul>
<li>鼓励新成员参与需求和设计方案的讨论，从一些非核心的需求开始，迅速了解整个工作流程和规范。</li>
</ul>
</li>
<li>培养信任关系，并充分放权
<ul>
<li>中高级研发成员加入团队是为了独挡一面。一旦确认他们的能力无误，我们应该给予他们足够的权力，让他们充分发挥自己的能力。</li>
</ul>
</li>
</ol>
<h2> 3. 小结</h2>
<p>对于团队成员的组建，是一个非常考研领头人个人综合能力的一项挑战。 认清团队目标，找准自我定位，搭建成员班底这仅是第一步，如何建立良好的团队关系，充分发挥团队的战斗力，也是我们接下来需要重点考虑的点</p>
<p>接下来我将以个人的实际经历，来看一下一个新的研发团队，怎么做新项目的承接、团队成员的磨合</p>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/column/manager/04_团队成员招聘.png" type="image/png"/>
    </item>
    <item>
      <title>05. 团队磨合</title>
      <link>https://liuyueyi.github.io/tutorial/column/tech/manager/05.%E5%9B%A2%E9%98%9F%E7%A3%A8%E5%90%88.html</link>
      <guid>https://liuyueyi.github.io/tutorial/column/tech/manager/05.%E5%9B%A2%E9%98%9F%E7%A3%A8%E5%90%88.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">05. 团队磨合</source>
      <description>上一篇介绍了团队组建的过程，当团队搭建起来开始运转时，作为领头羊、团队的掌舵者，我们首先需要解决的就是团队协作问题，即我们应该再团队的磨合期做些什么，以此来实现彼此的逐步熟悉、建立信任和提高协作效率 本文组织结构的思维导图如下，基于3w原则 团队磨合思维导图 1. 什么样的团队需要磨合</description>
      <category>技术管理</category>
      <pubDate>Wed, 06 Mar 2024 09:27:46 GMT</pubDate>
      <content:encoded><![CDATA[<p>上一篇介绍了团队组建的过程，当团队搭建起来开始运转时，作为领头羊、团队的掌舵者，我们首先需要解决的就是团队协作问题，即我们应该再团队的磨合期做些什么，以此来实现彼此的逐步熟悉、建立信任和提高协作效率</p>
<p>本文组织结构的思维导图如下，基于3w原则</p>
<figure><img src="/imgs/column/manager/05_团队磨合思维导图.png" alt="团队磨合思维导图" tabindex="0" loading="lazy"><figcaption>团队磨合思维导图</figcaption></figure>
<h2> 1. 什么样的团队需要磨合</h2>
<p>再看这个命题的时，首先需要明确的是，什么样的团队需要磨合？</p>
<p>一般来说，一个成熟稳健的团队，是不需要磨合的，对于这样的团队，需要关注的是信任的融入过程是否丝滑，是否有完善的培养晋升机制</p>
<p>而需要磨合的，则往往是我们这种新组建的团队，团队成员可能是新招，也可能是来自不同的部门进行抽调组成，由于大家彼此不熟，既往的工作履历、习惯、背景都存在差异，相互的信任还未建立，从而导致团队的整体运转不够高效明朗、相互之间的协作混乱冲突。 新组建的团队，都会经历一个磨合期，对于团队的管理来说，我们需要干的就是加快这个磨合过程，迅速增强凝聚力。</p>
<h2> 2. 磨合什么</h2>
<p>对于管理者而言，我需要做什么？ 基于我个人的实际认知，分成下面几点</p>
<figure><img src="/imgs/column/manager/05_团队磨合事项.jpg" alt="团队磨合事项" tabindex="0" loading="lazy"><figcaption>团队磨合事项</figcaption></figure>
<h3> 2.1 明确目标与期望</h3>
<p>正如每个旅程都有目的地一样，每个团队当然也有自己的使命与目标。对于团队管理而言，明确要干什么当然很重要，那团队成员呢，真的重要么?</p>
<p>以我个人的实际工作体验来说，当我是一线小兵时，对于团队的整体目标，并不会特别关心，我只要知道我自己负责什么、要做什么、什么时候交付，将自己的事情做好即可。</p>
<p>当站在管理者的视角，再看上面的表述，你会发现上面的执行过程没有任何问题，只是可能出现问题的地方在于管理者对成员的定位以及任务分配，我对他的这些规划，是不是符合我们团队的整体预期？ 请牢记我们是掌舵者，这条船开往那里是由我们来决定的，当你发现团队走偏时，不用怀疑其他，90%以上可能性就是你自己的问题</p>
<h3> 2.2 标准的工作流程</h3>
<p>从研发的角色，当然时崇尚自由、探索；但是作为管理者的角色，统一的标准和基线，是减少我们工作量的重要手段</p>
<h4> 2.2.1 统一的研发流程规范</h4>
<p>只要一个公司的研发人数大于10，那么必然会有自己的研发规范（无论这个规范是明文还是潜规则，合理or不合理），这些或明文或潜规则的规范，可以简单理解为这个团队所有人认可的工作过程，比如对于研发而言，一套完整的工作流程需要遵循的有：</p>
<ul>
<li>代码分支管理</li>
<li>需求交底，反串讲</li>
<li>方案设计、评审</li>
<li>统一的编码风格</li>
<li>提测前的功能自测</li>
<li>测试验收</li>
<li>部署上线</li>
<li>线上回归验证</li>
</ul>
<h4> 2.2.2 受信服的项目管理过程</h4>
<p>这里的项目管理过程，可以简单理解为我们常见的需求交付过程，比如常见的</p>
<ul>
<li>产品需求交底</li>
<li>研发反串讲</li>
<li>研发</li>
<li>上测试，提测</li>
<li>测试通过，上预发</li>
<li>产品验收</li>
<li>上生产</li>
</ul>
<h4> 2.2.3 清晰高效的沟通机制</h4>
<p>工作上出现多人协同工作的可能性非常之高，那么必然会出现沟通，而沟通表达可能是很多研发的弱项，由于沟通的缺乏导致的信息差，对于团队管理者而言，往往是一拳重击。</p>
<h3> 2.3 共识的技术标准</h3>
<p>由于我个人是研发出身，所以会单独说一下技术标准共识的磨合，why?</p>
<p>研发，通常会有一种技术崇拜，喜欢折腾新技术，乐于尝鲜；高级的研发认为代码写得好完全不需要研发；杀鸡用牛刀的炫技写法（潜台词即设计模式并不是所有场景通用，某些时候简单的if/else比设计模式更值得）</p>
<p>但是对于团队、公司而言，稳定可持续的交付更重要，对于新技术的引入一般会很慎重，更重视代码的可维护性、阅读性</p>
<p>因此这里说的技术标准，包含但不限于以下：</p>
<ul>
<li>技术栈选型</li>
<li>编码规范</li>
<li>架构设计原则</li>
<li>通用的文档模板:</li>
<li>新技术/组件的引入原则、评审机制</li>
<li>...</li>
</ul>
<h3> 2.4 熟悉工具栈</h3>
<p>每个团队都会有自己的效率/运营工具，请不要把这些大家今后工作中，高频使用的东西“藏起来”，我们应该金align的让所有的小伙伴，可以无障碍，快速的熟悉这些，比如</p>
<ul>
<li>代码管理工具：git/svn</li>
<li>项目管理软件：jira/禅道</li>
<li>持续集成/持续部署CI/CD</li>
<li>知识库：钉钉/飞书/石墨/wiki</li>
<li>内部的运营工具等</li>
</ul>
<h3> 2.5 问题解决机制</h3>
<p>这个也是团队磨合中需要提前解决的点，这里指得问题，有两类</p>
<ul>
<li>人的问题
<ul>
<li>团队成员关系问题</li>
<li>工作习惯的冲突问题</li>
<li>外部沟通、配合障碍的问题</li>
</ul>
</li>
<li>事的问题
<ul>
<li>系统故障处理预案</li>
<li>线上问题处理机制</li>
<li>业务边界问题</li>
</ul>
</li>
</ul>
<p>人的问题，若不能提前解决，那就真如那句“人心散了，队伍就不好带了”； 事的问题，解决不好，则容易带来直接的经济or口碑损失</p>
<h3> 2.6 共享机制</h3>
<p>磨合期间，个人强烈建议需要解决的一件事情是建立一套透明的共享机制，让知识再团队内最大化的流动起来，避免出现单点问题；同时一个良好的分享氛围，也可以有效的提高团队的稳定性</p>
<p>分享主题尽量可以分散一点，不要局限在技术侧</p>
<ul>
<li>业务分享</li>
<li>技术分享</li>
<li>人文分享</li>
</ul>
<h3> 2.7 信任建立</h3>
<p>在磨合期间，需要解决信任问题，这个拖的时间越长、解决得越差，那么团队得磨合期就只会更长</p>
<p>我们需要重点解决两种信任：</p>
<ol>
<li>团队成员对领队的信任</li>
<li>团队成员相互之间的信任</li>
</ol>
<h3> 2.8 绩效与考核机制</h3>
<p>透明的绩效与考核机制，对于团队的稳定性有较大的帮助，当然一般团队的管理对绩效制定这块并不会有太大的抉择权，所以在磨合期间做好宣贯即可</p>
<h2> 3. 怎么做</h2>
<p>当我们明确上面指出的几点之后，接下来就是需要去实现、去解决。 下面将结合个人实践进行阐述</p>
<h3> 3.1 目标与期望的宣贯</h3>
<p>目标主要针对的是团队的职责、任务目标； 期望则是上级对团队的预期以及你个人对团队成员的预期</p>
<p>step1: 认清目标与期望</p>
<p>作为团队管理者，这个是自己首先需要明确的点，关注项目背景、团队的组建原因，和上级多交流，总结自己的认知然后和上级领导、横向的团队管理进行交流，确保没有大的理解偏差</p>
<p>以我所经历的这次团队组建来说，上级制定的目标比较明确</p>
<ul>
<li>短期目标： 一个月内可以承接商城的简单需求研发交付</li>
<li>中期目标： 三个月内独立原团队，完成所有研发、运营任务的研发交付</li>
<li>长期目标： 彻底掌握商城，运营商城，改进商城</li>
</ul>
<p>对我们的期望总结两字就是“专业”</p>
<p>step2: 目标同步</p>
<p>当我们搞清楚目标和期望之后，需要在一个相对正式的环境下，给团队内的所有小伙伴进行宣贯，告诉大家我们应该往哪个方向努力，这一阶段请确保每个人都明确知道中短期目标，尤其是短期目标，是否都认可，愿意往这方面去努力</p>
<p>step3: 任务拆解</p>
<p>告诉大家方向之后，作为管理者，我们还需要为他们分工，每个人应该做哪些事情以使得我们可以实现目标</p>
<p>同样以我所处的团队为例进行说明（在新的项目组，我主要负责商城的订单和中团两个团队，下面以订单为例进行说明）</p>
<p>首先圈定团队业务边界</p>
<ul>
<li>订单团队负责下单之后的所有流程</li>
</ul>
<p>针对所有业务，按人头的方式进行粗分</p>
<ul>
<li>下单到采购计划： 1人</li>
<li>订单: 1人</li>
<li>收发货：1人</li>
<li>物流：1人</li>
<li>结算：2人</li>
<li>支付：1人</li>
<li>金服：1人</li>
<li>售后评价：0人 --&gt; 在我们这个商城项目中非常不重要，因此前期不用排人</li>
</ul>
<p>step4: 明确要求</p>
<p>上面是任务分工，如果活只是派下去了，但是没有明确的要求或者时间限制，那么这个任务的执行情况恐怕并不会好，因此一个合理的任务分配，除了告诉对方要干什么之外，还需要明确时间、产出物</p>
<p>如我所属的订单团队，任务职责划分之后，定了几个使用短期的关键节点计划</p>
<ul>
<li>3天：熟悉研发运维等流程规范，应用本地能跑起来进行debug测试</li>
<li>3天：梳理出各自领域内的数据模型，最后建立各主数据的关联关系</li>
<li>1周：实际体验商城的整体流程，梳理各自领域内的主体业务逻辑</li>
<li>1月：完成一次完整的线上迭代交付流程，熟悉常见的线上运维工具</li>
</ul>
<p>step5: 阶段性验收</p>
<p>按时检验任务执行情况，对交付好的不吝称赞，对实现的不好的找一下根因，动态调整交付任务与目标</p>
<h3> 3.2 沟通机制建立</h3>
<p>这一块内容较大，后面放在团队沟通这一块的内容进行展开。 可以简单说一下团队磨合期间我的个人做法</p>
<ul>
<li>方式一： 和组内的小伙伴一起吃饭，吃饭的过程中闲聊，增进关系</li>
<li>方式二： 和组内的小伙伴1v1面对面的交流，聊工作、聊困惑、聊生活</li>
<li>方式三： 组织分享，就分享主题进行沟通讨论</li>
<li>方式四： 前期，重点关注各位组员的任务交付，主动去了解他们的执行情况，是否有问题，及时掌握第一手的信息</li>
</ul>
<h3> 3.3 建立标准的工作流程</h3>
<p>让我们从0到1建立一套标准的工作流程并不太现实，但是抄一份适用的还是比较简单的。 大部分的技术管理，都是积年的老开发，或多或少在不同的公司、团队都待过，将自己既往的工作方式，提炼重整一下，输出一份工作流程还是有可能的。若实在不行，直接将之前工作过程中，认为不错的标准拿过来直接用，也不是不行</p>
<p>在我们制定工作流程时，切记几个注意实现:</p>
<ol>
<li>邀请资深成员参与流程制定的讨论，避免采用少数服从多数的策略。这是基于团队成员的常见梯度，即初级成员通常占据大部分。</li>
<li>标准工作流程的目标是为了统一和规范我们的工作机制。我们不能盲目迷信教条和大厂的光环。如果我们采用了其他大公司的工作流程，我们需要根据我们的实际情况进行调整。</li>
<li>工作流程制定完成后，我们需要在一个正式的场合，向所有团队成员进行宣讲</li>
</ol>
<p>比如我们当时制定的几个流程规范 （后续再给大家进行介绍）</p>
<ul>
<li>git工作流规范</li>
<li>代码规范：java后端编码规范 &amp; 代码检测规范 &amp; 命名规范 &amp; 日志应用规范</li>
<li>数据库与SQL规范</li>
<li>需求自测、提测，发版上线流程规范</li>
</ul>
<h3> 3.4 熟悉工具栈</h3>
<p>这个比较简单，首先身先士卒去了解所有相关的工具栈，然后整理一个图谱和简易的使用手册，然后这个手册的维护与更新交由团队内最后一个入职的小伙伴（即将这个手册顺道做成新人手册，再新人熟悉项目的同时，同时记录自己疑惑以及对应的解答，这样也可以减小后续小伙伴的融入成本）</p>
<p>常见的工具栈包括研发 + 运维两类，如</p>
<ul>
<li>代码管理工具：git/svn</li>
<li>代码仓库：gitlab/gerrit/github/gitee等</li>
<li>项目部署：jenkins/gitlab ci等</li>
<li>代码检测：sonar</li>
<li>日志查看：grafana</li>
<li>全链路： skywalking</li>
<li>监控预警： sentry</li>
<li>Sql审核查询平台： archery/Yearning</li>
<li>api管理平台： yapi/swagger</li>
<li>研发运营管理后台：xxx（通常是自己实现的，共研发、运营使用的工作台）</li>
<li>项目管理软件：jira/禅道</li>
<li>知识库： 钉钉文档/飞书文档/Confluence Wiki等</li>
</ul>
<h3> 3.5 问题解决机制</h3>
<p>关于问题的处理，可以衍生的内容也很多，会再后续的内容中以真实案例进行展开，这里主要说一下再磨合阶段，我们可以做的努力，以及预期达到的效果</p>
<p>首先说我们的预期目标：</p>
<ol>
<li>融洽的团队关系</li>
<li>养成问题及时上报的习惯</li>
</ol>
<p>入我们现在得到共识和执行落地问题处理机制如下：</p>
<p><strong>系统问题</strong></p>
<p>为了确保线上问题能够得到有效且高效的解决，我们制定了以下通用的问题解决流程图。该流程图详细标注了从问题出现到问题解决的全过程，以指导相关人员如何进行问题处理。</p>
<ol>
<li>开放沟通的习惯：在遇到问题时，首先需要养成开放沟通的习惯。一旦发现问题，应立即上报，确保问题能够被及时捕捉并得到关注。同时，需要有人主动跟进，确保问题能够得到及时的处理。</li>
<li>问题追踪文档的建立：根据我们的问题处理模板，我们需要新建一个问题追踪文档，用于记录问题处理过程中的关键节点信息。这包括：
<ul>
<li>问题的提出：记录问题是由谁在何时提出的。</li>
<li>问题的接取：记录问题是由谁在何时接取的，并对问题的影响范围进行评估。</li>
<li>问题原因的发现：记录问题的原因是由谁在何时发现的。</li>
<li>问题的解决：记录问题是由谁在何时解决的。</li>
</ul>
</li>
<li>问题原因的分析：在问题处理过程中，我们需要对问题的原因进行深入分析，找出问题的根本原因，以便能够从根本上解决问题。</li>
<li>复盘：在问题解决后，如果必要，我们需要进行复盘，回顾问题处理的过程，总结经验教训，以便在未来遇到类似问题时，能够更加迅速、有效地进行处理。</li>
</ol>
<p><strong>人际问题</strong></p>
<ol>
<li>作为团队管理，周期性的和组内成员1v1面谈。这种沟通方式不仅有助于了解成员的工作进度和挑战，还能加强彼此之间的信任和理解，从而确保团队的高效运作。</li>
<li>在每个大型需求交付的过程中，明确指定一个负责人进行全程跟进；团队管理则对负责人的推进过程进行兜底（如与外部沟通时的协助，内部推进的站台等）</li>
<li>请注意始终为你的团队成员站台，即该护短的时候别退缩（请知晓，你的团队成员可能除了你可以依靠之外，很难再得到其他的资源，若你不能为你的团队成员解决问题，那么你的权威和威信将难以建立起来）</li>
</ol>
<h3> 3.6 共享机制</h3>
<p>在组织中，若仅对成员施加超出其常规职责范围的额外任务，而未提供相应的激励措施，尤其是当领导层自身不参与其中时，这样的任务往往难以为继。具体而言，团队内部的业务技术分享活动，正属于这类缺乏直接激励的非日常工作内容。</p>
<p>基于我个人在多个团队的经历，具备良好分享文化的团队并不多见；而一个缺乏积极分享文化的团队，通常也会在成员的技术追求和交流氛围方面表现欠缺。 共享机制的搭建，真实尝试去推动之后，发现很难，下面是我的一些尝试过程</p>
<ol>
<li>以身作则，亲自参与团队内部的知识分享，为建立分享文化奠定基础</li>
<li>制订详细的分享计划，并与团队成员进行一对一沟通，鼓励他们参与分享，协助他们确定分享的主题。</li>
<li>建立积极的反馈机制，在分享过程中充当热情的听众，确保主讲人不会因沉默而感到尴尬；每次分享结束后，与主讲人进行交流，肯定其优秀表现，并提出建设性的改进建议。</li>
</ol>
<p>通过这些措施，我努力营造一个支持性的环境中，团队成员能够感受到他们的努力被认可，并从中获得成长和满足感。</p>
<p>比如下面就是我组织团队内成员做的一个面向整个项目团队的分享专栏（最后一个主题是我的🤭）</p>
<figure><img src="/imgs/column/manager/05_分享主题.jpg" alt="分享专题" tabindex="0" loading="lazy"><figcaption>分享专题</figcaption></figure>
<h3> 3.7 建立信任</h3>
<p>这里主要说一下再团队组建初期，快速让团队成员信任自己； 不同的团队管理，采用的方式可能各不一样</p>
<p>我得执行方式则比较粗暴简单</p>
<ol>
<li>身先士卒，参与团队内成员的所有需求交付过程；让自己成为团队内的业务专家</li>
<li>技术方案的把控，参与技术设计过程，展现自己的技术能力</li>
<li>拦截所有的线上运营问题，充当团队成员的第一道门户（尤其是我们这个新组建的团队，从另外一个团队手中接手新的项目，大家对系统都不熟），给团队成员熟悉系统的时间和空间</li>
<li>参与团队成员和产品、测试、外部人员的对接过程，协助他们的推进过程</li>
<li>帮团队成员背锅，能抗事</li>
<li>主动分享（技术 + 业务 + 效率工具 + 运营排查手册）</li>
</ol>
<h3> 3.8 绩效与考核</h3>
<p>这个没什么好说的，一线的团队管理没有这个权限；后续会给大家说一下有效的 “精神激励法”</p>
<h2> 4. 小结</h2>
<p>这一篇主要介绍的是团队磨合的相关内容，对于一个刚开始带团队的技术管理而言，可能对这块不知道怎么做，一如几年前只知到莽的我。。。</p>
<p>这里总结了一下个人的实际经验，介绍了磨合什么，怎么去做的一些个人看法； 当然每个团队的实际情况不一样，并不存在通用的万能公式。总的来说，这个磨合过程，主要就是实现大家的工作同频、拉齐认知，减少团队内的龃龉；接下来一篇，我会给大家介绍一下这个磨合过程中的输出物：《如何做项目的持续交接（项目流程规范制定与宣讲）》</p>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/column/manager/05_团队磨合思维导图.png" type="image/png"/>
    </item>
    <item>
      <title>06.持续交付</title>
      <link>https://liuyueyi.github.io/tutorial/column/tech/manager/06.%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%8C%81%E7%BB%AD%E4%BA%A4%E6%8E%A5.html</link>
      <guid>https://liuyueyi.github.io/tutorial/column/tech/manager/06.%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%8C%81%E7%BB%AD%E4%BA%A4%E6%8E%A5.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">06.持续交付</source>
      <description>再团队搭建之后，我们首先面临的问题就是如何统一大家的工作模式和日常习惯。 由于每个成员的履历背景、事务认知的差异性以及既往工作经验对当前项目的适配程度高低，都将影响我们的对项目持续交付流程的制定。再正式开始之前，借助哲学的一句名言 “一切事物总是在不断发展变化之中”，因此不要妄想一蹴而就的打造一个完美的工作流程，选择一个学习成本最低且适用于当前的项目的演进，就不算是失败的决策 接下来我将以下面几块内容进行阐述 持续交付的内容拆解，基于业界理论or最佳实践模式作为输入支撑 以一线程序员视角解读交付过程 以技术管理视角接的交付过程 结合当前项目实际场景，选择适用的持续交付策略</description>
      <category>技术管理</category>
      <pubDate>Tue, 12 Mar 2024 09:27:46 GMT</pubDate>
      <content:encoded><![CDATA[<p>再团队搭建之后，我们首先面临的问题就是如何统一大家的工作模式和日常习惯。 由于每个成员的履历背景、事务认知的差异性以及既往工作经验对当前项目的适配程度高低，都将影响我们的对项目持续交付流程的制定。再正式开始之前，借助哲学的一句名言 “一切事物总是在不断发展变化之中”，因此不要妄想一蹴而就的打造一个完美的工作流程，选择一个学习成本最低且适用于当前的项目的演进，就不算是失败的决策</p>
<p>接下来我将以下面几块内容进行阐述</p>
<ol>
<li>持续交付的内容拆解，基于业界理论or最佳实践模式作为输入支撑</li>
<li>以一线程序员视角解读交付过程</li>
<li>以技术管理视角接的交付过程</li>
<li>结合当前项目实际场景，选择适用的持续交付策略</li>
</ol>
<h2> 1. 什么是持续交付</h2>
<blockquote>
<p>持续集成，持续交付，持续部署属于DevOps中的相关概念，我们这里引入“持续交付”来介绍如何搭建团队的工作流程</p>
</blockquote>
<p>首先我们简单的解读一下这里的“持续交付”的概念</p>
<p>持续交付（Continuous delivery）指的是，频繁地将软件的新版本，交付给质量团队或者用户，以供评审。如果评审通过，代码就进入生产阶段。</p>
<p>再简单一点来说，也就是作为研发人员，从产品经理那里获取到原始需求之后，从研发开始到上线之后的回归，再这一周期内，我们应该遵循什么样的规范/规则来执行</p>
<h3> 1.1 交付流程关键节点</h3>
<figure><img src="/imgs/column/manager/06_研发过程关键节点.png" alt="研发过程关键节点" tabindex="0" loading="lazy"><figcaption>研发过程关键节点</figcaption></figure>
<p>上图是一个通用的研发过程关键节点，针对这些重要的节点，抛出一些疑问事项</p>
<ol>
<li>需求串讲</li>
</ol>
<ul>
<li>即产品的需求交底过程</li>
<li>如何进行？ 目的是什么？</li>
</ul>
<ol start="2">
<li>反串讲&amp;技术方案评审</li>
</ol>
<ul>
<li>研发理解需求之后，主导的实现思路/技术方案的串讲</li>
<li>是否一定需要？ 如何进行这个过程？ 怎么评判它的执行效果</li>
</ul>
<ol start="3">
<li>研发</li>
</ol>
<ul>
<li>研发过程走什么样的开发模式， 瀑布、迭代、敏捷？</li>
<li>研发进度如何把控，如何识别风险事项？</li>
</ul>
<ol start="4">
<li>联调自测</li>
</ol>
<ul>
<li>前后端如何联调，边开发边联调，还是约定时间专项联调？</li>
<li>自测范围包含哪些，如何做自测?</li>
</ul>
<ol start="5">
<li>测试上线</li>
</ol>
<ul>
<li>测试用例怎么维护，如何评判上线标准？</li>
</ul>
<h3> 1.2 过程规范</h3>
<p>基于上面的过程节点，我们来看一下是否</p>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/column/manager/06_研发过程关键节点.png" type="image/png"/>
    </item>
    <item>
      <title>从0到1转技术管理</title>
      <link>https://liuyueyi.github.io/tutorial/column/tech/manager/</link>
      <guid>https://liuyueyi.github.io/tutorial/column/tech/manager/</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">从0到1转技术管理</source>
      <description>技术管理之路 序 01. 契机 02. 准备工作 03. 入职新项目</description>
      <pubDate>Mon, 29 Jul 2024 08:58:55 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 技术管理之路</h2>
<p><strong>序</strong></p>
<ul class="task-list-container">
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-0" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-0"> <a href="./01.%E5%BA%8F%20%E8%BD%AC%E7%AE%A1%E7%90%86%E7%9A%84%E5%A5%91%E6%9C%BA">01. 契机</a></label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-1" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-1"> <a href="./02.%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C">02. 准备工作</a></label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-2" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-2"> <a href="./03.%E5%85%A5%E8%81%8C%E6%96%B0%E9%A1%B9%E7%9B%AE">03. 入职新项目</a></label></li>
</ul>
<p><strong>团队搭建</strong></p>
<ul class="task-list-container">
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-3" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-3"> <a href="./04.%E5%9B%A2%E9%98%9F%E7%BB%84%E5%BB%BA">04. 招人/带人</a></label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-4" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-4"> <a href="./05.%E5%9B%A2%E9%98%9F%E7%A3%A8%E5%90%88">05. 新项目交接，团队磨合</a></label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-5" disabled="disabled"><label class="task-list-item-label" for="task-item-5"> <a href="./06.%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%8C%81%E7%BB%AD%E4%BA%A4%E6%8E%A5">06. 如何做项目的持续交接（项目流程规范制定与宣讲）</a></label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-6" disabled="disabled"><label class="task-list-item-label" for="task-item-6"> <a href="">07. 建立信任：攻坚、身先士卒</a></label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-7" disabled="disabled"><label class="task-list-item-label" for="task-item-7"> <a href="">08. 进入正轨</a></label></li>
</ul>
<p><strong>抗压与异常的应对</strong></p>
<ul class="task-list-container">
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-8" disabled="disabled"><label class="task-list-item-label" for="task-item-8"> <a href="">09. 任务过重，压力分摊</a></label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-9" disabled="disabled"><label class="task-list-item-label" for="task-item-9"> <a href="">10. 突发故障及应对方案：超付</a></label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-10" disabled="disabled"><label class="task-list-item-label" for="task-item-10"> <a href="">11. 中间序曲：转正定级</a></label></li>
</ul>
<p><strong>团队凝聚力</strong></p>
<ul class="task-list-container">
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-11" disabled="disabled"><label class="task-list-item-label" for="task-item-11"> <a href="">12. 营造团队氛围</a></label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-12" disabled="disabled"><label class="task-list-item-label" for="task-item-12"> <a href="">13. 任务分配：能者多劳？</a></label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-13" disabled="disabled"><label class="task-list-item-label" for="task-item-13"> <a href="">14. 授人以渔-软福利的宣扬：项目推进、方案设计、代码评审</a></label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-14" disabled="disabled"><label class="task-list-item-label" for="task-item-14"> <a href="">15. 人员变动：怎么看离职</a></label></li>
</ul>
<p><strong>管理沟通</strong></p>
<ul class="task-list-container">
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-15" disabled="disabled"><label class="task-list-item-label" for="task-item-15"> <a href="">16. 向上沟通与成绩汇报</a></label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-16" disabled="disabled"><label class="task-list-item-label" for="task-item-16"> <a href="">17. 横向沟通与项目协同推进</a></label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-17" disabled="disabled"><label class="task-list-item-label" for="task-item-17"> <a href="">18. 向下沟通：1to1</a></label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-18" disabled="disabled"><label class="task-list-item-label" for="task-item-18"> <a href="">19. 外部沟通/与甲方沟通</a></label></li>
</ul>
<p><strong>小结</strong></p>
<ul class="task-list-container">
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-19" disabled="disabled"><label class="task-list-item-label" for="task-item-19"> <a href="">20. 小结与展望</a></label></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>1.容器刷新前回调ApplicationContextInitializer</title>
      <link>https://liuyueyi.github.io/tutorial/spring/extend/basic/220927-Spring%E6%89%A9%E5%B1%95%E4%B9%8B%E5%AE%B9%E5%99%A8%E5%88%B7%E6%96%B0%E5%89%8D%E5%9B%9E%E8%B0%83ApplicationContextInitializer.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/extend/basic/220927-Spring%E6%89%A9%E5%B1%95%E4%B9%8B%E5%AE%B9%E5%99%A8%E5%88%B7%E6%96%B0%E5%89%8D%E5%9B%9E%E8%B0%83ApplicationContextInitializer.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">1.容器刷新前回调ApplicationContextInitializer</source>
      <description>本文将作为Spring系列教程中源码版块的第一篇，整个源码系列将分为两部分进行介绍；单纯的源码解析，大概率是个吃力没人看的事情，因此我们将结合源码解析，一个是学习下别人的优秀设计，一个是站在源码的角度看一下我们除了日常的CURD之外，还可以干些啥</description>
      <category>Spring源码</category>
      <category>扩展点</category>
      <pubDate>Tue, 27 Sep 2022 19:26:11 GMT</pubDate>
      <content:encoded><![CDATA[<p>本文将作为Spring系列教程中源码版块的第一篇，整个源码系列将分为两部分进行介绍；单纯的源码解析，大概率是个吃力没人看的事情，因此我们将结合源码解析，一个是学习下别人的优秀设计，一个是站在源码的角度看一下我们除了日常的CURD之外，还可以干些啥</p>
<!-- more -->
<p>在Spring的启动过程中，一系列的操作步骤中，提供了很多的扩展点，供我们来增强；简单来说就是提供了很多的钩子，这样当我们在某个节点执行前后，想干点其他的事情时，可以很简单的支持；本文介绍的<code>ApplicationContextInitializer</code>，spring容器在刷新之前会回调这个接口，从而实现在spring容器未初始化前，干一些用户希望做的事情</p>
<h2> I. 项目准备</h2>
<p>本文创建的实例工程采用<code>SpringBoot 2.2.1.RELEASE</code> + <code>maven 3.5.3</code> + <code>idea</code>进行开发</p>
<p>具体的SpringBoot项目工程创建就不赘述了，核心的pom文件，无需额外的依赖</p>
<p>配置文件 <code>application.yml</code>， 也没有什么特殊的配置</p>
<p>源码工程参考文末的源码</p>
<h2> II. 容器刷新前扩展点实例</h2>
<h3> 1. 自定义ApplicationContextInitializer</h3>
<p>当我们希望实现一个自定义的上下文初始化时，非常简单，实现上面这个接口就行了，如</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 扩展点注册</h3>
<p>上面自定义一个扩展点，如何使它生效呢？</p>
<p>官方提供了三种方式，如在启动时，直接进行注册: <code>springApplication.addInitializers(new ApplicationContextInitializer01());</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当我们的扩展点是放在一个jar包中对外提供时，使用上面的启动注册方式显然是不可行的，此时更推荐的做法就是通过Spring的SPI机制进行注册</p>
<p>在资源目录下的<code>META-INF/spring.factories</code>文件中进行注册</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>说明</strong></p>
<ul>
<li>上面SPI的机制非常推荐大家使用，在之前的文章中，<code>AutoConfiguration</code>的注册通常也是使用这种方式</li>
</ul>
<p>除了上面的两种注册方式之外，另外还有一个配置文件的方式，在配置文件<code>application.properties</code> 或 <code>application.yml</code>中，如下配置</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>启动测试</strong></p>
<p>上面三种注册方式，我们实现三个自定义的扩展点，然后启动之后，看一下实际输出</p>
<figure><img src="/imgs/220927/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>上面的输出，可以简单的得出一个结论，不同注册方式的优先级（为了更合理的验证下面的观点，推荐大家修改下上面三个自定义扩展点名，排除掉是因为扩展名导致的排序问题）</p>
<ul>
<li>配置文件注册 &gt; SPI注册 &gt; 启动时注册</li>
</ul>
<h3> 3. 执行顺序指定</h3>
<p>对于自定义的扩展点实现，当存在顺序关系时，我们可以通过<code>@Order</code>注解来实现， 如当上面的三个扩展点都是通过启动方式注册时</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出实例如下</p>
<figure><img src="/imgs/220927/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p><strong>接着重点来了</strong></p>
<ul>
<li>若上面的三个自定义实现，不是相同的注册方式，如将03采用配置文件方式进行注册，那么01, 02 依然是启动注册</li>
<li>则顺序是 03 &gt; 02 &gt; 01</li>
<li>即 <code>@Order</code>注解修饰的顺序，并不能打破  <strong>配置文件 &gt; SPI &gt; 启动方式注册的顺序</strong></li>
</ul>
<p>关于自定义实现类的执行顺序，规则如下</p>
<ul>
<li>配置文件 &gt; SPI &gt; 启动方式</li>
<li>相同的注册方式，可以通过 <code>@Order</code> 注解进行修饰，值越小则优先级越高</li>
</ul>
<h3> 4. 使用场景示例</h3>
<p>最后我们再来看一下，这个扩展点到底有什么用，我们再什么场景下会用到这个呢？</p>
<p>一个经常可以看到的应用场景如通过它来指定需要激活的配置文件</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但是一般也很少见到有人这么干，因为直接使用配置参数就行了，那么有场景需要这么做么？</p>
<p>答案当然是有的，比如现在广为流行的docker容器部署，当我们希望每次都是打同一个镜像，然后在实际运行的时候，根据不同的环境来决定当前镜像到底启用哪些配置文件，这时就有用了</p>
<p>比如我们通过容器的环境参数 <code>app.env</code> 来获取当前运行的环境，如果是prod，则激活<code>application-prod.yml</code>; 如果是test，则激活<code>application-test.yml</code></p>
<p>那么此时可以这么干</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 5. 小结</h3>
<p>本文作为扩展点的第一篇，通过实现<code>ApplicationContextInitializer</code>接口，从而达到在spring容器刷新之前做某些事情的目的</p>
<p>通常自定义的ApplicationContextInitializer有三种注册方式，按照优先级如下</p>
<ul>
<li>配置文件 &gt; SPI方式 &gt; 启动方式注册</li>
<li>相同的注册方式中，可以使用<code>@Order</code>注解来指定优先级，值越小优先级越高</li>
</ul>
<p>最后还给出了一个可以应用得实例场景，即如何实现一个镜像在不同的环境中启动运行</p>
<p>下一个扩展点我们将介绍如何通过<code>BeanDefinitionRegistryPostProcessor</code>来实现非Spring生态的Bean加载使用</p>
<h2> III. 不能错过的源码和相关知识点</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/220927/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>2.自定义bean注册扩展机制BeanDefinitionRegistryPostProcessor</title>
      <link>https://liuyueyi.github.io/tutorial/spring/extend/basic/221026-Spring%E6%89%A9%E5%B1%95%E7%82%B9%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89bean%E6%B3%A8%E5%86%8C.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/extend/basic/221026-Spring%E6%89%A9%E5%B1%95%E7%82%B9%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89bean%E6%B3%A8%E5%86%8C.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">2.自定义bean注册扩展机制BeanDefinitionRegistryPostProcessor</source>
      <description>接着上一篇容器刷新前的扩展点，我们继续往下走；接下来来到的就是bean的定义扩展处，它是在Spring容器刷新之后，应用的bean定义加载完成、实例化之前提供的切入点，主要是通过实现BeanDefinitionRegistryPostProcessor接口的两个方法，来实现自定义的bean定义，或者对已注册的bean进行修改or代理替换 本文将带来的知识点如下： BeanDefinitionRegistryPostProcessor： 基本使用姿势 postProcessBeanDefinitionRegistry 方法 优先于 postProcessBeanFactory 方法执行 实现自定义的bean注册，实现对容器的bean定义进行修改</description>
      <category>Spring源码</category>
      <category>扩展点</category>
      <pubDate>Wed, 26 Oct 2022 14:45:41 GMT</pubDate>
      <content:encoded><![CDATA[<p>接着上一篇容器刷新前的扩展点，我们继续往下走；接下来来到的就是bean的定义扩展处，它是在Spring容器刷新之后，应用的bean定义加载完成、实例化之前提供的切入点，主要是通过实现<code>BeanDefinitionRegistryPostProcessor</code>接口的两个方法，来实现自定义的bean定义，或者对已注册的bean进行修改or代理替换</p>
<p>本文将带来的知识点如下：</p>
<ul>
<li>BeanDefinitionRegistryPostProcessor： 基本使用姿势</li>
<li><code>postProcessBeanDefinitionRegistry</code> 方法 优先于  <code>postProcessBeanFactory</code> 方法执行</li>
<li>实现自定义的bean注册，实现对容器的bean定义进行修改</li>
</ul>
<!-- more -->
<h2> I. 项目准备</h2>
<p>本文创建的实例工程采用<code>SpringBoot 2.2.1.RELEASE</code> + <code>maven 3.5.3</code> + <code>idea</code>进行开发</p>
<p>具体的SpringBoot项目工程创建就不赘述了，核心的pom文件，无需额外的依赖； 配置文件 <code>application.yml</code>， 也没有什么特殊的配置</p>
<p><strong>说明</strong></p>
<ul>
<li>源码工程参考文末的源码</li>
<li>虽然本文是基于 <code>2.2.1.RELEASE</code> 版本进行实测；实际上这些基础的扩展点，在更高的版本中表现也不会有太大的变动，基本上可以无修改复现</li>
</ul>
<h2> II. 自定义bean注册</h2>
<p>有关注过博主一灰灰的朋友，应该在我之前的文章中可以翻到bean的动态注册的内容，其中其实也介绍到通过<code>BeanDefinitionRegistryPostProcessor</code>来实现bean的动态注册，有兴趣的小伙伴可以翻一下，链接如下</p>
<blockquote>
<ul>
<li><a href="https://spring.hhui.top/spring-blog/2018/10/13/181013-SpringBoot%E5%9F%BA%E7%A1%80%E7%AF%87Bean%E4%B9%8B%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8C/" target="_blank" rel="noopener noreferrer">【基础系列】Bean之动态注册 | 一灰灰Blog</a></li>
</ul>
</blockquote>
<p>接下来我们开始进入正题</p>
<h3> 1. 自定义bean注册</h3>
<p>现在我们定义一个普通的bean对象，也定义了几个常见的bean初始化之后的回调方法，顺带验证两个知识点</p>
<ul>
<li>自定义注册的bean是否表现和普通的bean一致</li>
<li>初始化后的方法执行的顺序</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>再定义一个bean，构造方法依赖其他的bean</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来我们再看一下这两个bean如何进行注册</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>bean的注册从上面的代码来看比较简单，先看DemoBean的注册</p>
<p><strong>方法： <code>postProcessBeanDefinitionRegistry</code></strong></p>
<p>在这个方法中进行简单的bean注册，除了上面这个稍显复杂的注册方式之外，也可以使用更简单的策略，如下，省略掉<code>BeanDefinitionBuilder.genericBeanDefinition</code>第二个参数</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个方法内的bean注册，更适用于简单的bean对象注册，如当其构造方法依赖其他的bean时，放在这个方法中好像没辙，此时则放在第二个方法中就更合适了</p>
<p><strong>方法： <code>postProcessBeanFactory</code></strong></p>
<p>这个方法的参数是BeanFactory，可以通过它获取其他的bean对象，因此适用于DemoBeanWrapper的注册了，当然除了上面的使用姿势之外，也可以如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2.bean注册知识点</h3>
<p>单独看上面的代码可能对知识点理解不够直观清晰，那么我们就进行知识点归纳一下</p>
<p><strong>bean注册方式</strong></p>
<p>如何生成Bean的定义 <code>BeanDefinition</code> ?</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>两个方法的选择</strong></p>
<ul>
<li><code>postProcessBeanDefinitionRegistry</code> 方法执行先于 <code>postProcessBeanFactory</code></li>
<li><code>postProcessBeanDefinitionRegistry</code> 在bean实例化之前触发，可用于注册简单的自定义bean对象</li>
<li><code>postProcessBeanFactory</code>: 若bean的定义中需要依赖其他的bean对象，则放在这个方法内实现，通过BeanFactory参数获取其他bean</li>
</ul>
<h3> 3. bean定义扩展</h3>
<p>文章开头介绍了除了自定义bean之外，还可以做一些其他的操作，如针对现有的bean定义进行修改，下面给一个基础的demo，针对一个已有的bean，设置它的init方法</p>
<p>新增一个普通的bean对象</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后我们通过修改bean注册，来指定bean加载完之后，执行init方法，在前面的<code>AutoBeanDefinitionRegistryPostProcessor</code>中进行扩展</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后我们将整个项目执行以下，看下会输出些啥</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从上面的输出也可以看出，我们的几个自定义bean都被正常的加载、注入，依赖使用也没有什么问题；而且从日志输出还可以看出bean初始化后的触发方法，也有先后顺序</p>
<ul>
<li><code>@PostConstruct</code> &gt; <code>InitializingBean#afterPropertiesSet</code> &gt;  <code>init-method</code> (这个可以理解为xml定义bean中的初始化方法, @Bean注解中的initMethod)</li>
</ul>
<h3> 4. 小结</h3>
<p>最后进入大家喜闻乐见的知识点汇总环节，本文中主要介绍的是bean定义加载之后、实例化之前的扩展点<code>BeanDefinitionRegistryPostProcessor</code></p>
<h4> 4.1 知识点一：核心方法说明</h4>
<p>通过它，我们可以实现自定义的bean注册，也可以实现对现有的bean定义进行扩展修改；有两个方法</p>
<p><strong>postProcessBeanDefinitionRegistry</strong></p>
<ul>
<li>执行顺序在下面的方法之前，通常是在bean实例化之前被触发</li>
<li>适用于通用的bean注册定义</li>
</ul>
<p><strong>postProcessBeanFactory</strong></p>
<ul>
<li>其参数为BeanFactory，因此可以通过它获取Spring容器中的其他bean对象</li>
</ul>
<h4> 4.2 知识点二：bean注册</h4>
<p><strong>bean注册方式</strong></p>
<p>如何生成Bean的定义 <code>BeanDefinition</code> ?</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 4.3 知识点三：使用场景</h4>
<p>看完本文之后，勤于思考的小伙伴可能就会想，这个东西到底有啥用，有真实的应用场景么？</p>
<p><strong>自定义bean注册实例场景</strong></p>
<p>这个应用场景就非常的典型了，用过mybatis的小伙伴都知道，我们会定义一个Mapper接口，用于与对应的xml文件进行映射，那么这些mapper接口是怎么注册到Spring容器的呢？</p>
<ul>
<li>核心实现 <code>org.mybatis.spring.mapper.MapperScannerConfigurer</code></li>
<li>借助<code>BeanDefinitionRegistryPostProcessor</code>与<code>ClassPathBeanDefinitionScanner</code>来实现扫描相关的类，并注册bean</li>
</ul>
<p><strong>bean定义修改实例场景</strong></p>
<p>对于已有的bean定义进行修改，同样也有一个应用场景，在SpringCloud中，有个<code>RefreshAutoConfiguration#RefreshScopeBeanDefinitionEnhancer</code></p>
<p>它会捞出<code>HikariDataSource</code>数据源bean对象，添加<code>RefreshScope</code>的能力增强，支持配置文件的动态加载</p>
<p>从而实现数据源配置的热加载更新（不发版，直接改数据库连接池，是不是很方便？）</p>
<h4> 4.4 知识点四：bean初始化后执行方法先后顺序</h4>
<p>我们知道在bean创建之后执行某些方法有多种策略，那么不同的方式先后顺序是怎样的呢？</p>
<p>bean创建到销毁的先后执行顺序如下</p>
<ul>
<li>构造方法</li>
<li>@PostConstruct修饰的方法</li>
<li>InitializingBean接口的实现方法</li>
<li>xml/@Bean中定义的initMethod</li>
<li>@PreDestroy bean销毁前的执行方法</li>
</ul>
<h4> 其他</h4>
<p>本文为Spring扩展点系列中的第二篇，接下来的扩展知识点同样是bean定义之后，实例化之前的<code>BeanFactoryPostProcessor</code>，那么这两个究竟又有什么区别呢？ 应用场景又有什么区别呢？我是一灰灰，欢迎关注我的Spring专栏，咱们下文见</p>
<ul>
<li><a href="https://hhui.top/spring-extention/" target="_blank" rel="noopener noreferrer">一灰灰的Spring专栏</a></li>
</ul>
<h2> III. 不能错过的源码和相关知识点</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-extention/101-bean-definition" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-extention/101-bean-definition</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>Spring扩展点专栏</title>
      <link>https://liuyueyi.github.io/tutorial/spring/extend/basic/</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/extend/basic/</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">Spring扩展点专栏</source>
      <pubDate>Mon, 29 Jul 2024 08:58:55 GMT</pubDate>
    </item>
    <item>
      <title>分布式设计模式综述</title>
      <link>https://liuyueyi.github.io/tutorial/column/arch/distribute/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/01.%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%BB%BC%E8%BF%B0.html</link>
      <guid>https://liuyueyi.github.io/tutorial/column/arch/distribute/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/01.%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%BB%BC%E8%BF%B0.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">分布式设计模式综述</source>
      <description>天天说分布式分布式，那么我们是否知道什么是分布式，分布式会遇到什么问题，有哪些理论支撑，有哪些经典的应对方案，业界是如何设计并保证分布式系统的高可用呢？ 1.架构设计 这一节将从一些经典的开源系统架构设计出发，来看一下，如何设计一个高质量的分布式系统； 而一般的设计出发点，无外乎 冗余：简单理解为找个备胎，现任挂掉之后，备胎顶上 拆分：不能让一个人承担所有的重任，拆分下，每个人负担一部分，压力均摊 1.1 主备架构 给现有的服务搭建一个备用的服务，两者功能完全一致，区别在于平时只有主应用对外提供服务能力；而备应用则只需要保证与主应用能力一致，随时待机即可，并不用对外提供服务；当主应用出现故障之后，将备应用切换为主应用，原主应用下线；迅速的主备切换可以有效的缩短故障时间</description>
      <category>分布式</category>
      <category>设计模式</category>
      <pubDate>Fri, 08 Jul 2022 19:27:54 GMT</pubDate>
      <content:encoded><![CDATA[<p>天天说分布式分布式，那么我们是否知道什么是分布式，分布式会遇到什么问题，有哪些理论支撑，有哪些经典的应对方案，业界是如何设计并保证分布式系统的高可用呢？</p>
<h2> 1.架构设计</h2>
<p>这一节将从一些经典的开源系统架构设计出发，来看一下，如何设计一个高质量的分布式系统；</p>
<p>而一般的设计出发点，无外乎</p>
<ul>
<li>冗余：简单理解为找个备胎，现任挂掉之后，备胎顶上</li>
<li>拆分：不能让一个人承担所有的重任，拆分下，每个人负担一部分，压力均摊</li>
</ul>
<h3> 1.1 主备架构</h3>
<p>给现有的服务搭建一个备用的服务，两者功能完全一致，区别在于平时只有主应用对外提供服务能力；而备应用则只需要保证与主应用能力一致，随时待机即可，并不用对外提供服务；当主应用出现故障之后，将备应用切换为主应用，原主应用下线；迅速的主备切换可以有效的缩短故障时间</p>
<p>基于上面的描述，主备架构特点比较清晰</p>
<ul>
<li>采用冗余的方案，加一台备用服务</li>
<li>缺点就是资源浪费</li>
</ul>
<p>其次就是这个架构模型最需要考虑的则是如何实现主备切换？</p>
<ul>
<li>人工</li>
<li>VIP(虚拟ip) + keepalived 机制</li>
</ul>
<h3> 1.2 主从架构</h3>
<p>主从一般又叫做读写分离，主提供读写能力，而从则只提供读能力</p>
<p>鉴于当下的互联网应用，绝大多数都是读多写少的场景；读更容易成为性能瓶颈，所以采用读写分离，可以有效的提高整个集群的响应能力</p>
<p>主从架构可以区分为：一主多从 + 一主一从再多从，以mysql的主从架构模型为例进行说明</p>
<figure><img src="/imgs/column/distribute/220708/mysql03.jpg" alt="MySql主从" tabindex="0" loading="lazy"><figcaption>MySql主从</figcaption></figure>
<p>主从模式的主要特点在于</p>
<ul>
<li>添加从，源头依然是数据冗余的思想</li>
<li>读写分离：主负责读写，从只负责读，可以视为负载均衡策略</li>
<li>从需要向主同步数据，所若有的从都同步与主，对主的压力依然可能很大；所以就有了主从从的模式</li>
</ul>
<p>关键问题则在于</p>
<ul>
<li>主从延迟</li>
<li>主的写瓶颈</li>
<li>主挂之后如何选主</li>
</ul>
<h3> 1.3 多主多从架构</h3>
<p>一主多从面临单主节点的瓶颈问题，那就考虑多主多从的策略，同样是主负责提供读写，从提供读；</p>
<p>但是这里有一个核心点在于多主之间的数据同步，如何保证数据的一致性是这个架构模型的重点</p>
<p>如MySql的双主双从可以说是一个典型的应用场景，在实际使用的时候除了上面的一致性之外，还需要考虑主键id冲突的问题</p>
<h3> 1.4 普通集群模式</h3>
<p>无主节点，集群中所有的应用职能对等，没有主次之分（当下绝大多数的业务服务都属于这种），一个请求可以被集群中任意一个服务响应；</p>
<p>这种也可以叫做去中心化的设计模式，如redis的集群模式，eureka注册中心，以可用性为首要目标</p>
<p>对于普通集群模式而言，重点需要考虑的点在于</p>
<ul>
<li>资源竞争：如何确保一个资源在同一时刻只能被一个业务操作
<ul>
<li>如现在同时来了申请退款和货物出库的请求，如果不对这个订单进行加锁，两个请求同时响应，将会导致发货又退款了，导致财货两失</li>
</ul>
</li>
<li>数据一致性：如何确保所有的实例数据都是一致的，或者最终是一致的
<ul>
<li>如应用服务使用jvm缓存，那么如何确保所有实例的jvm缓存一致？</li>
<li>如Eureka的分区导致不同的分区的注册信息表不一致</li>
</ul>
</li>
</ul>
<h3> 1.5 数据分片架构</h3>
<blockquote>
<p>这个分片模型的描述可能并不准确，大家看的时候重点理解一下这个思想</p>
</blockquote>
<p>前面几个的架构中，采用的是数据冗余的方式，即所有的实例都有一个全量的数据，而这里的数据分片，则从数据拆分的思路来处理，将全量的数据，通过一定规则拆分到多个系统中，每个系统包含部分的数据，减小单个节点的压力，主要用于解决数据量大的场景</p>
<p>比如redis的集群方式，通过hash槽的方式进行分区</p>
<p>如es的索引分片存储</p>
<h3> 1.6 一灰灰的小结</h3>
<p>这一节主要从架构设计层面对当前的分布式系统所采用的方案进行了一个简单的归类与小结，并不一定全面，欢迎各位大佬留言指正</p>
<p>基于冗余的思想：</p>
<ul>
<li>主备</li>
<li>主从</li>
<li>多主多从</li>
<li>无中心集群</li>
</ul>
<p>基于拆分的思想：</p>
<ul>
<li>数据分片</li>
</ul>
<blockquote>
<p>对于拆分这一块，我们常说的分库分表也体现的是这一思想</p>
</blockquote>
<h2> 2.理论基础</h2>
<p>这一小节将介绍分布式系统中的经典理论，如广为流程的CAP/BASE理论，一致性理论基础paxios,raft，信息交换的Gossip协议，两阶段、三阶段等</p>
<p>本节主要内容参考自</p>
<ul>
<li><a href="https://cloud.tencent.com/developer/article/1662426" target="_blank" rel="noopener noreferrer">一致性算法-Gossip协议详解 - 腾讯云开发者社区-腾讯云</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/41228196" target="_blank" rel="noopener noreferrer">P2P 网络核心技术：Gossip 协议 - 知乎</a></li>
<li><a href="https://blog.51cto.com/u_15060467/2678779" target="_blank" rel="noopener noreferrer">从Paxos到Raft，分布式一致性算法解析_mb5fdb0a87e2fa1的技术博客_51CTO博客</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/338628717" target="_blank" rel="noopener noreferrer">【理论篇】浅析分布式中的 CAP、BASE、2PC、3PC、Paxos、Raft、ZAB - 知乎</a></li>
</ul>
<h3> 2.1 CAP定理</h3>
<p>CAP 定理指出，分布式系统 <strong>不可能</strong> 同时提供下面三个要求：</p>
<ul>
<li>Consistency：一致性
<ul>
<li>操作更新完成并返回客户端之后，所有节点数据完全一致</li>
</ul>
</li>
<li>Availability：可用性
<ul>
<li>服务一直可用</li>
</ul>
</li>
<li>Partition tolerance：分区容错性
<ul>
<li>分布式系统在遇到某节点或网络分区故障的时候，仍然能够对外提供满足<strong>一致性</strong>和<strong>可用性</strong>的服务</li>
</ul>
</li>
</ul>
<p>通常来讲P很难不保证，当服务部署到多台实例上时，节点异常、网络故障属于常态，根据不同业务场景进行选择</p>
<p>对于服务有限的应用而言，首选AP，保证高可用，即使部分机器异常，也不会导致整个服务不可用；如绝大多数的前台应用都是这种</p>
<p>对于数据一致性要求高的场景，如涉及到钱的支付结算，CP可能更重要了</p>
<p>对于CAP的三种组合说明如下</p>
<table>
<thead>
<tr>
<th>选择</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>CA</td>
<td>放弃分区容错性，加强一致性和可用性，其实就是传统的单机场景</td>
</tr>
<tr>
<td>AP</td>
<td>放弃一致性（这里说的一致性是强一致性），追求分区容错性和可用性，这是很多分布式系统设计时的选择，例如很多NoSQL系统就是如此</td>
</tr>
<tr>
<td>CP</td>
<td>放弃可用性，追求一致性和分区容错性，基本不会选择，网络问题会直接让整个系统不可用</td>
</tr>
</tbody>
</table>
<h3> 2.2 BASE理论</h3>
<p>base理论作为cap的延伸，其核心特点在于放弃强一致性，追求最终一致性</p>
<ul>
<li>Basically Available: 基本可用
<ul>
<li>指分布式系统在出现故障的时候，允许损失部分可用性，即保证核心可用</li>
<li>如大促时降级策略</li>
</ul>
</li>
<li>Soft State：软状态
<ul>
<li>允许系统存在中间状态，而该中间状态不会影响系统整体可用性</li>
<li>MySql异步方式的主从同步，可能导致的主从数据不一致</li>
</ul>
</li>
<li>Eventual Consistency：最终一致性
<ul>
<li>最终一致性是指系统中的所有数据副本经过一定时间后，最终能够达到一致的状态</li>
</ul>
</li>
</ul>
<p>基于上面的描述，可以看到BASE理论适用于大型高可用可扩展的分布式系统</p>
<p>注意其不同于ACID的强一致性模型，而是通过牺牲强一致性 来获得可用性，并允许数据在一段时间内是不一致的，但最终达到一致状态</p>
<h3> 2.3 PACELEC 定理</h3>
<blockquote>
<p>这个真没听说过，以下内容来自:</p>
<ul>
<li><a href="https://medium.com/@nishantparmar/distributed-system-design-patterns-2d20908fecfc" target="_blank" rel="noopener noreferrer">Distributed System Design Patterns | by Nishant | Medium</a></li>
</ul>
</blockquote>
<ul>
<li>如果有一个分区（'P'），分布式系统可以在可用性和一致性（即'A'和'C'）之间进行权衡;</li>
<li>否则（'E'），当系统在没有分区的情况下正常运行时，系统可以在延迟（'L'）和一致性（'C'）之间进行权衡。</li>
</ul>
<figure><img src="/imgs/column/distribute/220708/peace.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>定理（PAC）的第一部分与CAP定理相同，ELC是扩展。整个论点假设我们通过复制来保持高可用性。因此，当失败时，CAP定理占上风。但如果没有，我们仍然必须考虑复制系统的一致性和延迟之间的权衡。</p>
<h3> 2.4 Paxos共识算法</h3>
<blockquote>
<p>Paxos算法解决的问题是分布式共识性问题，即一个分布式系统中的各个进程如何就某个值（决议）通过共识达成一致</p>
</blockquote>
<p>基于上面这个描述，可以看出它非常适用于选举；其工作流程</p>
<ul>
<li>一个或多个提议进程 (Proposer) 可以发起提案 (Proposal)，</li>
<li>Paxos算法使所有提案中的某一个提案，在所有进程中达成一致。 系统中的多数派同时认可该提案，即达成了一致</li>
</ul>
<p>角色划分:</p>
<ul>
<li>Proposer: 提出提案Proposal，包含编号 + value</li>
<li>Acceptor: 参与决策，回应Proposers的提案；当一个提案，被半数以上的Acceptor接受，则该提案被批准
<ul>
<li>每个acceptor只能批准一个提案</li>
</ul>
</li>
<li>Learner: 不参与决策，获取最新的提案value</li>
</ul>
<h3> 2.5 Raft算法</h3>
<blockquote>
<p>推荐有兴趣的小伙伴，查看</p>
<ul>
<li><a href="http://thesecretlivesofdata.com/raft/" target="_blank" rel="noopener noreferrer">Raft 算法动画演示</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/32052223" target="_blank" rel="noopener noreferrer">Raft算法详解 - 知乎</a></li>
</ul>
</blockquote>
<p>为了解决paxos的复杂性，raft算法提供了一套更易理解的算法基础，其核心流程在于：</p>
<p>leader接受请求，并转发给follow，当大部分follow响应之后，leader通知所有的follow提交请求、同时自己也提交请求并告诉调用方ok</p>
<p>角色划分：</p>
<ul>
<li>Leader：领导者，接受客户端请求，并向Follower同步请求，当数据同步到大多数节点上后告诉Follower提交日志</li>
<li>Follow: 接受并持久化Leader同步的数据，在Leader告之日志可以提交之后，提交</li>
<li>Candidate：Leader选举过程中的临时角色，向其他节点拉选票，得到多数的晋升为leader，选举完成之后不存在这个角色</li>
</ul>
<figure><img src="/imgs/column/distribute/220708/raft03.jpg" alt="raft共识流程" tabindex="0" loading="lazy"><figcaption>raft共识流程</figcaption></figure>
<h3> 2.6 ZAB协议</h3>
<blockquote>
<p>ZAB(Zookeeper Atomic Broadcast) 协议是为分布式协调服务ZooKeeper专门设计的一种支持崩溃恢复的一致性协议，基于该协议，ZooKeeper 实现了一种 主从模式的系统架构来保持集群中各个副本之间的数据一致性。</p>
<ul>
<li><a href="https://segmentfault.com/a/1190000037550497" target="_blank" rel="noopener noreferrer">zookeeper核心之ZAB协议就这么简单！</a></li>
</ul>
</blockquote>
<p>主要用于zk的数据一致性场景，其核心思想是Leader再接受到事务请求之后，通过给Follower，当半数以上的Follower返回ACK之后，Leader提交提案，并向Follower发送commit信息</p>
<p><strong>角色划分</strong></p>
<ul>
<li>Leader: 负责整个Zookeeper 集群工作机制中的核心
<ul>
<li>事务请求的唯一调度和处理者，保证集群事务处理的顺序性</li>
<li>集群内部各服务器的调度者</li>
</ul>
</li>
<li>Follower：Leader的追随者
<ul>
<li>处理客户端的非实物请求，转发事务请求给 Leader 服务器</li>
<li>参与事务请求 Proposal 的投票</li>
<li>参与 Leader 选举投票</li>
</ul>
</li>
<li>Observer：是 zookeeper 自 3.3.0 开始引入的一个角色，
<ul>
<li>它不参与事务请求 Proposal 的投票，</li>
<li>也不参与 Leader 选举投票</li>
<li>只提供非事务的服务（查询），通常在不影响集群事务处理能力的前提下提升集群的非事务处理能力。</li>
</ul>
</li>
</ul>
<figure><img src="/imgs/column/distribute/220708/zab00.jpg" alt="ZAB消息广播" tabindex="0" loading="lazy"><figcaption>ZAB消息广播</figcaption></figure>
<h3> 2.7 2PC协议</h3>
<blockquote>
<p>two-phase commit protocol，两阶段提交协议，主要是为了解决强一致性，中心化的强一致性协议</p>
</blockquote>
<p><strong>角色划分</strong></p>
<ul>
<li>协调节点(coordinator)：中心化</li>
<li>参与者节点(partcipant)：多个</li>
</ul>
<p><strong>执行流程</strong></p>
<p>协调节点接收请求，然后向参与者节点提交 <code>precommit</code>，当所有的参与者都回复ok之后，协调节点再给所有的参与者节点提交<code>commit</code>，所有的都返回ok之后，才表明这个数据确认提交</p>
<p>当第一个阶段，有一个参与者失败，则所有的参与者节点都回滚</p>
<figure><img src="/imgs/column/distribute/220708/2pc00.jpg" alt="2pc流程" tabindex="0" loading="lazy"><figcaption>2pc流程</figcaption></figure>
<p><strong>特点</strong></p>
<p>优点在于实现简单</p>
<p>缺点也很明显</p>
<ul>
<li>协调节点的单点故障</li>
<li>第一阶段全部ack正常，第二阶段存在部分参与者节点异常时，可能出现不一致问题</li>
</ul>
<h3> 2.8 3PC协议</h3>
<blockquote>
<p><a href="https://segmentfault.com/a/1190000012534071" target="_blank" rel="noopener noreferrer">分布式事务：两阶段提交与三阶段提交 - SegmentFault 思否</a></p>
</blockquote>
<p>在两阶段的基础上进行扩展，将第一阶段划分两部，cancommit + precommit，第三阶段则为 docommit</p>
<p><strong>第一阶段 cancommit</strong></p>
<p>该阶段协调者会去询问各个参与者是否能够正常执行事务，参与者根据自身情况回复一个预估值，相对于真正的执行事务，这个过程是轻量的</p>
<p><strong>第二阶段 precommit</strong></p>
<p>本阶段协调者会根据第一阶段的询盘结果采取相应操作，若所有参与者都返回ok，则协调者向参与者提交事务执行(单不提交)通知；否则通知参与者abort回滚</p>
<p><strong>第三阶段 docommit</strong></p>
<p>如果第二阶段事务未中断，那么本阶段协调者将会依据事务执行返回的结果来决定提交或回滚事务，若所有参与者正常执行，则提交；否则协调者+参与者回滚</p>
<p>在本阶段如果因为协调者或网络问题，导致参与者迟迟不能收到来自协调者的 commit 或 rollback 请求，那么参与者将不会如两阶段提交中那样陷入阻塞，而是等待超时后继续 commit，相对于两阶段提交虽然降低了同步阻塞，但仍然无法完全避免数据的不一致</p>
<p><strong>特点</strong></p>
<ul>
<li>降低了阻塞与单点故障：
<ul>
<li>参与者返回 CanCommit 请求的响应后，等待第二阶段指令，若等待超时/协调者宕机，则自动 abort，降低了阻塞；</li>
<li>参与者返回 PreCommit 请求的响应后，等待第三阶段指令，若等待超时/协调者宕机，则自动 commit 事务，也降低了阻塞；</li>
</ul>
</li>
<li>数据不一致问题依然存在
<ul>
<li>比如第三阶段协调者发出了 abort 请求，然后有些参与者没有收到 abort，那么就会自动 commit，造成数据不一致</li>
</ul>
</li>
</ul>
<h3> 2.9 Gossip协议</h3>
<blockquote>
<p>Gossip 协议，顾名思义，就像流言蜚语一样，利用一种随机、带有传染性的方式，将信息传播到整个网络中，并在一定时间内，使得系统内的所有节点数据一致。Gossip 协议通过上面的特性，可以保证系统能在极端情况下（比如集群中只有一个节点在运行）也能运行</p>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/41228196" target="_blank" rel="noopener noreferrer">P2P 网络核心技术：Gossip 协议 - 知乎</a></li>
</ul>
</blockquote>
<p>主要用在分布式数据库系统中各个副本节点同步数据之用，这种场景的一个最大特点就是组成的网络的节点都是对等节点，是非结构化网络</p>
<p><strong>工作流程</strong></p>
<ul>
<li>周期性的传播消息，通常周期时间为1s</li>
<li>被感染的节点，随机选择n个相邻节点，传播消息</li>
<li>每次传播消息都选择还没有发送过的节点进行传播</li>
<li>收单消息的节点，不会传播给向它发送消息的节点</li>
</ul>
<figure><img src="/imgs/column/distribute/220708/gossip.gif" alt="Gossip传播示意图" tabindex="0" loading="lazy"><figcaption>Gossip传播示意图</figcaption></figure>
<p><strong>特点</strong></p>
<ul>
<li>扩展性：允许节点动态增加、减少，新增的节点状态最终会与其他节点一致</li>
<li>容错：网络中任意一个节点宕机重启都不会影响消息传播</li>
<li>去中心化：不要求中心节点，所有节点对等，任何一个节点无需知道整个网络状况，只要网络连通，则一个节点的消息最终会散播到整个网络</li>
<li>一致性收敛：协议中的消息会以一传十、十传百一样的指数级速度在网络中快速传播，因此系统状态的不一致可以在很快的时间内收敛到一致。消息传播速度达到了 logN</li>
<li>简单：Gossip 协议的过程极其简单，实现起来几乎没有太多复杂性</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>消息延迟：节点只会随机向少数几个节点发送消息，消息最终是通过多个轮次的散播而到达全网的，因此使用 Gossip 协议会造成不可避免的消息延迟</li>
<li>消息冗余：节点会定期随机选择周围节点发送消息，而收到消息的节点也会重复该步骤，导致消息的冗余</li>
</ul>
<h3> 2.10 一灰灰的小结</h3>
<p>本节主要介绍的是分布式系统设计中的一些常见的理论基石，如分布式中如何保障一致性，如何对一个提案达成共识</p>
<ul>
<li>BASE，CAP，PACELEC理论：构建稳定的分布式系统应该考虑的方向</li>
<li>paxos,raft共识算法</li>
<li>zab一致性协议</li>
<li>gossip消息同步协议</li>
</ul>
<h2> 3.算法</h2>
<p>这一节将主要介绍下分布式系统中的经典的算法，比如常用于分区的一致性hash算法，适用于一致性的Quorum NWR算法，PBFT拜占庭容错算法，区块链中大量使用的工作量证明PoW算法等</p>
<h3> 3.1 一致性hash算法</h3>
<p>一致性hash算法，主要应用于数据分片场景下，有效降低服务的新增、删除对数据复制的影响</p>
<p>通过对数据项的键进行哈希处理映射其在环上的位置，然后顺时针遍历环以查找位置大于该项位置的第一个节点，将每个由键标识的数据分配给hash环中的一个节点</p>
<figure><img src="/imgs/column/distribute/220708/hash.jpg" alt="一致性hash算法" tabindex="0" loading="lazy"><figcaption>一致性hash算法</figcaption></figure>
<p>一致散列的主要优点是增量稳定性; 节点添加删除，对整个集群而言，仅影响其直接邻居，其他节点不受影响。</p>
<p><strong>注意：</strong></p>
<ul>
<li>redis集群实现了一套hash槽机制，其核心思想与一致性hash比较相似</li>
</ul>
<h3> 3.2 Quorum NWR算法</h3>
<blockquote>
<p>用来保证数据冗余和最终一致性的投票算法，其主要数学思想来源于鸽巢原理</p>
<ul>
<li><a href="https://developer.aliyun.com/article/53498" target="_blank" rel="noopener noreferrer">分布式系统之Quorum （NRW）算法-阿里云开发者社区</a></li>
</ul>
</blockquote>
<ul>
<li>N 表示副本数，又叫做复制因子（Replication Factor）。也就是说，N 表示集群中同一份数据有多少个副本</li>
<li>W，又称写一致性级别（Write Consistency Level），表示成功完成 W 个副本更新写入，才会视为本次写操作成功</li>
<li>R 又称读一致性级别（Read Consistency Level），表示读取一个数据对象时需要读 R 个副本, 才会视为本次读操作成功</li>
</ul>
<p>Quorum NWR算法要求每个数据拷贝对象 都可以投1票，而每一个操作的执行则需要获取最小的读票数，写票数；通常来讲写票数W一般需要超过N/2，即我们通常说的得到半数以上的票才表示数据写入成功</p>
<p>事实上当W=N、R=1时，即所谓的WARO(Write All Read One)。就是CAP理论中CP模型的场景</p>
<h3> 3.3 PBFT拜占庭算法</h3>
<p>拜占庭算法主要针对的是分布式场景下无响应，或者响应不可信的情况下的容错问题，其核心分三段流程，如下</p>
<figure><img src="/imgs/column/distribute/220708/bzt.jpg" alt="拜占庭算法" tabindex="0" loading="lazy"><figcaption>拜占庭算法</figcaption></figure>
<p>假设集群节点数为 N，f个故障节点(无响应)和f个问题节点(无响应或错误响应),f+1个正常节点，即 3f+1=n</p>
<ul>
<li>客户端向主节点发起请求，主节点接受请求之后，向其他节点广播 pre-prepare 消息</li>
<li>节点接受pre-prepare消息之后，若同意请求，则向其他节点广播 prepare 消息；</li>
<li>当一个节点接受到2f+1个prepare新消息，则进入commit阶段，并广播commit消息</li>
<li>当收到 2f+1 个 commit 消息后（包括自己），代表大多数节点已经进入 commit 阶段，这一阶段已经达成共识，于是节点就会执行请求，写入数据</li>
</ul>
<p>相比 Raft 算法完全不适应有人作恶的场景，PBFT 算法能容忍 (n 1)/3 个恶意节点 (也可以是故障节点)。另外，相比 PoW 算法，PBFT 的优点是不消耗算 力。PBFT 算法是O(n ^ 2) 的消息复杂度的算法，所以以及随着消息数 的增加，网络时延对系统运行的影响也会越大，这些都限制了运行 PBFT 算法的分布式系统 的规模，也决定了 PBFT 算法适用于中小型分布式系统</p>
<h3> 3.4 PoW算法</h3>
<p>工作量证明 (Proof Of Work，简称 PoW)，同样应用于分布式下的一致性场景，区别于前面的raft, pbft, paxos采用投票机制达成共识方案，pow采用工作量证明</p>
<p>客户端需要做一定难度的工作才能得出一个结果，验证方却很容易通过结果来检查出客户端是不是做了相应的工作，通过消耗一定工作浪，增加消息伪造的成本，PoW以区块链中广泛应用而广为人知，下面以区块链来简单说一下PoW的算法应用场景</p>
<p>以BTC的转账为例，A转n个btc给B，如何保证不会同时将这n个币转给C？</p>
<ul>
<li>A转账给B，交易信息记录在一个区块1中</li>
<li>A转账给C，交易信息被记录在另一个区块2中</li>
<li>当区块1被矿工成功提交到链上，并被大多数认可（通过校验区块链上的hash值验证是否准确，而这个hash值体现的是矿工的工作量），此时尚未提交的区块2则会被抛弃</li>
<li>若区块1被提交，区块2也被提交，各自有部分人认可，就会导致分叉，区块链中采用的是优选最长的链作为主链，丢弃分叉的部分（这就属于区块链的知识点了，有兴趣的小伙伴可以扩展下相关知识点，这里就不展开了）</li>
</ul>
<p>PoW的算法，主要应用在上面的区块提交验证，通过hash值计算来消耗算力，以此证明矿工确实有付出，得到多数认可的可以达成共识</p>
<h3> 3.5 一灰灰的小结</h3>
<p>本节主要介绍了下当前分布式下常见的算法，</p>
<ul>
<li>分区的一致性hash算法: 基于hash环，减少节点动态增加减少对整个集群的影响；适用于数据分片的场景</li>
<li>适用于一致性的Quorum NWR算法: 投票算法，定义如何就一个提案达成共识</li>
<li>PBFT拜占庭容错算法: 适用于集群中节点故障、或者不可信的场景</li>
<li>区块链中大量使用的工作量证明PoW算法: 通过工作量证明，认可节点的提交</li>
</ul>
<h2> 4.技术思想</h2>
<p>这一节的内容相对前面几个而言，并不太容易进行清晰的分类；主要包含一些高质量的分布式系统的实践中，值得推荐的设计思想、技术细节</p>
<h3> 4.1 CQRS</h3>
<blockquote>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/115685384" target="_blank" rel="noopener noreferrer">DDD 中的那些模式 — CQRS - 知乎</a></li>
<li><a href="https://www.infoq.cn/article/wdlpjosudoga34jutys9" target="_blank" rel="noopener noreferrer">详解CQRS架构模式_架构_Kislay Verma_InfoQ精选文章</a></li>
</ul>
</blockquote>
<p>Command Query Responsibility Segregation 即我们通俗理解的读写分离，其核心思想在于将两类不同操作进行分离，在独立的服务中实现</p>
<figure><img src="/imgs/column/distribute/220708/cqrs.jpg" alt="cqrs" tabindex="0" loading="lazy"><figcaption>cqrs</figcaption></figure>
<p>用途在于将领域模型与查询功能进行分离，让一些复杂的查询摆脱领域模型的限制，以更为简单的 DTO 形式展现查询结果。同时分离了不同的数据存储结构，让开发者按照查询的功能与要求更加自由的选择数据存储引擎</p>
<h3> 4.2 复制负载平衡服务</h3>
<blockquote>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/34191846" target="_blank" rel="noopener noreferrer">分布式系统设计:服务模式之复制负载平衡服务 - 知乎</a></li>
<li><a href="https://www.runoob.com/w3cnote/balanced-algorithm.html" target="_blank" rel="noopener noreferrer">负载均衡调度算法大全 | 菜鸟教程</a></li>
</ul>
</blockquote>
<p>复制负载平衡服务(Replication Load Balancing Service, RLBS)，可以简单理解为我们常说的负载均衡，多个相同的服务实例构建一个集群，每个服务都可以响应请求，负载均衡器负责请求的分发到不同的实例上，常见的负载算法</p>
<table>
<thead>
<tr>
<th>算法</th>
<th>说明</th>
<th>特点</th>
</tr>
</thead>
<tbody>
<tr>
<td>轮询</td>
<td>请求按照顺序依次分发给对应的服务器</td>
<td>优点简单，缺点在于未考虑不同服务器的实际性能情况</td>
</tr>
<tr>
<td>加权轮询</td>
<td>权重高的被分发更多的请求</td>
<td>优点：充分利用机器的性能</td>
</tr>
<tr>
<td>最少连接数</td>
<td>找连接数最少的服务器进行请求分发,若所有服务器相同的连接数，则找第一个选择的</td>
<td>目的是让优先让空闲的机器响应请求</td>
</tr>
<tr>
<td>少连接数慢启动时间</td>
<td>刚启动的服务器，在一个时间段内，连接数是有限制且缓慢增加</td>
<td>避免刚上线导致大量的请求分发过来而超载</td>
</tr>
<tr>
<td>加权最少连接</td>
<td>平衡服务性能 + 最少连接数</td>
<td></td>
</tr>
<tr>
<td>基于代理的自适应负载均衡</td>
<td>载主机包含一个自适用逻辑用来定时监测服务器状态和该服务器的权重</td>
<td></td>
</tr>
<tr>
<td>源地址哈希法</td>
<td>获取客户端的IP地址，通过哈希函映射到对应的服务器</td>
<td>相同的来源请求都转发到相同的服务器上</td>
</tr>
<tr>
<td>随机</td>
<td>随机算法选择一台服务器</td>
<td></td>
</tr>
<tr>
<td>固定权重</td>
<td>最高权重只有在其他服务器的权重值都很低时才使用。然而，如果最高权重的服务器下降，则下一个最高优先级的服务器将为客户端服务</td>
<td>每个真实服务器的权重需要基于服务器优先级来配置</td>
</tr>
<tr>
<td>加权响应</td>
<td>服务器响应越小其权重越高，通常是基于心跳来判断机器的快慢</td>
<td>心跳的响应并不一定非常准确反应服务情况</td>
</tr>
</tbody>
</table>
<h3> 4.3 心跳机制</h3>
<p>在分布式环境里中，如何判断一个服务是否存活，当下最常见的方案就是心跳</p>
<p>比如raft算法中的leader向所有的follow发送心跳，表示自己还健在，避免发生新的选举；</p>
<p>比如redis的哨兵机制，也是通过ping/pong的心跳来判断节点是否下线，是否需要选新的主节点；</p>
<p>再比如我们日常的业务应用得健康监测，判断服务是否正常</p>
<h3> 4.4 租约机制</h3>
<p>租约就像一个锁，但即使客户端离开，它也能工作。客户端请求有限期限的租约，之后租约到期。如果客户端想要延长租约，它可以在租约到期之前续订租约。</p>
<p>租约主要是了避免一个资源长久被某个对象持有，一旦对方挂了且不会主动释放的问题；在实际的场景中，有两个典型的应用</p>
<p><strong>case1 分布式锁</strong></p>
<p>业务获取的分布式锁一般都有一个有效期，若有效期内没有主动释放，这个锁依然会被释放掉，其他业务也可以抢占到这把锁；因此对于持有锁的业务方而言，若发现在到期前，业务逻辑还没有处理完，则可以续约，让自己继续持有这把锁</p>
<p>典型的实现方式是redisson的看门狗机制</p>
<p><strong>case2 raft算法的任期</strong></p>
<p>在raft算法中，每个leader都有一个任期，任期过后会重新选举，而Leader为了避免重新选举，一般会定时发送心跳到Follower进行续约</p>
<h3> 4.5 Leader &amp; Follow</h3>
<p>这个比较好理解，上面很多系统都采用了这种方案，特别是在共识算法中，由领导者负责代表整个集群做出决策，并将决策传播到所有其他服务器</p>
<p>领导者选举在服务器启动时进行。每个服务器在启动时都会启动领导者选举，并尝试选举领导者。除非选出领导者，否则系统不接受任何客户端请求</p>
<h3> 4.6 Fencing</h3>
<p>在领导者-追随者模式中，当领导者失败时，不可能确定领导者已停止工作，如慢速网络或网络分区可能会触发新的领导者选举，即使前一个领导者仍在运行并认为它仍然是活动的领导者</p>
<p>Fencint是指在以前处于活动状态的领导者周围设置围栏，使其无法访问集群资源，从而停止为任何读/写请求提供服务</p>
<ul>
<li>资源屏蔽：系统会阻止以前处于活动状态的领导者访问执行基本任务所需的资源。</li>
<li>节点屏蔽：系统会阻止以前处于活动状态的领导者访问所有资源。执行此操作的常见方法是关闭节点电源或重置节点。</li>
</ul>
<h3> 4.7 Quorum法定人数</h3>
<p>法定人数，常见于选举、共识算法中，当超过Quorum的节点数确认之后，才表示这个提案通过(数据更新成功)，通常这个法定人数为 = 半数节点 + 1</p>
<h3> 4.8 High-Water mark高水位线</h3>
<p>高水位线，跟踪Leader（领导者）上的最后一个日志条目，且该条目已成功复制到&gt;quorum（法定人数）的Follow（跟谁者），即表示这个日志被整个集群接受</p>
<p>日志中此条目的索引称为高水位线索引。领导者仅公开到高水位线索引的数据。</p>
<p>如Kafka：为了处理非可重复读取并确保数据一致性，Kafka broker会跟踪高水位线，这是特定分区的最大偏移量。使用者只能看到高水位线之前的消息。</p>
<h3> 4.9 Phi 累计故障检测</h3>
<p>Phi Accrual Failure Detection,使用历史检测信号信息使阈值自适应</p>
<p>通用的应计故障检测器不会判断服务器是否处于活动状态，而是输出有关服务器的可疑级别。</p>
<p>如Cassandra（Facebook开源的分布式NoSql数据库）使用 Phi 应计故障检测器算法来确定群集中节点的状态</p>
<h3> 4.10 Write-ahead Log预写日志</h3>
<p>预写日志记录是解决操作系统中文件系统不一致的问题的高级解决方案，当我们提交写到操作系统的文件缓存，此时业务会认为已经提交成功；但是在文件缓存与实际写盘之间会有一个时间差，若此时机器宕机，会导致缓存中的数据丢失，从而导致完整性缺失</p>
<p>为了解决这个问题，如mysql，es等都采用了预写日志的机制来避免这个问题</p>
<p>MySql：</p>
<ul>
<li>事务提交的流程中，先写redolog precommit， 然后写binlog，最后再redolog commit；当redolog记录成功之后，才表示事务执行成功；</li>
<li>因此当出现上面的宕机恢复时，则会加载redologo，然后重放对应的命令，来恢复未持久化的数据</li>
</ul>
<p>ElasticSearch:</p>
<ul>
<li>在内存中数据生成段写到操作系统文件缓存前，会先写事务日志，出现异常时，也是从事务日志进行恢复</li>
</ul>
<h3> 4.11 分段日志</h3>
<p>将日志拆分为多个较小的文件，而不是单个大文件，以便于操作。</p>
<p>单个日志文件在启动时读取时可能会增长并成为性能瓶颈。较旧的日志会定期清理，并且很难对单个大文件执行清理操作。</p>
<p>单个日志拆分为多个段。日志文件在指定的大小限制后滚动。使用日志分段，需要有一种将逻辑日志偏移量（或日志序列号）映射到日志段文件的简单方法。</p>
<p>这个其实也非常常见，比如我们实际业务应用配置的log，一般都是按天、固定大小进行拆分，并不会把所有的日志都放在一个日志文件中</p>
<p>再比如es的分段存储，一个段就是一个小的存储文件</p>
<h3> 4.12 checksum校验</h3>
<p>在分布式系统中，在组件之间移动数据时，从节点获取的数据可能会损坏。</p>
<p>计算校验和并将其与数据一起存储。</p>
<p>要计算校验和，请使用 MD5、SHA-1、SHA-256 或 SHA-512 等加密哈希函数。哈希函数获取输入数据并生成固定长度的字符串（包含字母和数字）;此字符串称为校验和。</p>
<p>当系统存储某些数据时，它会计算数据的校验和，并将校验和与数据一起存储。当客户端检索数据时，它会验证从服务器接收的数据是否与存储的校验和匹配。如果没有，则客户端可以选择从另一个副本检索该数据。</p>
<p>HDFS和Chubby将每个文件的校验和与数据一起存储。</p>
<h3> 4.13 一灰灰的小结</h3>
<p>这一节很多内容来自下面这篇博文，推荐有兴趣的小伙伴查看原文</p>
<ul>
<li><a href="https://medium.com/@nishantparmar/distributed-system-design-patterns-2d20908fecfc" target="_blank" rel="noopener noreferrer">Distributed System Design Patterns | by Nishant | Medium</a></li>
</ul>
<p>这一节主要简单的介绍了下分布式系统中应用到的一些技术方案，如有对其中某个技术有兴趣的小伙伴可以留言，后续会逐一进行补全</p>
<h2> 5.分布式系统解决方案</h2>
<p>最后再介绍一些常见的分布式业务场景及对应的解决方案，比如全局唯一的递增ID-雪花算法，分布式系统的资源抢占-分布式锁，分布式事务-2pc/3pc/tcc ，分布式缓存等</p>
<h3> 5.1 缓存</h3>
<p>缓存实际上并不是分布式独有的，这里把它加进来，主要是因为实在是应用得太广了，无论是应用服务、基础软件工具还是操作系统，大量都可以见到缓存的身影</p>
<p>缓存的核心思想在于： 借助更高效的IO方式，来替代代价昂贵的IO方式</p>
<p>如：</p>
<ul>
<li>redis的性能高于mysql</li>
<li>如内存的读写，远高于磁盘IO，文件IO</li>
<li>磁盘顺序读写 &gt; 随机读写</li>
</ul>
<p>用好缓存可以有效提高应用性能，下面以一个普通的java前台应用为例说明</p>
<ul>
<li>JVM缓存 -&gt; 分布式缓存(redis/memcache) -&gt; mysql缓存 -&gt; 操作系统文件缓存 -&gt; 磁盘文件</li>
</ul>
<p>缓存面临的核心问题，则在于</p>
<ul>
<li>一致性问题：缓存与db的一致性如何保障（相信大家都听说过或者实际处理过这种问题）</li>
<li>数据完整性：比如常见的先写缓存，异步刷新到磁盘，那么缓存到磁盘刷新这段时间内，若宕机导致数据丢失怎么办？
<ul>
<li>TIP: 上面这个问题可以参考mysql的redolog</li>
</ul>
</li>
</ul>
<h3> 5.2 全局唯一ID</h3>
<p>在传统的单体架构中，业务id基本上是依赖于数据库的自增id来处理；当我们进入分布式场景时，如我们常说的分库分表时，就需要我们来考虑如何实现全局唯一的业务id了，避免出现在分表中出现冲突</p>
<p>全局唯一ID解决方案：</p>
<ul>
<li>uuid</li>
<li>数据库自增id表</li>
<li>redis原子自增命令</li>
<li>雪花算法 (原生的，扩展的百度UidGenerator, 美团Leaf等)</li>
<li>Mist 薄雾算法</li>
</ul>
<h3> 5.3 分布式锁</h3>
<p>常用于分布式系统中资源控制，只有持有锁的才能继续操作，确保同一时刻只会有一个实例访问这个资源</p>
<p>常见的分布式锁有</p>
<ul>
<li>基于数据库实现分布式锁</li>
<li><a href="https://hhui.top/spring-db/09.%E5%AE%9E%E4%BE%8B/20.201030-springboot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8Bredis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%BA%94%E7%94%A8%E7%AF%87/" target="_blank" rel="noopener noreferrer">Redis实现分布式锁（应用篇） | 一灰灰Learning</a></li>
<li><a href="https://hhui.top/spring-middle/03.zookeeper/02.210415-springboot%E6%95%B4%E5%90%88zookeeper%E4%BB%8E0%E5%88%B01%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/" target="_blank" rel="noopener noreferrer">从0到1实现一个分布式锁 | 一灰灰Learning</a></li>
<li>etcd实现分布式锁</li>
<li>基于consul实现分布式锁</li>
</ul>
<h3> 5.4 分布式事务</h3>
<p>事务表示一组操作，要么全部成功，要么全部不成功；单机事务通常说的是数据库的事务；而分布式事务，则可以简单理解为多个数据库的操作，要么同时成功，要么全部不成功</p>
<p>更确切一点的说法，分布式事务主要是要求事务的参与方，可能涉及到多个系统、多个数据资源，要求它们的操作要么都成功，要么都回滚；</p>
<p>一个简单的例子描述下分布式事务场景：</p>
<p><strong>下单扣库存</strong></p>
<ul>
<li>用户下单，付钱</li>
<li>此时订单服务，会生成订单信息</li>
<li>支付网关，会记录付款信息，成功or失败</li>
<li>库存服务，扣减对应的库存</li>
</ul>
<p>一个下单支付操作，涉及到三个系统，而分布式事务则是要求，若支付成功，则上面三个系统都应该更新成功；若有一个操作失败，如支付失败，则已经扣了库存的要回滚（还库存），生成的订单信息回滚（删掉--注：现实中并不会去删除订单信息，这里只是用于说明分布式事务，请勿带入实际的实现方案）</p>
<p>分布式事务实现方案：</p>
<ul>
<li>2PC: 前面说的两阶段提交，就是实现分布式事务的一个经典解决方案</li>
<li>3PC: 三阶段提交</li>
<li>TCC：补偿事务，简单理解为应用层面的2PC</li>
<li>SAGA事务</li>
<li>本地消息表</li>
<li>MQ事务方案</li>
</ul>
<h3> 5.5 分布式任务</h3>
<p>分布式任务相比于我们常说单机的定时任务而言，可以简单的理解为多台实例上的定时任务，从应用场景来说，可以区分两种</p>
<ul>
<li>互斥性的分布式任务
<ul>
<li>即同一时刻，集群内只能有一个实例执行这个任务</li>
</ul>
</li>
<li>并存式的分布式任务
<ul>
<li>同一时刻，所有的实例都可以执行这个任务</li>
<li>续考虑如何避免多个任务操作相同的资源</li>
</ul>
</li>
</ul>
<p>分布式任务实现方案：</p>
<ul>
<li>Quartz Cluster</li>
<li>XXL-Job</li>
<li>Elastic-Job</li>
<li>自研：
<ul>
<li>资源分片策略</li>
<li>分布式锁控制的唯一任务执行策略</li>
</ul>
</li>
</ul>
<h3> 5.6 分布式Session</h3>
<blockquote>
<p>Session一般叫做会话，Session技术是http状态保持在服务端的解决方案，它是通过服务器来保持状态的。我们可以把客户端浏览器与服务器之间一系列交互的动作称为一个 Session。是服务器端为客户端所开辟的存储空间，在其中保存的信息就是用于保持状态。因此，session是解决http协议无状态问题的服务端解决方案，它能让客户端和服务端一系列交互动作变成一个完整的事务。</p>
</blockquote>
<p>单机基于session/cookie来实现用户认证，那么在分布式系统的多实例之间，如何验证用户身份呢？这个就是我们说的分布式session</p>
<p>分布式session实现方案：</p>
<ul>
<li>session stick：客户端每次请求都转发到同一台服务器(如基于ip的hash路由转发策略）</li>
<li>session复制: session生成之后，主动同步给其他服务器</li>
<li>session集中保存：用户信息统一存储，每次需要时统一从这里取(也就是常说的redis实现分布式session方案)</li>
<li>cookie: 使用客户端cookie存储session数据，每次请求时携带这个</li>
</ul>
<h3> 5.7 分布式链路追踪</h3>
<p>分布式链路追踪也可以叫做全链路追中，而它可以说是每个开发者的福音，通常指的是一次前端的请求，将这个请求过程中，所有涉及到的系统、链路都串联起来，可以清晰的知道这一次请求中，调用了哪些服务，有哪些IO交互，瓶颈点在哪里，什么地方抛出了异常</p>
<p>当前主流的全链路方案大多是基于google的<code>Dapper</code> 论文实现的</p>
<p>全链路实现方案</p>
<ul>
<li>zipkin</li>
<li>pinpoint</li>
<li>SkyWalking</li>
<li>CAT</li>
<li>jaeger</li>
</ul>
<h3> 5.8 布隆过滤器</h3>
<p>Bloom过滤器是一种节省空间的概率数据结构，用于测试元素是否为某集合的成员。</p>
<p>布隆过滤器由一个长度为 m 比特的位数组（bit array）与 k 个哈希函数（hash function）组成的数据结构。</p>
<p>原理是当一个元素被加入集合时，通过 K 个散列函数将这个元素映射成一个位数组中的 K 个点，把它们置为 1。</p>
<p>检索时，我们只要看看这些点是不是都是 1 就大约知道集合中有没有它了，也就是说，如果这些点有任何一个 0 ，则被检元素一定不在；如果都是 1 ，则被检元素很可能在。</p>
<p>关于布隆过滤器，请牢记一点</p>
<ul>
<li>判定命中的，不一定真的命中</li>
<li>判定没有命中的，则一定不在里面</li>
</ul>
<figure><img src="/imgs/column/distribute/220708/bloom-filter.png" alt="布隆过滤器" tabindex="0" loading="lazy"><figcaption>布隆过滤器</figcaption></figure>
<p>常见的应用场景，如</p>
<ul>
<li>防止缓存穿透</li>
<li>爬虫时重复检测</li>
</ul>
<h3> 5.9 一灰灰的小结</h3>
<p>分布式系统的解决方案当然不局限于上面几种，比如分布式存储、分布式计算等也属于常见的场景，当然在我们实际的业务支持过程中，不太可能需要让我们自己来支撑这种大活；而上面提到的几个点，基本上或多或少会与我们日常工作相关，这里列出来当然是好为了后续的详情做铺垫</p>
<h2> 6.一灰灰的总结</h2>
<h3> 6.1 综述</h3>
<p>这是一篇概括性的综述类文章，可能并没有很多的干货，当然也限于“一灰灰”我个人的能力，上面的总结可能并不准确，如有发现，请不吝赐教</p>
<p>全文总结如下</p>
<p>常见的分布式架构设计方案：</p>
<ul>
<li>主备，主从，多主多从，普通无中心集群，数据分片架构</li>
</ul>
<p>分布式系统中的理论基石：</p>
<ul>
<li>CAP， BASE, PACELEC</li>
<li>共识算法：paxos, raft, zab</li>
<li>一致性协议：2pc, 3pc</li>
<li>数据同步：gossip</li>
</ul>
<p>分布式系统中的算法：</p>
<ul>
<li>分区的一致性hash算法: 基于hash环，减少节点动态增加减少对整个集群的影响；适用于数据分片的场景</li>
<li>适用于一致性的Quorum NWR算法: 投票算法，定义如何就一个提案达成共识</li>
<li>PBFT拜占庭容错算法: 适用于集群中节点故障、或者不可信的场景</li>
<li>区块链中大量使用的工作量证明PoW算法: 通过工作量证明，认可节点的提交</li>
</ul>
<p>分布式系统解决方案：</p>
<ul>
<li>分布式缓存</li>
<li>全局唯一ID</li>
<li>分布式锁</li>
<li>分布式事务</li>
<li>分布式任务</li>
<li>分布式会话</li>
<li>分布式链路追踪</li>
<li>布隆过滤器</li>
</ul>
<h3> 6.2 题外话</h3>
<p>最后总结一下这篇耗时两周写完的“心血巨作”（有点自吹了哈），准备这篇文章确实花了很大的精力，首先我个人对于分布式这块的理解并不能算深刻，其次分布式这块的理论+实践知识特别多，而且并不是特别容易上手理解，在输出这篇文章的同时，遇到一些疑问点我也会去查阅相关资料去确认，整个过程并不算特别顺利； 那么为什么还要去做这个事情呢？</p>
<ol>
<li>咸鱼太久了，想做一些有意思的东西，活跃一下大脑</li>
<li>准备依托于《分布式专栏》来将自己的知识体系进行归纳汇总，让零散分布在大脑中的知识点能有一个脉络串联起来</li>
<li>不想做架构的码农不是好码农，而想成为一个好的架构，当然得做一些基础准备，向业务精品学习取经</li>
</ol>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/column/distribute/220708/mysql03.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>分布式系统的8个谬误</title>
      <link>https://liuyueyi.github.io/tutorial/column/arch/distribute/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/02.%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%848%E4%B8%AA%E8%B0%AC%E8%AF%AF.html</link>
      <guid>https://liuyueyi.github.io/tutorial/column/arch/distribute/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/02.%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%848%E4%B8%AA%E8%B0%AC%E8%AF%AF.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">分布式系统的8个谬误</source>
      <description>你在分布式系统上工作吗？微服务，Web API，SOA，Web服务器，应用服务器，数据库服务器，缓存服务器，负载均衡器 - 如果这些描述了系统设计中的组件，那么答案是肯定的。分布式系统由许多计算机组成，这些计算机协调以实现共同的目标。 20多年前，Peter Deutsch和James Gosling定义了分布式计算的8个谬误。这些是许多开发人员对分布式系统做出的错误假设。从长远来看，这些通常被证明是错误的，导致难以修复错误。 8个谬误是： 网络可靠。 延迟为零。 带宽是无限的。 网络是安全的。 拓扑不会改变。 有一个管理员。 运输成本为零。 网络是同质的。</description>
      <category>分布式</category>
      <category>设计模式</category>
      <pubDate>Thu, 14 Jul 2022 07:27:54 GMT</pubDate>
      <content:encoded><![CDATA[<p>你在分布式系统上工作吗？微服务，Web API，SOA，Web服务器，应用服务器，数据库服务器，缓存服务器，负载均衡器 - 如果这些描述了系统设计中的组件，那么答案是肯定的。分布式系统由许多计算机组成，这些计算机协调以实现共同的目标。</p>
<p>20多年前，Peter Deutsch和James Gosling定义了分布式计算的8个谬误。这些是许多开发人员对分布式系统做出的错误假设。从长远来看，这些通常被证明是错误的，导致难以修复错误。</p>
<p>8个谬误是：</p>
<ol>
<li>网络可靠。</li>
<li>延迟为零。</li>
<li>带宽是无限的。</li>
<li>网络是安全的。</li>
<li>拓扑不会改变。</li>
<li>有一个管理员。</li>
<li>运输成本为零。</li>
<li>网络是同质的。</li>
</ol>
<p>让我们来看看每个谬误，讨论问题和潜在的解决方案。</p>
<h2> 1.网络可靠</h2>
<h3> 问题</h3>
<blockquote>
<p>通过网络呼叫将失败。</p>
</blockquote>
<p>今天的大多数系统都会调用其他系统。您是否正在与第三方系统（支付网关，会计系统，CRM）集成？你在做网络服务电话吗？如果呼叫失败会发生什么？如果您要查询数据，则可以进行简单的重试。但是如果您发送命令会发生什么？我们举一个简单的例子：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>如果我们收到HTTP超时异常会怎么样？如果服务器没有处理请求，那么我们可以重试。但是，如果它确实处理了请求，我们需要确保我们不会对客户进行双重收费。您可以通过使服务器具有幂等性来实现此目的。这意味着如果您使用相同的收费请求拨打10次，则客户只需支付一次费用。如果您没有正确处理这些错误，那么您的系统是不确定的。处理所有这些情况可能会非常复杂。</p>
<h3> 解决方案</h3>
<p>因此，如果网络上的呼叫失败，我们能做什么？好吧，我们可以自动重试。排队系统非常擅长这一点。它们通常使用称为存储和转发的模式。它们在将消息转发给收件人之前在本地存储消息。如果收件人处于脱机状态，则排队系统将重试发送邮件。MSMQ是这种排队系统的一个例子。</p>
<p>但是这种变化将对您的系统设计产生重大影响。您正在从请求/响应模型转移到触发并忘记。由于您不再等待响应，因此您需要更改系统中的用户行程。您不能只使用队列发送替换每个Web服务调用。</p>
<h3> 结论</h3>
<p>你可能会说网络现在更可靠 - 而且它们是。但事情发生了。硬件和软件可能会出现故障 - 电源，路由器，更新或补丁失败，无线信号弱，网络拥塞，啮齿动物或鲨鱼。是的，鲨鱼：在一系列鲨鱼叮咬之后，谷歌正在加强与Kevlar的海底数据线。</p>
<p>还有人为因素。人们可以开始DDOS攻击，也可以破坏物理设备。</p>
<p>这是否意味着您需要删除当前的技术堆栈并使用消息传递系统？并不是的！您需要权衡失败的风险与您需要进行的投资。您可以通过投资基础架构和软件来最小化失败的可能性。在许多情况下，失败是一种选择。但在设计分布式系统时，您确实需要考虑失败的问题。</p>
<h2> 2.延迟是零</h2>
<h3> 问题</h3>
<blockquote>
<p>通过网络拨打电话不是即时的。</p>
</blockquote>
<p>内存呼叫和互联网呼叫之间存在七个数量级的差异。您的应用程序应该是网络感知。这意味着您应该清楚地将本地呼叫与远程呼叫分开。让我们看看我在代码库中看到的一个例子：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>没有进一步检查，这看起来很好。但是，有两个远程呼叫。第2行进行一次调用以获取文档摘要列表。在第5行，还有另一个调用，它检索有关每个文档的更多信息。这是一个经典的Select n + 1问题。为了解决网络延迟问题，您应该在一次调用中返回所有必需的数据。一般的建议是本地调用可以细粒度，但远程调用应该更粗粒度。这就是为什么分布式对象和网络透明度的想法死了。但是，即使每个人都同意分布式对象是一个坏主意，有些人仍然认为延迟加载总是一个好主意：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>您不希望财产获取者进行网络呼叫。但是，每个。 在上面的代码中调用实际上可以触发数据库之旅。</p>
<h3> 解决方案</h3>
<h4> 带回您可能需要的所有数据</h4>
<p>如果您进行远程呼叫，请确保恢复可能需要的所有数据。网络通信不应该是唠叨的。</p>
<h4> 将Data Closer移动到客户端</h4>
<p>另一种可能的解决方案是将数据移近客户端。如果您正在使用云，请根据客户的位置仔细选择可用区。缓存还可以帮助最小化网络呼叫的数量。对于静态内容，内容交付网络（CDN）是另一个不错的选择。</p>
<h4> 反转数据流</h4>
<p>删除远程调用的另一个选项是反转数据流。我们可以使用Pub / Sub并在本地存储数据，而不是查询其他服务。这样，我们就可以在需要时获取数据。当然，这会带来一些复杂性，但它可能是工具箱中的一个很好的工具。</p>
<h3> 结论</h3>
<p>虽然延迟可能不是LAN中的问题，但当您转移到WAN或Internet时，您会注意到延迟。这就是为什么将网络呼叫与内存中的呼叫明确分开是很重要的。在采用微服务架构模式时，您应该牢记这一点。您不应该只使用远程调用替换本地呼叫。这可能会使你的系统变成分布式的大泥球。</p>
<h2> 3.带宽是无限的</h2>
<h3> 问题</h3>
<blockquote>
<p>带宽是有限的。</p>
</blockquote>
<p>带宽是网络在一段时间内发送数据的容量。到目前为止，我还没有发现它是一个问题，但我可以看到为什么它在某些条件下可能是一个问题。虽然带宽随着时间的推移而有所改善，但我们发送的数据量也有所增加。与通过网络传递简单DTO的应用相比，视频流或VoIP需要更多带宽。带宽对于移动应用程序来说更为重要，因此开发人员在设计后端API时需要考虑它。</p>
<p>错误地使用ORM也会造成伤害。我见过开发人员在查询中过早调用.ToList（）的示例，因此在内存中加载整个表。</p>
<h3> 解决方案</h3>
<h4> 领域驱动的设计模式</h4>
<p>那么我们怎样才能确保我们不会带来太多数据呢？域驱动设计模式可以帮助：</p>
<ul>
<li>首先，您不应该争取单一的企业级域模型。您应该将域划分为有界上下文。</li>
<li>要避免有界上下文中的大型复杂对象图，可以使用聚合模式。聚合确保一致性并定义事务边界。</li>
</ul>
<h4> 命令和查询责任隔离</h4>
<p>我们有时会加载复杂的对象图，因为我们需要在屏幕上显示它的一部分。如果我们在很多地方这样做，我们最终会得到一个庞大而复杂的模型，对于写作和阅读来说都是次优的。另一种方法可以是使用命令和查询责任隔离 - CQRS。这意味着将域模型分为两部分：</p>
<ul>
<li>在写模式将确保不变保持真实的数据是一致的。由于写模型不关心视图问题，因此可以保持较小且集中。</li>
<li>该读取模型是视图的担忧进行了优化，所以我们可以获取所有所需的特定视图中的数据（例如，我们的应用程序的屏幕）。</li>
</ul>
<h3> 结论</h3>
<p>在第二个谬误（延迟不是0）和第三个谬误（带宽是无限的）之间有延伸，您应该传输更多数据，以最大限度地减少网络往返次数。您应该传输较少的数据以最小化带宽使用。您需要平衡这两种力量，并找到通过线路发送的_正确_数据量。</p>
<p>虽然您可能不会经常遇到带宽限制，但考虑传输的数据非常重要。更少的数据更容易理解。数据越少意味着耦合越少。因此，只传输您可能需要的数据。</p>
<h2> 4.网络是安全的</h2>
<h3> 问题</h3>
<blockquote>
<p>网络并不安全。</p>
</blockquote>
<p>这是一个比其他人更多的媒体报道的假设。您的系统仅与最薄弱的链接一样安全。坏消息是分布式系统中有很多链接。您正在使用HTTPS，除非与不支持它的第三方遗留系统进行通信。您正在查看自己的代码，寻找安全问题，但正在使用可能存在风险的开源库。一个OpenSSL的漏洞允许人们通过盗取SSL / TLS保护的数据。Apache Struts中的一个错误允许攻击者在服务器上执行代码。即使你正在抵御所有这些，仍然存在人为因素。恶意DBA可能错放数据库备份。今天的攻击者掌握着大量的计算能力和耐心。所以问题不在于他们是否会攻击你的系统，而是什么时候。</p>
<h3> 解决方案</h3>
<h4> 深度防御</h4>
<p>您应该使用分层方法来保护您的系统。您需要在网络，基础架构和应用程序级别进行不同的安全检查。</p>
<h4> 安全心态</h4>
<p>在设计系统时要牢记安全性。十大漏洞列表在过去5年中没有发生太大变化。您应遵循安全软件设计的最佳实践，并检查常见安全漏洞的代码。您应该定期搜索第三方库以查找新漏洞。常见漏洞和暴露列表可以提供帮助。</p>
<h4> 威胁建模</h4>
<p>威胁建模是一种识别系统中可能存在的安全威胁的系统方法。首先确定系统中的所有资产（数据库中的用户数据，文件等）以及如何访问它们。之后，您可以识别可能的攻击并开始执行它们。我建议阅读高级API安全性的第2章，以便更好地概述威胁建模。</p>
<h3> 结论</h3>
<p>唯一安全的系统是关闭电源的系统，不连接到任何网络（理想情况下是在一个有形模块中）。它是多么有用的系统！事实是，安全是艰难而昂贵的。分布式系统中有许多组件和链接，每个组件和链接都是恶意用户的可能目标。企业需要平衡攻击的风险和概率与实施预防机制的成本。</p>
<p>攻击者手上有很多耐心和计算能力。我们可以通过使用威胁建模来防止某些类型的攻击，但我们无法保证100％的安全性。因此，向业务部门明确表示这一点是个好主意，共同决定投资安全性的程度，并制定安全漏洞何时发生的计划。</p>
<h2> 5.拓扑不会改变</h2>
<h3> 问题</h3>
<blockquote>
<p>网络拓扑不断变化。</p>
</blockquote>
<p>网络拓扑始终在变化。有时它会因意外原因而发生变化 - 当您的应用服务器出现故障并需要更换时。很多时候它是故意的 - 在新服务器上添加新进程。如今，随着云和容器的增加，这一点更加明显。弹性扩展 - 根据工作负载添加或删除服务器的能力 - 需要一定程度的网络灵活性。</p>
<h3> 解决方案</h3>
<h4> 摘要网络的物理结构</h4>
<p>您需要做的第一件事是抽象网络的物理结构。有几种方法可以做到这一点：</p>
<ul>
<li>停止硬编码IP - 您应该更喜欢使用主机名。通过使用URI，我们依靠DNS将主机名解析为IP。</li>
<li>当DNS不够时（例如，当您需要映射IP和端口时），则使用发现服务。</li>
<li>Service Bus框架还可以提供位置透明性。</li>
</ul>
<h4> 无价值的，而非重要的</h4>
<p>通过将您的服务器视为没有价值的，而不是很重要的，您确保没有服务器是不可替代的。这一点智慧可以帮助您进入正确的思维模式：任何服务器都可能出现故障（从而改变拓扑结构），因此您应该尽可能地自动化。</p>
<h4> 测试</h4>
<p>最后一条建议是测试你的假设。停止服务或关闭服务器，看看您的系统是否仍在运行。像Netflix的Chaos Monkey这样的工具可以通过随机关闭生产环境中的VM或容器来实现这一目标。通过带来痛苦，您更有动力构建一个可以处理拓扑更改的更具弹性的系统。</p>
<h3> 结论</h3>
<p>十年前，大多数拓扑结构并没有经常改变。但是当它发生时，它可能发生在生产中并引入了一些停机时间。如今，随着云和容器的增加，很难忽视这种谬误。你需要为失败做好准备并进行测试。不要等到它在生产中发生！</p>
<h2> 6.有一位管理员</h2>
<h3> 问题</h3>
<blockquote>
<p>这个知道一切的并不存在。</p>
</blockquote>
<p>嗯，这个看起来很明显。当然，没有一个人知道一切。这是一个问题吗？只要应用程序运行顺利，它就不是。但是，当出现问题时，您需要修复它。因为很多人触摸了应用程序，知道如何解决问题的人可能不在那里。</p>
<p>有很多事情可能会出错。一个例子是配置。今天的应用程序在多个商店中存储配置：配置文件，环境变量，数据库，命令行参数。没有人知道每个可能的配置值的影响是什么。</p>
<p>另一件可能出错的事情是系统升级。分布式应用程序有许多移动部件，您需要确保它们是同步的。例如，您需要确保当前版本的代码适用于当前版本的数据库。如今，人们关注DevOps和持续交付。但支持零停机部署并非易事。</p>
<p>但是，至少这些东西都在你的控制之下。许多应用程序与第三方系统交互。这意味着，如果它们失效，你可以做的事情就不多了。因此，即使您的系统有一名管理员，您仍然无法控制第三方系统。</p>
<h3> 解决方案</h3>
<h4> 每个人都应对释放过程负责</h4>
<p>这意味着从一开始就涉及Ops人员或系统管理员。理想情况下，他们将成为团队的一员。尽早让系统管理员了解您的进度可以帮助您发现限制因素。例如，生产环境可能具有与开发环境不同的配置，安全限制，防火墙规则或可用端口。</p>
<h4> 记录和监控</h4>
<p>系统管理员应该拥有用于错误报告和管理问题的正确工具。你应该从一开始就考虑监控。分布式系统应具有集中式日志。访问十个不同服务器上的日志以调查问题是不可接受的方法。</p>
<h4> 解耦</h4>
<p>您应该在系统升级期间争取最少的停机时间。这意味着您应该能够独立升级系统的不同部分。通过使组件向后兼容，您可以在不同时间更新服务器和客户端。</p>
<p>通过在组件之间放置队列，您可以暂时将它们分离。这意味着，例如，即使后端关闭，Web服务器仍然可以接受请求。</p>
<h4> 隔离第三方依赖关系</h4>
<p>您应该以不同于您拥有的组件的方式处理控制之外的系统。这意味着使您的系统更能适应第三方故障。您可以通过引入抽象层来减少外部依赖的影响。这意味着当第三方系统出现故障时，您将找到更少的地方来查找错误。</p>
<h3> 结论</h3>
<p>要解决这个谬论，您需要使系统易于管理。DevOps，日志记录和监控可以提供帮助。您还需要考虑系统的升级过程。如果升级需要数小时的停机时间，则无法部署每个sprint。没有一个管理员，所以每个人都应该对发布过程负责。</p>
<h2> 7.运输成本为零</h2>
<h3> 问题</h3>
<blockquote>
<p>运输成本_不是_零。</p>
</blockquote>
<p>这种谬论与第二个谬误有关，即 延迟为零。通过网络传输内容在时间和资源上都有代价。如果第二个谬误讨论了时间方面，那么谬误＃7就会解决资源消耗问题。</p>
<p>这种谬论有两个不同的方面：</p>
<h4> 网络基础设施的成本</h4>
<p>网络基础设施需要付出代价。服务器，SAN，网络交换机，负载平衡器以及负责此设备的人员 - 所有这些都需要花钱。如果您的系统是在内部部署的，那么您需要预先支付这个价格。如果您正在使用云，那么您只需为您使用的内容付费，但您仍然需要付费。</p>
<h4> 序列化/反序列化的成本</h4>
<p>这种谬误的第二个方面是在传输级别和应用程序级别之间传输数据的成本。序列化和反序列化会消耗CPU时间，因此需要花钱。如果您的应用程序是内部部署的，那么如果您不主动监视资源消耗，则会隐藏此成本。但是，如果您的应用程序部署在云端，那么这笔费用就会非常明显，因为您需要为使用的内容付费。</p>
<h3> 解决方案</h3>
<p>关于基础设施的成本，你无能为力。您只能确保尽可能高效地使用它。SOAP或XML比JSON更昂贵。JSON比像Google的Protocol Buffers这样的二进制协议更昂贵。根据系统的类型，这可能或多或少重要。例如，对于与视频流或VoIP有关的应用，传输成本更为重要。</p>
<h3> 结论</h3>
<p>您应该注意运输成本以及应用程序正在执行的序列化和反序列化程度。这并不意味着您应该优化，除非需要它。您应该对资源消耗进行基准测试和监控，并确定运输成本是否对您有用。</p>
<h2> 8.网络是同质的</h2>
<h3> 问题</h3>
<blockquote>
<p>网络_不是_同质的。</p>
</blockquote>
<p>同质网络是使用类似配置和相同通信协议的计算机网络。拥有类似配置的计算机是一项艰巨的任务。例如，您几乎无法控制哪些移动设备可以连接到您的应用。这就是为什么重点关注标准协议。</p>
<h3> 解决方案</h3>
<p>您应该选择标准格式以避免供应商锁定。这可能意味着XML，JSON或协议缓冲区。有很多选择可供选择。</p>
<h3> 结论</h3>
<p>您需要确保系统的组件可以相互通信。使用专有协议会损害应用程序的互操作性。</p>
<h2> 设计分布式系统很难</h2>
<p>这些谬论发表于20多年前。但他们今天仍然坚持，其中一些比其他人更多。我认为今天许多开发人员都知道它们，但我们编写的代码并没有显示出来。</p>
<p>我们必须接受这些事实：网络不可靠，不安全并且需要花钱。带宽有限。网络的拓扑结构将发生变化。其组件的配置方式不同。意识到这些限制将有助于我们设计更好的分布式系统。</p>
<h2> 参考文章</h2>
<p>原文标题 <a href="https://dzone.com/articles/understanding-the-8-fallacies-of-distributed-syste" target="_blank" rel="noopener noreferrer">《Understanding the 8 Fallacies of Distributed Systems》</a></p>
<p>作者：Victor Chircu</p>
<p>译者：February</p>
<p>译文： <a href="https://cloud.tencent.com/developer/article/1370391" target="_blank" rel="noopener noreferrer">https://cloud.tencent.com/developer/article/1370391</a></p>
]]></content:encoded>
    </item>
    <item>
      <title>什么是分布式系统</title>
      <link>https://liuyueyi.github.io/tutorial/column/arch/distribute/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/03.%E4%BB%80%E4%B9%88%E6%98%AF%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F.html</link>
      <guid>https://liuyueyi.github.io/tutorial/column/arch/distribute/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/03.%E4%BB%80%E4%B9%88%E6%98%AF%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">什么是分布式系统</source>
      <description>分布式的概念存在年头有点久了，在正式进入我们《分布式专栏》之前，感觉有必要来聊一聊，什么是分布式，分布式特点是什么，它又有哪些问题，在了解完这个概念之后，再去看它的架构设计，理论奠基可能帮助会更大 本文将作为专栏的第0篇，将从三个方面来讲述一下我理解的&amp;quot;分布式系统&amp;quot; 分布式系统的特点 分布式系统面临的挑战 如何衡量一个分布式系统 1.分布式系统特点 什么是分布式系统，看一下wiki上的描述 1.1 定义 分布式系统（distributed system）是建立在网络之上的软件系统。正是因为软件的特性，所以分布式系统具有高度的内聚性和透明性。因此，网络和分布式系统之间的区别更多的在于高层软件（特别是操作系统），而不是硬件</description>
      <category>分布式</category>
      <category>设计模式</category>
      <pubDate>Sat, 13 Aug 2022 19:27:54 GMT</pubDate>
      <content:encoded><![CDATA[<p>分布式的概念存在年头有点久了，在正式进入我们《分布式专栏》之前，感觉有必要来聊一聊，什么是分布式，分布式特点是什么，它又有哪些问题，在了解完这个概念之后，再去看它的架构设计，理论奠基可能帮助会更大</p>
<p>本文将作为专栏的第0篇，将从三个方面来讲述一下我理解的"分布式系统"</p>
<ul>
<li>分布式系统的特点</li>
<li>分布式系统面临的挑战</li>
<li>如何衡量一个分布式系统</li>
</ul>
<h2> 1.分布式系统特点</h2>
<p>什么是分布式系统，看一下wiki上的描述</p>
<h3> 1.1 定义</h3>
<p>分布式系统（distributed system）是建立在网络之上的软件系统。正是因为软件的特性，所以分布式系统具有高度的内聚性和透明性。因此，网络和分布式系统之间的区别更多的在于高层软件（特别是操作系统），而不是硬件</p>
<ul>
<li><a href="https://baike.baidu.com/item/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/4905336" target="_blank" rel="noopener noreferrer">分布式系统（建立在网络之上的软件系统）_百度百科</a></li>
</ul>
<p>分布式操作系统（Distributed operating system），是一种软件，它是许多独立的，网络连接的，通讯的，并且物理上分离的计算节点的集合[1]。每个节点包含全局总操作系统的一个特定的软件子集。每个软件子集是两个不同的服务置备的复合物[2]。第一个服务是一个普遍存在的最小的内核，或微内核，直接控制该节点的硬件。第二个服务是协调节点的独立的和协同的活动系统管理组件的更高级别的集合。这些组件抽象微内核功能，和支持用户应用程序[3]。</p>
<ul>
<li><a href="https://zh.m.wikipedia.org/zh-hans/%E5%88%86%E5%B8%83%E5%BC%8F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F" target="_blank" rel="noopener noreferrer">分布式操作系统 - 维基百科，自由的百科全书</a></li>
</ul>
<p>Distributed system: is a system in which components located on networked computers communicate and coordinate their actions by passing messages. The components interact with each other in order to achieve a common goal[3].</p>
<ul>
<li><a href="https://computersciencewiki.org/index.php/Distributed_systems" target="_blank" rel="noopener noreferrer">Distributed systems - Computer Science Wiki</a></li>
</ul>
<p>虽然上面几个描述不完全相同，但是含义其实也差不了太多；基于我个人的理解，用大白话来描述一下分布式系统，就是“一个系统的服务能力，由网络上多个节点共同提供”，正如其名的“分布一词”</p>
<p>在了解完分布式系统的概念之后，接下来抓住其主要特点，来加深这个分布式的理解</p>
<h3> 1.2 分布性</h3>
<p>分布式系统分布在多个节点（可以理解为多个计算机），这些节点可以是网络上任意的一台计算机，即在空间上没有原则性的限制</p>
<h3> 1.3 对等性</h3>
<p>分布式系统中有很多的节点，这些节点之间没有主从、优劣直说，它们应该是对等的，从服务能力来说，访问分布式系统中的任何一个节点，整个服务请求应该都是等价的</p>
<p>看到这里可能就会有一个疑问了，分布式系统中经典主从架构，数据拆分架构，就不满足这个对等特性了啊（这个问题先留着，后续再详情中进行解答）</p>
<h3> 1.4 自治性</h3>
<p>分布式系统中的各个节点都有自己的计算能力，各自具有独立的处理数据的功能。通常，彼此在地位上是平等的，无主次之分，既能自治地进行工作，又能利用共享的通信线路来传送信息，协调任务处理。</p>
<h3> 1.5 并发性</h3>
<p>分布式系统既然存在多个节点，那么天然就存在多个节点的同事响应请求的能力，即并发性支持，如何做好分布式系统的并发控制则是所有分布式系统需要解决的一个问题</p>
<h2> 2. 分布式系统面临的问题</h2>
<p>当系统分布在多个节点之上时，自然而然就带来了很多单机场景下不会有问题，如经典的 <a href="https://hhui.top/%E5%88%86%E5%B8%83%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/02.%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%848%E4%B8%AA%E8%B0%AC%E8%AF%AF/" target="_blank" rel="noopener noreferrer">分布式系统的8个谬误 | 一灰灰Learning</a></p>
<h3> 2.1 全局时钟</h3>
<p>分布式系统的多个节点，如何保证每个节点的时钟一致？这个是需要重点考虑的问题</p>
<p>我们知道大名鼎鼎的分布式主键生成算法 “雪花算法” 就是利用了机器时钟来作为算法因子，如果一个系统的多个节点不能保证时钟统一，那这个算法的唯一性将无法得到保障</p>
<h3> 2.2 网络延迟、异常</h3>
<p>网络是有开销的，多个节点之间的通信是有成本的，既然存在网络的开销、或异常状况，那么如何保证多个节点的数据一致性呢？ 当无法保证数据的一致性时，如何提供分布式系统的对等性呢？</p>
<p>在经典的CAP理论中，对于P（网络分区）一般都是需要保障的，一个系统存在多个计算节点，那么网络问题将不可避免，网络分区必然会存在</p>
<h3> 2.3 数据一致性</h3>
<p>如何保证所有节点中的数据完全一致是一个巨大的挑战，这个问题比较好理解，我们操作分布式系统中的一个节点实现数据修改，如果要保证数据一致性，则要求所有的节点，同步收到这个修改</p>
<p>但是我们需要注意的时，网络是不可靠的，且网络的传输是存在延迟的，如何衡量数据的一致性和服务的可用性则是我们在设计一个分布式系统中需要取舍的</p>
<h3> 2.4 节点异常</h3>
<p>机器宕机属于不可抗力因素，如果分布式系统中的一个节点宕机了，整个系统会怎么样？要如何确保机器宕机也不会影响系统的可用性呢？ 机器恢复之后，又应该如何保证数据的一致性呢？ 又应该如何判断一个节点是否正常呢？</p>
<h3> 2.5 资源竞争</h3>
<p>前面说到分布式系统天然支持并发，那么随之而来的问题则是如何资源竞争的问题；当一个资源同一时刻只允许一个实例访问时，怎么处理？多个系统同时访问一个资源是否会存在数据版本差异性（如经典的ABA问题）、数据一致性问题？</p>
<p>基于这个问题，分布式锁可以说是应运而生，相信各位开发大佬都不会陌生这个知识点</p>
<h3> 2.6 全局协调</h3>
<p>这个协调怎么理解呢？ 举几个简单的实例</p>
<ul>
<li>如何判断分布式系统中那些节点正常提供服务，那些节点故障</li>
<li>如一个任务希望在分布式系统中只执行一次，那么应该哪个节点执行这个任务呢？</li>
<li>如一组有先后顺序的请求发送给分布式系统，但是由于网络问题，可能出现后面的请求先被系统接收到，这种场景怎么处理呢？</li>
<li>一个用户已经登录，如何在所有节点中确认他的身份呢？</li>
</ul>
<h3> 2.7 一灰灰的小结</h3>
<p>实际上分布式系统面临的挑战并不止于上面这些，一个具体的系统面临的问题可能各不相同，但总的来说，分布式系统的理论基础会给我们非常好的指引方向，这一节推荐查看 * <a href="https://hhui.top/%E5%88%86%E5%B8%83%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/01.%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%BB%BC%E8%BF%B0/" target="_blank" rel="noopener noreferrer">分布式设计模式综述 | 一灰灰Learning</a></p>
<h2> 3. 分布式系统的衡量指标</h2>
<p>最后再来看一下如何衡量一个分布式系统的“好差”，它的指标有哪些</p>
<h3> 3.1 性能指标</h3>
<p>常见的性能指标如rt, QPS, TPS来判断一个系统的承载能力，重点关注是哪个要点</p>
<ul>
<li>响应延迟</li>
<li>并发能力</li>
<li>事务处理能力</li>
</ul>
<h3> 3.2 可用性</h3>
<p>这个就是传说中你的系统达到几个9的那个指标，即系统的异常时间占总的可用时间的比例</p>
<p>统的可用性可以用系统停服务的时间与正常服务的时间的比例来衡量，也可以用某功能的失败次数与成功次数的比例来衡量。可用性是分布式的重要指标，衡量了系统的鲁棒性，是系统容错能力的体现。</p>
<h3> 3.3 扩展性</h3>
<p>系统的可扩展性(scalability)指分布式系统通过扩展集群机器规模提高系统性能（吞吐、延迟、并发）、存储容量、计算能力的特性</p>
<p>最简单来讲，就是你的系统能不能直接加机器，来解决性能瓶颈，如果能加机器，有没有上限（如由于数据库的连接数限制了机器的数量上限， 如机器加到某个程度之后，服务能力没有明显提升）</p>
<h3> 3.4 一致性</h3>
<p>分布式系统为了提高可用性，总是不可避免的使用副本的机制，从而引发副本一致性的问题。越是强的一致的性模型，对于用户使用来说使用起来越简单</p>
<h2> 4. 总结</h2>
<p>这一篇文章相对来说比较干燥，全是文字描述，介绍下什么是分布式系统，分布系统的特点及面对的问题和衡量指标，提炼一下关键要素，如下</p>
<p>分布式系统的特点</p>
<ul>
<li>分布性</li>
<li>对等性</li>
<li>并发性</li>
<li>自治性</li>
</ul>
<p>分布式系统面临的挑战</p>
<ul>
<li>全局时钟</li>
<li>网络延迟、异常</li>
<li>数据一致性</li>
<li>节点异常</li>
<li>资源竞争</li>
<li>全局协调</li>
</ul>
<p>分布式系统衡量指标</p>
<ul>
<li>性能指标</li>
<li>可用性</li>
<li>扩展性</li>
<li>一致性</li>
</ul>
<p>最后强烈推荐阅读下面两个万字干货</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247487507&amp;idx=1&amp;sn=9c4ff02747e8335ee5e3c7765cc80b3c&amp;chksm=fce70bbfcb9082a9a8d972af80f19a9b66a5425c949bc400872727cc2da9f401047a5a523ac4&amp;token=1624762777&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">1w5字详细介绍分布式系统的38个技术方案</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247487533&amp;idx=1&amp;sn=cd07d5d601986fd3911858ea5f3a18d4&amp;chksm=fce70b81cb908297fe66eac564028a6c7ef197f8f10921c4dfe05cf8d433b5ee45566099e467&amp;token=1624762777&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">基于MySql,Redis,Mq,ES的高可用方案解析</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>分布式常用的设计模式</title>
      <link>https://liuyueyi.github.io/tutorial/column/arch/distribute/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link>
      <guid>https://liuyueyi.github.io/tutorial/column/arch/distribute/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">分布式常用的设计模式</source>
      <description>分布式系统的设计与实现过程中，常用到的一些协议和设计模式介绍，本专题将作为分布式的理论知识科普，为各位看官打开视野 主要内容将包含并不限于以下内容： 如CAP、BASE，gossip协议 如主从、切片、热备、Leader选举策略等 如一致性hash、布隆过滤器、全局自增序列号、心跳机制等 分布式设计模式综述 分布式系统的8个谬误 什么是分布式系统</description>
      <pubDate>Mon, 29 Jul 2024 08:58:55 GMT</pubDate>
      <content:encoded><![CDATA[<p>分布式系统的设计与实现过程中，常用到的一些协议和设计模式介绍，本专题将作为分布式的理论知识科普，为各位看官打开视野</p>
<p>主要内容将包含并不限于以下内容：</p>
<ul class="task-list-container">
<li>
<p>如CAP、BASE，gossip协议</p>
</li>
<li>
<p>如主从、切片、热备、Leader选举策略等</p>
</li>
<li>
<p>如一致性hash、布隆过滤器、全局自增序列号、心跳机制等</p>
</li>
<li class="task-list-item">
<p><input type="checkbox" class="task-list-item-checkbox" id="task-item-0" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-0"> <a href="01.%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%BB%BC%E8%BF%B0">分布式设计模式综述</a></label></p>
</li>
<li class="task-list-item">
<p><input type="checkbox" class="task-list-item-checkbox" id="task-item-1" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-1"> <a href="02.%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%848%E4%B8%AA%E8%B0%AC%E8%AF%AF">分布式系统的8个谬误</a></label></p>
</li>
<li class="task-list-item">
<p><input type="checkbox" class="task-list-item-checkbox" id="task-item-2" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-2"> <a href="03.%E4%BB%80%E4%B9%88%E6%98%AF%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F">什么是分布式系统</a></label></p>
</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>01.常见的高可用技术方案</title>
      <link>https://liuyueyi.github.io/tutorial/column/arch/distribute/%E9%AB%98%E5%8F%AF%E7%94%A8/01.%E5%B8%B8%E8%A7%81%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88.html</link>
      <guid>https://liuyueyi.github.io/tutorial/column/arch/distribute/%E9%AB%98%E5%8F%AF%E7%94%A8/01.%E5%B8%B8%E8%A7%81%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">01.常见的高可用技术方案</source>
      <description>大家好我是一灰灰，本文将接着前文 1w5字详细介绍分布式系统的那些技术方案 文章基础上，进行实际的案例解析</description>
      <category>分布式</category>
      <category>高可用</category>
      <pubDate>Fri, 08 Jul 2022 08:53:44 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>大家好我是一灰灰，本文将接着前文 <a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247487507&amp;idx=1&amp;sn=9c4ff02747e8335ee5e3c7765cc80b3c&amp;chksm=fce70bbfcb9082a9a8d972af80f19a9b66a5425c949bc400872727cc2da9f401047a5a523ac4&amp;token=309565785&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">1w5字详细介绍分布式系统的那些技术方案</a> 文章基础上，进行实际的案例解析</p>
</blockquote>
<p>高可用对于当下的系统而言，可以说是一个硬指标，常年专注于业务开发的我们，对于高可用最直观的感觉可能就是祈祷应用不要出问题，不要报错；即便有问题，也最好不是我们的业务代码逻辑导致的，如果是服务器、DB、中间件(如注册中心、配置中心等)的异常那就抛给对应的sre, dba；然而常在河边走，哪有不湿鞋，为了保障服务的高可用，我们可以从哪些方面进行努力呢？</p>
<p>本文将作为高可用的开篇，通过简述一些常用的系统的高可用方案，给大家介绍一下我们可以从哪些方面努力让我们的系统达到高可用，主要涉及到的系统如下</p>
<ul>
<li>缓存：Redis</li>
<li>数据库：MySql</li>
<li>消息队列：RabbitMQ</li>
<li>搜索: ElasticSearch</li>
</ul>
<h2> 1 redis高可用策略</h2>
<p>redis广泛应用于缓存的业务场景，当然也有将其当做持久化存储的nosql数据库使用，这些都不重要，重点是redis在提供服务的时候，是如何支持高可用的呢？</p>
<p>redis官方支持了四种策略：</p>
<ul>
<li>数据持久化</li>
<li>主从同步</li>
<li>哨兵模式</li>
<li>集群</li>
</ul>
<p>除以上姿势之外，我们自己在使用时还可以选择根据业务场景使用不同的redis实例（即传说中的不把所有鸡蛋放在一个篮子里）</p>
<p>接下来将针对redis的几种高可用策略进行简述说明</p>
<h3> 1.1 数据持久化</h3>
<blockquote>
<p>官方手册: <a href="https://redis.io/docs/manual/persistence/" target="_blank" rel="noopener noreferrer">Redis persistence</a></p>
</blockquote>
<p>持久化是在高可用、一致性的场景中经常会看到的一种技术手段；</p>
<p>在高可用的场景中，数据的持久化主要是为了解决在服务出现问题（如宕机）之后，可以快速恢复并对外继续提供服务能力；</p>
<p>redis官方提供了两种持久化策略</p>
<ul>
<li>AOF: 将更新的操作命令记录在对应的日志文件中，在重启的时候采用“回放”策略，将所有的命令重新执行一遍来实现场景恢复</li>
<li>RDB: 定时存储redis中的数据快照到数据文件中，在重启的时候，加载rdb文件，恢复所有的数据</li>
</ul>
<p>简单来讲AOF记录的是操作动作，采用回放执行的机制进行恢复；RDB则相当于数据落盘，重新读取加载的机制进行恢复</p>
<p><strong>注：AOF RDB可以一起工作，没有排他性</strong></p>
<h3> 1.2 主从方式</h3>
<p>虽然redis性能爆炸，但是单机依然存在性能瓶颈；当我们遇到单机的性能瓶颈的时候，一般怎么做？</p>
<p>没错，加机器</p>
<p>redis也支持多机服务，比如常见的一主多从策略：</p>
<ul>
<li>主机：提供读写能力</li>
<li>从机：只提供读</li>
</ul>
<p>针对绝大多数读多写少的场景，我们可以起多个redis实例，其中一个设置为主，提供所有的写请求；其他的实例则设置为从，客户端通过负载策略路由到不同的从redis，从而实现流量分摊；</p>
<p>同时也因为有多个实例，所以单台或几台实例下线，对整个服务的可用性影响并不会太大（及时摘除故障机器，其他的实例依然可以正常提供服务；当然前提是流量所示太大把其他的实例也打挂，那就gg了）</p>
<figure><img src="/imgs/column/distribute/220708/redis00.jpg" alt="redis主从模式" tabindex="0" loading="lazy"><figcaption>redis主从模式</figcaption></figure>
<p>主从模式还有一个变种，叫做从从模式，主要是为了解决主redis的同步压力，改成主 -&gt; 从，然后由一个从同步给其他的从实例，具体架构图如下</p>
<figure><img src="/imgs/column/distribute/220708/redis01.jpg" alt="redis主从从模式" tabindex="0" loading="lazy"><figcaption>redis主从从模式</figcaption></figure>
<p>使用主从、主从从模式实现高可用可算是分布式系统的经典策略，其主要思想在于：</p>
<ul>
<li>多实例提供服务，实现负载均衡</li>
<li>每个实例<strong>冗余</strong>一份全量数据</li>
</ul>
<h3> 1.3 哨兵模式</h3>
<blockquote>
<p>官方手册: <a href="https://redis.io/docs/manual/sentinel/" target="_blank" rel="noopener noreferrer">High availability with Redis Sentinel</a></p>
</blockquote>
<p>哨兵模式主要是为了解决主从模式中，主机宕机的场景，由于主机本身存在单点，所以主节点对成了高可用的关键因素了；那么如果实现主节点宕机之后，自动选择一个新的主节点，这样不就可以提高系统的可用性了么； redis官方提供的机制就是 - 哨兵模式</p>
<p>主要工作原理：</p>
<ul>
<li>哨兵：监听redis实例，判断是否存活（不太对外提供服务能力）</li>
<li>通过 PING 命令，检查与主从服务器之间的连接情况，若正常相应，则认为存活；否则认为<code>主观下线</code></li>
<li>当 <code>n/2 + 1</code>半数以上哨兵认为主节点下线，则认为主节点<code>客观下线</code>，尝试选新的主节点</li>
<li>从所有从节点中，选择与之前主库相似度最高的从节点作为新的主库</li>
</ul>
<figure><img src="/imgs/column/distribute/220708/redis02.jpg" alt="哨兵模式" tabindex="0" loading="lazy"><figcaption>哨兵模式</figcaption></figure>
<p>哨兵模式，可以理解为探活 + 选主，而这也常见于各大分布式系统的技术方案中</p>
<h3> 1.4 集群模式</h3>
<blockquote>
<p>官方手册: <a href="https://redis.io/docs/manual/scaling/" target="_blank" rel="noopener noreferrer">Scaling with Redis Cluster</a></p>
</blockquote>
<p>相比于主从模式的全量冗余，redis的集群策略在在于数据分片，每个实例上存储部分的数据；而不是全量数据，从而解决数据量大的场景下，对于redis服务本身以及数据同步的压力</p>
<p>集群模式的特点在于多个实例，构建成一个实例，每个实例上存储部分的数据；redis并没有采用一致性hash来做数据分布，而是使用特有的slots插槽机制，来实现数据的hash映射</p>
<figure><img src="/imgs/column/distribute/220708/redis03.jpg" alt="集群模式" tabindex="0" loading="lazy"><figcaption>集群模式</figcaption></figure>
<p>集群模式，主要特点在于数据分片，每个实例存部分数据，其思路在于<strong>拆分</strong></p>
<p>从上面的图中也可以看出，集群一般与主从搭配使用，集群中的每个分片对应的是主从模式的redis服务，从而加强高可用</p>
<h3> 1.5 小结</h3>
<p>这一节主要介绍的是redis的高可用策略，从中也可以看到很多经典的技术方案</p>
<ul>
<li>持久化：RDB数据落盘加载方式 + AOF记录操作命令用于回放策略</li>
<li>主从，主从从：全量数据冗余、读写请求分离，负载均衡的思想；核心问题在于主节点挂掉之后需要人工参与手动指定主库</li>
<li>哨兵机制：PING/PONG的探活机制，监听主节点，宕机之后自动选主，确保高可用；核心问题在于所有的实例冗余相同的一份数据，数据量大时不友好</li>
<li>集群：数据分片，每个实例提供部分服务能力</li>
</ul>
<p>看到这里的小伙伴自然会想到，为什么redis会提供这些不同的策略？它们各自的应用场景是什么，优缺点是啥？这些疑问就放在后续的redis高可用详解中介绍</p>
<p>相关博文：</p>
<ul>
<li><a href="https://redis.io/docs/manual/scaling/" target="_blank" rel="noopener noreferrer">Scaling with Redis Cluster | Redis</a></li>
<li><a href="https://mp.weixin.qq.com/s/gofXUXKD_ZelbOJDinHs4g" target="_blank" rel="noopener noreferrer">Redis高可用策略 - 楼仔</a></li>
<li><a href="https://xie.infoq.cn/article/6c3500c66c3cdee3d72b88780" target="_blank" rel="noopener noreferrer">redis系列之——高可用（主从、哨兵、集群）诸葛小猿</a></li>
</ul>
<h2> 2 MySql高可用策略</h2>
<p>MySql数据库的高可用策略就比较多了，同样也非常的经典；仅仅主节点的保活策略就非常多了；在这里将主要的重心放在MySql的高可用架构主备、主从、一主多从，多主多从上，至于主节点故障时转移策略则放在后续详细的文章中进行介绍</p>
<h3> 2.1 数据持久化</h3>
<p>对于每个开发者而言，大多都听说过数据库的ACID特性，其中的D对应的就是这里说到的持久化；区别于redis的持久化，以MySql的InnoDB引擎为例，其持久化涉及到多个日志文件(undo log,redo log,binlog)，缓存区(buffer)，磁盘(idb文件)</p>
<p>接下来看一下完整的数据更新/插入的流程</p>
<figure><img src="/imgs/column/distribute/220708/mysql00.jpg" alt="mysql数据持久化流程图" tabindex="0" loading="lazy"><figcaption>mysql数据持久化流程图</figcaption></figure>
<p>接下来描述一下核心思想：</p>
<ul>
<li>数据更新策略：总是更新缓存的内容（缓存未命中，则从磁盘加载到缓存）</li>
<li>先写undolog日志文件：记录之前的数据，支持mvcc、支持回滚就靠它</li>
<li>redolog记录的两阶段提交：（先是prepare，待binlog写完之后，再次更新状态为commit）</li>
<li>最后异步刷新缓存数据到磁盘</li>
</ul>
<p>虽然上面的描述比较简单，但是这里的知识点非常多，如</p>
<ul>
<li>为什么先更新缓存，最后异步刷磁盘？
<ul>
<li>核心在于操作内存的速度 &gt;&gt; 操作磁盘</li>
</ul>
</li>
<li>undolog作用是什么，怎么支持mvcc，实现事务回滚的？
<ul>
<li>保障事务原子性的关键所在，数据行非主键变更时，记录修改前的数据到undolog，并指向它，其他sql读这个undolog中的副本数据从而支持mvcc，回滚时则是根据undo log进行逻辑恢复</li>
</ul>
</li>
<li>redolog作用是什么，为什么两阶段方案？
<ul>
<li>主要保障事务的持久性，当数据库异常宕机之后，可以通过重新执行redo log来恢复未及时落盘的数据；两阶段的主要目的是为了解决redolog与binlog的一致性问题，避免出现redolog第一阶段成功，但是binlog失败导致不一致问题</li>
<li>redolog属于innodb引擎，固定大小，环形结构覆盖写策略；内部同样是先写缓存，再刷磁盘的策略</li>
</ul>
</li>
</ul>
<p>更多详情内容，后面到mysql的专题时再详细介绍</p>
<h3> 2.2 主备架构</h3>
<p>保证高可用的一个最简单策略就是“冗余”，也就是我们这里说到的主备架构，对mysql而言，就是我启动两个实例；一个主库对外提供读写服务，一个备库，冗余主库的所有数据内容，并不对外提供服务；</p>
<p>当主库gg之后，然后备库升级，切换为主库</p>
<blockquote>
<p>话说这个思想和古代的储君制非常像了，平时都是皇帝总领朝堂，太子就当吉祥物；皇帝驾崩之后，太子就晋升为皇帝（论备胎的重要性）</p>
</blockquote>
<figure><img src="/imgs/column/distribute/220708/mysql01.jpg" alt="MySql主备" tabindex="0" loading="lazy"><figcaption>MySql主备</figcaption></figure>
<p>主备的最大特点就是多备一台实例，在出问题时顶上，当然缺点就很明显了，严重的资源浪费</p>
<h3> 2.3 主从架构</h3>
<p>主从和前面mysql的思路差不多，主从模式一般又叫做读写分离，即写主库，读从库；相比于主备而言，最主要的突破点在于另外一个mysql实例不会干放着，而是尤其来承担读请求</p>
<figure><img src="/imgs/column/distribute/220708/mysql02.jpg" alt="MySql主从" tabindex="0" loading="lazy"><figcaption>MySql主从</figcaption></figure>
<p>主从的核心思想在于读写分离</p>
<h3> 2.4 一主多从</h3>
<p>在前面主从的基础上多挂几个从库，主要出发点在于当前的互联网场景下，绝大多数的应用都是读多写少，通过挂多个从库，可以有效提供整体服务的性能指标</p>
<p>同样一主多从的模式，也会区分为主从 + 主从从两种，后者则主要是为了减少主库的同步压力，下图为核心4架构模型</p>
<figure><img src="/imgs/column/distribute/220708/mysql03.jpg" alt="MySql主从" tabindex="0" loading="lazy"><figcaption>MySql主从</figcaption></figure>
<h3> 2.5 多主多从</h3>
<p>一主多从可以解决读多写少的场景，但总会出现写瓶颈的场景；在不考虑分库分表的业务手段之前（这种方式也可以理解为数据分片，类似上面说到的redis集群模式），仅仅从mysql的架构模式出发，自然会想到的策略就是多个主库提供写能力，这就是我们说的多主多从的架构了</p>
<figure><img src="/imgs/column/distribute/220708/mysql04.jpg" alt="MySql主从" tabindex="0" loading="lazy"><figcaption>MySql主从</figcaption></figure>
<p>多主多从，其中每个主库都可以独立对外提供写请求；从库则对外提供读请求</p>
<p>需要注意的是主库之间的数据同步，即一个写请求落到一个任意一个主库之后，所有的主库都会同步这个写操作</p>
<h3> 2.6 主库切换策略、主从同步策略</h3>
<p>前面介绍的是几种不同的主从架构特点，主要通过主、备/从来新增实例来提高可用性；但是还有两个非常重要的点没有细说，一个是故障之后，如何确定新的主库；另外一个则是主从/主主之间的数据如何同步，如何保证数据的一致性；</p>
<p>接下来我们将简单的介绍下mysql中常见的一些做法（更详细的当然留在后面的专题）</p>
<h4> 主库切换策略</h4>
<p><strong>VIP + KeepAlived</strong></p>
<ul>
<li>vip: 即virtual ip虚拟ip</li>
<li>KeepAlived: 保活脚本</li>
</ul>
<p>其主要思路在于外部通过VIP访问mysql实例(主从/主主)，而KeepAlived用于检测主库是否存活，当挂掉之后，VIP偏移到另外一个主库（或者选一个从库作为主库）上，从而实现自动的切主流程</p>
<p>缺点：</p>
<ul>
<li>级联复制(主-&gt;从-&gt;从这种复制模式叫做级联复制)或者一主多从在切换之后，其他从实例需要重新配置连接新主</li>
</ul>
<p><strong>MHA</strong></p>
<p>Master High Avaliable 主库高可用机制，也是当下很多公司采用的策略；其包含一套完整的工具，在检测到主库不可用后，会自动将同步到最接近主库的slave提升为master，然后将其他的slave指向新的master</p>
<p>其优点非常明显，通常可以实现十秒内的主从切换，扩展MySql节点也非常方便；而缺点则在于主要监控主库</p>
<p><strong>MXC</strong></p>
<p>PXC（Percona XtraDB Cluster）是一个完全开源的 MySQL 高可用解决方案。它将 Percona Server、Percona XtraBackup 与 Galera 库集成在一起，以实现多主复制的 MySQL 集群</p>
<p>其核心特点在于写请求会自动同步到其他节点，要求在所有的节点都验证之后才会提交，保证数据的强一致性</p>
<p>因此缺点就在于木桶效应，性能取决于最差的那个节点</p>
<p><strong>MGR/InnoDB Cluste</strong></p>
<p>MySQL 5.7 推出了 MGR（MySQL Group Replication），与 PXC 类似，也实现了多节点数据写入和强一致性的特点。MGR 采用 GCS（Group Communication System）协议同步数据，GCS 可保证消息的原子性</p>
<p>外部连接通过 MySql router与一组mysql实例进行交互，当主库切换时，mysql router会自动切换到新的主节点</p>
<p><strong>Xenon</strong></p>
<p>给予Raft协议的MySql高可用和复制性管理工具，无中心化选主，支持秒级切换</p>
<h4> 主从同步策略</h4>
<p>当存在主从库时，必然会存在同步问题，如何保障主库与从库数据的一致性呢？</p>
<p><strong>主从同步流程</strong></p>
<p>主从同步主要借助Binlog来实现，这个在前面的图中有简单的体现，下面则是相对完整的同步流程</p>
<figure><img src="/imgs/column/distribute/220708/mysql05.jpg" alt="MySql主从数据同步" tabindex="0" loading="lazy"><figcaption>MySql主从数据同步</figcaption></figure>
<ul>
<li>主库生成binlog日志文件
<ul>
<li>statement:记录具体引起改动的操作语句，比如insert xxxxx，缺点是某些函数会导致数据不一致（如now()）</li>
<li>row:基于数据行的，原来数据行是xx值改为了yy 值，缺点是数据量大</li>
<li>mixed: 上面两个混用</li>
</ul>
</li>
<li>从库的io线程拉主库的binlog日志，写入自己的relaylog(中继日志)，然后由sql线程读取relaylog日志进行回放，实现数据同步</li>
</ul>
<p><strong>主从同步策略</strong></p>
<p>使用主从之后，在实际的业务开发中，最最常遇到的问题就是主从延迟，即主库数据已经写入了，但是读从库却读不到对应的数据，这个就是主从延迟了，它直接导致数据的不一致；当然一般这种影响还好，但是如果因为主从延迟，现在主库挂了，所有的从库都没有最新的记录，这不就导致数据丢失了么，会导致严重的数据一致性问题</p>
<p>所以在主从同步的策略上，有下面几种</p>
<p>case1:异步复制</p>
<p>主库完成写请求之后，理解返回结果，并不关心从库是否同步接收处理，此时就可能出现上面说的，主库挂了之后，所有从库还存在未同步的数据，导致数据丢失</p>
<p>case2:半同步复制</p>
<p>为了避免出现上面的问题，我们要求最少有一个从库同步完之后，才响应用户端请求，这样表明主库宕机之后还有个兜底的</p>
<p>case3:全同步复制</p>
<p>这个更激进一点，要求所有的从库都同步完，才算真正的ok，保证强一致性，缺点则在于性能会受到影响</p>
<h3> 2.7 小结</h3>
<p>这一小节主要介绍的是MySql的高可用策略，从架构方面出发，有主备，主从，一主多从，多主多从，同时也简单的介绍了下如何实现主库的自动切换(MHA,MXC,MGR等)、主从数据同步流程，同步策略；如果想了解更详细的内容，请移步到mysql的高可用专题</p>
<p>下面小结一下保持高可用的主要思路</p>
<ul>
<li>通过冗余来实现高可用：如主备</li>
<li>读写分离，实现负载均衡：主从、主从从模式</li>
<li>数据持久化策略：操作内存(buffer)，异步刷盘，两阶段提交保障一致性</li>
</ul>
<p>相关博文:</p>
<ul>
<li><a href="https://dev.mysql.com/doc/refman/8.0/en/mysql-innodb-cluster-introduction.html" target="_blank" rel="noopener noreferrer">官方文档 InnoDB Cluster</a></li>
<li><a href="https://www.php.cn/mysql-tutorials-488418.html" target="_blank" rel="noopener noreferrer">读完搞懂MySQL持久化和回滚（图文详解）-mysql教程</a></li>
<li><a href="https://mp.weixin.qq.com/s/3ICMQUF_vQpuDm2nHi1qqw" target="_blank" rel="noopener noreferrer">MySQL 常用高可用方案</a></li>
<li><a href="https://blog.csdn.net/weixin_47019016/article/details/114740096" target="_blank" rel="noopener noreferrer">MySQL高可用之PXC详解_现实如此呀的博客-CSDN博客_pxc</a></li>
<li><a href="https://www.51cto.com/article/606556.html" target="_blank" rel="noopener noreferrer">一文看懂MySQL的异步复制、全同步复制与半同步复制</a></li>
</ul>
<h2> 3. RabbitMq高可用方案</h2>
<p>消息中间件也是大家或多或少会接触的一类系统，接下来将以RabbitMq来看一下它的高可用是如何实现的</p>
<h3> 3.1 数据持久化</h3>
<p>不同于前面MySql必然会持久化，RabbitMq的数据持久化是可选的，当我们对数据的完整性要求高时，最好开启持久化</p>
<p>首先简单看一下rabbitmq的模型</p>
<figure><img src="/imgs/column/distribute/220708/rabbitmq00.jpg" alt="RabbitMq架构" tabindex="0" loading="lazy"><figcaption>RabbitMq架构</figcaption></figure>
<p>我们这里说的持久化主要指</p>
<ul>
<li>exchange持久化: 即exchange本身不会因为rabbitmq宕机而被删除，需要手动指定durable=true</li>
<li>topic持久化：消费者通过topic从exchange中读取消息，需要指定durable=true，避免出现宕机后队列中的消息丢失</li>
<li>msg消息持久化：即生产者投递到echange的消息，需要持久化到磁盘</li>
</ul>
<p>注意rabbitmq的消息持久化也是先写到buffer，然后再定时刷新到磁盘；</p>
<p>当我们为了保障数据的完整性时，一般会开启消息的确认机制/事务机制，每次投递等到mq回复一个确认ack之后，才表示真正的投递成功，而mq的应答则是在消息的持久化之后进行</p>
<h3> 3.2 主备模式</h3>
<p>同前面的MySql的主备，主节点提供读写，备节点同步主节点的数据，不对外提供服务能力；当主节点挂了之后，启用备节点对外服务，原主节点恢复之后则作为备节点存在</p>
<h3> 3.3 Shovel远程模式</h3>
<blockquote>
<p>官方文档： * <a href="https://www.rabbitmq.com/shovel.html" target="_blank" rel="noopener noreferrer">Shovel Plugin — RabbitMQ</a></p>
</blockquote>
<p>远程模式可以实现双活的一种模式，简称 shovel 模式，所谓的 shovel 就是把消息进行不同数据中心的复制工作，可以跨地域的让两个 MQ 集群互联，远距离通信和复制。</p>
<ul>
<li>Shovel 就是我们可以把消息进行数据中心的复制工作，我们可以跨地域的让两个 MQ 集群互联。</li>
</ul>
<figure><img src="/imgs/column/distribute/220708/rabbitmq01.jpg" alt="RabbitMq远程模式" tabindex="0" loading="lazy"><figcaption>RabbitMq远程模式</figcaption></figure>
<p>如上图，有两个异地的 MQ 集群（可以是更多的集群），当用户在地区 1 这里下单了，系统发消息到 1 区的 MQ 服务器，发现 MQ 服务已超过设定的阈值，负载过高，这条消息就会被转到 地区 2 的 MQ 服务器上，由 2 区的去执行后面的业务逻辑，相当于分摊我们的服务压力。</p>
<h3> 3.4 镜像模式</h3>
<p>如下图，用 KeepAlived 做了 HA-Proxy 的高可用，然后有 3 个节点的 MQ 服务，消息发送到主节点上，主节点通过 mirror 队列把数据同步到其他的 MQ 节点，这样来实现其高可靠</p>
<figure><img src="/imgs/column/distribute/220708/rabbitmq02.jpg" alt="RabbitMq镜像模式" tabindex="0" loading="lazy"><figcaption>RabbitMq镜像模式</figcaption></figure>
<p>镜像模式的主要特点在于每个mq实例都包含一份完整的数据镜像，内部有一个master选举算法，通过VIP对外提供连接</p>
<ul>
<li>consumer，任意连接一个节点，若连上的不是master，请求会转发给master，为了保证消息的可靠性，consumer回复ack给master后，master删除消息并广播所有的slaver去删除。</li>
<li>publisher ，任意连接一个节点，若连上的不是master，则转发给master，由master存储并转发给其他的slaver存储。
如果master挂掉，则从slaver中选择消息队列最长的为master，</li>
</ul>
<h3> 3.5 普通集群模式</h3>
<p>exchange，buindling再所有的节点上都会保存一份，但是queue只会存储在其中的一个节点上，但是所有的节点都会存储一份queue的meta信息</p>
<p>如果生产者连接的是另外一个节点，将会把消息转发到存储该队列的节点上。如果消费者连接了非存储队列的节点取数据，则从存储消息的节点拉取数据。</p>
<p>其核心特点在于：</p>
<ul>
<li>数据拆分存储，若纯消息的节点挂了，则只能等待它恢复之后才能正常工作</li>
</ul>
<h3> 3.6 多活模式</h3>
<blockquote>
<p>这个模式我的理解也不够深刻，以下内容来自于网上摘录，待后面到rabbitmq专题之后调研后进一步阐述</p>
</blockquote>
<p>rabbitMQ 部署架构采用双中心模式(多中心)，那么在两套(或多套)数据中心各部署一套 rabbitMQ 集群，各中心的rabbitMQ 服务除了需要为业务提供正常的消息服务外，中心之间还需要实现部分队列消息共享</p>
<figure><img src="/imgs/column/distribute/220708/rabbitmq03.jpg" alt="RabbitMq镜像模式" tabindex="0" loading="lazy"><figcaption>RabbitMq镜像模式</figcaption></figure>
<p>federation 插件是一个不需要构建 cluster ，而在 brokers 之间传输消息的高性能插件，federation 插件可以在 brokers 或者 cluster 之间传输消息，连接的双方可以使用不同的 users 和 virtual hosts，双方也可以使用不同版本的 rabbitMQ 和 erlang。</p>
<p>federation 插件使用 AMQP 协议通信，可以接受不连续的传输。federation 不是建立在集群上的，而是建立在单个节点上的，如图上黄色的 rabbit node 3 可以与绿色的 node1、node2、node3 中的任意一个利用 federation 插件进行数据同步。</p>
<h3> 3.7 小结</h3>
<p>rabbitmq的高可用机制的方案也比较好理解</p>
<ul>
<li>主备模式</li>
<li>镜像模式：全量冗余一份数据，主对外提供服务，可以实现自动切主</li>
<li>普通集群模式：数据拆分到集群的实例中，consumer/publisher连接到实例之后，会从具体持有exchange/topic的实例上拉数据</li>
<li>远程模式：适用于多中心的场景，将消息转发给其他中心的实例</li>
</ul>
<p>这里采用的高可用思路也无外乎常见的几种：持久化 + 数据冗余 + 拆分</p>
<p>相关博文：</p>
<ul>
<li><a href="https://spring.hhui.top/spring-blog/2020/02/12/200212-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B9%8BRabbitMq%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%E5%B0%8F%E7%BB%93/" target="_blank" rel="noopener noreferrer">【MQ系列】RabbitMq核心知识点小结 | 一灰灰Blog</a></li>
<li><a href="https://www.jianshu.com/p/b7cc32b94d2a" target="_blank" rel="noopener noreferrer">RabbitMQ 的4种集群架构</a></li>
<li><a href="http://www.liaoqiqi.com/post/215" target="_blank" rel="noopener noreferrer">rabbitmq消息一致性问题 - Knight's Blog</a></li>
</ul>
<h2> 4. ElasticSearch高可用方案</h2>
<p>接下来我们再看一下现在非常流行的分布式搜索引擎ElasticSearch是如何保证高可用的</p>
<h3> 4.1 集群</h3>
<blockquote>
<p>Elasticsearch 是一个分布式、RESTful 风格的搜索和数据分析引擎</p>
<p>by 官网描述</p>
</blockquote>
<p>对于es而言，通常都是集群方式对外提供服务，每启动一个实例叫做一个节点(Node)，每个节点会定义一个节点名(Node Name)，集群名(Cluster Name)，相同集群名的节点会构建为一个集群；</p>
<figure><img src="/imgs/column/distribute/220708/es00.jpg" alt="ES集群" tabindex="0" loading="lazy"><figcaption>ES集群</figcaption></figure>
<p>上图包含了es集群的核心要素：</p>
<ul>
<li>每个节点包含集群名 + 节点名两个属性，相同集群名的节点挂在一个集群内</li>
<li>节点启动之后，开始PING其他节点（连接上后会得到对应节点所在集群的所有信息）</li>
<li>节点发现主要靠Zen Discover来实现，选举也是靠它来实现</li>
</ul>
<p>选举主要流程如下</p>
<figure><img src="/imgs/column/distribute/220708/es01.jpg" alt="ES选举" tabindex="0" loading="lazy"><figcaption>ES选举</figcaption></figure>
<ul>
<li>选举同样也是依赖Zen Discover来实现</li>
<li>每个节点上报自己任务的主节点，然后票数最多的就是主节点；票数相同的情况下，根据ID排序，选第一个</li>
</ul>
<p>上面就是es集群的构建与主节点的选举过程；es支持任意节点数目的集群（1- N），无法完全依赖投票的机制来选主，而是通过一个规则。</p>
<p>只要所有的节点都遵循同样的规则，得到的信息都是对等的，选出来的主节点肯定是一致的。</p>
<p>但分布式系统的问题就出在信息不对等的情况，这时候很容易出现脑裂（Split-Brain）的问题。</p>
<p>大多数解决方案就是设置一个 Quorum 值，要求可用节点必须大于 Quorum（一般是超过半数节点），才能对外提供服务。而 Elasticsearch 中，这个 Quorum 的配置就是 <code>discovery.zen.minimum_master_nodes</code>，当<strong>候选主节点</strong>的个数超过这个参数值时，开始选举，选主完成之后对外提供服务</p>
<p>ES作为分布式、近实时搜索系统，天然支持集群的服务能力，通过Zen Discover来实现节点通信、集群管理、选主</p>
<h3> 4.2 脑裂问题</h3>
<p>上面提到了脑裂，接下来简单看一下ES是如何解决脑裂问题的</p>
<blockquote>
<p>脑裂：由于网络或者集群健康监测问题，导致整个集群出现多个master节点，这种现象就是脑裂</p>
</blockquote>
<p>es对节点进行了角色划分</p>
<ul>
<li>数据节点：负责数据的存储和相关的操作(CURD，聚合)等，因此对机器性能要求较高</li>
<li>候选主节点：拥有选举权和被选举权，主节点在候选主节点中评选出来，负责创建索引、删除索引、跟踪哪些节点是群集的一部分，并决定哪些分片分配给哪些的节点、追踪集群中节点的状态等</li>
</ul>
<blockquote>
<p>一个节点，可以即是数据节点，又是候选主节点，但是注意它们两者的定位，主节点对机器性能要求没有数据节点高，当一台机器既是数据节点又是主节点时，可能出现长耗时、耗资源的请求导致主节点服务异常；</p>
<p>通常更推荐的方案是使用性能低一点的作为候选主节点，性能高的作为数据节点</p>
</blockquote>
<figure><img src="/imgs/column/distribute/220708/es02.jpg" alt="ES角色划分" tabindex="0" loading="lazy"><figcaption>ES角色划分</figcaption></figure>
<p>接下来看下脑裂出现的情况</p>
<ul>
<li>网络问题，导致分区：即部分节点连接不到主节点，认为它挂了，然后选举出现的主节点</li>
<li>主节点负载、响应延迟：主节点由于负载过高、或者响应超时，导致重新选举新的主节点</li>
</ul>
<p>解决方案：</p>
<ul>
<li>适当调大ping timeout响应时间，避免因为网络、主节点性能问题导致的选举</li>
<li>设置最少选举节点数大于候选主节点的半数，这样只要有半数以上的候选节点存活，则可以选举出一个主节点；而当可用节点数小于半数时，不参与选举，集群无法使用，也不会出现状态异常的情况</li>
<li>角色分离：数据节点 + 候选主节点不放在一台机器上；</li>
</ul>
<p>在有主节点的系统中，一般都需要考虑脑裂问题，常见的策略无非是：</p>
<ul>
<li>半数节点以上的投票才算有效</li>
<li>es额外提供了节点的角色定位，数据节点和候选主节点，其中只有候选主节点才有选举权和被选举权，提供一种角色分离的可选方案，来避免主节点被其他数据服务影响</li>
</ul>
<h3> 4.3 数据分片</h3>
<p>当数据量过大时，es支持自动拆分，将一个索引的上数据水平拆分到不同的数据块--分片(Shards)，为了提供可用性，每个索引在定义时除了分片之外，还会定义副本数量，这里的副本可以理解为数据冗余，其中副本和分片必然不在一个节点上，在主节点异常时，副本可以提供数据查询能力</p>
<blockquote>
<p>es默认在创建索引时，分片数为5，每个分片对应一个副本</p>
</blockquote>
<figure><img src="/imgs/column/distribute/220708/es03.jpg" alt="ES分片" tabindex="0" loading="lazy"><figcaption>ES分片</figcaption></figure>
<p>ES通过分片，将索引数据水平拆分，分片数越多，每个分片上的数据量就越少；而副本则是对应的每个分片的冗余，可以理解为主备，副本越多，消耗则越大</p>
<p>两点小说明</p>
<ul>
<li>对应副本的概念，上面的分片也叫做主分片</li>
<li>当一个数据写入/更新到分片时，只有所有的副本都更新完毕之后，才算完成（可以MySql的全同步）</li>
</ul>
<h3> 4.4 数据持久化</h3>
<p>最后再说一下es的持久化机制，与前面先说持久化不同，es这里则需要先了解上面的基本流程，索引数据需要保存到主分片上，最终落盘，接下来看一下完整的流程</p>
<p><strong>主分片数据更新流程</strong></p>
<figure><img src="/imgs/column/distribute/220708/es04.jpg" alt="ES数据更新流程" tabindex="0" loading="lazy"><figcaption>ES数据更新流程</figcaption></figure>
<p>简述一下上面的流程</p>
<ul>
<li>首先请求随机连一个es节点（这个节点叫做协调节点），然后通过路由算法，确定数据对应的主分片</li>
<li>写数据到主分片，然后同步到副本（多个副本时采用并发同步，乐观锁控制）</li>
<li>所有副本同步完成之后，主分片节点告诉协调节点最终结果，然后协调节点告诉调用者响应</li>
</ul>
<p>当数据写入到主分片上之后，接下来再看一下这个数据时如何刷新到磁盘上的</p>
<p><strong>分段存储</strong></p>
<p>索引文档以段的形式存储磁盘，即一个索引文件会划分为很多个子文件，这里的子文件就是段</p>
<blockquote>
<p>每一个段本身都是一个倒排索引，并且段具有不变性，一旦索引的数据被写入硬盘，就不可再修改；段被写入到磁盘后会生成一个提交点，提交点是一个用来记录所有提交后段信息的文件</p>
</blockquote>
<p>段的特性，有下面几个有点</p>
<ul>
<li>分段存储，可以有效避免读写时加锁的问题</li>
<li>不变性，数据只读可以高效缓存，无需考虑更新</li>
<li>一个段一旦拥有了提交点，就说明这个段只有读的权限，失去了写的权限。相反，当段在内存中时，就只有写的权限，而不具备读数据的权限，意味着不能被检索</li>
</ul>
<p>由于段不可变，所以在更新时需要额外处理</p>
<ul>
<li>新增：当前文档新增一个段</li>
<li>删除：新增一个.del文件，记录被删除的文档信息；被标记删除的文档仍然可以被检索到，只是最终返回时被移除</li>
<li>更新：删除文件中标记旧的文档删除，插入新的段</li>
</ul>
<p><strong>延迟写</strong></p>
<p>ES并不会实时将内存中的数据写入段，而是采用延迟写的策略（类似前面的写buffer，然后异步定时刷盘）</p>
<p>es先将内存数据，写入文件缓存系统(操作系统内存)，</p>
<figure><img src="/imgs/column/distribute/220708/es05.jpg" alt="ES文档写入流程" tabindex="0" loading="lazy"><figcaption>ES文档写入流程</figcaption></figure>
<blockquote>
<p>上图来自 * <a href="https://mp.weixin.qq.com/s/gvSNazpxAE78v0J7DP9K1g" target="_blank" rel="noopener noreferrer">两万字教程，带你遨游ElasticSearch</a></p>
</blockquote>
<p>注意几个事项</p>
<ul>
<li>写入文件缓存系统，之后异步落盘，可能导致丢数据，es采用事务日志的方式来处理恢复策略(即mysql的先写日志，崩溃之后做回放恢复)</li>
<li>es对外服务时，检索文件缓存系统 + 段中的文档，而内存中的数据不会被检索到（所以所es是近实时搜索引擎，因为最新写入的数据还在内存中，没有提交，立马查就查不到）</li>
<li>为了避免段过多，es会定时做合并，将很多小的段合并成大的段（合并过程中会自动移除被标记删除的文档）</li>
</ul>
<p>最后小结一下es的持久化</p>
<ul>
<li>索引分段存储，段生成checkpoint之后，则只读，因此可以全量缓存，不用考虑更新修改</li>
<li>延迟写策略：先更新内存数据，异步提交文件缓存系统，最后再由操作系统刷盘</li>
<li>内存中的数据不能被检索；文件缓存 + 段中的数据提供查询聚合，最终的结果会过滤已标记删除的文档</li>
</ul>
<p><strong>参考博文</strong></p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/gvSNazpxAE78v0J7DP9K1g" target="_blank" rel="noopener noreferrer">两万字教程，带你遨游ElasticSearch</a></li>
<li><a href="https://xie.infoq.cn/article/55095e9626718380c4072f5fb" target="_blank" rel="noopener noreferrer">ElasticSearch原理解析_elasticsearch_Chank</a></li>
</ul>
<h3> 4.5 小结</h3>
<p>这一小节主要介绍的是ES的高可用机制，包括ES的集群工作原理，选举策略；采用数据分片支持大数据场景的支持，借助副本来提高可用性；</p>
<p>ES原生支持集群</p>
<ul>
<li>角色划分：候选主节点 + 数据节点</li>
<li>数据节点：负责数据的存储和相关的操作(CURD，聚合)等，因此对机器性能要求较高</li>
<li>候选主节点：拥有选举权和被选举权，主节点在候选主节点中评选出来，负责创建索引、删除索引、跟踪哪些节点是群集的一部分，并决定哪些分片分配给哪些的节点、追踪集群中节点的状态等</li>
</ul>
<p>ES数据持久化策略</p>
<ul>
<li>索引分段存储，段生成checkpoint之后，则只读，因此可以全量缓存，不用考虑更新修改；当出现修改时，标记原来段中文档删除，在新的段写入数据</li>
<li>延迟写策略：先更新内存数据，异步提交文件缓存系统，最后再由操作系统刷盘</li>
<li>内存中的数据不能被检索；文件缓存 + 段中的数据提供查询聚合，最终的结果会过滤已标记删除的文档</li>
</ul>
<h2> 5.一灰灰的总结</h2>
<h3> 5.1  综述</h3>
<p>本片文章主要是分析当下不同应用场景下的几个主流系统的高可用策略，来看一下如何来保障的系统的高可用</p>
<p><strong>常见的高可用思路</strong></p>
<ul>
<li>冗余 （如数据副本、主备服务等）</li>
<li>拆分 （数据拆分、服务能力拆分等）</li>
<li>持久化</li>
</ul>
<p><strong>redis</strong></p>
<ul>
<li>持久化：RDB数据落盘加载方式 + AOF记录操作命令用于回放策略</li>
<li>主从，主从从：全量数据冗余、读写请求分离，负载均衡的思想；核心问题在于主节点挂掉之后需要人工参与手动指定主库</li>
<li>哨兵机制：PING/PONG的探活机制，监听主节点，宕机之后自动选主，确保高可用；核心问题在于所有的实例冗余相同的一份数据，数据量大时不友好</li>
<li>集群：数据分片，每个实例提供部分服务能力</li>
</ul>
<p><strong>mysql</strong></p>
<ul>
<li>通过冗余来实现高可用：如主备</li>
<li>读写分离，实现负载均衡：主从、主从从模式</li>
<li>数据持久化策略：操作内存(buffer)，异步刷盘，两阶段提交保障一致性</li>
</ul>
<p><strong>rabbitmq</strong></p>
<ul>
<li>主备模式</li>
<li>镜像模式：全量冗余一份数据，主对外提供服务，可以实现自动切主</li>
<li>普通集群模式：数据拆分到集群的实例中，consumer/publisher连接到实例之后，会从具体持有exchange/topic的实例上拉数据</li>
<li>远程模式：适用于多中心的场景，将消息转发给其他中心的实例</li>
</ul>
<p><strong>ElasticSearch</strong></p>
<ul>
<li>ES集群：数据节点 + 候选主节点</li>
<li>ES持久化：
<ul>
<li>延迟写策略，先更新内存，然后提交操作系统缓存，最后异步刷新到磁盘；</li>
<li>索引分段存储：段生成checkpoint之后，则只读，因此可以全量缓存，不用考虑更新修改；当出现修改时，标记原来段中文档删除，在新的段写入数据</li>
</ul>
</li>
</ul>
<h3> 5.2 主题无关</h3>
<p>在准备写本文时，原计划针对不同业务场景各挑一个经典的系统来分析下各自的高可用方案，实际写下来发现工作量有点大；就把最后的一个分布式文件系统hdfs给暂缓了（对于大多数业务开发而言，接触的机会也不会太多），这个会放在《分布式系统-案例剖析》中进行介绍</p>
<p>最近会花大量的时间精力，准备做一个高质量的《分布式专栏》，欢迎有兴趣收藏关注 一灰灰的主站</p>
<ul>
<li>专栏地址：* <a href="https://hhui.top/%E5%88%86%E5%B8%83%E5%BC%8F/" target="_blank" rel="noopener noreferrer">分布式专栏 | 一灰灰Learning</a></li>
<li>精选： * <a href="https://hhui.top/%E5%88%86%E5%B8%83%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/01.%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%BB%BC%E8%BF%B0/" target="_blank" rel="noopener noreferrer">分布式设计模式综述 | 一灰灰Learning</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/column/distribute/220708/redis00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>02.Redis、ES、Hbase的高可用方案</title>
      <link>https://liuyueyi.github.io/tutorial/column/arch/distribute/%E9%AB%98%E5%8F%AF%E7%94%A8/02.Redis%E3%80%81ES%E3%80%81Hbase%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8%E6%96%B9%E6%A1%88.html</link>
      <guid>https://liuyueyi.github.io/tutorial/column/arch/distribute/%E9%AB%98%E5%8F%AF%E7%94%A8/02.Redis%E3%80%81ES%E3%80%81Hbase%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8%E6%96%B9%E6%A1%88.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">02.Redis、ES、Hbase的高可用方案</source>
      <description>以下内容来自同事的内部分享，经得同意分享给各位小伙伴 我们常说的高可用是怎么实现的呢？单机向集群的演进中遵循哪些原则，注意哪些事项呢？集群如何协同工作？集群之间的一致性如何保障？ 纯干货，推荐看到的小伙伴仔细认证的阅读一下，相信会有不少的收获</description>
      <category>分布式</category>
      <category>高可用</category>
      <pubDate>Wed, 30 Mar 2022 08:53:44 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>以下内容来自同事的内部分享，经得同意分享给各位小伙伴</p>
<p>我们常说的高可用是怎么实现的呢？单机向集群的演进中遵循哪些原则，注意哪些事项呢？集群如何协同工作？集群之间的一致性如何保障？</p>
<p>纯干货，推荐看到的小伙伴仔细认证的阅读一下，相信会有不少的收获</p>
</blockquote>
<!-- more -->
<h2> 一.nosql发展历史</h2>
<h3> 1.关系型数据库</h3>
<p>上世纪60年代以来至今，传统的关系型数据库一直被互联网应用的作为首选数据存储系统，典型的代表产品包括有oracle、mysql等。</p>
<p>关系型数据库的核心优势在于：第一，具备事务属性，注重数据一致性，内部实现有复杂的锁机制等还包含有其它一系列机制来保障数据一致性，能够基于AID(原子性、隔离性和持久性)的基础能力而带来事务强一致性来保证我们的数据存、取安全；第二，关系型数据模式其支持的二维表格模式比较契合现实中大部分的业务场景且易于理解，因此得以快速应用和发展。</p>
<p>关系型数据库最大的缺陷在于扩展性不足，在面对大量用户的并发访问以及海量存储的存取场景下，往往很难平滑的去做到性能升级，而使得DB经常作为整个系统应用的发展瓶颈。通常情况下，关系型数据库的扩展思路分为以下两种：</p>
<p>（1）纵向扩展。纵向扩展即提升单机硬件基础设施来提升处理能力。这种方式下虽然可以换来一定的性能提升，但是单机终归是存在有性能上限的，且升级过程中往往需要停机处理而无法做到平滑升级。其整体收益成本比比较低。</p>
<p>（2）横向扩展。横向扩展即通过分片，将数据分散至多台物理节点，降低单点压力，来提升处理能力。这种方式通常是对上层应用抽象出一个逻辑数据库，背后则是将数据分散到不同的物理数据库上。整体上来说，这种方式虽然可以在大部分常规场景下带来较大的性能提升，但与此同时又会引入另一个新的问题分布式事务问题，当然还包括有跨库join、非路由键查询等其它一系列问题。</p>
<h3> 2.NoSql的诞生</h3>
<p>在随着互联网业务与场景不断发展的背景下，由于在应对海量存储数据时传统的关系型数据在扩展能力上的不足，以及出现了越来越多的场景在关系型模式下显得并不适用，典型的如OLAP数据分析类型场景。促使Nosql技术开始诞生，Nosql的核心思想在于放弃传统关系型数据库的事务强一致性与关系模式，以此换取更高的可扩展性以及面对高并发海量数据时具备更强的处理能力。</p>
<p>对于Nosql而言，其定位并不是取代关系型数据库，而是作为关系型数据库的一种补充，两者分别有各自适合的领域场景。典型的nosql产品包括：基于kv的redis、列存储的hbase、文档型数据库ES等。</p>
<h3> 3.NewSql</h3>
<p>nosql虽然具备高扩展性的优势但其实在放弃了传统关系型数据库的强事务一致性的代价下换来的。因此，在关系型数据库与nosql均存在明显局限的背景下，NewSql概念开始应运而生。NewSQL可以说是传统的RDBMS与NoSQL技术结合之下的产物。这些系统既拥有NoSQL数据库的高扩展性，又希望能保持传统数据库的事务特性。典型的产品代表如google的spanner和国内的TiDB。</p>
<h2> 二.常见的Nosql产品简介</h2>
<p>常见的nosql产品如下：</p>
<table>
<thead>
<tr>
<th><strong>产品名称</strong></th>
<th><strong>特点</strong></th>
<th><strong>适用场景</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>redis</td>
<td>1.k-v结构； 2.内存数据库； 3.高性能，单机2C4G下读可达10WQPS；</td>
<td>1.缓存； 2.分布式锁、延时队列、限流等；</td>
</tr>
<tr>
<td>ES</td>
<td>1.文档型数据库； 2.结构化查询。支持多字段查询，以及复杂的过滤和聚合统计功能； 3.近实时查询。默认1s refresh一次将内存中的数据固化生成一个新的segment，此时为该segment创建倒排索引，外部读请求才能访问到这个segment的内容；</td>
<td>1.大数量背景下的检索类场景。例如日志搜索、大宽表解决mysql跨库join问题以及作为辅助索引解决分表下的非路由键查询问题； 2.数据统计、分析； 3.全文检索；</td>
</tr>
<tr>
<td>Hbase</td>
<td>1.列存储； 2.采用块存储机制，底层数据结构采用的是LSM合并树，将随机IO写转变为一次性顺序写，相比于B+树在写性能上表现更加优秀。但读性能会更弱；</td>
<td>1.PB级数据存储规模； 2.适合写多读少的场景，例如下沉的冷数据存储； 3.OLAP数据分析类场景；</td>
</tr>
</tbody>
</table>
<h2> 三. 集群工作原理</h2>
<h3> 3.1 集群模式</h3>
<p>对于大规模数据存储系统都会面临一个问题就是如何进行横向扩展，当数据集越来越大时，一主多从的模式无法支持这么大的数据存储与访问量，此时一般情况下就会考虑进行横向扩展，将多个主从模式组合在一起对外提供服务。但是这里有两个首要问题就是如何实现数据的分片逻辑以及分片逻辑放在哪里。于是在这种背景下就会衍生出两种不同的集群模式，一种就是集中式模式，一种则是去中心化的模式。</p>
<h4> <strong>1.集中式</strong></h4>
<p>集中式集群模式下，通常会引入一个中心节点作为集群的管理者，由管理者来进行集群状态管理、故障处理以及元数据维护等，其它节点只需响应数据请求，而无需知道集群中其它节点的情况。典型的解决方案都会借助于zookeeper分布式协调服务来进行集群管理，比如Hbase、kafka等。</p>
<p>Zookeeper：维护集群中的服务状态，并提供服务故障通知；</p>
<p>master：存储和维护集群元数据，以及故障转移等集群事务处理；</p>
<figure><img src="/imgs/column/distribute/220330/00.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h4> <strong>2.去中心化</strong></h4>
<p>即P2P交互模式，客户端与集群节点直接进行交互，而非之前业界的Proxy方式。典型的集群代表如redis cluster、es集群。</p>
<p><strong>redis Cluster介绍</strong></p>
<p>redis3.0版本开始，官方正式支持集群模式。redis官方集群模式最大的两个特点在于：</p>
<p>（1）去中心化。即P2P交互模式，客户端与集群节点直接进行交互，而非业界之前的Proxy方式。</p>
<p>（2）内部自治。redis 集群模式并未像Hbase、Kafka等引入第三方组件比如ZK，来实现对集群的节点状态管理、故障转移以及元数据管理等，而是基于Gssiop协议实现集群内节点监控、状态同步，并内置选举算法实现故障自动转移，在集群内部高度自治。</p>
<p>如下图是一个三主三从的redis cluster，三个机房部署，其中一主一从构成一个分片，之间通过异步复制同步数据。节点之间基于ping-pong心跳机制相互通信感知对方状态，一旦某个机房掉线，则分片上位于另一个机房的slave会被提升为master继续对外提供服务。</p>
<figure><img src="/imgs/column/distribute/220330/01.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 3.2 数据分片</h3>
<p>分布式集群在进行横向扩展时，首要问题就是如何实现数据的分片逻辑。</p>
<p><strong>1.分片策略</strong></p>
<p>常见分片策略如下：</p>
<p>（1）hash分片。hash分片也是我们最常用的分片策略。例如ES默认采用的就是这种方式。hash分片的好处在于数据会被打的比较分散，其次不用额外存储映射关系，客户端与服务端以约定好的hash公式进行路由。但是它的问题在于如果一旦需要进行扩缩容，那么整个映射关系都会被打破，此时需要进行一次全量的rehash数据迁移，工作量非常大。所以一般情况下，在设计的时候会尽可能的让这个hash模值大一点，避免频繁的进行扩容。</p>
<p>（2）基于某一key值的范围划分。例如基于时间范围或者id范围分片。这种分片方式的优劣势其实与hash的方式是相反的。它的好处在于，当需要进行扩缩容时，不会像hash一样破坏掉全局的映射关系，只需要对部分分片的映射关系产生影响。但是这种方式的问题在于它会存在一定的热点数据问题，导致整个集群各个节点的负载不均衡。例如Habse采用的就是这种方式，HBase 表根据 RowKey 的开始和结束范围水平拆分为多个 Region，一个region就是分片。每个 Region 都包含了 StartKey 和 EndKey 之间的所有行。每个 Region 都会分配到集群的一个节点上，即 RegionServer，由它们提供读写服务。</p>
<p>（3）一致性hash。一致性hash是通过构建一个环形的hash空间，对于用户的请求，先经过hash映射到这个环上，这就是第一层的映射关系，只要这个hash的模值不变，这层关系就不会变。其次，顺着环的顺时针方向找到的第一个节点，就是负责该请求对应的节点。</p>
<p>一致性hash的优势在于当进行扩缩容时，不会破坏全局的映射关系，而导致整个rehash，发起全局的数据迁移，而只会影响局部数据的映射关系。比如缩容减少一个节点，因为第一层映射依然保持不变，原来的请求该分配到哪个节点还是在哪个节点上，只是改变了第二层从环上到节点之间的一个局部映射关系。从环上来看，只会影响这个节点的上一个节点到这个这个节点的这一段弧区间上，整个环上的其它区间由于第一层关系不变，其映射关系不会受到影响。原来去掉的这个节点之间负责的那一段弧上请求，会全部顺移到它的下一个节点，我们只需要把去掉节点负责的数据迁移到下一个节点即可，其它的所有节点不用做任何变更。</p>
<figure><img src="/imgs/column/distribute/220330/02.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p><strong>2.基于Hash槽的数据分片</strong></p>
<p>redis cluster中，数据分片借助与hash槽slot来实现，集群预先划分16384个slot，对于每个请求集群的键值对，根据key 按CRC hash算法散列生成的值唯一匹配一个slot。在redis集群中每个master节点分片负责其中一部分槽位的读写请求，而且当且仅当每个slot都有对应节点负责时，集群才会进入可用状态。当动态扩缩容时，需求将16384个slot做一次再分配，相应数据也要进行迁移。</p>
<p>redis hash槽的算法与一致性hash算法的本质思想是一样的，通过不直接建立请求到节点的映射关系，而是建立一种间接的映射关系。避免在发生扩缩容时对于传统hash算法而言因为模值的变化而打乱整个映射关系。如下图所示，将映射关系分为两层，hash槽通过槽位路由表作为中间映射，因为槽位数量是16384不会变，这样当发生扩缩容时，对于请求而言该映射到哪个槽位还是映射到哪个槽位，即Part1映射不变，只用针对Part2部分中需要迁移的slot产生影响，而并非会让全部请求受到影响；</p>
<figure><img src="/imgs/column/distribute/220330/03.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 3.3 客户端交互流程</h3>
<p><strong>Redis集群交互</strong></p>
<p>redis客户端与集群之间的交互是基于槽位映射表来进行的，该映射表类似于集群的数据分布图，其中维护着槽位与负责该槽位的节点地址信息，客户端根据该映射关系与节点进行直连交互。</p>
<p>redis客户端首次连接集群时，会从集群中拉取一份完整的槽位映射表，缓存在本地。在进行请求访问时，首先会采用CRC16冗余校验法的值对16384取模，映射到具体一个槽位，随之通过查询槽位映射表定位到具体负责该槽位的节点，进而直接与节点进行通信。对于服务端节点来说在收到请求后首先会判断该槽位是否是自己负责的槽位，如果是，则会响应客户端请求。如果不是，例如集群发生扩缩容，此时槽位发生迁移，则会返回Moved/ask指令，引导客户端重定向至正确的节点进行访问。</p>
<p>Moved指令：当迁移已经全部完成，此时该slot已经永久转交给另一个节点时，A节点会返回Moved指令。当Client收到Moved指令后，则会重定向至正确的节点再次进行访问，同时更新本地的槽位映射表，下次直接访问到正确的节点。</p>
<p>ASK指令：ASK指令主要是在迁移过程中，此时该slot的数据可能一部分位于B，而另一部分key可能还在源节点A上。此时对于读请求而言，源节点A在收到请求后，会先在自己的数据库中查找，如果存在则直接返回结果；如果不存在则说明可能已经迁移至B，则会返回ask错误指令，引导client转向目的地节点查询key；</p>
<p>当Client收到Moved/AKS指令后，会去重定向至新的节点访问，同时还会更新本地的槽位映射表，在下次访问时直接定位至正确的节点上；</p>
<figure><img src="/imgs/column/distribute/220330/04.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p><strong>ES集群交互过程</strong></p>
<p>es作为搜索引擎而言，其支持的查询条件不局限于路由key，还包括其它关键字作为条件进行查询，因此其在查询流程不太一样。</p>
<p>es默认的查询模式为query then fetch模式，此模式下整个查询分为query 和 fetch两个步骤，query步骤负责查询符合条件文档id以及汇总排序截取limit等，fetch阶段则是查询完整数据，查询过程中需要进行两次交互。</p>
<figure><img src="/imgs/column/distribute/220330/05.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>（1）client首先会将查询请求发送至任一协调节点；</p>
<p>（2）协调节点在收到请求后，会并发的将请求发送至所有的数据节点；</p>
<p>（3）数据节点在收到请求后根据查询条件在自己负责的分片上查询符合条件的文档集合，不过只取文档 id和排名相关的字段信息，并将数据集返回至协调节点；</p>
<p>（4）协调节点在收到数据节点返回的结果集后，进行汇总排序取limit等，随着得到需要返回的结果集docId集合；</p>
<p>（5）此时query阶段结束，进入fetch阶段，协调节点会根据hash算法对docId进行路由，得到对应结果分别在哪些分片节点后，再次发送请求至数据节点，fetch数据；</p>
<p>（6）数据节点根据docId查询完整结果数据，并将数据再次返回至协调节点；</p>
<p>（7）协调结果进行完数据汇总后，将数据返回至客户端；</p>
<p>除了query then fetch之外，es还有另外一种比较常见的查询模式：query and fetch**。<strong>此模式下向索引的所有分片 （ shard）都发出查询请求， 各分片执行完query 后再执行fetch，即在分片节点中做完查询、排序和截取后将完整的数据一并返回至协调节点。这种搜索方式是最快的。 因为这种查询方法只需要去 shard查询一次。 但是各个 shard 返回的结果的数量之和可能是用户要求的 size 的 n 倍。</strong></p>
<p><strong>Hbase集群交互过程</strong></p>
<p>Hbase集群与redis集群不一样，其基于ZK进行集群状态管理以及元数据维护，集群中数据节点只知道自己负责的数据分片而不知其他节点。因此，在客户端进行集群访问时，通常需要先于ZK进行一次访问，在获取路由表后，再与集群节点直连访问。kafka也是同理。</p>
<p>如下图所示，HBase集群中的读取流程大致如下所示:</p>
<figure><img src="/imgs/column/distribute/220330/06.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>（1）client首先会访问一次zk，查询集群中master节点；</p>
<p>（2）在查询到master地址信息后，Client第二次发起请求访问master，查询路由信息表，路由表中记录着每个region节点负责处理哪个范围的rowkey；</p>
<p>（3）client在查询到路由信息后，会将其缓存在本地，随之基于路由信息表，查询rowkey对应的节点地址信息；</p>
<p>（4）直连数据节点服务器，发送查询请求获取数据；</p>
<p>（5）节点服务器在收到请求后，查询对应的完整数据并将结果返回至客户端；</p>
<p></p>
<h3> 3.4 集群管理</h3>
<h4> <strong>1.集群元数据管理</strong></h4>
<p>在集中式集群中，通常情况下会直接基于第三方协调服务zk来管理和维护集群元数据，zk在作为分布式协调服务之外，本身也是一个内存数据库。不过通常为减轻zk压力以及降低对zk的依赖，因此一般情况下，集群还会基于zk选举出一个master节点，代理zk进行元数据管理和维护以及非master节点的故障转移等相关事务处理。同时，zk中也会备份一份集群的元数据信息，避免master故障后集群元数据丢失，当选举出来的新master，会从zk中拉取一份集群元数据继续进行维护。</p>
<p>在去中心化的集群中，例如redis集群下每个节点都存储有整个集群的元数据信息，包括自己以及其它节点的存活状态、负责的slot槽位信息等。各节点间基于 Gossip 协议来相互交换信息，Gossip协议又叫病毒协议，是基于流行病传播的方式在节点或者进程之间信息交换的协议，在P2P去中心化的分布式系统中应用比较广泛。</p>
<p>Gossip协议的特点在于：</p>
<p>1.去中心化。Gossip 协议不要求任何中心节点，所有节点都可以是对等的，任何一个节点无需知道整个网络状况，只要网络是连通的，就可以把消息散播到全集群。</p>
<p>2.最终一致性。数据的传播过程是由一传十十传百逐步流散开来，整个传播过程需要经历多个周期，可能需要一定的时间，不过在一个处于有界网络的集群里，理论上集群各个节点对该份信息的认知最终都将会收敛一致。</p>
<p>Redis Cluster 中的每个节点都维护一份自己视角下的当前整个集群的状态，主要包括：</p>
<p>a.集群中各节点所负责的slots信息；</p>
<p>b.集群中各节点的存活状态信息；</p>
<p>对于集群中每个节点而言，会按照一定的频率周期，从自己的节点列表中随机挑选部分最长时间没有与它进行过通信的节点，对这些节点发送ping消息，并附加上自己视角下的集群状态信息，节点在收到其他节点发送的ping消息后再回复一个pong，以交换彼此的状态信息，对于差异化数据则版本决定是否更新本地状态数据，最终集群内所有节点达成统一认知。</p>
<figure><img src="/imgs/column/distribute/220330/07.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p><strong>优点：</strong></p>
<p>（1）容错。Gossip 协议具有天然的分布式系统容错特性，集群中任何节点的状态发生变化，例如上下线都不会影响 Gossip 消息的传播，且当节点重新上线后，依然会接收集群内其他节点的状态数据，并最终与其他节点达成一致。</p>
<p><strong>缺点：</strong></p>
<p>（1）Gossip是最终一致性，当集群状态发生变更时，变更数据需要经过多伦同步，整个集群的节点才会达成一致，相比于ZK而言其感知会出现明显延迟；</p>
<p>（2）Gossip协议下，每个节点按自己的节奏频率周期性的发送消息，而由于同步全量状态信息使得Gossip包体积较大，会存在一定的网络压力。其次由于随机的发送消息，而收到消息的节点也会重复该步骤，不可避免的引起同一节点消息多次接收，增加消息处理压力。</p>
<h4> <strong>2.集群状态检测</strong></h4>
<p>对于集中式集群模式的Hbase、kafka来说，对于集群的状态检测也是基于ZooKeeper 来做的，每台节点机器在启动时，都需要事先在zookeeper中注册一个节点，zk会与该节点维持一个会话关系，基于心跳检测来感知节点的状态变化。</p>
<p>具体来说，客户端会周期性的向服务端发送PING请求来保持心跳，一旦客户端发生故障，超过限定时间后，Zookeeper服务器会判定会话超时，并基于Watch机制实时通知给Master节点，master进行元数据更新以及后续的故障转移，以此来完成对集群中节点的状态检测。</p>
<figure><img src="/imgs/column/distribute/220330/08.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>跟大多数分布式系统一样，Redis cluster也是基于heart beat来进行节点状态检测。redis内部节点基于Gossip协议通信交互，具体来说，每个节点会定期会与其它节点发送ping-pong消息进行交互，以此来感知对方是否状态发生变化。对于集群中每个节点而言，每次随机挑选5个最长时间没有与它进行过通信的节点，对这些节点发送ping消息，节点在收到其他节点发送的ping消息后再回复一个pong。每个节点根据自己是否收到pong消息的结果来感知其它节点的存活状态。</p>
<p><strong>节点上线</strong></p>
<p>Redis Cluster 加入新节点时，首先需要在客户端需要执行 CLUSTER MEET 命令，命令中需要指定新增节点的地址信息。</p>
<figure><img src="/imgs/column/distribute/220330/09.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>redis集群中任一节点在收到 MEET命令后，会根据据 MEET 命令中的 IP 地址和端口号，向新节点发送一条 MEET 消息。</p>
<p>接着，新节点在收到Meet消息后，会向节点一返回一条PONG消息。</p>
<p>节点一接收到新节点返回的PONG消息后，得知新节点已经成功的接收了自己发送的MEET消息。随着将该新节点加入自己的元数据信息库中，从而完成了新节点接入的握手操作。</p>
<p>Meet成功之后，节点一会在下次周期性信息交互过程中，将新节点加入的消息传递出去。因为节点之间基于Gossip协议进行工作，在随着时间的推移，最终集群的所有节点都感知它的存在。</p>
<p><strong>节点下线</strong></p>
<p>redis集群中节点会周期性心跳同步，当某一节点在发其ping请求后，发现某个节点超过一定未给出回复，那么它会把这个节点的状态标记为pfail预下线的状态。</p>
<figure><img src="/imgs/column/distribute/220330/10.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>节点一会在下一轮交互中，会将节点二疑似下线消息同步出去。对于节点三在同步到这条消息后，并不会直接把自己的节点列表中该故障节点的状态也标记为预下线，因为这时候可能只是该节点一个人的主观认为下线，只是先记录下来节点一在XX时间认为节点二疑似下线；同时在节点三的下一轮ping-pong中，会优先选择节点二进行交互；</p>
<figure><img src="/imgs/column/distribute/220330/11.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>随着时间的推移，经过多轮同步后，对于节点X也超时未收到节点二的PONG，也认为节点二疑似下线，此时节点X发现集群中大部分超过一半的节点都认为它下线时，节点X会把该节点二标记为fail下线状态，并同时在集群中广播该节点fail。所有收到该消息的节点在发现某节点已经被标记为fail状态时，都会更新自己的节点列表将它标记为下线状态，如果该节点是leader副本的节点，则其对应的slave节点在收到下线消息会开始进行选举，进入故障转移流程。</p>
<figure><img src="/imgs/column/distribute/220330/12.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 3.5 高可用性</h3>
<p>对于分布式存储系统而言，集群高可用保证在于解决两个前提，第一个是要保证数据的可靠性，即当节点机器出现故障时，数据不能因此出现丢失。第二，在故障发生后集群需具备自动故障转移机制。</p>
<h4> <strong>1.数据的<strong><strong>可靠性</strong></strong>保证</strong></h4>
<p>通常而言，数据的可靠性都是基于多副本机制来解决的，即构建主从模式，为每个主节点部署多个slave从节点，当主节点故障时由从节点顶替。</p>
<p>对于多副本机制而言，其核心问题在于如何解决多副本之间的一致性。在多副本数据一致性问题上，一般会有两种解决方案。一种是基于ACK应答机制下的主从复制机制；另一种是目前业界更为主流的方案，基于分布式共识算法Paxos或者Raft来解决多副本之间的一致性问题。</p>
<p><strong>主从复制+<strong><strong>ACK</strong></strong>机制</strong></p>
<p>基于ACK的应答机制十分常见，首先从同步方式上来说又分为推模式和拉模式，拉模式相对而言十分常见，例如mysql的主从复制就是拉模式。两种模式的比较如下：</p>
<table>
<thead>
<tr>
<th><strong>模式</strong></th>
<th><strong>代表产品</strong></th>
<th><strong>优劣势</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>拉</td>
<td>mysql、es\kafka等</td>
<td><strong>优势：</strong> 从节点可基于自身消费能力处理同步数据； <strong>劣势：</strong> 数据同步及时性相对差一点</td>
</tr>
<tr>
<td>推</td>
<td>redis</td>
<td><strong>优势：</strong> 数据同步相对更加及时； <strong>劣势：</strong> 从节点一旦同步过程中出现重启，则重新启动后需要再次完整的同步一次全量数据。因此，在这种模式下一般还需要配备相关的缓冲区机制。例如redis中会配置同步缓冲区，在commit之前同时会先在缓冲区中备份一份。从节点重启后同步位移还在缓冲区中，则从缓冲区增量同步进行对齐。</td>
</tr>
</tbody>
</table>
<p>从应答机制的角度上来说又分为异步复制、半同步复制与全同步复制。</p>
<p>（1）异步复制。主节点在收到写请求后，会将数据写入内存以及同步至中继日志后，进行commit提交。随后通知slave节点过来复制，slave是否成功复制主节点并不关心。对于异步复制而言，它是存在有数据丢失风险的，当master宕机时，从节点可能还没来得及复制数据。</p>
<p>（2）半同步复制。半同步复制每次都会至少有一个从节点ack应答，相对而言它可以有更强的一个数据一致性保证。但还是会存在不一致的问题的场景，比如脑裂问题，导致数据丢失。当发生网络分区时，master节点和一个从节点被划分到一个区域与其它的从节点分离，这时其它从节点发现与master失联后就会选出一个新的master来提供服务，但是原来的master并不知道自己被失联了，而且每次依然会有一个从节点给它ack应答，因此它也可以正常处理客户端请求，这个时候就会存在两个master同时对外提供服务，接收客户端的写请求，而当网络分区结束后旧的master发现有新的master了，就会向新的master看齐，丢弃掉脑裂期间客户端提交的数据了。</p>
<p>（3）全同步复制。全同步复制则是必须每个从节点都给出ack应答才提交数据，这样可以避免脑裂情况发生，因为当发生脑裂时旧master因为不能得不到所有从节点的ack应答，所以是不会处理客户端的请求写从而旧可以避免脑裂问题。但是它的问题是在于性能较低，因为需要全部副本的响应，如果其中一个节点响应较慢则会拖慢整体的提交时间。</p>
<p><strong>分布式共识算法</strong></p>
<p>对于paxos、raft这类共识算法来说，因为它采用的多数决的机制，在出现网络分区时，只会存在有一个大多数而不会同时出现两个大多数。如果master位于网络分区后的少数派中，那这个master在接收到用户请求后，由于与它连通的只有少数节点达不到超过一半节点的支持，因此它是无法提交数据的。只会由多数节点构成的集群选举出来的新master这一个master对外提供服务；如果master处于多数节点构成的集群中，对于分隔出去的少数派节点构成的集群中因为节点数量不超过一半，所以根本就选取不出来一个新master。因此对于共识算法来说天然不会出现脑裂现象，相比于主从复制+ack的做法来说它能够带来更强的一致性保证。</p>
<p>分布式共识算法核心优势在于：</p>
<p>（1）容错。因为其多数派的原则，在出现网络分区时，只要不要超过半数以上的节点不可用，整个共识系统仍然是满足大多数原则的，仍然可以正常运转，在可用性方面具备非常强的一个容错能力。</p>
<p>（2）在强一致性的同时具备一定的性能优势。相比于全同步复制而言，因为多数决的机制，每次commit并不需要全部的节点同意，因此性能上而言相比于全同步复制更具有优势。</p>
<p>因为共识算法它所带来的强一致性保证和对集群节点的超强的容错能力，所以现在越来越多的分布式存储系统在解决多副本一致性问题上都在使用共识算法，比如new sql的tidb，内部就是基于raft算法以及mysql自身也推出了MGR集群，内部就是使用的mutil-paxos算法取代传统的半同步复制来解决多副本的一致性问题。</p>
<h4> <strong>2.故障转移</strong></h4>
<p>一般来说，对于引入第三方协调服务的存储系统来说，会事先在集群中选举一个Master，此master并非我们所说的主从复制中的leader副本节点。以kafka为例，在Kafka集群中这类节点称之为Controller。当节点发生故障时，会由ZK将故障通知至Controller节点，此时触发controller节点进行故障转移。</p>
<p>按故障节点类型来说分为以下几类：</p>
<p>（1）leader副本节点故障。当故障节点为某分片的leader副本节点时，则直接会由Controller负责为该分区重新选举新的Leader副本；Controller在watch关于某leader副本节点故障后，则会直接从该leader副本节点的从节点列表中找到位移提交最大也就是数据最新的节点作为新的master。</p>
<p>（2）Controller节点故障。当故障节点为Controller自身时，则由借助于ZK从集群中的其他leader节点中选取一个新的controller节点。整个选举过程本质上也是ZK的一次分布式锁的抢占过程。当controller产生时，会从ZK中拉取一份集群元数据备份存储到本地。同时一般来说Controller节点并不是单独的物理节点实例，而是由集群中某leader分片节点担任。当controller节点故障时，同时也是leader副本节点故障，因此当新master产生后，同时还会为旧master节点的slave节点中选举新的leader副本。</p>
<p>对于redis、ES这些在集群内部实现自治的集群系统而言，则通常会在集群内部实现选举算法，来实现故障转移。</p>
<p>当集群中某节点在发现半数以上的节点都认为某节点疑似下线后，会将该节点标记为确定下线并在集群中进行广播。当slave收到节点下线通知后，判断如果是自己的master节点，则触发选举流程，开始进行故障转移。</p>
<p>以redis为例其选举算法流程如下：</p>
<figure><img src="/imgs/column/distribute/220330/13.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>（1）slave收到master下线通知，开启一个纪元，将currentEpoch+1，开启选举；</p>
<p>（2）slave计算发起投票的延时时间。对于所有有资格参选的节点来说，并不会一收到选举通知后立马就开始发起选举，而是会先延迟一段时间。其延时时间的计算基于当前slave复制的数据总量，如果总量越高比较数据越接近master，那么它的延时时间会越短，被选中的概率也就越大。</p>
<p>（3）发起投票。slave在延时时间到期后，会向集群广播投票请求；</p>
<p>（4）投票。集群中只有master节点具备投票权利，且在每个纪元中只有一次投票机会，master的投票原则是先到先得。当master收到投票请求后，会先基于自身的元数据审查该节点是否为故障节点的slave节点，如果是且当前还未给其他的slave节点投过票，则会将票投给该节点，因此理论上而言，数据越新的从节点获得票数会越高；</p>
<p>（5）票数统计。每个节点在达到指定时间后会统计自身的票数，因为每个节点只能投一次票，所以得票超过一半以上的只会有一个节点。</p>
<p>（6）广播通知。当该从节点发现自己得票一半以后，就会像整个集群中广播新master节点的消息，让其它节点都知道它已经是最新的主节点，其它的主节点在收到后会更新自己的节点表，从节点则会将它设为新的主节点，此时选举结束。如果有一些从节点发现自己既没有达到半数以上的投票，又在指定时间内没有收到新master的消息，则会开启新的纪元，再次发起选票，但是此次其它的主节点发现如果直接的节点列表中该主节点的状态不是fail状态或者对该纪元已经进行过投票，不会再进行投票。</p>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/column/distribute/220330/00.png" type="image/png"/>
    </item>
    <item>
      <title>分布式系统高可用详解</title>
      <link>https://liuyueyi.github.io/tutorial/column/arch/distribute/%E9%AB%98%E5%8F%AF%E7%94%A8/</link>
      <guid>https://liuyueyi.github.io/tutorial/column/arch/distribute/%E9%AB%98%E5%8F%AF%E7%94%A8/</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">分布式系统高可用详解</source>
      <description>本专栏将主要讲解当前常用的各大系统的高可用方案 常见的高可用技术方案 Redis/ES/HBase的高可用方案</description>
      <pubDate>Mon, 29 Jul 2024 08:58:55 GMT</pubDate>
      <content:encoded><![CDATA[<p>本专栏将主要讲解当前常用的各大系统的高可用方案</p>
<ul class="task-list-container">
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-0" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-0"> <a href="01.%E5%B8%B8%E8%A7%81%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88">常见的高可用技术方案</a></label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-1" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-1"> <a href="02.Redis%E3%80%81ES%E3%80%81Hbase%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8%E6%96%B9%E6%A1%88">Redis/ES/HBase的高可用方案</a></label></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>基础架构</title>
      <link>https://liuyueyi.github.io/tutorial/column/arch/distribute/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/</link>
      <guid>https://liuyueyi.github.io/tutorial/column/arch/distribute/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">基础架构</source>
      <description>分布式系统常见的基础架构设计说明</description>
      <pubDate>Mon, 29 Jul 2024 08:58:55 GMT</pubDate>
      <content:encoded><![CDATA[<p>分布式系统常见的基础架构设计说明</p>
]]></content:encoded>
    </item>
    <item>
      <title>理论基础</title>
      <link>https://liuyueyi.github.io/tutorial/column/arch/distribute/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/</link>
      <guid>https://liuyueyi.github.io/tutorial/column/arch/distribute/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">理论基础</source>
      <description>分布式系统相关的理论基础</description>
      <pubDate>Mon, 29 Jul 2024 08:58:55 GMT</pubDate>
      <content:encoded><![CDATA[<p>分布式系统相关的理论基础</p>
]]></content:encoded>
    </item>
    <item>
      <title>raft共识算法</title>
      <link>https://liuyueyi.github.io/tutorial/column/arch/distribute/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/Raft%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95.html</link>
      <guid>https://liuyueyi.github.io/tutorial/column/arch/distribute/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/Raft%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">raft共识算法</source>
      <description>Raft共识算法 推荐有兴趣的小伙伴，查看 Raft 算法动画演示 Raft算法详解 - 知乎</description>
      <category>分布式</category>
      <category>设计模式</category>
      <category>理论基础</category>
      <pubDate>Tue, 12 Jul 2022 19:27:54 GMT</pubDate>
      <content:encoded><![CDATA[<h1> Raft共识算法</h1>
<blockquote>
<p>推荐有兴趣的小伙伴，查看</p>
<ul>
<li><a href="http://thesecretlivesofdata.com/raft/" target="_blank" rel="noopener noreferrer">Raft 算法动画演示</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/32052223" target="_blank" rel="noopener noreferrer">Raft算法详解 - 知乎</a></li>
</ul>
</blockquote>
<p>为了解决paxos的复杂性，raft算法提供了一套更易理解的算法基础</p>
<p>角色划分：</p>
<ul>
<li>Leader：领导者，接受客户端请求，并向Follower同步请求，当数据同步到大多数节点上后告诉Follower提交日志</li>
<li>Follow: 接受并持久化Leader同步的数据，在Leader告之日志可以提交之后，提交</li>
<li>Candidate：Leader选举过程中的临时角色，向其他节点拉选票，得到多数的晋升为leader，选举完成之后不存在这个角色</li>
</ul>
<figure><img src="/imgs/column/distribute/220708/raft01.jpg" alt="Raft角色" tabindex="0" loading="lazy"><figcaption>Raft角色</figcaption></figure>
<p>Follower只响应其他服务器的请求。如果Follower超时没有收到Leader的消息，它会成为一个Candidate并且开始一次Leader选举。收到大多数服务器投票的Candidate会成为新的Leader。Leader在宕机之前会一直保持Leader的状态。</p>
<h2> 选举</h2>
<p>Raft算法将时间分为一个个的任期（term），每一个term的开始都是Leader选举。在成功选举Leader之后，Leader会在整个term内管理整个集群。如果Leader选举失败，该term就会因为没有Leader而结束。</p>
<p>Raft 使用心跳（heartbeat）来检测Leader是否存活，Leader向所有Followers周期性发送heartbeat，表示自己还活着</p>
<p>如果Follower在选举超时时间内没有收到Leader的heartbeat，就会等待一段随机的时间后发起一次Leader选举</p>
<figure><img src="/imgs/column/distribute/220708/raft02.jpg" alt="Raft选举" tabindex="0" loading="lazy"><figcaption>Raft选举</figcaption></figure>
<p>选举的核心要点在于：</p>
<ul>
<li>follower一段时间没有接受到leader的心跳，认为leader挂了，变成candidate状态。 为了避免选举冲突，这个超时时间是一个150/300ms之间的随机数</li>
<li>candidate，会重置计时器，先投自己一票，向其他节点拉选票</li>
<li>得到多数选票的晋升为主节点</li>
<li>当多个节点的选票相同，则选举失败；之后等待计时器超时的follower会变成candidate，将任期加一并开始新一轮的投票。</li>
</ul>
<h2> 日志同步</h2>
<p>Leader接受外部请求，并将请求作为LogEntries加入日志中，然后复制给其他的Follow节点，</p>
<ul>
<li>大部分结点响应时才提交日志</li>
<li>通知所有follower结点日志已提交</li>
<li>所有follower也提交日志</li>
</ul>
<figure><img src="/imgs/column/distribute/220708/raft03.jpg" alt="Raft日志同步" tabindex="0" loading="lazy"><figcaption>Raft日志同步</figcaption></figure>
<h2> 脑裂问题</h2>
<blockquote>
<p>指在一个高可用（HA）系统中，当联系着的两个节点断开联系时，本来为一个整体的系统，分裂为两个独立节点，这时两个节点开始争抢共享资源， 结果会导致系统混乱，数据损坏。</p>
</blockquote>
<p>假设<code>A~E</code>五个结点，B是leader。 如果发生“脑裂”，A、B成为一个子分区，C、D、E成为一个子分区。</p>
<ul>
<li>此时C、D、E会发生选举，选出C作为新term的leader。这样我们在两个子分区内就有了不同term的两个leader</li>
<li>这时如果有客户端写A时, 因为B无法复制日志到大部分follower所以日志处于uncommitted未提交状态。</li>
<li>而同时另一个客户端对C的写操作却能够正确完成，因为C是新的leader，它只知道D和E。</li>
<li>当网络通信恢复，B能够发送心跳给C、D、E了，却发现有新的leader了，因为C的term值更大，所以B自动降格为follower。 然后A和B都回滚未提交的日志，并从新leader那里复制最新的日志。</li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/column/distribute/220708/raft01.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>zab协议</title>
      <link>https://liuyueyi.github.io/tutorial/column/arch/distribute/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/ZAB%E5%8D%8F%E8%AE%AE.html</link>
      <guid>https://liuyueyi.github.io/tutorial/column/arch/distribute/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/ZAB%E5%8D%8F%E8%AE%AE.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">zab协议</source>
      <description>Zookeeper Atomic Broadcast, ZK原子广播协议 ZAB(Zookeeper Atomic Broadcast) 协议是为分布式协调服务ZooKeeper专门设计的一种支持崩溃恢复的一致性协议，基于该协议，ZooKeeper 实现了一种 主从模式的系统架构来保持集群中各个副本之间的数据一致性。 zookeeper核心之ZAB协议就这么简单！</description>
      <category>分布式</category>
      <category>设计模式</category>
      <category>理论基础</category>
      <pubDate>Tue, 12 Jul 2022 19:27:54 GMT</pubDate>
      <content:encoded><![CDATA[<h1> Zookeeper Atomic Broadcast, ZK原子广播协议</h1>
<blockquote>
<p>ZAB(Zookeeper Atomic Broadcast) 协议是为分布式协调服务ZooKeeper专门设计的一种支持崩溃恢复的一致性协议，基于该协议，ZooKeeper 实现了一种 主从模式的系统架构来保持集群中各个副本之间的数据一致性。</p>
<ul>
<li><a href="https://segmentfault.com/a/1190000037550497" target="_blank" rel="noopener noreferrer">zookeeper核心之ZAB协议就这么简单！</a></li>
</ul>
</blockquote>
<p><strong>角色划分</strong></p>
<ul>
<li>Leader: 负责整个Zookeeper 集群工作机制中的核心
<ul>
<li>事务请求的唯一调度和处理者，保证集群事务处理的顺序性</li>
<li>集群内部各服务器的调度者</li>
</ul>
</li>
<li>Follower：Leader的追随者
<ul>
<li>处理客户端的非实物请求，转发事务请求给 Leader 服务器</li>
<li>参与事务请求 Proposal 的投票</li>
<li>参与 Leader 选举投票</li>
</ul>
</li>
<li>Observer：是 zookeeper 自 3.3.0 开始引入的一个角色，
<ul>
<li>它不参与事务请求 Proposal 的投票，</li>
<li>也不参与 Leader 选举投票</li>
<li>只提供非事务的服务（查询），通常在不影响集群事务处理能力的前提下提升集群的非事务处理能力。</li>
</ul>
</li>
</ul>
<p><strong>消息广播</strong></p>
<figure><img src="/imgs/column/distribute/220708/zab00.jpg" alt="ZAB消息广播" tabindex="0" loading="lazy"><figcaption>ZAB消息广播</figcaption></figure>
<p>leader再接收到事务请求之后，将请求转换为事务Proposal提案，leader会为每个follower创建一个队列，将该事务proposal放入响应队列，保证事务的顺序性；</p>
<p>然后再在队列中按照顺序向其它节点广播该提案；</p>
<p>follower收到后会将其以事务的形式写入到本地日志中，并且向leader发送Ack信息确认</p>
<p>有一半以上的follower返回Ack信息时， leader会提交该提案并且向其它节点发送commit信息</p>
<p><strong>事务有序性</strong></p>
<p>队列 + 事务递增ID（ZXID）来保证提案的有序性，</p>
<p>ZXID:</p>
<ul>
<li>高32位：纪元epoch，新选举一个leader，纪元+1</li>
<li>低32位：计数器counter，单调递增的数字</li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/column/distribute/220708/zab00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>三阶段协议</title>
      <link>https://liuyueyi.github.io/tutorial/column/arch/distribute/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E4%B8%89%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4%E5%8D%8F%E8%AE%AE.html</link>
      <guid>https://liuyueyi.github.io/tutorial/column/arch/distribute/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E4%B8%89%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4%E5%8D%8F%E8%AE%AE.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">三阶段协议</source>
      <description>在两阶段的基础上进行扩展，将第一阶段划分两部，cancommit + precommit，第三阶段则为 docommit 第一阶段 cancommit 该阶段协调者会去询问各个参与者是否能够正常执行事务，参与者根据自身情况回复一个预估值，相对于真正的执行事务，这个过程是轻量的 第二阶段 precommit 本阶段协调者会根据第一阶段的询盘结果采取相应操作，询盘结果主要有 3 种： 第一阶段响应 步骤 所有的参与者都返回确定 1.协调者向所有的事务参与者发送事务执行通知 2.参与者收到通知后执行事务但不提交 3.参与者将事务执行情况返回给客户端 一个或多个参与者返回否定信息 无法执行，向各个参与者发出 abort 通知，请求退出预备状态 协调者等待超时 同上</description>
      <category>分布式</category>
      <category>设计模式</category>
      <category>理论基础</category>
      <pubDate>Tue, 12 Jul 2022 19:27:54 GMT</pubDate>
      <content:encoded><![CDATA[<p>在两阶段的基础上进行扩展，将第一阶段划分两部，cancommit + precommit，第三阶段则为 docommit</p>
<p><strong>第一阶段 cancommit</strong></p>
<p>该阶段协调者会去询问各个参与者是否能够正常执行事务，参与者根据自身情况回复一个预估值，相对于真正的执行事务，这个过程是轻量的</p>
<p><strong>第二阶段 precommit</strong></p>
<p>本阶段协调者会根据第一阶段的询盘结果采取相应操作，询盘结果主要有 3 种：</p>
<table>
<thead>
<tr>
<th>第一阶段响应</th>
<th>步骤</th>
</tr>
</thead>
<tbody>
<tr>
<td>所有的参与者都返回确定</td>
<td>1.协调者向所有的事务参与者发送事务执行通知 <br> 2.参与者收到通知后执行事务但不提交 <br> 3.参与者将事务执行情况返回给客户端</td>
</tr>
<tr>
<td>一个或多个参与者返回否定信息</td>
<td>无法执行，向各个参与者发出 abort 通知，请求退出预备状态</td>
</tr>
<tr>
<td>协调者等待超时</td>
<td>同上</td>
</tr>
</tbody>
</table>
<figure><img src="/imgs/column/distribute/220708/3pc00.jpg" alt="3PC回滚" tabindex="0" loading="lazy"><figcaption>3PC回滚</figcaption></figure>
<p><strong>第三阶段 docommit</strong></p>
<p>如果第二阶段事务未中断，那么本阶段协调者将会依据事务执行返回的结果来决定提交或回滚事务，分为 3 种情况：</p>
<table>
<thead>
<tr>
<th>第二阶段响应</th>
<th>步骤</th>
</tr>
</thead>
<tbody>
<tr>
<td>所有的参与者都能正常执行事务</td>
<td>1.向所有参与者提交commit <br> 2.所有参与者在收到通知之后执行 commit 操作释放资源 <br> 3.参与者向协调者反馈事务提交结果</td>
</tr>
<tr>
<td>一个或多个参与者执行事务失败</td>
<td>协调者认为事务无法成功执行 <br> 1.向所有参与者提交rollback <br> 2.所有参与者执行rollback回滚 <br> 3.参与者向协调者反馈事务回滚结果</td>
</tr>
<tr>
<td>协调者等待超时</td>
<td>同上</td>
</tr>
</tbody>
</table>
<p>事务提交流程图：</p>
<figure><img src="/imgs/column/distribute/220708/3pc01.jpg" alt="3PC提交" tabindex="0" loading="lazy"><figcaption>3PC提交</figcaption></figure>
<p>事务回滚流程图：</p>
<figure><img src="/imgs/column/distribute/220708/3pc02.jpg" alt="3PC回滚" tabindex="0" loading="lazy"><figcaption>3PC回滚</figcaption></figure>
<p>在本阶段如果因为协调者或网络问题，导致参与者迟迟不能收到来自协调者的 commit 或 rollback 请求，那么参与者将不会如两阶段提交中那样陷入阻塞，而是等待超时后继续 commit，相对于两阶段提交虽然降低了同步阻塞，但仍然无法完全避免数据的不一致</p>
<p><strong>特点</strong></p>
<ul>
<li>降低了阻塞与单点故障：
<ul>
<li>参与者返回 CanCommit 请求的响应后，等待第二阶段指令，若等待超时/协调者宕机，则自动 abort，降低了阻塞；</li>
<li>参与者返回 PreCommit 请求的响应后，等待第三阶段指令，若等待超时/协调者宕机，则自动 commit 事务，也降低了阻塞；</li>
</ul>
</li>
<li>数据不一致问题依然存在
<ul>
<li>比如第三阶段协调者发出了 abort 请求，然后有些参与者没有收到 abort，那么就会自动 commit，造成数据不一致</li>
</ul>
</li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/column/distribute/220708/3pc00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>专栏</title>
      <link>https://liuyueyi.github.io/tutorial/column/</link>
      <guid>https://liuyueyi.github.io/tutorial/column/</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">专栏</source>
      <description>技术专栏 ❤️ 管理 一灰灰的技术管理 📝 架构 分布式专栏 🏪 项目 实战项目 &amp;amp; 配套教程</description>
      <pubDate>Fri, 22 Dec 2023 03:01:10 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 技术专栏</h1>
<h2> ❤️ 管理</h2>
<p><a href="tech/manager">一灰灰的技术管理</a></p>
<h2> 📝 架构</h2>
<p><a href="/tutorial/column/arch/" target="blank">分布式专栏</a></p>
<h2> 🏪 项目</h2>
<p><a href="/tutorial/column/app/" target="blank">实战项目 &amp; 配套教程</a></p>
]]></content:encoded>
    </item>
    <item>
      <title>16.从零开始：SpringBoot配置动态刷新的详细解析与实践！</title>
      <link>https://liuyueyi.github.io/tutorial/spring/basic/%E9%85%8D%E7%BD%AE/231030-SpringBoot%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E5%8A%A8%E6%80%81%E9%85%8D%E7%BD%AE%E5%88%B7%E6%96%B0%E6%96%B9%E6%A1%88.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/basic/%E9%85%8D%E7%BD%AE/231030-SpringBoot%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E5%8A%A8%E6%80%81%E9%85%8D%E7%BD%AE%E5%88%B7%E6%96%B0%E6%96%B9%E6%A1%88.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">16.从零开始：SpringBoot配置动态刷新的详细解析与实践！</source>
      <description>关于SpringBoot的自定义配置源、配置刷新之前也介绍过几篇博文；最近正好在使用apollo时，排查配置未动态刷新的问题时，看了下它的具体实现发现挺有意思的； 接下来我们致敬经典，看一下如果让我们来实现配置的动态刷新，应该怎么搞？</description>
      <category>SpringBoot</category>
      <category>基础系列</category>
      <category>配置</category>
      <pubDate>Mon, 30 Oct 2023 07:46:58 GMT</pubDate>
      <content:encoded><![CDATA[<p>关于SpringBoot的自定义配置源、配置刷新之前也介绍过几篇博文；最近正好在使用apollo时，排查配置未动态刷新的问题时，看了下它的具体实现发现挺有意思的；</p>
<p>接下来我们致敬经典，看一下如果让我们来实现配置的动态刷新，应该怎么搞？</p>
<!-- more -->
<h2> I. 配置使用姿势</h2>
<p>既然要支持配置的动态刷新，那么我们就得先看一下，在SpringBoot中，常见的配置使用姿势有哪些</p>
<h3> 1. @Value注解绑定</h3>
<p>直接通过<code>@Value</code>注解，将一个对象得成员变量与Environment中的配置进行绑定，如</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意：<code>@Value</code>支持SpEL</p>
<h3> 2. @ConfigurationProperties绑定</h3>
<p>通过<code>@ConfigurationProperties</code>注解声明一个配置类，这个类中的成员变量都是从<code>Environment</code>中进行初始化</p>
<p>如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. Environment.getProperty()直接获取配置</h3>
<p>直接从上下文中获取配置，也常见于各种使用场景中，如</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2> II. 配置刷新</h2>
<p>接下来我们看一下，如何实现配置刷新后，上面的三种使用姿势都能获取到刷新后的值</p>
<h3> 1. 自定义一个属性配置源</h3>
<p>自定义一个配置源，我们直接基于内存的<code>ConcurrentHashMap</code>来进行模拟，内部提供了一个配置更新的方法，当配置刷新之后，还会对外广播一个配置变更事件</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来就需要将这个自定义的配置元，注册到 <code>environment</code> 上下文，在这里我们可以借助<code>ApplicationContextInitializer</code>来实现，在上下文初始化前，完成自定义配置注册</p>
<blockquote>
<ul>
<li><a href="https://spring.hhui.top/spring-blog/2022/09/27/220927-Spring%E6%89%A9%E5%B1%95%E4%B9%8B%E5%AE%B9%E5%99%A8%E5%88%B7%E6%96%B0%E5%89%8D%E5%9B%9E%E8%B0%83ApplicationContextInitializer/" target="_blank" rel="noopener noreferrer">【扩展点】 容器刷新前回调ApplicationContextInitializer | 一灰灰Blog</a></li>
</ul>
</blockquote>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来注册这个扩展点，直接选择在项目启动时，进行注册</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. Environment配置刷新</h3>
<p>envionment实时获取配置的方式，支持配置刷新应该相对简单，如直接吐出一个接口，支持更新我们自定义配置源的配置，不做任何变更，这个配置应该时同时更新的</p>
<p>首先提供一个Spring的工具类，用于更简单的获取Spring上下文</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>配置更新的示例</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>执行验证一下:</p>
<figure><img src="/imgs/231030/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 3. <code>@ConfigurationProperties</code> 配置刷新</h3>
<blockquote>
<p><a href="https://spring.hhui.top/spring-blog/2023/06/27/230627-SpringBoot%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7%E9%85%8D%E7%BD%AE%E7%BB%91%E5%AE%9A%E5%AE%9E%E7%8E%B0%E4%BB%8B%E7%BB%8D/" target="_blank" rel="noopener noreferrer">【基础系列】自定义属性配置绑定极简实现姿势介绍 | 一灰灰Blog</a></p>
</blockquote>
<p>之前在介绍自定义属性配置绑定时介绍过，通过<code>Binder</code>来实现绑定配置的Config对象动态刷新，我们这里同样可以实现配置变更时，主动刷新<code>@ConfigurationProperties</code>注解绑定的属性</p>
<p>具体实现如下，</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意上面的实现，分三类：</p>
<ol>
<li><code>public &lt;T&gt; void bind(Bindable&lt;T&gt; bindable)</code>: 具体实现绑定配置刷新的逻辑</li>
</ol>
<p>核心思想就是将当前对象与environment配置进行重新绑定</p>
<ol start="2">
<li><code>public void run</code>: binder初始化</li>
</ol>
<p>在应用启动之后进行回调，确保是在environment准备完毕之后回调，获取用于属性配置绑定的binder，避免出现<code>envionment</code>还没有准备好</p>
<p>也可以借助实现<code>EnvironmentPostProcessor</code>来实现</p>
<ol start="3">
<li><code>public void refreshConfig(ConfigChangeListener.ConfigChangeEvent event)</code>： 配置刷新</li>
</ol>
<p>通过<code>@EventListener</code>监听配置变更事件，找到所有的<code>ConfigurationProperties</code>修饰对象，执行重新绑定逻辑</p>
<p>接下来我们验证一下配置变更是否会生效</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>定义一个UserConfig来接收<code>config</code>前缀开始的配置，通过update接口来更新相关配置，更新完毕之后返回UserConfig的结果</p>
<figure><img src="/imgs/231030/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 4. @Value 配置刷新</h3>
<p>最后我们再来看一下@Value注解绑定的配置的刷新策略，很久很久之前我也介绍一篇博文，如何实现动态刷新，欢迎查看</p>
<blockquote>
<p><a href="https://spring.hhui.top/spring-blog/2021/08/01/210801-SpringBoot%E5%BA%94%E7%94%A8%E7%AF%87-Value%E6%B3%A8%E8%A7%A3%E6%94%AF%E6%8C%81%E9%85%8D%E7%BD%AE%E8%87%AA%E5%8A%A8%E5%88%B7%E6%96%B0%E8%83%BD%E5%8A%9B%E6%89%A9%E5%B1%95/" target="_blank" rel="noopener noreferrer">【基础系列】SpringBoot应用篇@Value注解支持配置自动刷新能力扩展 | 一灰灰Blog</a></p>
</blockquote>
<p>其核心思想就是找出所有<code>@Value</code>绑定的成员变量，当监听到配置变更之后，通过反射的方式进行刷新</p>
<p>关键的实现如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的实现，主要利用到<code>BeanPostProcessor</code>，在bean初始化之后，扫描当前bean中是否有<code>@Value</code>绑定的属性，若有，则注册到自定义的<code>SpringValueRegistry</code>中</p>
<p><strong>注意事项：</strong></p>
<ol>
<li><code>@Value</code>有两种绑定姿势，直接放在成员变量上，以及通过方法进行注入</li>
</ol>
<p>所以上面的实现策略中，有<code>Field</code>和<code>Method</code>两种不同的处理策略；</p>
<ol start="2">
<li><code>@Value</code>支持SpEL表达式，我们需要对配置key进行解析</li>
</ol>
<p>相关的源码，推荐直接在下面的项目中进行获取，demo中的实现也是来自apollo-client</p>
<p>接下来再看一下注册配置绑定的实现，核心方法比较简单，两个，一个注册，一个刷新</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>SpringValue的构建，主要就是基于反射需要使用到的一些关键信息的组成上；可以按需进行设计补充</p>
<p>到此，关于@Value注解的配置动态刷新就已经实现了，接下来写几个demo验证一下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/231030/02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 5. 小结</h3>
<p>本文主要介绍了项目中配置的动态刷新的实现方案，也可以看作是apollo配置中心的简易实现原理，其中涉及到的知识点较多，下面做一个简单的小结</p>
<ol>
<li>配置的三种使用姿势</li>
</ol>
<ul>
<li><code>@Value</code>绑定</li>
<li><code>@ConfigurationProperties</code>绑定对象</li>
<li><code>environment.getProperty()</code></li>
</ul>
<ol start="2">
<li>自定义配置源加载</li>
</ol>
<ul>
<li><code>environment.getPropertySources().addFirst(MapPropertySource)</code></li>
</ul>
<ol start="3">
<li>配置刷新</li>
</ol>
<ul>
<li>Binder实现ConfigurationProperties刷新</li>
<li>反射实现@Value注解刷新</li>
</ul>
<h2> III. 不能错过的源码和相关知识点</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/003-self-config-binder" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/003-self-config-binder</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/231030/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>6.如何利用雪花算法生成分布式ID</title>
      <link>https://liuyueyi.github.io/tutorial/spring/db/%E5%9F%BA%E7%A1%80/231026-SpringBoot%E8%87%AA%E5%AE%9A%E4%B9%89%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95%E7%94%9F%E6%88%90%E5%88%86%E5%B8%83%E5%BC%8Fid.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/db/%E5%9F%BA%E7%A1%80/231026-SpringBoot%E8%87%AA%E5%AE%9A%E4%B9%89%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95%E7%94%9F%E6%88%90%E5%88%86%E5%B8%83%E5%BC%8Fid.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">6.如何利用雪花算法生成分布式ID</source>
      <description>系统唯一ID是我们在设计一个系统的时候常常会遇见的问题，比如常见的基于数据库自增主键生成的id，随机生成的uuid，亦或者redis自增的计数器等都属于常见的解决方案；本文我们将会重点看一下业界内大名鼎鼎的雪花算法，是如何实现分布式id的</description>
      <category>SpringBoot</category>
      <category>DB系列</category>
      <category>配置</category>
      <pubDate>Thu, 26 Oct 2023 17:28:47 GMT</pubDate>
      <content:encoded><![CDATA[<p>系统唯一ID是我们在设计一个系统的时候常常会遇见的问题，比如常见的基于数据库自增主键生成的id，随机生成的uuid，亦或者redis自增的计数器等都属于常见的解决方案；本文我们将会重点看一下业界内大名鼎鼎的雪花算法，是如何实现分布式id的</p>
<!-- more -->
<h2> I. 雪花算法</h2>
<h3> 1. 全局唯一id</h3>
<p>雪花算法主要是为了解决全局唯一id，那么什么是全局唯一id呢？它应该满足什么属性呢</p>
<p>基本属性：</p>
<ul>
<li>全局唯一性：不能出现重复的 ID 号，既然是唯一标识，这是最基本的要求；</li>
<li>趋势递增：在 MySQL InnoDB 引擎中使用的是聚集索引，由于多数 RDBMS 使用 B-tree 的数据结构来存储索引数据，在主键的选择上面我们应该尽量使用有序的主键保证写入性能；</li>
<li>单调递增：保证下一个 ID 一定大于上一个 ID，例如事务版本号、IM 增量消息、排序等特殊需求；</li>
<li>信息安全：如果 ID 是连续的，恶意用户的爬取工作就非常容易做了，直接按照顺序下载指定 URL 即可；如果是订单号就更危险了，竞争对手可以直接知道我们一天的单量。所以在一些应用场景下，会需要 ID 无规则、不规则。</li>
</ul>
<h3> 2. 雪花算法</h3>
<p>雪花算法可以说是业界内生成全局唯一id的经典算法，其基本原理也比较简单</p>
<figure><img src="/imgs/231026/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>Snowflake 以 64 bit 来存储组成 ID 的4 个部分：</p>
<ol>
<li>最高位占1 bit，值固定为 0，以保证生成的 ID 为正数；</li>
<li>中位占 41 bit，值为毫秒级时间戳；</li>
<li>中下位占 10 bit，值为机器标识id，值的上限为 1024；</li>
<li>末位占 12 bit，值为当前毫秒内生成的不同的自增序列，值的上限为 4096；</li>
</ol>
<p>从上面的结构设计来看，雪花算法的实现可以说比较清晰了，我们重点看一下它的缺陷</p>
<ol>
<li>时钟回拨问题：由于id的高位依赖于系统的时间戳，因此当服务器时间错乱或者出现时钟回拨，可能导致数据重复</li>
<li>集群规模1024台机器，每1ms单机4096个id最大限制</li>
</ol>
<h3> 3. 实现与使用</h3>
<p>目前雪花算法的实现方式较多，通常也不需要我们进行额外开发，如直接Hutool的<code>Snowflake</code></p>
<p>看下它的核心实现</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>关键实现在 <code>nextId()</code> 方法内，做了两个保护性兼容</p>
<ol>
<li>记录上次生成id的时间戳，若当前时间戳小于上次产生的时间戳，则表示出现了时钟回拨，超过一定间隔，则直接抛异常</li>
</ol>
<figure><img src="/imgs/231026/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<ol start="2">
<li>当前时间戳生成的id数量超过了4096最大值限制，则等待下一秒</li>
</ol>
<figure><img src="/imgs/231026/02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>接下来看一下实际的使用</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出如下:</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>生成的id：19位</li>
<li>单调递增，同一毫秒内，序号+1</li>
</ul>
<h3> 4. 自定义雪花算法实现</h3>
<p>在某些时候我们对雪花算法的实现有一些特殊的定制化场景，比如希望生成的id能一些更具有标识性，如以商城领域的订单数据模型为例</p>
<ul>
<li>第一位：标记订单类型， 1: 普通订单  2: 换货订单  3: 退货订单  4: 退款订单</li>
<li>第二三位：标记订单所属年份，如 22xxx，表示22年的订单；23xxx，则表示23年的订单</li>
</ul>
<p>再比如对订单的长度希望做一些限制,19位太多了，我希望16、7位的长度</p>
<p>再比如我希望调整workerId 与 datacenter之间的分配比例</p>
<p>基于以上等等原因，当我们面对需要修改雪花算法逻辑时，再知晓算法原理的基础上，完全可以自己手撸</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意上面的实现，相比较于前面HuTool的实现，有几个变更</p>
<ol>
<li>时间戳从毫秒改为秒</li>
<li>生成id前五位：年 + 天</li>
<li>workcenterId : dataCenterId = 3 : 7</li>
<li>当时钟回拨时，等待时间追上，而不是直接抛异常</li>
<li>自增序列的起始值，0/1互切</li>
</ol>
<p>接下来再看下实际的使用输出</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 5. 小结</h3>
<p>雪花算法本身的实现并不复杂，但是它的设计理念非常有意思；业界内也有不少基于雪花算法的变种实现，主要是为了解决时钟不一致及时钟回拨问题，如百度<code>UIDGenerator</code>，美团的<code>Leaf-Snowflake</code>方案</p>
<p>雪花算法其实是依赖于时间的一致性的，如果时间回拨，就可能有问题，其次机器数与自增序列虽然官方推荐是10位与12位，但正如没有万能的解决方案，只有最合适的解决方案，我们完全可以根据自己的实际诉求，对64个字节，进行灵活的分配</p>
<p>再实际使用雪花算法时，有几个注意事项</p>
<ol>
<li>雪花算法生成的id，通常是长整形，对于前端使用时，对于超过16位的数字，会出现精度问题，需要转换成String的方式传递，否则就会出现各种预料之外的事情发生</li>
<li>workId如何获取？</li>
</ol>
<ul>
<li>如：借助第三方服务(db/redis/zk)，统一为每个实例分配唯一的workId</li>
<li>如：同一个局域网内的所有应用，借助ip的最后一段来定位</li>
</ul>
<h2> II. 不能错过的源码和相关知识点</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/600-snowflake-id" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/600-snowflake-id</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/231026/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>17.压缩返回结果实例演示，让你的性能更高效！</title>
      <link>https://liuyueyi.github.io/tutorial/spring/web/Response/231108-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8B%E5%8E%8B%E7%BC%A9%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C%E5%AE%9E%E4%BE%8B%E6%BC%94%E7%A4%BA.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/web/Response/231108-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8B%E5%8E%8B%E7%BC%A9%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C%E5%AE%9E%E4%BE%8B%E6%BC%94%E7%A4%BA.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">17.压缩返回结果实例演示，让你的性能更高效！</source>
      <description>本文将介绍一个SpringBoot进阶技巧：压缩返回结果实例演示，旨在提升您的网站访问性能。 当返回的数据较大时，网络开销通常不可忽视。为了解决这个问题，我们可以考虑压缩返回的结果，以减少传输的数据量，从而降低网络开销并提高性能。对于依赖Spring生态的Java开发者来说，幸运的是SpringBoot提供了非常便捷的使用方式。 接下来，我们将介绍几种不同情况下的压缩返回的使用方式： 直接返回文本：使用text/plain作为响应类型。 返回JSON数据：使用application/json作为响应类型。 返回静态资源文件：对于静态资源文件，可以使用压缩算法进行压缩后再返回。</description>
      <category>SpringBoot</category>
      <category>WEB系列</category>
      <category>Response</category>
      <pubDate>Wed, 08 Nov 2023 10:38:11 GMT</pubDate>
      <content:encoded><![CDATA[<p>本文将介绍一个SpringBoot进阶技巧：压缩返回结果实例演示，旨在提升您的网站访问性能。</p>
<p>当返回的数据较大时，网络开销通常不可忽视。为了解决这个问题，我们可以考虑压缩返回的结果，以减少传输的数据量，从而降低网络开销并提高性能。对于依赖Spring生态的Java开发者来说，幸运的是SpringBoot提供了非常便捷的使用方式。</p>
<p>接下来，我们将介绍几种不同情况下的压缩返回的使用方式：</p>
<ul>
<li>直接返回文本：使用text/plain作为响应类型。</li>
<li>返回JSON数据：使用application/json作为响应类型。</li>
<li>返回静态资源文件：对于静态资源文件，可以使用压缩算法进行压缩后再返回。</li>
</ul>
<!-- more -->
<h2> I. 项目配置</h2>
<h3> 1. 依赖</h3>
<p>首先搭建一个标准的SpringBoot项目工程，相关版本以及依赖如下</p>
<p>本项目借助<code>SpringBoot 2.2.1.RELEASE</code> + <code>maven 3.5.3</code> + <code>IDEA</code>进行开发</p>
<p>核心依赖 <code>spring-boot-starter-web</code></p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 启动入口</h3>
<p>我们使用默认的配置进行测试，因此启动入口也可以使用最基础的</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> II. 返回结果压缩</h2>
<h3> 1. 开启gzip压缩</h3>
<p>在Spring Boot中开启压缩，只需要在配置文件中添加以下配置即可自动开启：</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意上面的两个配置，其中 <code>server.compression.enabled</code> 用于控制是否开启压缩；而<code>server.compression.min-response-size</code>则根据实际返回的大小，来决定是否需要开启压缩，上面的配置表示，只有返回的长度超过128时，才开启压缩。</p>
<p>写一个简单的demo进行验证</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>下图为实际访问对比，从两次请求的返回头来看，左边的示例表示没有开启压缩处理，而右边的示例则开启了gzip压缩。</p>
<figure><img src="/imgs/231108/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 2. 返回json对象时最小返回阈值不生效问题</h3>
<p>接下来我们再看一个特殊的场景，当我们返回的是jsonObject对象时，即便返回的内容小于前面配置的128，也会开启压缩</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/231108/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>根据上述实际表现，我们注意到一个令人费解的现象：同样返回一条数据时，如前面返回String时，不需要进行压缩；然而，当数据类型为JsonObject时，即使返回的内容小于128字节，也会启用gzip压缩。</p>
<p>这一现象的主要原因则是：</p>
<p>在Spring Boot框架中，默认情况下会对所有的json对象进行压缩处理。即使返回的数据量较小，即使未达到最小返回阈值，系统也会自动对其进行压缩操作。这样做的目的是为了减少传输的数据量并提高性能。</p>
<blockquote>
<p>即当返回的是对象，即<code>Content-Type: application/json</code>时，不会设置Content-Length，服务端无法判断长度，并且是通过<code>Transfer-Encoding: chunked</code>的方式发送给客户端，因此一定会做压缩。</p>
</blockquote>
<p>若我们希望严格按照预期来执行，那么可以通过对返回结果进行包装，补齐<code>Content-Length</code>来实现</p>
<p>自定义一个过滤器，借助<code>ContentCachingResponseWrapper</code>来包装返回结果</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>再次访问验证一下，结果和我们预期的保持一致了</p>
<figure><img src="/imgs/231108/02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 3. 返回静态资源压缩</h3>
<p>对于前后端未分离的项目，后端可能还需要返回静态资源文件，如JavaScript、CSS和图像等。在Spring Boot中，这些静态资源文件也可以被压缩并返回。为了实现这一功能，主要借助了<code>EncodedResourceResolver</code>类。</p>
<p><code>EncodedResourceResolver</code>是Spring框架中的一个类，用于解析和处理静态资源文件的编码和解码。通过使用<code>EncodedResourceResolver</code>，我们可以对静态资源文件进行压缩，并将其作为响应返回给前端。</p>
<p>一个简单的使用实例如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的配置中，表示将static资源目录下的文件，作为静态资源返回，会设置缓存时间，并开启压缩支持</p>
<p>我们可以再项目的 <code>resources/static/</code> 目录下新增一个 <code>txt.txt</code> 文件，并再其中随意补充一些内容</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>然后直接访问验证一下</p>
<figure><img src="/imgs/231108/03.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>从上面的访问示例可以看出，首次访问时，压缩返回；再次访问时，因为资源未发生变更，所以直接使用本地的缓存。这是因为浏览器在第一次请求静态资源时会将其缓存起来，以便下次访问时能够更快地加载。如果资源发生了更改，浏览器将不会使用缓存的版本，而是重新发起请求以获取最新的资源。</p>
<h3> 4. 小结</h3>
<p>最后对文中介绍的内容做一个整体的总结，在Spring Boot中开启gzip压缩可以通过以下方式实现：</p>
<ol>
<li>在配置文件中添加如下配置：</li>
</ol>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2">
<li>返回json对象时最小返回阈值不生效问题：</li>
</ol>
<p>当返回的是对象时，即使返回的内容小于前面配置的128字节，也会启用gzip压缩。这是因为在Spring Boot框架中，默认会对所有的json对象进行压缩处理。如果不想压缩，可以将返回结果进行包装，实现按需压缩。</p>
<ol start="3">
<li>返回静态资源压缩：</li>
</ol>
<p>对于前后端未分离的项目，后端可能还需要返回静态资源文件，如JavaScript、CSS和图像等。在Spring Boot中，这些静态资源文件也可以被压缩并返回。为了实现这一功能，主要借助了<code>EncodedResourceResolver</code>类，通过设置静态资源的压缩方式，并再<code>WebMvcConfigurer</code>实现中进行注册，从而实现静态资源的压缩与缓存</p>
<h2> III. 不能错过的源码和相关知识点</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/207-web-res-gzip" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/207-web-res-gzip</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/231108/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>2.从零开始学习SpringBoot整合WebSocket与STOMP协议：实用案例带你轻松入门！</title>
      <link>https://liuyueyi.github.io/tutorial/spring/web/WebSocket/231115-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8BWebScoket%E6%95%B4%E5%90%88stomp%E5%8D%8F%E8%AE%AE%E5%AE%9E%E4%BE%8B.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/web/WebSocket/231115-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8BWebScoket%E6%95%B4%E5%90%88stomp%E5%8D%8F%E8%AE%AE%E5%AE%9E%E4%BE%8B.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">2.从零开始学习SpringBoot整合WebSocket与STOMP协议：实用案例带你轻松入门！</source>
      <description>在我们的日常工作中，我们可能会遇到需要实现双向通讯的场景。为了解决这个问题，常见的实现方案包括短轮询、长轮询、SSE和WebSocket等几种方式。本文将重点介绍如何通过整合WebSocket和STOMP协议来实现双向通讯的方案, 并给出一个应用实例，带你轻松掌握如何基于SpringBoot搭建一个在线聊天系统</description>
      <category>WEB系列</category>
      <category>WebSocket</category>
      <pubDate>Wed, 15 Nov 2023 15:12:39 GMT</pubDate>
      <content:encoded><![CDATA[<p>在我们的日常工作中，我们可能会遇到需要实现双向通讯的场景。为了解决这个问题，常见的实现方案包括短轮询、长轮询、SSE和WebSocket等几种方式。本文将重点介绍如何通过整合WebSocket和STOMP协议来实现双向通讯的方案, 并给出一个应用实例，带你轻松掌握如何基于SpringBoot搭建一个在线聊天系统</p>
<!-- more -->
<h2> I. 基础知识点</h2>
<h3> 1. 相关概念释疑</h3>
<p>再开始之前，简单介绍一下文中会出现的几个术语的</p>
<p><strong>WebSocket</strong>： WebSocket是一种在单个TCP连接上进行全双工通信的协议。它使得客户端和服务器之间能够实时地进行双向数据传输，而不需要频繁地建立和关闭连接。这种机制可以提高数据传输的效率和性能。</p>
<p><strong>STOMP</strong>:  Simple Text Oriented Messaging Protocol 是一种简单而灵活的消息传递协议，它是在HTTP之上实现的。STOMP协议定义了一套简单的命令和帧格式，用于在客户端和服务器之间进行消息传递。通过使用STOMP协议，我们可以实现客户端和服务器之间的双向通讯。</p>
<p>注意：stomp协议属于websocket的子协议</p>
<h3> 2. WebSocket整合STOMP</h3>
<p>WebSocket整合STOMP协议实现双向通讯的方案，主要步骤如下：</p>
<ol>
<li>
<p>建立WebSocket连接：客户端通过JavaScript的WebSocket API与服务器建立连接。</p>
</li>
<li>
<p>发送STOMP帧：在WebSocket连接建立后，客户端和服务器就可以通过发送STOMP帧来进行通信了。STOMP帧是STOMP协议的基本单位，它定义了消息的各种操作，如订阅、发布等。</p>
</li>
<li>
<p>处理STOMP帧：服务器收到STOMP帧后，会根据帧的类型进行相应的处理。例如，如果收到一个SUBSCRIBE帧，服务器就会为客户端创建一个订阅；如果收到一个SEND帧，服务器就会将消息发送给指定的目的地。</p>
</li>
<li>
<p>关闭WebSocket连接：当客户端和服务器都完成了通信后，可以通过调用WebSocket API的close方法来关闭连接。</p>
</li>
</ol>
<h3> 3. SpringBoot整合STOMP流程</h3>
<p>SpringBoot对websocket提供了非常友好的封装，对于业务开放而言，可以简单迅速的搭建一个基于STOMP协议的websocket应用工程</p>
<figure><img src="/imgs/231115/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>上图展示了STOMP的基本工作流程。</p>
<p><strong>步骤1：初始化</strong></p>
<p>服务端：</p>
<ul>
<li>定义接收建立WebSocket连接的端点EndPoint。</li>
<li>配置消息代理Broker，用于前端订阅（subscribe），后端向该Broker写入消息后，订阅了该Broker的前端都会收到相应的消息。</li>
<li>配置路由转发规则，将用户发送的信息转发给相应的处理器（类似于<code>RequestMappingHandlerMapping</code>与@<code>RequestMapping</code>注解，在WebSocket中使用的是<code>Destination</code> + <code>@MessageMapping</code>）。</li>
</ul>
<p>客户端：</p>
<ul>
<li>与EndPoint建立连接。</li>
<li>订阅Broker，注册消息回调。</li>
</ul>
<p><strong>步骤2：通讯</strong></p>
<p>服务端：</p>
<ul>
<li>主动向Broker写入消息：使用<code>simpMessagingTemplate</code>。</li>
<li>消息应答：使用<code>@SendTo</code>注解。</li>
</ul>
<p>客户端：</p>
<ul>
<li>发送消息：调用send(xxxx)方法。</li>
<li>消息应答：触发订阅的回调函数。</li>
</ul>
<h2> II. 实例演示</h2>
<h3> 1. 项目配置</h3>
<p>首先搭建一个标准的SpringBoot项目工程，相关版本以及依赖如下</p>
<p>本项目借助<code>SpringBoot 2.2.1.RELEASE</code> + <code>maven 3.5.3</code> + <code>IDEA</code>进行开发</p>
<p>核心依赖 <code>spring-boot-starter-websocket</code>， 其中模板渲染引擎<code>thymeleaf</code>主要是集成前端页面</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. WebSocket配置</h3>
<p>正如前面流程图中介绍的，后端需要先配置一下websocket的相关信息，通过实现配置类<code>WebSocketMessageBrokerConfigurer</code>来定义</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol>
<li>定义端点： <code>registerStompEndpoints()</code></li>
<li>定义客户端与服务端通讯信息: <code>configureMessageBroker()</code></li>
</ol>
<ul>
<li>配置消息代理: <code>registry.enableSimpleBroker</code></li>
<li>配置消息转发: <code>registry.setApplicationDestinationPrefixes</code>，转发前缀可以是多个</li>
</ul>
<p>上面的配置完毕之后，对于客户端而言</p>
<ul>
<li>建立连接的路径是： <code>/ws/hello</code></li>
<li>订阅消息的路径是： <code>/topic/xxx</code>
<ul>
<li>订阅的路径全程，是由 <code>@SendTo</code>的路径来确定</li>
</ul>
</li>
<li>接收前端消息的路劲是: <code>/app/xxx</code>
<ul>
<li>后面的这个xxx，是由 <code>@MessageMapping</code>中的路径来补齐</li>
</ul>
</li>
</ul>
<h3> 3. 消息接收应答</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>实现一个非常简单的消息应答，接收客户端朝 <code>/app/hello</code> 发送的消息，然后将结果写回到 <code>/topic/hello</code> 对应的Broker，那么订阅了这个broker的客户端，都会收到这个应答消息了</p>
<p>再写一个定时器，由后端定时的向<code>/topic/hello</code>这个Broker中写入消息，模拟后台主动下发消息的场景</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4. 前端示例</h3>
<p>一个简单基础的html页面</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>核心的js逻辑，实现websocket连接建立，通讯</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意上面的实现：</p>
<ol>
<li>建立连接 <code>connect()</code></li>
</ol>
<ul>
<li>与后端定义的端点建立连接: <code>new SockJS('/ws/hello');</code></li>
<li>连接建立成功之后，订阅Broker，接收消息回传: <code>stompClient.subscribe('/topic/hello', 消息应答回调)</code></li>
</ul>
<ol start="2">
<li>发送消息</li>
</ol>
<ul>
<li>`stompClient.send("/app/hello", xxx)``</li>
</ul>
<ol start="3">
<li>断开连接</li>
</ol>
<ul>
<li><code>stompClient.disconnect();</code></li>
</ul>
<h3> 5. 演示</h3>
<p>到这里，一个完整的基于SpringBoot整合WebSocket与STOMP协议的示例应用已经搭建完成；接下来我们实际启动一下看看效果</p>
<figure><img src="/imgs/231115/01.gif" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>上面的动图展示了前端建立连接后，向后端发送信息并接收后端广播的消息的过程。由于两个客户端订阅的是同一个broker，因此后端发送的消息可以被所有客户端接收到。</p>
<p>这种交互方式类似于群组聊天，当一个人发送消息后，其他人都可以收到。</p>
<p>如果我希望通过websocket实现一个消息通知的功能，其中后端发送的消息既有广播的，也有面向个人的，那么应该如何实现呢？</p>
<p>我们下篇博文将进行详细介绍</p>
<h2> III. 不能错过的源码和相关知识点</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/203-websocket" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/203-websocket</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/231115/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>3.从零开始学习SpringBoot WebSocket身份鉴权，让你的项目更上一层楼！</title>
      <link>https://liuyueyi.github.io/tutorial/spring/web/WebSocket/231204-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8BWebSocket%E8%BA%AB%E4%BB%BD%E9%89%B4%E6%9D%83.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/web/WebSocket/231204-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8BWebSocket%E8%BA%AB%E4%BB%BD%E9%89%B4%E6%9D%83.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">3.从零开始学习SpringBoot WebSocket身份鉴权，让你的项目更上一层楼！</source>
      <description>上一篇博文介绍了如何利用STOMP和SpringBoot搭建一个能够实现相互通讯的聊天系统。通过该系统，我们了解了STOMP的基本使用方法以及一些基础概念。接下来，我们将在此基础上进行一些增强。由于聊天的本质是交流，因此我们需要知道是谁在与谁进行聊天，这就需要登录功能的支持。 接下来，我们将探讨如何为WebSocket通信添加身份验证功能。</description>
      <category>WEB系列</category>
      <category>WebSocket</category>
      <pubDate>Mon, 04 Dec 2023 09:40:04 GMT</pubDate>
      <content:encoded><![CDATA[<p>上一篇博文介绍了如何利用STOMP和SpringBoot搭建一个能够实现相互通讯的聊天系统。通过该系统，我们了解了STOMP的基本使用方法以及一些基础概念。接下来，我们将在此基础上进行一些增强。由于聊天的本质是交流，因此我们需要知道是谁在与谁进行聊天，这就需要登录功能的支持。</p>
<p>接下来，我们将探讨如何为WebSocket通信添加身份验证功能。</p>
<!-- more -->
<h2> I. 实例演示</h2>
<h3> 1. 项目配置</h3>
<p>首先搭建一个标准的SpringBoot项目工程，相关版本以及依赖如下</p>
<p>本项目借助<code>SpringBoot 2.2.1.RELEASE</code> + <code>maven 3.5.3</code> + <code>IDEA</code>进行开发</p>
<p>核心依赖 <code>spring-boot-starter-websocket</code>， 其中模板渲染引擎<code>thymeleaf</code>主要是集成前端页面</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. WebSocket配置</h3>
<p>首先我们先看一下后端的配置，对于SpringBoot整合STOMP，主要通过实现配置类<code>WebSocketMessageBrokerConfigurer</code>来定义相关的信息：</p>
<ul>
<li>注册端点Endpoint</li>
<li>定义消息转发规则</li>
<li>定义拦截器（配置消息接收、返回的相关参数）</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>有兴趣的小伙伴可以对比一下上面的Endpoint配置与之前整合STOMP的示例中的配置，两者之间存在两个主要差异：</p>
<ol>
<li><code>addEndpoint("/ws/chat/{channel}")</code></li>
</ol>
<p>这个端点并不是一个固定的值，最后一个<code>{channel}</code>是一个变量。可以理解为聊天群，不同聊天群中的信息是相互隔离的，不会出现串频的情况。</p>
<ol start="2">
<li><code>addInterceptors(authHandshakeInterceptor())</code></li>
</ol>
<p>这里设置了身份鉴权拦截器，也是本文的核心内容。在WebSocket连接建立之后，如何识别当前建立连接的用户呢？</p>
<h3> 3. 身份鉴权拦截器</h3>
<p>与SpringMVC类似，WebSocket也支持拦截器。在握手之前，可以通过识别用户身份来实现辅助操作。例如，我们可以从cookie中获取用户信息，并将其写入消息的全局属性请求头。</p>
<p>实现方式主要是通过拦截器在握手过程中进行用户身份验证，并将用户信息存储在全局属性中，以便在整个WebSocket连接的生命周期内使用。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的拦截器可以通过cookie来识别用户身份。当用户登录成功后，将用户名写入请求头uname中。这样，在后续的WebSocket通信过程中，就可以通过访问请求头uname来获取当前登录的用户信息</p>
<h3> 4. 用户登录</h3>
<p>我们还是基于springmvc搭建一个用户的登录入口，直接基于内存做一个最简单的用户登录管理</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>新增一个用户登录的入口，用户登录成功之后，将session写入cookie，有效期30天</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 5. ws聊天实现</h3>
<p>接下来我们开始写登录聊天的相关业务逻辑</p>
<p><strong>后端实现</strong></p>
<p>首先提供一个消息转发的后端接口</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意上面的实现，有几个关键信息</p>
<ol>
<li><code>@MessageMapping("/hello/{channel}")</code></li>
</ol>
<p>这里的<code>{channel}</code>是一个传参形式，表示接收不同目标来源的消息；其取值通过<code>DestinationVariable("channel") String channel</code> 来获取</p>
<p>举个简单的例子：</p>
<ul>
<li>客户端往 <code>app/hello/globalChannel</code> 发送的消息，会被后端转发给 <code>/topic/chat/globalChannel</code></li>
<li>客户端往 <code>app/hello/signleChannel</code> 发送的消息，会被后端转发给 <code>/topic/chat/signleChannel</code></li>
</ul>
<ol start="2">
<li><code>headerAccessor.getSessionAttributes().get("uname")</code></li>
</ol>
<p>从请求头中获取用户身份，没错，这里的uname就是在上面的拦截器 <code>AuthHandshakeInterceptor</code> 写入的</p>
<ol start="3">
<li>消息发送</li>
</ol>
<p>写了一个简单的工具类，实现后端给客户端发送消息， <code>WsAnswerHelper</code>实现如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>最后再给出前端访问入口</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>前端实现</strong></p>
<p>前端的实现和上一篇博文的基本没有太大差别，无非是多了一个登录</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>js实现如下</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>和之前的示例相比，区别在于建立连接之前，先调用了登录接口实现自动登录</p>
<h3> 6. 示例演示</h3>
<p>接下来我们演示一下，用户登录之后，再进行聊天的表现形式</p>
<figure><img src="/imgs/231204/00.gif" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>面的示意图也可以看出，在相同channel之间的用户可以相互通信。聊天信息前面都会带上发送这个消息的用户名。这样可以方便用户识别和区分来自不同用户的聊天信息。</p>
<h3> 7. 小结</h3>
<p>本文通过实例演示了WebSocket的身份鉴权，其底层依然是借助Cookie来实现用户身份识别。与常规的Cookie鉴权不同之处在于，在WebSocket连接的生命周期内，通过HttpSessionHandshakeInterceptor拦截器来解析用户身份，并将相关信息写入到请求头中，以供其他地方进行使用。</p>
<p>本文的主要目的是为大家演示如何实现WebSocket的身份识别验证，整体的功能相对较少。以下是一些可能的应用场景和实现方式：</p>
<ul>
<li>当一个用户加入聊天室时，系统可以通过广播一个通知来告知其他用户。具体实现方式可以是，在用户加入聊天室时，服务器将该用户的身份信息发送给所有已连接的客户端，客户端收到通知后可以在界面上显示相应的提示信息。</li>
<li>当一个用户离开聊天室时，系统同样可以通过广播一个通知来告知其他用户。具体实现方式可以是，在用户离开聊天室时，服务器将该用户的身份信息发送给所有已连接的客户端，客户端收到通知后可以在界面上移除相应的提示信息。</li>
<li>如现在一个订阅对应一个websocket连接，那么是否可以一个ws连接，通过订阅不同的topic，来实现多群组聊天的功能呢？</li>
</ul>
<p>下篇博文将探讨如何实现以下功能：</p>
<ol>
<li>当一个用户加入聊天时，系统广播一个通知。</li>
<li>当用户离开聊天时，系统广播一个通知。</li>
<li>使用一个WebSocket连接，通过订阅不同的主题来实现多群组聊天的功能。</li>
</ol>
<p>敬请期待下篇博文！我是你们的好朋友一灰灰</p>
<h2> II. 不能错过的源码和相关知识点</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-case/207-websocket-chat" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-case/207-websocket-chat</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/231204/00.gif" type="image/gif"/>
    </item>
    <item>
      <title>4.SpringBoot WebSocket进阶：如何利用消息拦截器优化聊天功能？</title>
      <link>https://liuyueyi.github.io/tutorial/spring/web/WebSocket/231218-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8BWebsocket%E6%B6%88%E6%81%AF%E6%8B%A6%E6%88%AA%E5%99%A8%E5%AE%9E%E7%8E%B0%E8%81%8A%E5%A4%A9%E6%8F%90%E9%86%92.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/web/WebSocket/231218-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8BWebsocket%E6%B6%88%E6%81%AF%E6%8B%A6%E6%88%AA%E5%99%A8%E5%AE%9E%E7%8E%B0%E8%81%8A%E5%A4%A9%E6%8F%90%E9%86%92.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">4.SpringBoot WebSocket进阶：如何利用消息拦截器优化聊天功能？</source>
      <description>在上一篇文章中，我们成功地为WebSocket的聊天应用添加了身份验证功能。然而，当时遗留了一个关键问题：当一个新用户加入群聊时，我们希望向群聊内的其他成员发送一条欢迎消息，以告知他们有新朋友加入了。那么，如何实现这一需求呢？ 接下来，我们将重点介绍如何使用ChannelInterceptor来实现加入/退出群聊的通知功能。</description>
      <category>WEB系列</category>
      <category>WebSocket</category>
      <pubDate>Mon, 18 Dec 2023 14:23:43 GMT</pubDate>
      <content:encoded><![CDATA[<p>在上一篇文章中，我们成功地为WebSocket的聊天应用添加了身份验证功能。然而，当时遗留了一个关键问题：当一个新用户加入群聊时，我们希望向群聊内的其他成员发送一条欢迎消息，以告知他们有新朋友加入了。那么，如何实现这一需求呢？</p>
<p>接下来，我们将重点介绍如何使用<code>ChannelInterceptor</code>来实现加入/退出群聊的通知功能。</p>
<!-- more -->
<h2> I. 实例演示</h2>
<h3> 1. 项目搭建</h3>
<p>项目搭建过程与前文类似，请直接参考上文 或者 查看文末的项目源码</p>
<h3> 2. WebSocket配置</h3>
<p>在之前介绍的几篇博文中，我们提到了通过实现接口<code>WebSocketMessageBrokerConfigure</code>在之前介绍的几篇博文中，我们提到了通过实现接口<code>WebSocketMessageBrokerConfigurer</code> 来进行 WebSocket 的配置。</p>
<p>本文的重点正是在这个配置类中进行实现，因此我们将借此机会回顾一下之前的内容。</p>
<ul>
<li>首先，我们需要创建一个配置类，并实现 <code>WebSocketMessageBrokerConfigurer</code> 接口。然后，我们可以重写其中的方法来配置 WebSocket 的相关参数和消息代理。</li>
<li>在 <code>configureMessageBroker</code> 方法中，我们可以指定使用的消息代理（例如：SimpleBroker）以及对应的前缀（用于路由消息）。同时，我们还可以设置订阅者模式（<code>subscriptionChannel</code>）和广播模式（<code>publisherChannel</code>），以便在不同的场景下使用不同的通信方式。</li>
<li>接下来，在 <code>registerStompEndpoints</code> 方法中，我们可以注册一个或多个端点（<code>endpoint</code>），并为每个端点指定一个路径（<code>path</code>）。这样，客户端就可以通过这个路径与服务器进行 WebSocket 通信了。</li>
<li>最后，在 <code>addInterceptors</code> 方法中，我们可以添加一些拦截器（<code>interceptor</code>），用于处理 WebSocket 连接、消息发送和接收等过程中的一些逻辑。例如，我们可以添加一个身份验证拦截器，用于验证客户端的身份信息。</li>
</ul>
<p><code>WebSocketMessageBrokerConfigurer</code> 接口允许我们配置 Stomp 协议的各种属性，包括端点、拦截器、消息转换器等。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>configureMessageBroker()方法</strong></p>
<p>配置消息代理与消息转发</p>
<ul>
<li><code>registry.enableSimpleBroker("/topic")</code>: 启用简单的消息代理，即对于客户端而言，前端需要订阅的就是这个路径，如对应 index.js中的 <code>stompClient.subscribe('/topic/hello', xx)</code></li>
<li><code>registry.setApplicationDestinationPrefixes("/app")</code>: 设置了目标转发的前缀为<code>/app</code>，客户端发送给<code>/app/xxx</code>的消息，会被转发给<code>@MessageMapping</code>注解修饰的方法</li>
</ul>
<p>如我们定义的消息转发实现</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>registerStompEndpoints()方法</strong></p>
<p>注册连接端点</p>
<ul>
<li><code>registry.addEndpoint("/ws/chat/{channel}")</code>: 添加端点，对应的就是客户端建立连接的url</li>
<li><code>.addInterceptors(authHandshakeInterceptor())</code>: 上文中用于身份识别的拦截器</li>
</ul>
<p>此外对于跨域支持，也是在这里进行设置，如在上面的链式使用中，添加 <code>.setAllowedOrigins("*")</code></p>
<p><strong>configureClientInboundChannel()方法</strong></p>
<p>用于设置接收客户端消息的相关配置参数，如线程连接参数、拦截器配置</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>关于拦截器<code>SocketInChannelInterceptor</code>为我们自定义的实现，其内部实现了我们对聊天通知的核心逻辑；咱们下一节再看它</p>
<p>请注意上面配置的taskExecutor, 上面的几个配置参数和线程池的配置参数别无二致，一般建议是使用自定义的线程池来进行管理；方便监控</p>
<p><strong>configureClientOutboundChannel()方法</strong></p>
<p>与前面的使用姿势一致，唯一的区别则在于它主要设置的是服务端返回消息给客户端的相关配置，或者拦截</p>
<h3> 3. 管道拦截</h3>
<p>在完成前面的配置后，接下来我们将进入管道拦截器的重点部分。我们的目标是在用户进入或离开群聊时，向群聊的其他成员推送一条通知。</p>
<p>为了实现这一目标，一个直观的方案是监控客户端的订阅和取消订阅操作，并在此基础上进行相应的操作。因此，我们的核心实现将基于之前定义的<code>SocketInChannelInterceptor</code>。</p>
<p>首先来看一下管道拦截器的接口签名</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对于消息广播通知，我们放在<code>afterSendCompletion</code>来实现，判断客户端的命令，对于订阅/取消订阅进行处理</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的订阅实现相对简单，主要有下面几个关键知识点：</p>
<ol>
<li>封装消息头访问器： <code>StompHeaderAccessor.wrap(message)</code>， 简化请求相关信息的获取方式</li>
<li>判断交互类型： <code>headerAccessor.getCommand()</code></li>
<li>获取请求头：</li>
</ol>
<ul>
<li><code>headerAccessor.getHeader("simpDestination")</code></li>
<li><code>message.getHeaders().get("simpDestination")</code></li>
</ul>
<p>需要注意一点：直接可以从请求头中找到客户端订阅的是哪个群组(通过<code>destination</code>)，但是对于取消订阅时，则拿不到这个信息了，因此需要客户端再取消时，将这个关键信息回传给我们</p>
<h3> 4. 前端订阅/取消订阅</h3>
<p>前面说到了需要再取消订阅的时候，告诉后端退出的是哪个群组，所以我们的客户端的使用上，需要做一些小的适配调整</p>
<p>完整的前端代码可以参考项目源码中的 <code>chat.html</code>， 下面是关键的订阅/取消订阅逻辑</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>再上面的实现中，使用一个对象<code>subscribeMap</code>来存储订阅关系，并设置了订阅的ID 正好等于订阅的<code>channel</code>, 这样在订阅/取消订阅时，都会新增一个id的请求头，如下图所示，这样后端就可以根据这个id来做离开群聊的广播通知</p>
<figure><img src="/imgs/231218/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 5. 效果演示</h3>
<p>接下来我们实际演示一下，开始订阅/和结束订阅时，其他的小伙伴是否可以收到相关的提示消息</p>
<figure><img src="/imgs/231218/01.gif" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>从上图可以比较直观的看到，当一个用户加入群聊时，其他用户/自己均可以正常收到对应的系统通知消息；离开群聊时，因为取消了订阅所以也就只有其他的小伙伴能收到系统消息，而自己是收不到的</p>
<h3> 6. 小结</h3>
<p>本文主要介绍了管道拦截器，用于在接收和发送客户端消息时进行定制开发，以满足特定需求场景。</p>
<p>目前为止，我们所讨论的都是与群聊相关的内容。然而，如果后台系统希望向用户推送私人消息，例如提醒用户在线时间过长需要休息的提示消息，应该如何实现呢？</p>
<h2> III. 不能错过的源码和相关知识点</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-case/207-websocket-chat" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-case/207-websocket-chat</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/231218/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>5.一文教你如何在SpringBoot中使用WebSocket发送消息！</title>
      <link>https://liuyueyi.github.io/tutorial/spring/web/WebSocket/231220-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8BWebSocket%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81%E7%A4%BA%E4%BE%8B.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/web/WebSocket/231220-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8BWebSocket%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81%E7%A4%BA%E4%BE%8B.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">5.一文教你如何在SpringBoot中使用WebSocket发送消息！</source>
      <description>前面介绍的几篇是消息广播，所有在群组内的小伙伴都可以收到消息；那么如果后台只想给某个用户私发消息，可以怎么实现呢？ 本文将主要介绍服务端如何给客户端发送消息</description>
      <category>WEB系列</category>
      <category>WebSocket</category>
      <pubDate>Wed, 20 Dec 2023 14:54:40 GMT</pubDate>
      <content:encoded><![CDATA[<p>前面介绍的几篇是消息广播，所有在群组内的小伙伴都可以收到消息；那么如果后台只想给某个用户私发消息，可以怎么实现呢？</p>
<p>本文将主要介绍服务端如何给客户端发送消息</p>
<!-- more -->
<h2> I. 实例演示</h2>
<h3> 1. 项目搭建</h3>
<p>项目搭建过程与前文类似，请直接参考上文 或者 查看文末的项目源码</p>
<h3> 2. WebSocket配置</h3>
<p>核心的websocket配置依然与之前一致，实现<code>WebSocketMessageBrokerConfigurer</code>接口，定义端点、消息代理、认证授权拦截器</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. 消息发送</h3>
<h4> 3.1 @SendTo 返回消息</h4>
<p>对于服务器若需要将消息发送给客户端，最简单的方式就是接收消息时，直接返回，如</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这个实现，即表示接收 <code>/app/hello</code> 发送的消息，然后将结果转发给所有订阅了  <code>/topic/hello</code> 的客户端</p>
<h4> 3.2 SimpMessagingTemplate 返回消息</h4>
<p>若我们希望更灵活的返回消息，比如后台主动的返回消息，此时则可以借助Spring封装的<code>SimpMessagingTemplate</code>来实现消息回传</p>
<p>直接通过<code>@Autowired</code>的方式注入</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的工具类，主要封装了官方提供的两种返回方式</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>虽然上面提供了两种方式，但是看一下<code>convertAndSendToUser</code>的源码实现会发现，它的底层依然调用的是<code>convertAndSend</code>，向特定用户发送消息，无非就是调整 <code>destination</code> 的取值</p>
<figure><img src="/imgs/231220/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>重点看一下<code>destination</code>的取值 = <code>this.destinationPrefix + user + destination</code> = <code>"/user/" + user + destination</code></p>
<p>所以当我们希望给特定用户发送消息时；需要用户订阅 <code>/user/destination</code> 的地址， 如下</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对于客户端而言，虽然我订阅的是 <code>/user/topic/notify</code>， 但是后台返回消息的目的地，实际上则是 <code>/user/xxxx/topic/notify</code> ，其中的xxx则是用户标识</p>
<p>现在的问题就是，这个用户的标识，是怎么确定的呢?</p>
<ul>
<li>主要就是我们前面做用户身份鉴权中介绍到的<code>HandshakeHandler</code>中定义的Principal</li>
<li>在webscoket的生命周期内，通过Principal来识别用户身份，当需要向后端发送消息时，也是基于它来确定user</li>
</ul>
<h3> 4. 使用实例</h3>
<p>比如写一个定时器，给每个3s给当前登录的用户报时</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/231220/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 5. 小结</h3>
<p>本文主要介绍的是后端如何给客户端发送消息，其中重点介绍了一下当我们希望给用户私发消息时，可以借助<code>simpMessagingTemplate.convertAndSendToUser</code>来实现，当然对应的用户也需要订阅<code>/user/xxx</code>的channel</p>
<p>到目前位置，我们的所有聊天还局限于文本的交流，如果我们希望传图，可以怎么做呢？</p>
<h2> II. 不能错过的源码和相关知识点</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-case/207-websocket-chat" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-case/207-websocket-chat</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/231220/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>7.别再为JS长整型精度丢失烦恼了！这些方法帮你轻松搞定！</title>
      <link>https://liuyueyi.github.io/tutorial/spring/web/%E5%85%B6%E4%BB%96/231027-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8B%E9%95%BF%E6%95%B4%E5%9E%8B%E7%B2%BE%E5%BA%A6%E4%B8%A2%E5%A4%B1%E9%97%AE%E9%A2%98%E4%BF%AE%E5%A4%8D%E6%96%B9%E6%A1%88.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/web/%E5%85%B6%E4%BB%96/231027-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8B%E9%95%BF%E6%95%B4%E5%9E%8B%E7%B2%BE%E5%BA%A6%E4%B8%A2%E5%A4%B1%E9%97%AE%E9%A2%98%E4%BF%AE%E5%A4%8D%E6%96%B9%E6%A1%88.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">7.别再为JS长整型精度丢失烦恼了！这些方法帮你轻松搞定！</source>
      <description>javascript以64位双精度浮点数存储所有Number类型值，即计算机最多存储64位二进制数。 但是需要注意的是Number包含了我们常说的整形、浮点型，相比较于整形而言，会有一位存储小数点的偏移位，由于存储二进制时小数点的偏移量最大为52位，计算机存储的为二进制，而能存储的二进制为62位，超出就会有舍入操作，因此 JS 中能精准表示的最大整数是 Math.pow(2, 53)，十进制即9007199254740992 大于9007199254740992的可能会丢失精度 因此对于java后端返回的一个大整数，如基于前面说到的雪花算法生成的id，前端js接收处理时，就可能出现精度问题 接下来我们以Thymeleaf模板渲染引擎，来介绍一下对于大整数的精度丢失问题的几种解决方案</description>
      <category>SpringBoot</category>
      <category>WEB系列</category>
      <category>Response</category>
      <pubDate>Fri, 27 Oct 2023 13:50:27 GMT</pubDate>
      <content:encoded><![CDATA[<p>javascript以64位双精度浮点数存储所有Number类型值，即计算机最多存储64位二进制数。 但是需要注意的是Number包含了我们常说的整形、浮点型，相比较于整形而言，会有一位存储小数点的偏移位，由于存储二进制时小数点的偏移量最大为52位，计算机存储的为二进制，而能存储的二进制为62位，超出就会有舍入操作，因此 JS 中能精准表示的最大整数是 Math.pow(2, 53)，十进制即<code>9007199254740992</code> 大于<code>9007199254740992</code>的可能会丢失精度</p>
<p>因此对于java后端返回的一个大整数，如基于前面说到的雪花算法生成的id，前端js接收处理时，就可能出现精度问题</p>
<p>接下来我们以Thymeleaf模板渲染引擎，来介绍一下对于大整数的精度丢失问题的几种解决方案</p>
<!-- more -->
<h2> I. 测试项目搭建</h2>
<h3> 1. 依赖</h3>
<p>首先搭建一个标准的SpringBoot项目工程，相关版本以及依赖如下</p>
<p>本项目借助<code>SpringBoot 2.2.1.RELEASE</code> + <code>maven 3.5.3</code> + <code>IDEA</code>进行开发</p>
<p>添加web支持，用于配置刷新演示</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 配置</h3>
<p>接下来配置一下db的相关配置 <code>application.yml</code></p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> II. 长整型适配</h2>
<p>首先我们借助Thymeleaf创建一个简单的页面，用于返回演示长整型的使用</p>
<h3> 1. 场景复现</h3>
<p>模板网页如下</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们直接借助前面实现的Snowflake来生成长整数，写一个对应的接口</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>直接访问，表现如下</p>
<figure><img src="/imgs/231027/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>从截图可以看出，再html标签中，直接使用<code>${hu}</code>获取长整型时，显示正常；</p>
<p>但是js中，获取的长整型，则出现了精度丢失问题</p>
<p>如控制台中打印的 <code>console.log("hu = ", hu);</code> 最后的几位变成了0，与实际不符</p>
<h3> 2. long转String，解决长整型问题</h3>
<p>对于长整型导致的精度问题，最容易想到也是最推荐的解决方案，即对于long类型的参数，改为String方式进行返回，让前端以String的方式进行处理，从而解决精度丢失问题</p>
<p>方案1：修改后端的返回，将长整形改String</p>
<p>如将上面的流程如下修改:</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>方案2：前端js使用String方式接收长整形</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>具体的效果就不再演示，有兴趣的小伙伴可以自己体验一下；这种方式虽然简单有效，但是对现有的项目改造还是挺大的，且很容易有遗漏；自然的，我们就会思考一下，是否有统一的处理方式来解决这种问题</p>
<h3> 3. 修改序列化方式，实现长整型转字符串</h3>
<p>作为后端，前端的使用姿势我们无法控制；为了整个程序的准确性，后端直接返回String格式通常是首选的方案；对于现下主流的前后端分离方案，后端一般是返回json格式的数据，所以要想实现统一的格式转换，自然会想到对序列化做文章</p>
<p>比如SpringBoot默认的jackson序列化框架，直接让其实现对长整型转String的转换</p>
<p>先实现一个工具类，来实现上面的诉求，支持long/bigint/bigdecimal转string</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其次就是注册一个支持长整型转String的序列化转换类<code>HttpMessageConverter</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来我们对比一下，上面注册前后，访问 '<a href="http://localhost:8080/id2" target="_blank" rel="noopener noreferrer">http://localhost:8080/id2</a>' 返回的数据格式</p>
<figure><img src="/imgs/231027/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>基于上面的输出结果，可以看到我们的目标已经实现，返回的长整型会自动转换为字符串；这样前端使用时，就不会出现精度丢失问题了（除非前端又将字符串转number）</p>
<p>上面这个是后端直接返回Json对象数据；这种解决方案适用于 <code>Thymeleaf</code> 模板渲染引擎么？</p>
<ul>
<li>直接访问一下 <code>http://localhost:8080/show</code> 看一下控制台输出</li>
<li>很遗憾的是，依然是<strong>精度丢失</strong></li>
</ul>
<p>why?</p>
<blockquote>
<p>Thymeleaf模板的参数传递，并不是通过<code>HttpMessageConverter</code>来实现的，数据转换的实现主要是靠<code>IStandardJavaScriptSerializer</code></p>
</blockquote>
<h3> 4. Thymeleaf 长整型精度丢失问题解决方案</h3>
<p>既然直接返回json数据可以通过修改序列化的转换方式来实现，那么Thymeleaf按照这个思路，应该也是可行的</p>
<p>直接通过debug，我们可以知道Thymeleaf默认使用的是<code>JacksonStandardJavaScriptSerializer</code>来对js传递的对象进行序列化</p>
<figure><img src="/imgs/231027/02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>从<code>JacksonStandardJavaScriptSerializer</code>的实现来看，比较遗憾的是它并没有支持长整型转字符串，也没有预留给我们进行注册<code>Module</code>的口子</p>
<p>因此一个粗暴的解决方案就是反射拿到它，然后进行主动注册</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面配置完毕之后，正常我们再js中获取到的长整型就会变成字符串，不会再出现精度丢失问题了；直接再次验证一下，正常输出应该如下：</p>
<figure><img src="/imgs/231027/03.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>使用反射的方式虽然可以解决我们的诉求，但是不太优雅，既然官方定义了接口，我们完全可以注册自定义实现，来解决这个问题</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后再将我们自定义的是转换类注册到<code>TemplateEngine</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 5. 小结</h3>
<p>本文的内容相对较多，但是核心的问题解决思路只有一个：</p>
<p><strong>对于长整型的精度问题，解决方案就是将长整型转换为字符串</strong></p>
<p>对应的解决方案有下面几种</p>
<ol>
<li>后端直接编码中，对于长整型的字段转换为字符串进行返回</li>
<li>前端接收时，以字符串方式接收长整形</li>
<li>后端针对json返回，通过注册自定义的<code>HttpMessageConverter</code>做统一的长整型格式化转换</li>
<li>对于Thymeleaf模板渲染引擎，通过修改<code>IStandardJavaScriptSerializer</code>支持长整型的格式转换</li>
</ol>
<p>最后再抛出一个问题，上面给出了Thymeleaf的长整形转换，但是如果我用的是Freemaker渲染引擎， 序列化工具使用的是gson, fastjson，那应该怎么处理呢？</p>
<h2> III. 不能错过的源码和相关知识点</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/600-snowflake-id" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/600-snowflake-id</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/231027/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>1.内存缓存Caffeine基本使用</title>
      <link>https://liuyueyi.github.io/tutorial/spring/basic/%E7%BC%93%E5%AD%98/230307-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8B%E5%86%85%E5%AD%98%E7%BC%93%E5%AD%98Caffeine%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/basic/%E7%BC%93%E5%AD%98/230307-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8B%E5%86%85%E5%AD%98%E7%BC%93%E5%AD%98Caffeine%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">1.内存缓存Caffeine基本使用</source>
      <description>Caffeine作为当下本地缓存的王者被大量的应用再实际的项目中，可以有效的提高服务吞吐率、qps，降低rt 本文将简单介绍下Caffeine的使用姿势</description>
      <category>SpringBoot</category>
      <category>中间件</category>
      <category>Caffiene</category>
      <pubDate>Mon, 06 Mar 2023 22:55:36 GMT</pubDate>
      <content:encoded><![CDATA[<p>Caffeine作为当下本地缓存的王者被大量的应用再实际的项目中，可以有效的提高服务吞吐率、qps，降低rt</p>
<p>本文将简单介绍下Caffeine的使用姿势</p>
<!-- more -->
<h2> 项目配置</h2>
<h3> 1. 依赖</h3>
<p>首先搭建一个标准的SpringBoot项目工程，相关版本以及依赖如下</p>
<p>本项目借助<code>SpringBoot 2.2.1.RELEASE</code> + <code>maven 3.5.3</code> + <code>IDEA</code>进行开发</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 使用实例</h2>
<p>引入上面的jar包之后，就可以进入caffeine的使用环节了；我们主要依照官方wiki来进行演练</p>
<blockquote>
<ul>
<li><a href="https://github.com/ben-manes/caffeine/wiki/Home-zh-CN" target="_blank" rel="noopener noreferrer">Home zh CN · ben-manes/caffeine Wiki</a></li>
</ul>
</blockquote>
<p>caffeine提供了四种缓存策略，主要是基于手动添加/自动添加，同步/异步来进行区分</p>
<p>其基本使用姿势于Guava差不多</p>
<h3> 1. 手动加载</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 1.1 三种失效策略</h4>
<p>注意参数设置，我们先看一下失效策略，共有下面几种</p>
<p><strong>权重：</strong></p>
<ul>
<li>maximumSize: 基于容量策略，当缓存内元素个数超过时，通过基于就近度和频率的算法来驱逐掉不会再被使用到的元素</li>
<li>maximumWeight: 基于权重的容量策略，主要应用于缓存中的元素存在不同的权重场景</li>
</ul>
<p><strong>时间：</strong></p>
<ul>
<li>expireAfterAccess: 基于访问时间</li>
<li>expireAfterWrite: 基于写入时间</li>
<li>expireAfter: 可以根据读更新写入来调整有效期</li>
</ul>
<p><strong>引用：</strong></p>
<ul>
<li>weakKeys: 保存的key为弱引用</li>
<li>weakValues: 保存的value会使用弱引用</li>
<li>softValues: 保存的value使用软引用</li>
</ul>
<p>弱引用：这允许在GC的过程中，当没有被任何强引用指向的时候去将缓存元素回收</p>
<p>软引用：在GC过程中被软引用的对象将会被通过LRU算法回收</p>
<h4> 1.2 缓存增删查姿势</h4>
<p>接下来我们看一下手动方式的使用</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>查询缓存&amp;添加缓存</strong></p>
<ul>
<li><code>getIfPresent(key)</code>: 不存在时，返回null</li>
<li><code>get(key, (key) -&gt; {value初始化策略})</code>: 不存在时，会根据第二个lambda表达式来写入数据，这个就表示的是手动加载缓存</li>
<li><code>asMap</code>: 获取缓存所有数据</li>
</ul>
<p><strong>添加缓存</strong></p>
<ul>
<li><code>put(key, val)</code>: 主动添加缓存</li>
</ul>
<p><strong>清空缓存</strong></p>
<ul>
<li><code>invalidate</code>: 主动移除缓存</li>
<li><code>invalidateAll</code>: 失效所有缓存</li>
</ul>
<p>执行完毕之后，输出日志:</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 自动加载</h3>
<p>在创建的时候，就指定缓存未命中时的加载规则</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>它的配置，与前面介绍的一致；主要的区别点在于build时，确定缓存值的获取方式</p>
<h4> 2.1 缓存使用姿势</h4>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>与前面的区别在于获取缓存值的方式</p>
<ul>
<li>get(key): 不用传第二个参数，直接传key获取对应的缓存值，如果没有自动加载数据</li>
<li>getAll(keys): 可以批量获取数据，若某个key不再缓存中，会自动加载；在里面的则直接使用缓存的</li>
</ul>
<p>实际输出结果如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3.异步手动加载</h3>
<p>异步，主要是值在获取换粗内容时，采用的异步策略；使用与前面没有什么太大差别</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 3.1 缓存使用姿势</h4>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>getIfPresent: 存在时返回CompletableFuture，不存在时返回null，因此注意npe的问题</li>
<li>get(key, Function&lt;&gt;): 第二个参数表示加载数据的逻辑</li>
<li>put(key, CompletableFuture&lt;&gt;): 手动加入缓存，注意这里也不是直接加一个具体的value到缓存</li>
<li>synchronous().invalidate() : 同步清除缓存</li>
<li>getAll: 一次获取多个缓存，同样的是在缓存的取缓存，不在的根据第二个传参进行加载</li>
</ul>
<p>与前面相比，使用姿势差不多，唯一注意的是，获取的并不是直接的结果，而是CompletableFuture，上面执行之后的输出如下：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4. 异步自动加载</h3>
<p>在定义缓存时，就指定了缓存不存在的加载逻辑；与第二个相比区别在于这里是异步加载数据到缓存中</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 4.1 缓存使用姿势</h4>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 不能错过的源码和相关知识点</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>2.内存Caffeine整合Cachebale注解</title>
      <link>https://liuyueyi.github.io/tutorial/spring/basic/%E7%BC%93%E5%AD%98/230308-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8B%E5%86%85%E5%AD%98%E7%BC%93%E5%AD%98Caffeine%E6%95%B4%E5%90%88Cachebale%E6%B3%A8%E8%A7%A3.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/basic/%E7%BC%93%E5%AD%98/230308-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8B%E5%86%85%E5%AD%98%E7%BC%93%E5%AD%98Caffeine%E6%95%B4%E5%90%88Cachebale%E6%B3%A8%E8%A7%A3.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">2.内存Caffeine整合Cachebale注解</source>
      <description>前面一片文章虽说介绍了Caffeine的使用方式，但是更多的是偏向于基础的Caffeine用法；接下来这边博文将给大家介绍一下Caffeine结合Spring的@Cacheable注解，来实现内部缓存的使用姿势</description>
      <category>SpringBoot</category>
      <category>中间件</category>
      <category>Caffiene</category>
      <pubDate>Wed, 08 Mar 2023 22:55:36 GMT</pubDate>
      <content:encoded><![CDATA[<p>前面一片文章虽说介绍了Caffeine的使用方式，但是更多的是偏向于基础的Caffeine用法；接下来这边博文将给大家介绍一下Caffeine结合Spring的<code>@Cacheable</code>注解，来实现内部缓存的使用姿势</p>
<!-- more -->
<h2> 项目配置</h2>
<h3> 1. 依赖</h3>
<p>首先搭建一个标准的SpringBoot项目工程，相关版本以及依赖如下</p>
<p>本项目借助<code>SpringBoot 2.2.1.RELEASE</code> + <code>maven 3.5.3</code> + <code>IDEA</code>进行开发</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 配置</h3>
<p>SpringBoot官方对Caffeine的集成，提供了非常好的支持，比如本文介绍的在使用 <code>@Cacheable</code> 注解来处理缓存时，我们无需额外操作，直接在配置文件来实现缓存的指定，以及对应的Caffeine相关配置限定</p>
<p>核心配置如下 application.yml</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的 spring.cache.type 主要用来表明缓存注解的具体缓存实现为 Caffeine，当然还可以是Guava、redis等</p>
<p>其次就是 <code>spring.cache.caffeine.spec</code>， 它指定了Caffeine的初始化容量大小，最大个数，失效时间等 （无特殊场景时，所有的缓存注解都是公用这个配置的）</p>
<h2> 使用实例</h2>
<h3> 1. 开启缓存注解支持</h3>
<p>首先在启动类上添加 <code>@EnableCaching</code> 注解，注意若不加则缓存不会生效</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 使用实例</h3>
<p>我们定义一个UserService，主要是用来操作用户相关信息，现在先定义一个<code>User</code>实体类</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后添加增删查</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面分别介绍了三个注解</p>
<ul>
<li>CachePut: 不管缓存有没有，都将方法的返回结果写入缓存中</li>
<li>Cacheable: 先从缓存查，没有则执行方法，并塞入缓存</li>
<li>CacheEvit: 失效缓存</li>
</ul>
<p>其次在类上还有一个<code>@CacheConfig</code>注解，主要定义了一个 <code>cacheNames</code> 属性，当我们使用缓存注解时，需要注意的是这个cacheNames必须得有，否则就会报错</p>
<p>当一个类中所有缓存公用一个cacheNames时，可以直接在类上添加<code>@CacheConfig</code>来避免在每个地方都添加指定</p>
<h3> 3. 写个测试demo</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们来实际看一下，第一次没有数据时，返回的是不是空；当有数据之后，缓存是否会命中</p>
<figure><img src="/imgs/230308/00.gif" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 4. 小结</h3>
<p>这篇博文主要介绍了SpringBoot如何整合Caffeine，结合Spring的缓存注解，基于可以说是很低成本的就让我们的方法实现缓存功能，但是请注意，有几个注意点</p>
<ol>
<li>当我并不希望所有数据公用一个缓存时，怎么处理？</li>
</ol>
<ul>
<li>比如我有一些关键数据，虽然访问频率可能没那么高，但是还每次实际读取的成本很高，又不怎么变动，我希望可以更长久的缓存；</li>
<li>如果公用一个缓存，则有可能导致它们被其他的热点数据给挤下线了（超过最大数量限制给删除了）</li>
</ul>
<ol start="2">
<li>在实际使用时，需要特别注意，加了缓存注解之后，返回的实际上是缓存中的对象，如上面返回的是User对象还好，如果返回的是一个容器，那么直接像这些容器中进行额外的添加、删除元素，是直接影响缓存结果的</li>
</ol>
<p>另外，查看本文推荐结合下面几篇博文一起享用，以获取更多的知识点</p>
<ul>
<li><a href="https://spring.hhui.top/spring-blog/2021/06/16/210616-SpringBoot%E7%BC%93%E5%AD%98%E6%B3%A8%E8%A7%A3-Cacheable-CacheEvit-CachePut%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF%E4%BB%8B%E7%BB%8D/" target="_blank" rel="noopener noreferrer">【DB系列】缓存注解@Cacheable @CacheEvit @CachePut使用姿势介绍 | 一灰灰Blog</a></li>
<li><a href="https://spring.hhui.top/spring-blog/2021/07/01/210701-SpringBoot%E7%BC%93%E5%AD%98%E6%B3%A8%E8%A7%A3-Cacheable%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89key%E7%AD%96%E7%95%A5%E5%8F%8A%E7%BC%93%E5%AD%98%E5%A4%B1%E6%95%88%E6%97%B6%E9%97%B4%E6%8C%87%E5%AE%9A/" target="_blank" rel="noopener noreferrer">【DB系列】SpringBoot缓存注解@Cacheable之自定义key策略及缓存失效时间指定 | 一灰灰Blog</a></li>
</ul>
<h2> 不能错过的源码和相关知识点</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/500-cache-caffeine" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/500-cache-caffeine</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/230308/00.gif" type="image/gif"/>
    </item>
    <item>
      <title>3.内存缓存Caffiene自定义CacheManager</title>
      <link>https://liuyueyi.github.io/tutorial/spring/basic/%E7%BC%93%E5%AD%98/230309-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8B%E5%86%85%E5%AD%98%E7%BC%93%E5%AD%98Caffiene%E8%87%AA%E5%AE%9A%E4%B9%89CacheBean.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/basic/%E7%BC%93%E5%AD%98/230309-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8B%E5%86%85%E5%AD%98%E7%BC%93%E5%AD%98Caffiene%E8%87%AA%E5%AE%9A%E4%B9%89CacheBean.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">3.内存缓存Caffiene自定义CacheManager</source>
      <description>上一篇介绍了Caffiene整合Spring的缓存注解@Cacheable，在这篇示例中，所有的缓存公用，但是实际的场景中，我们可能会更希望针对不同的场景，配置不同的缓存（比如我的关键数据，虽然访问频率可能没那么高，但是每次实际读取的成本很高，又不怎么变动，我希望可以更长久的缓存；不希望这些数据因为缓存的淘汰策略被其他的热点数据给淘汰掉），那么可以怎么处理呢？ 接下来我们来看一下两种不同的方式，来实现上面的诉求</description>
      <category>SpringBoot</category>
      <category>中间件</category>
      <category>Caffiene</category>
      <pubDate>Thu, 09 Mar 2023 17:55:36 GMT</pubDate>
      <content:encoded><![CDATA[<p>上一篇介绍了Caffiene整合Spring的缓存注解@Cacheable，在这篇示例中，所有的缓存公用，但是实际的场景中，我们可能会更希望针对不同的场景，配置不同的缓存（比如我的关键数据，虽然访问频率可能没那么高，但是每次实际读取的成本很高，又不怎么变动，我希望可以更长久的缓存；不希望这些数据因为缓存的淘汰策略被其他的热点数据给淘汰掉），那么可以怎么处理呢？</p>
<p>接下来我们来看一下两种不同的方式，来实现上面的诉求</p>
<!-- more -->
<h2> 项目配置</h2>
<h3> 1. 依赖</h3>
<p>首先搭建一个标准的SpringBoot项目工程，相关版本以及依赖如下</p>
<p>本项目借助<code>SpringBoot 2.2.1.RELEASE</code> + <code>maven 3.5.3</code> + <code>IDEA</code>进行开发</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>与前面不同，我们不需要在配置文件中指定缓存类型以及caffeine的相关条件参数，直接放在配置类中</p>
<h3> 2. 配置类</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意上面的 cacheList，其中传入的就是<code>Cache</code>对象，每个Cache对象就可以理解为一个缓存实例，重点注意构造参数中的第一个<code>customCache</code>，这个就是后面缓存具体使用时，注解中的<code>cacheNames</code>属性</p>
<h2> 使用实例</h2>
<h3> 1. SimpleCacheManager 使用实例</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>重点注意一下上面的<code>@CacheConfig</code>，它定义了这个类中的的缓存，都使用 <code>customCacheManager</code> 缓存管理器，且具体的缓存为定义的<code>customCache</code> （改成其他的会报错）</p>
<p>从上面的配置声明，也可以看出，当我们希望使用多个缓存时，可以直接如下面这种方式进行扩展即可</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. CaffeineCacheManager 方式</h3>
<p>除了上面这种方式之外，我们当然也可以再额外定义一个CacheManager，如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用上面这种方式，cacheName可以不需要指定，具体使用如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>方法的内部实现完全一致；重点看<code>@CacheConfig</code>中的属性值</p>
<ul>
<li>cacheNames 表示这个缓存前缀，没有约束限制</li>
</ul>
<h3> 3. 测试</h3>
<p>上面介绍了两种使用不同缓存的姿势：</p>
<ul>
<li>SimpleCacheManager: 定义多个Cache</li>
<li>多个CacheManager</li>
</ul>
<p>我们写个简单的验证上面两个CacheManager表示不同缓存的测试用例</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>操作步骤：</p>
<ul>
<li>anoCacheService 写入缓存</li>
<li>anoCacheService2 查看缓存，此时不应该能查到前面写入的缓存</li>
</ul>
<figure><img src="/imgs/230309/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> 不能错过的源码和相关知识点</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/501-cache-caffeine-special" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/501-cache-caffeine-special</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/230309/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>缓存</title>
      <link>https://liuyueyi.github.io/tutorial/spring/basic/%E7%BC%93%E5%AD%98/</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/basic/%E7%BC%93%E5%AD%98/</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">缓存</source>
      <description>SpringBoot 缓存相关知识点 guava caffeine</description>
      <pubDate>Thu, 21 Sep 2023 09:55:31 GMT</pubDate>
      <content:encoded><![CDATA[<p>SpringBoot 缓存相关知识点</p>
<ul>
<li>guava</li>
<li>caffeine</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>14. 编程式属性绑定Binder</title>
      <link>https://liuyueyi.github.io/tutorial/spring/basic/%E9%85%8D%E7%BD%AE/14.230618-SpringBoot%E4%B9%8B%E7%BC%96%E7%A8%8B%E5%BC%8F%E5%B1%9E%E6%80%A7%E7%BB%91%E5%AE%9ABinder.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/basic/%E9%85%8D%E7%BD%AE/14.230618-SpringBoot%E4%B9%8B%E7%BC%96%E7%A8%8B%E5%BC%8F%E5%B1%9E%E6%80%A7%E7%BB%91%E5%AE%9ABinder.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">14. 编程式属性绑定Binder</source>
      <description>SpringBoot中极大的简化了项目中对于属性配置的加载方式，可以简单的通过 @Value, @ConfigurationProperties 来实现属性配置与Java POJO对象、Bean的成员变量的绑定，那如果出现一个某些场景，需要我们手动的、通过编程式的方式，将属性配置与给定的pojo对象进行绑定，我们又应该怎么实现呢?</description>
      <category>SpringBoot</category>
      <category>基础系列</category>
      <category>配置</category>
      <pubDate>Sun, 18 Jun 2023 11:28:28 GMT</pubDate>
      <content:encoded><![CDATA[<p>SpringBoot中极大的简化了项目中对于属性配置的加载方式，可以简单的通过 <code>@Value</code>, <code>@ConfigurationProperties</code> 来实现属性配置与Java POJO对象、Bean的成员变量的绑定，那如果出现一个某些场景，需要我们手动的、通过编程式的方式，将属性配置与给定的pojo对象进行绑定，我们又应该怎么实现呢?</p>
<!-- more -->
<h2> I. 项目配置</h2>
<h3> 1. 依赖</h3>
<p>首先搭建一个标准的SpringBoot项目工程，相关版本以及依赖如下</p>
<p>本项目借助<code>SpringBoot 2.2.1.RELEASE</code> + <code>maven 3.5.3</code> + <code>IDEA</code>进行开发</p>
<h3> 2. 启动入口</h3>
<p>我们使用默认的配置进行测试，因此启动入口也可以使用最基础的</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> II. 实例演示</h2>
<h3> 1. 基础知识点Binder</h3>
<p>本文的目的主要是给大家介绍编程式的属性绑定，当然除了我们最熟悉的直接写代码，从<code>Environment</code>中获取配置之外，还可以使用Binder来更方便的实现属性绑定</p>
<p>因此我们首先来了解一下这个不太常出现在CURD的日常工作中的Binder类：</p>
<blockquote>
<p><a href="https://docs.spring.io/spring-boot/docs/current/api/org/springframework/boot/context/properties/bind/Binder.html" target="_blank" rel="noopener noreferrer">Binder JavaDoc</a></p>
</blockquote>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>两种常见的使用姿势：</p>
<ul>
<li>bind方法: 将属性绑定到对应的类上, 不会返回null</li>
<li>bindOrCreate: 将属性绑定到对应的类上, 返回结果可能为null</li>
</ul>
<h3> 2. 实例演示</h3>
<p>接下来我们看几个常见的使用姿势</p>
<h4> 2.1 配置绑定到POJO属性类</h4>
<p>直接将配置绑定到我们自定义的属性配置类上，也就是我们最常见的、可直接利用<code>@ConfigurationProperties</code>来实现的使用方式</p>
<p>我们在配置文件中，添加一个基础的配置</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来定义一个对应的属性配置类Mail</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后我们的使用姿势，将如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面的基础使用姿势之上，我们再加两个使用姿势</p>
<ul>
<li>配置不存在时，返回什么？</li>
<li>使用bind对于不存在时，如何表现</li>
</ul>
<p>微调一下上面的bindInfo()方法</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>执行之后，输出如下</p>
<figure><img src="/imgs/230618/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>从上面的输出可以看出，对于</p>
<ul>
<li>bindOrCreat 而言，若整个配置不存在，返回一个空对象，内部属性为null； bind 若相关的配置不存在，会抛异常 (这个不存在指的是配置前缀<code>demo.mail2</code>的都没有)</li>
<li>配置内的某个属性不存在，如 <code>demo.mail.user</code> 这个配置不存在时（配置中的是username），此时bind/bindOrCrate 返回的对象中，相关的属性是null (主意这种场景 bind 方法调用不会抛移异常，有兴趣的小伙伴可以实际验证一下)</li>
</ul>
<h4> 2.2 配置绑定到List对象</h4>
<p>在实际的应用场景中，配置为数组的可能性也很高，比如我有一个代理库，对应的相关配置如下</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>此时我们的实际使用姿势可以如下</p>
<ul>
<li>首先定义Proxy类</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对应的手动绑定方式</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4> 2.3 配置绑定到Map对象</h4>
<p>将属性配置绑定到一个Map的场景也不算少见，如之前写过的多数据源自主切换的实现方式中，就有这么个场景</p>
<ul>
<li><a href="https://spring.hhui.top/spring-blog/2021/01/10/210110-SpringBoot%E7%B3%BB%E5%88%97Mybatis%E5%9F%BA%E4%BA%8EAbstractRoutingDataSource%E4%B8%8EAOP%E5%AE%9E%E7%8E%B0%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E5%88%87%E6%8D%A2/" target="_blank" rel="noopener noreferrer">SpringBoot系列Mybatis基于AbstractRoutingDataSource与AOP实现多数据源切换/</a></li>
</ul>
<p>我们写一个简单的配置模拟上面的场景</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面的配置中，master/slave 为数据源名称，在下面的配置则为数据源配置信息，结构都一致；基于此，我们需要声明的配置类实际为</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>配置绑定的实现也很简单，与上面List的类似</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>执行之后的输出结果如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4> 2.4 配置转换处理</h4>
<p>上面介绍的姿势都是直接将配置绑定到对应的java对象上，那么我们是否会存在需要对配置属性进行特殊处理的场景呢？</p>
<p>这种场景当然也不算少见，如驼峰与下划线的互转，如密码之类的配置文件中属于加密填写，应用加载时需要解密之后使用等</p>
<p>对于这种场景，我们也给出一个简单的实例，在配置文件中，添加一个base64加密的数据</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对应的解析方式</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>执行之后，实际输出结果如下：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4> 2.5 绑定方法回调</h4>
<p>除了上面介绍到的属性绑定姿势之外，Binder还非常贴心的给大家提供了过程回调，给你提供更灵活的控制方式</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>同样是实现配置解密，如上面的方式也是可行的，对应的输出如</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. 小结</h3>
<p>本文的知识点比较简单，属于看过就会的范畴，但是它的实际应用场景可以说非常多；特别是当我们在某些场景下，直接使用SpringBoot的属性配置绑定不太好实现时，如动态数据源、配置的回调处理等，不妨考虑借助Binder来实现编程式的配置绑定加载</p>
<p>其次本文只介绍了Binder类的使用姿势，有好气的小伙伴，自然会想了解它的具体实现姿势，它是怎么实现配置属性与java实体类进行绑定的呢？ 类型转换如何支持的呢？ 如果让我们自己来实现配置绑定，可以怎么支持呢？</p>
<p>不妨再进一步，让我们实现一个自定义的配置加载、解析、绑定并注入到Spring容器的解决方案，可以怎么整？</p>
<h2> III. 不能错过的源码和相关知识点</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/230618/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>15.自定义属性配置绑定极简实现姿势介绍</title>
      <link>https://liuyueyi.github.io/tutorial/spring/basic/%E9%85%8D%E7%BD%AE/15.230627-SpringBoot%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7%E9%85%8D%E7%BD%AE%E7%BB%91%E5%AE%9A%E5%AE%9E%E7%8E%B0%E4%BB%8B%E7%BB%8D.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/basic/%E9%85%8D%E7%BD%AE/15.230627-SpringBoot%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7%E9%85%8D%E7%BD%AE%E7%BB%91%E5%AE%9A%E5%AE%9E%E7%8E%B0%E4%BB%8B%E7%BB%8D.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">15.自定义属性配置绑定极简实现姿势介绍</source>
      <description>使用过SpringBoot应用的小伙伴应该对它配套的配置文件application.yml不会陌生，通常我们将应用需要的配置信息，放在配置文件中，然后再应用中，就可以通过 @Value 或者 @ConfigurationProperties来引用 那么配置信息只能放在这些配置文件么？ 能否从db/redis中获取配置信息呢？ 又或者借助http/rpc从其他的应用中获取配置信息呢？ 答案当然是可以，比如我们熟悉的配置中心（apollo, nacos, SpringCloudConfig) 接下来我们将介绍一个不借助配置中心，也可以实现自定义配置信息加载的方式，并且支持配置的动态刷新</description>
      <category>SpringBoot</category>
      <category>基础系列</category>
      <category>配置</category>
      <pubDate>Tue, 27 Jun 2023 04:46:58 GMT</pubDate>
      <content:encoded><![CDATA[<p>使用过SpringBoot应用的小伙伴应该对它配套的配置文件application.yml不会陌生，通常我们将应用需要的配置信息，放在配置文件中，然后再应用中，就可以通过 <code>@Value</code> 或者 <code>@ConfigurationProperties</code>来引用</p>
<p>那么配置信息只能放在这些配置文件么？ 能否从db/redis中获取配置信息呢？ 又或者借助http/rpc从其他的应用中获取配置信息呢？</p>
<p>答案当然是可以，比如我们熟悉的配置中心（apollo, nacos, SpringCloudConfig)</p>
<p>接下来我们将介绍一个不借助配置中心，也可以实现自定义配置信息加载的方式，并且支持配置的动态刷新</p>
<!-- more -->
<h2> I. 项目配置</h2>
<h3> 1. 依赖</h3>
<p>首先搭建一个标准的SpringBoot项目工程，相关版本以及依赖如下</p>
<p>本项目借助<code>SpringBoot 2.2.1.RELEASE</code> + <code>maven 3.5.3</code> + <code>IDEA</code>进行开发</p>
<p>添加web支持，用于配置刷新演示</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 启动入口</h3>
<p>我们使用默认的配置进行测试，因此启动入口也可以使用最基础的</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> II. 自定义配置实现</h2>
<h3> 1. 方案设计</h3>
<p>我们的目标是实现一个自定义的配置信息加载，并支持配置与Spring bean对象的绑定，同时我们还需要支持这个配置的动态刷新</p>
<p>基于上面这个目标，要想实现则需要几个知识储备：</p>
<ul>
<li><a href="https://spring.hhui.top/spring-blog/2020/05/07/200507-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B9%8B%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E8%87%AA%E5%AE%9A%E4%B9%89%E9%85%8D%E7%BD%AE%E5%8A%A0%E8%BD%BD%E5%99%A8/" target="_blank" rel="noopener noreferrer">【基础系列】 实现一个自定义配置加载器（应用篇） | 一灰灰Blog</a></li>
<li><a href="https://spring.hhui.top/spring-blog/2021/01/17/210117-SpringBoot%E7%B3%BB%E5%88%97ConfigurationProperties%E9%85%8D%E7%BD%AE%E7%BB%91%E5%AE%9A%E4%B8%AD%E9%82%A3%E4%BA%9B%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%E4%BA%8B%E6%83%85/" target="_blank" rel="noopener noreferrer">【基础系列】 ConfigurationProperties配置绑定中那些你不知道的事情 | 一灰灰Blog</a></li>
<li><a href="https://spring.hhui.top/spring-blog/2021/08/01/210801-SpringBoot%E5%BA%94%E7%94%A8%E7%AF%87-Value%E6%B3%A8%E8%A7%A3%E6%94%AF%E6%8C%81%E9%85%8D%E7%BD%AE%E8%87%AA%E5%8A%A8%E5%88%B7%E6%96%B0%E8%83%BD%E5%8A%9B%E6%89%A9%E5%B1%95/" target="_blank" rel="noopener noreferrer">【基础系列】 SpringBoot应用篇@Value注解支持配置自动刷新能力扩展 | 一灰灰Blog</a></li>
<li><a href="https://spring.hhui.top/spring-blog/2023/06/18/230618-SpringBoot%E4%B9%8B%E7%BC%96%E7%A8%8B%E5%BC%8F%E5%B1%9E%E6%80%A7%E7%BB%91%E5%AE%9ABinder/" target="_blank" rel="noopener noreferrer">【基础系列】 编程式属性绑定Binder | 一灰灰Blog</a></li>
</ul>
<p>结合上面的知识点，我们主要需要实现的有三步：</p>
<ol>
<li>读取自定义的配置</li>
<li>扫描需要绑定自定义配置的bean</li>
<li>借助Binder来重新绑定bean中的定义的属性到envionment的配置参数（这里就包含了自定义的配置及默认的配置）</li>
</ol>
<h3> 2. 实现方式</h3>
<p>为了简化自定义的配置使用，我们这里直接使用一个内存缓存来模拟自定义的配置源</p>
<h4> 2.1 加载自定义配置源</h4>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意上面的实现，这里是自定义的配置源 propertySources 中包含了environment的配置信息；如果希望将自定义的配置信息源注入到environment，可以如下实现</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h4> 2.2 扫描需要绑定bean</h4>
<p>接下来我们自定义一个注解<code>@ConfDot</code>, 凡是带有这个注解的bean的成员变量，从上面的属性源中进行初始化</p>
<p>这个注解可以完全按照<code>@ConfigurationProperties</code>的来设计（实际上我们也可以直接使用<code>@ConfigurationProperties</code>注解，这样适用范围更广了）</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后借助Spring来扫描带有特定注解的bean，就可以很简单了</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 2.3 bean与配置的绑定</h4>
<p>上面两部完成之后，接下来就需要我们将配置与bean进行绑定，这里就主要使用Binder来实现我们的预期功能了</p>
<p>实现一个自定义的绑定工具类</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的实现虽然多，但是核心其实比较简单：</p>
<ol>
<li>初始化Binder对象 <code>this.binder = new Binder(getConfigurationPropertySources(), getPropertySourcesPlaceholdersResolver(), getConversionService(), getPropertyEditorInitializer());</code></li>
<li>提供绑定入口</li>
</ol>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 2.4 完整实现</h4>
<p>上面的三步实现，基本上已经将整个功能给实现了，其中<code>SelfConfigBinder</code>提供了完成的代码实现，接下来我们再将第一步与第三步的整合，来看一下完整的实现，并且提供一个配置刷新的支持</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. 测试验证</h3>
<p>接下来就是验证一下上面的设计，首先再配置文件中，添加几个默认的信息</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>绑定配置的bean对象</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这个MyConfig中的 user, pwd 从前面的配置文件中获取，然后type则此自定义的配置信息<code>configCache</code>中获取，应该是12，接下来我们首先一个访问与刷新的接口</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>实际执行测试如下图</p>
<figure><img src="/imgs/230627/00.gif" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> III. 不能错过的源码和相关知识点</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-case/003-self-config-binder" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-case/003-self-config-binder</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/230627/00.gif" type="image/gif"/>
    </item>
    <item>
      <title>1.数据库初始化-DataSourceInitializer方式</title>
      <link>https://liuyueyi.github.io/tutorial/spring/db/%E5%9F%BA%E7%A1%80/221221-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%9D%E5%A7%8B%E5%8C%96-DataSourceInitializer%E6%96%B9%E5%BC%8F.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/db/%E5%9F%BA%E7%A1%80/221221-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%9D%E5%A7%8B%E5%8C%96-DataSourceInitializer%E6%96%B9%E5%BC%8F.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">1.数据库初始化-DataSourceInitializer方式</source>
      <description>前面介绍的两篇基于配置方式的数据库初始化方式，使用起来非常简单，但是有一个非常明显的问题，如何实现表结构存在时不再初始化，不存在时才执行？ 如果数据库也不存在，也需要初始化时创建，可行么？ 接下来介绍一下如何使用DataSourceInitializer来实现自主可控的数据初始化</description>
      <category>SpringBoot</category>
      <category>DB系列</category>
      <category>初始化</category>
      <pubDate>Wed, 21 Dec 2022 11:52:03 GMT</pubDate>
      <content:encoded><![CDATA[<p>前面介绍的两篇基于配置方式的数据库初始化方式，使用起来非常简单，但是有一个非常明显的问题，如何实现表结构存在时不再初始化，不存在时才执行？ 如果数据库也不存在，也需要初始化时创建，可行么？</p>
<p>接下来介绍一下如何使用DataSourceInitializer来实现自主可控的数据初始化</p>
<!-- more -->
<h2> I. 项目搭建</h2>
<h3> 1. 依赖</h3>
<p>首先搭建一个标准的SpringBoot项目工程，相关版本以及依赖如下</p>
<p>本项目借助<code>SpringBoot 2.2.1.RELEASE</code> + <code>maven 3.5.3</code> + <code>IDEA</code>进行开发</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>本文使用MySql数据库, 版本8.0.31</p>
<h3> 2. 配置</h3>
<p>注意实现初始化数据库表操作的核心配置就在下面，重点关注</p>
<p>配置文件： <code>resources/application.yml</code></p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意上面的配置，我们新定义了一个数据库的配置项 <code>database.name</code>， 主要是为了检测database是否存在，若不存在时，创建对应的数据库时使用</p>
<p>接下来是初始化sql脚本</p>
<p><code>resources/init-schema.sql</code> 对应的初始化ddl</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>resources/init-data.sql</code> 对用的初始化dml</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2> II. 初始化</h2>
<h3> 1.初始化配置</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们这里主要是借助 DataSourceInitializer 来实现初始化，其核心有两个配置</p>
<ul>
<li>DatabasePopulator: 通过<code>addScripts</code>来指定对应的sql文件</li>
<li>DataSourceInitializer#setEnabled: 判断是否需要执行初始化</li>
</ul>
<p>接下来重点需要看的就是needInit方法，我们再这个方法里面，需要判断数据库是否存在，若不存在时，则创建数据库；然后再判断表是否存在，以此来决定是否需要执行初始化方法</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的数据库判断是否存在以及初始化的过程相对基础，直接使用了基础的Connection进行操作；这里借助了SpringUtil来获取配置信息，对应的类源码如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>到此整个初始化相关的配置已经完成；接下来我们验证一下</p>
<h3> 2.验证</h3>
<p>再项目启动成功之后，查看一下数据</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/221221/03.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 3. 小结</h3>
<p>本文主要介绍的是基于<code>DataSourceInitializer</code>来实现自主可控的数据初始化，其核心配置为</p>
<ul>
<li>DatabasePopulator: 通过<code>addScripts</code>来指定对应的sql文件</li>
<li>DataSourceInitializer#setEnabled: 判断是否需要执行初始化</li>
</ul>
<p>此外本文还介绍了如何判断数据库是否存在，当数据库不存在时，借助基础的Connection来建立连接，创建数据库；从初始化角度来看，这几篇文中介绍的方式已经足够，但是在项目制的场景下，我们需要记录数据库的版本迭代记录，下一篇将介绍如何使用liquibase来实现数据版本管理，解决初始化以及增量的迭代变更</p>
<h2> III. 不能错过的源码和相关知识点</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/221221/03.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>2.数据库初始化-datasource配置方式</title>
      <link>https://liuyueyi.github.io/tutorial/spring/db/%E5%9F%BA%E7%A1%80/221221-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%9D%E5%A7%8B%E5%8C%96-datasource%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/db/%E5%9F%BA%E7%A1%80/221221-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%9D%E5%A7%8B%E5%8C%96-datasource%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">2.数据库初始化-datasource配置方式</source>
      <description>在我们的日常业务开发过程中，如果有db的相关操作，通常我们是直接建立好对应的库表结构，并初始化对应的数据，即更常见的情况下是我们在已有表结构基础之下，进行开发； 但是当我们是以项目形式工作时，更常见的做法是所有的库表结构变更、数据的初始、更新等都需要持有对应的sql变更，并保存在项目工程中，这也是使用liqubase的一个重要场景； 将上面的问题进行简单的翻译一下，就是如何实现在项目启动之后执行相应的sql，实现数据库表的初始化？ 本文将作为初始化方式的第一篇：基于SpringBoot的配置方式实现的数据初始化</description>
      <category>SpringBoot</category>
      <category>DB系列</category>
      <category>初始化</category>
      <pubDate>Wed, 21 Dec 2022 09:57:22 GMT</pubDate>
      <content:encoded><![CDATA[<p>在我们的日常业务开发过程中，如果有db的相关操作，通常我们是直接建立好对应的库表结构，并初始化对应的数据，即更常见的情况下是我们在已有表结构基础之下，进行开发；
但是当我们是以项目形式工作时，更常见的做法是所有的库表结构变更、数据的初始、更新等都需要持有对应的sql变更，并保存在项目工程中，这也是使用liqubase的一个重要场景；
将上面的问题进行简单的翻译一下，就是如何实现在项目启动之后执行相应的sql，实现数据库表的初始化？</p>
<p>本文将作为初始化方式的第一篇：基于SpringBoot的配置方式实现的数据初始化</p>
<!-- more -->
<h2> I. 项目搭建</h2>
<h3> 1. 依赖</h3>
<p>首先搭建一个标准的SpringBoot项目工程，相关版本以及依赖如下</p>
<p>本项目借助<code>SpringBoot 2.2.1.RELEASE</code> + <code>maven 3.5.3</code> + <code>IDEA</code>进行开发</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>本文使用MySql数据库, 版本8.0.31</p>
<h3> 2. 配置</h3>
<p>注意实现初始化数据库表操作的核心配置就在下面，重点关注</p>
<p>配置文件： <code>resources/application.yml</code></p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的配置中，相比较于普通的数据库链接配置，多了几个配置项</p>
<ul>
<li>spring.datasource.initialization-mode: 取值为 always，改成其他的会导致sql不会被执行</li>
<li>spring.datasource.platform: mysql</li>
<li>spring.datasource.seprator: ;  这个表示sql之间的分隔符</li>
<li>spring.datasource.data: classpath:config-data.sql  取值可以是数组，这里存的是初始化数据的sql文件地址</li>
<li>spring.datasource.data-username:  上面data对应的sql文件执行用户名</li>
<li>spring.datasource.data-password:  上面data对应的sql文件执行用户密码</li>
<li>spring.datasource.schema: classpath:config-schema.sql   取值也可以是数组，这里存的是初始化表结构的sql文件地址</li>
</ul>
<h3> 3. 初始化sql</h3>
<p>上面指定了两个sql，一个是用于建表的ddl，一个是用于初始化数据的dml</p>
<p><code>resources/config-schema.sql</code> 文件对应的内容如下</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>resources/config-data.sql</code> 文件对应的内容如下</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2> II. 示例</h2>
<h3> 1. 验证demo</h3>
<p>接下来上面的工作准备完毕之后，在我们启动项目之后，正常就会执行上面的两个sql，我们写一个简单的验证demo</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/221221/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 2. 问题记录</h3>
<p>从上面的过程走下来，看起来很简单，但是在实际的使用过程中，很容易遇到不生效的问题，下面记录一下</p>
<h4> 2.1 只有初始化数据data.sql，没有schema.sql时，不生效</h4>
<p>当库表已经存在时，此时我们可能并没有上文中的<code>config-schema.sql</code>文件，此时对应的配置可能是</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如上面所示，当我们只指定了data时，会发现data对应的sql文件也不会被执行；即要求schema对应的sql文件也必须同时存在</p>
<p>针对上面这种情况，可以考虑将data.sql中的语句，卸载schema.sql中</p>
<h4> 2.2 版本问题导致配置不生效</h4>
<p>在SpringBoot2.5+版本，使用 <code>spring.sql.init</code> 代替上面的配置项</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>相关的配置参数说明如下</p>
<ul>
<li><code>spring.sql.init.enabled</code>：是否启动初始化的开关，默认是true。如果不想执行初始化脚本，设置为false即可。通过-D的命令行参数会更容易控制。</li>
<li><code>spring.sql.init.username</code>和<code>spring.sql.init.password</code>：配置执行初始化脚本的用户名与密码。这个非常有必要，因为安全管理要求，通常给业务应用分配的用户对一些建表删表等命令没有权限。这样就可以与datasource中的用户分开管理。</li>
<li><code>spring.sql.init.schema-locations</code>：配置与schema变更相关的sql脚本，可配置多个（默认用;分割）</li>
<li><code>spring.sql.init.data-locations</code>：用来配置与数据相关的sql脚本，可配置多个（默认用;分割）</li>
<li><code>spring.sql.init.encoding</code>：配置脚本文件的编码</li>
<li><code>spring.sql.init.separator</code>：配置多个sql文件的分隔符，默认是;</li>
<li><code>spring.sql.init.continue-on-error</code>：如果执行脚本过程中碰到错误是否继续，默认是false`</li>
</ul>
<h4> 2.3 mode配置不对导致不生效</h4>
<p>当配置完之后发，发现sql没有按照预期的执行，可以检查一下<code>spring.datasource.initialization-mode</code>配置是否存在，且值为<code>always</code></p>
<h4> 2.4 重复启动之后，报错</h4>
<p>同样上面的项目，在第一次启动时，会执行schema对应的sql文件，创建表结构；执行data对应的sql文件，初始化数据；但是再次执行之后就会报错了，会提示表已经存在</p>
<p>即初始化是一次性的，第一次执行完毕之后，请将<code>spring.datasource.initialization-mode</code>设置为<code>none</code></p>
<h3> 3. 小结</h3>
<p>本文主要介绍了项目启动时，数据库的初始化方式，当然除了本文中介绍的<code>spring.datasource</code>配置之外，还有<code>spring.jpa</code>的配置方式</p>
<p>对于配置方式不太友好的地方则在于不好自适应控制，若表存在则不执行；若不存在则执行；后面将介绍如何使用<code>DataSourceInitializer</code>来实现自主可控的数据初始化，以及更现代化一些的基于liquibase的数据库版本管理记录</p>
<h2> III. 不能错过的源码和相关知识点</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/161-schema-init" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/161-schema-init</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/221221/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>3.数据库初始化-jpa配置方式</title>
      <link>https://liuyueyi.github.io/tutorial/spring/db/%E5%9F%BA%E7%A1%80/221221-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%9D%E5%A7%8B%E5%8C%96-jpa%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/db/%E5%9F%BA%E7%A1%80/221221-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%9D%E5%A7%8B%E5%8C%96-jpa%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">3.数据库初始化-jpa配置方式</source>
      <description>上一篇博文介绍如何使用spring.datasource来实现项目启动之后的数据库初始化，本文作为数据库初始化的第二篇，将主要介绍一下，如何使用spring.jpa的配置方式来实现相同的效果</description>
      <category>SpringBoot</category>
      <category>DB系列</category>
      <category>初始化</category>
      <pubDate>Wed, 21 Dec 2022 10:59:32 GMT</pubDate>
      <content:encoded><![CDATA[<p>上一篇博文介绍如何使用<code>spring.datasource</code>来实现项目启动之后的数据库初始化，本文作为数据库初始化的第二篇，将主要介绍一下，如何使用<code>spring.jpa</code>的配置方式来实现相同的效果</p>
<!-- more -->
<h2> I. 项目搭建</h2>
<h3> 1. 依赖</h3>
<p>首先搭建一个标准的SpringBoot项目工程，相关版本以及依赖如下</p>
<p>本项目借助<code>SpringBoot 2.2.1.RELEASE</code> + <code>maven 3.5.3</code> + <code>IDEA</code>进行开发</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>本文使用MySql数据库, 版本8.0.31</p>
<h3> 2. 配置</h3>
<p>注意实现初始化数据库表操作的核心配置就在下面，重点关注</p>
<p>配置文件： <code>resources/application.yml</code></p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意上面jpa的一个配置，其次就是上一篇博文中介绍的 <code>spring.datasource.initialization-mode</code> 同样需要将配置设置为 <code>always</code></p>
<p>使用jpa的配置方式，将<code>ddl-auto</code>设置为<code>create</code>或者<code>create-drop</code>时，会自动搜索<code>@Entity</code>实体对象，并创建为对应的表</p>
<h2> II. 示例</h2>
<h3> 1. 验证demo</h3>
<p>接下来上面的工作准备完毕之后，我们先创建一个实体对象</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来我们的目标就是基于上面这个实体类生成对应的表结构</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>直接启动项目之后，到数据库中将可以查到已经创建了一个库<code>user3</code></p>
<figure><img src="/imgs/221221/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 2. 初始化数据</h3>
<p>上面的过程只是初始化了表结构，如果我们希望导入一些初始化数据，可以怎么办？</p>
<p>如上面的配置： <code>spring.jpa.hibernate.ddl-auto: update</code>，此时在资源目录下，新建 <code>data.sql</code> , 取值为</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>然后再次执行，既可以看到db中会新增一条数据</p>
<figure><img src="/imgs/221221/02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>若<code>spring.jpa.hibernate.ddl-auto: create</code>，则再资源目录下，新建<code>import.sql</code>文件，来实现数据初始化</p>
<h3> 3. 小结</h3>
<p>使用Jpa的配置方式，总体来说和前面的介绍的spring.datasource的配置方式差别不大，jpa方式主要是基于<code>@Entity</code>来创建对应的表结构，且不会出现再次启动之后重复建表导致异常的问题（注意如上面data.sql中的数据插入依然会重复执行，会导致主键插入冲突）</p>
<p>本文中需要重点关注的几个配置:</p>
<ul>
<li>spring.datasource.initialization-mode: always 同样需要设置为always</li>
<li>spring.jpa.generate-ddl: true 会根据@Entity注解的实体类生成对应数据表</li>
<li>spring.jpa.hibernate.ddl-auto: create/create-drop 这两个取值时，再创建表之后执行import.sql文件导入测试数据；若取值为update，则会执行data.sql</li>
</ul>
<p>本文作为数据初始化第二篇，推荐与前文对比阅读，收获更多的知识点 <a href="https://spring.hhui.top/spring-blog/2022/12/21/221221-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%9D%E5%A7%8B%E5%8C%96-datasource%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F/" target="_blank" rel="noopener noreferrer">【DB系列】 数据库初始化-datasource配置方式</a></p>
<h2> III. 不能错过的源码和相关知识点</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/161-schema-init" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/161-schema-init</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/221221/01.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>4.数据库版本管理Liquibase集成</title>
      <link>https://liuyueyi.github.io/tutorial/spring/db/%E5%9F%BA%E7%A1%80/221222-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86Liquibase%E9%9B%86%E6%88%90.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/db/%E5%9F%BA%E7%A1%80/221222-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86Liquibase%E9%9B%86%E6%88%90.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">4.数据库版本管理Liquibase集成</source>
      <description>前面几篇介绍了项目启动之后进行数据库初始化的几种方式，接下来我们看一下如何使用Liquibase来实现数据库版本管理</description>
      <category>SpringBoot</category>
      <category>DB系列</category>
      <category>Liquebase</category>
      <pubDate>Thu, 22 Dec 2022 12:52:35 GMT</pubDate>
      <content:encoded><![CDATA[<p>前面几篇介绍了项目启动之后进行数据库初始化的几种方式，接下来我们看一下如何使用Liquibase来实现数据库版本管理</p>
<!-- more -->
<p>SpringBoot内置了对Liquibase的支持，在项目中使用非常简单</p>
<h2> I. 项目搭建</h2>
<h3> 1. 依赖</h3>
<p>首先搭建一个标准的SpringBoot项目工程，相关版本以及依赖如下</p>
<p>本项目借助<code>SpringBoot 2.2.1.RELEASE</code> + <code>maven 3.5.3</code> + <code>IDEA</code>进行开发</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>本文使用MySql数据库, 版本8.0.31; Liquibase的核心依赖<code>liquibase-core</code>，版本推荐使用SpringBoot配套的版本，一般来讲无需特殊指定</p>
<h3> 2. 配置</h3>
<p>配置文件 <code>resources/application.yml</code></p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>关键配置为 <code>spring.liquibase.change-log</code> 和 <code>spring.liquibase.enabled</code></p>
<p>第一个指定的是change-log对应的xml文件，其内容如下</p>
<p>liquibase核心xml文件 <code>resources/liquibase/master.xml</code></p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的xml依赖了一个xml文件，如第一个主要定义的是初始化的表结构</p>
<p><code>resources/changelog/000_initial_schema.xml</code> 对应的内容如下</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面的配置文件中，核心点在 <code>&lt;changeSet&gt;</code> 其中id要求全局唯一，<code>sqlFile</code>表示这次变动对应的sql语句; 一个<code>&lt;changeSet&gt;</code>对应一次变更，注意每次变更完成之后，不能再修改（sql文件内容不能改），changeSet本身也不要再去修改</p>
<p>接下来再看一下对应的sql文件</p>
<p><code>resources/liquibase/data/init_schema_221209.sql</code>对应的schema相关的表结构定义如下</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>resources/liquibase/data/init_data_221209.sql</code>对应的初始化数据定义如下</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2> II. 项目演示</h2>
<h3> 1. 测试</h3>
<p>上面配置完毕之后，再主项目结构工程中无需特殊处理，我们写一个简单的启动测试一下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>直接执行之后看一下输出结果(再执行之前，请确保数据库已经创建成功了；若没有则会抛异常)</p>
<figure><img src="/imgs/221222/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 2. 增量变更</h3>
<p>上面演示的是初始化过程；再实际开发过程中，若存在增量的变更，比如现在需要新增一个测试数据，此时我们的操作流程可以如下</p>
<p>再<code>liquibase/</code>目录下新增一个<code>001_change_schema.xml</code>文件，后续的增量变更相关的<code>ChangeSet</code>都放在这个xml文件中；再master.xml文件中，添加上面xml文件的引入</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>其次就是 <code>resources/liquibase/changelog/001_change_schema.xml</code> 文件内容</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的<code>changeSet</code>中包含初始化相关的sql文件，内容如下</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>再次启动验证一下，是否增加了新的数据</p>
<figure><img src="/imgs/221222/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 3. 小结</h3>
<p>本文主要介绍的是SpringBoot如何结合Liquibase来实现数据库版本管理，核心知识点介绍得不多，再实际使用的时候，重点注意</p>
<p>每次变更，都新增一个 <code>&lt;changeSet&gt;</code>，且保证所有的id唯一；当变更完成之后，不要再修改对应sql文件内容</p>
<blockquote>
<p>liquibase本身也有一些相关的知识点，如版本回滚，标签语义等，下篇博文再专门介绍Liquibase本身的核心知识点</p>
</blockquote>
<p>如对项目启动之后数据初始话相关有兴趣的小伙伴，欢迎查看</p>
<ul>
<li><a href="https://spring.hhui.top/spring-blog/2022/12/21/221221-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%9D%E5%A7%8B%E5%8C%96-datasource%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F/" target="_blank" rel="noopener noreferrer">【DB系列】数据库初始化-datasource配置方式 | 一灰灰Blog</a></li>
<li><a href="https://spring.hhui.top/spring-blog/2022/12/21/221221-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%9D%E5%A7%8B%E5%8C%96-jpa%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F/" target="_blank" rel="noopener noreferrer">【DB系列】数据库初始化-jpa配置方式 | 一灰灰Blog</a></li>
<li><a href="https://spring.hhui.top/spring-blog/2022/12/21/221221-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%9D%E5%A7%8B%E5%8C%96-DataSourceInitializer%E6%96%B9%E5%BC%8F/" target="_blank" rel="noopener noreferrer">【DB系列】数据库初始化-DataSourceInitializer方式 | 一灰灰Blog</a></li>
</ul>
<h2> III. 不能错过的源码和相关知识点</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/162-liquibase" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/162-liquibase</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/221222/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>5.SQL执行日志打印的几种方式</title>
      <link>https://liuyueyi.github.io/tutorial/spring/db/%E5%9F%BA%E7%A1%80/230719-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8BDB%E6%89%A7%E8%A1%8C%E6%97%A5%E5%BF%97%E6%89%93%E5%8D%B0%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/db/%E5%9F%BA%E7%A1%80/230719-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8BDB%E6%89%A7%E8%A1%8C%E6%97%A5%E5%BF%97%E6%89%93%E5%8D%B0%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">5.SQL执行日志打印的几种方式</source>
      <description>sql日志打印，再我们日常排查问题时，某些时候帮助可以说是非常大的，那么一般的Spring项目中，可以怎么打印执行的sql日志呢？ 本文将介绍三种sql日志打印的方式： Druid打印sql日志 Mybatis自带的日志输出 基于拦截器实现sql日志输出</description>
      <category>SpringBoot</category>
      <category>DB系列</category>
      <category>Mybatis</category>
      <pubDate>Wed, 19 Jul 2023 08:52:04 GMT</pubDate>
      <content:encoded><![CDATA[<p>sql日志打印，再我们日常排查问题时，某些时候帮助可以说是非常大的，那么一般的Spring项目中，可以怎么打印执行的sql日志呢？</p>
<p>本文将介绍三种sql日志打印的方式：</p>
<ol>
<li>Druid打印sql日志</li>
<li>Mybatis自带的日志输出</li>
<li>基于拦截器实现sql日志输出</li>
</ol>
<!-- more -->
<h2> I. 项目配置</h2>
<h3> 1. 依赖</h3>
<p>首先搭建一个标准的SpringBoot项目工程，相关版本以及依赖如下</p>
<p>本项目借助<code>SpringBoot 2.2.1.RELEASE</code> + <code>maven 3.5.3</code> + <code>IDEA</code>进行开发</p>
<p>添加web支持，用于配置刷新演示</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 配置</h3>
<p>接下来配置一下db的相关配置 <code>application.yml</code></p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>关于上面配置的一些细节，后面进行细说</p>
<p>我们创建一个用于测试的数据库</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对应的myabtis-config.xml，配置我们自定义的sql日志输出拦截器</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> II. 实例</h2>
<h3> 1. mybatis默认配置</h3>
<p>我们先看一下mybatis的默认日志输出方案，首先写一个<code>money</code>数据库的db操作mapper</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来重点看一下，如需开启myabtis默认的sql日志输出，应该如何配置</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>重点看上面的 <code>mybatis.configuration.log-prefix</code> 与 <code>myabtis.configuration.log-impl</code> 这里制定了日志输出的方式</p>
<p>但是请注意，通常我们的日志是基于<code>logback/slf4j</code>来输出，默认的mybati的sql日志输出是debug级别，所以要看到输出的sql日志，还需要配置一下日志输出级别（本项目的实例中是直接控制台输出，因此不配置下面的也没有问题）</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后写个demo验证一下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/230719/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>从上图可以看出，myabtis将具体的sql执行，返回的行数等信息进行了返回，但是这个sql，并不是一个可以直接执行的，还需要我们自己来拼装一下，为了解决这个问题，可以通过 <a href="https://book.hhui.top/sql.html" target="_blank" rel="noopener noreferrer">https://book.hhui.top/sql.html</a> 来进行sql的自动拼接</p>
<h3> 2. Druid日志输出</h3>
<p>除了mybatis的默认日志之外，对于使用druid数据源的场景，也可以直接借助druid来打印执行日志</p>
<p>核心的配置如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>示例如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/230719/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>druid的默认输出日志中，并没有将请求参数打印出来，其效果相比较于mybatis而言，信息更少一些</p>
<h3> 3. 基于Mybatis的Interceptor实现方案</h3>
<p>默认的输出方案虽好，但是总有一些缺陷，如果有一些自定义的诉求，如日志输出的脱敏，不妨考虑下接下来的基于mybatis的拦截器的实现方案</p>
<p>如下面是一个自定义的日志输出拦截器, 相关知识点较多，有兴趣的小伙伴，推荐参考下文</p>
<blockquote>
<ul>
<li><a href="https://spring.hhui.top/spring-blog/2021/07/26/210726-SpringBoot%E7%B3%BB%E5%88%97Mybatis%E4%B9%8B%E6%8F%92%E4%BB%B6%E6%9C%BA%E5%88%B6Interceptor/" target="_blank" rel="noopener noreferrer">【DB系列】SpringBoot系列Mybatis之插件机制Interceptor | 一灰灰Blog</a></li>
</ul>
</blockquote>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后将第一种测试用例再跑一下，实际输出如下</p>
<figure><img src="/imgs/230719/02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 3. 小结</h3>
<p>本文主要介绍了三种常见的sql日志输出方案，原则上推荐通过自定义的插件方式来实现更符合业务需求的sql日志打印；但是，掌握了默认的myabtis日志输出方案之后，我们就可以借助配置中心，通过动态添加/修改 <code>logging.level.com.git.hui.boot.db.mapper.*</code> 来动态设置日志输出级别，再线上问题排查、尤其时场景可以复现的场景时，会有奇效哦</p>
<h2> III. 不能错过的源码和相关知识点</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/100-db-log" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/230719/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>MySql</title>
      <link>https://liuyueyi.github.io/tutorial/spring/db/%E5%9F%BA%E7%A1%80/</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/db/%E5%9F%BA%E7%A1%80/</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">MySql</source>
      <description>MySql数据库相关知识点</description>
      <pubDate>Thu, 21 Sep 2023 09:55:31 GMT</pubDate>
      <content:encoded><![CDATA[<p>MySql数据库相关知识点</p>
]]></content:encoded>
    </item>
    <item>
      <title>7.数据报表统计并定时推送用户的手把手教程</title>
      <link>https://liuyueyi.github.io/tutorial/spring/db/%E5%AE%9E%E4%BE%8B/21.220819-SpringBoot%E5%AE%9E%E6%88%98%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E6%8A%A5%E8%A1%A8%E7%BB%9F%E8%AE%A1%E5%B9%B6%E5%AE%9A%E6%97%B6%E6%8E%A8%E9%80%81%E7%94%A8%E6%88%B7.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/db/%E5%AE%9E%E4%BE%8B/21.220819-SpringBoot%E5%AE%9E%E6%88%98%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E6%8A%A5%E8%A1%A8%E7%BB%9F%E8%AE%A1%E5%B9%B6%E5%AE%9A%E6%97%B6%E6%8E%A8%E9%80%81%E7%94%A8%E6%88%B7.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">7.数据报表统计并定时推送用户的手把手教程</source>
      <description>本文节选自 《实战演练专题》 通过一个小的业务点出发，搭建一个可以实例使用的项目工程，将各种知识点串联起来; 实战演练专题中，每一个项目都是可以独立运行的，包含若干知识点，甚至可以不做修改直接应用于生产项目； 今天的实战项目主要解决的业务需求为：每日新增用户统计，生成报表，并邮件发送给相关人 本项目将包含以下知识点： 基于MySql的每日新增用户报表统计（如何统计每日新增用户，若日期不连续如何自动补0？） 定时执行报表统计任务 MyBatis + MySql数据操作 邮件发送 Thymeleaf引擎实现报表模板渲染</description>
      <category>SpringBoot</category>
      <category>中间件</category>
      <category>email</category>
      <category>应用篇</category>
      <pubDate>Fri, 19 Aug 2022 10:34:38 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>本文节选自 <a href="https://hhui.top/spring/" target="_blank" rel="noopener noreferrer">《实战演练专题》 </a></p>
</blockquote>
<p>通过一个小的业务点出发，搭建一个可以实例使用的项目工程，将各种知识点串联起来; 实战演练专题中，每一个项目都是可以独立运行的，包含若干知识点，甚至可以不做修改直接应用于生产项目；</p>
<p>今天的实战项目主要解决的业务需求为：<code>每日新增用户统计，生成报表，并邮件发送给相关人</code></p>
<p>本项目将包含以下知识点：</p>
<ul>
<li>基于MySql的每日新增用户报表统计（如何统计每日新增用户，若日期不连续如何自动补0？）</li>
<li>定时执行报表统计任务</li>
<li>MyBatis + MySql数据操作</li>
<li>邮件发送</li>
<li>Thymeleaf引擎实现报表模板渲染</li>
</ul>
<!-- more -->
<h2> I. 需求拆解</h2>
<p>需要相对来说属于比较明确的了，目的就是实现一个自动报表统计的任务，查询出每日的用户新增情况，然后推送给指定的用户</p>
<p>因此我们将很清晰的知道，我们需要干的事情</p>
<p><strong>定时任务</strong></p>
<p>这里重点放在如何来支持这个任务的定时执行，通常来说定时任务会区分为固定时刻执行 + 间隔时长执行两种（注意这种区分主要是为了方便理解，如每天五点执行的任务，也可以理解为每隔24h执行一次）</p>
<p>前者常见于<code>一次性任务</code>，如本文中的每天统计一次，这种就是相对典型的固定时刻执行的任务；</p>
<p>后者常见于<code>轮询式任务</code>，如常见的应用探活(每隔30s发一个ping消息，判断服务是否健在）</p>
<blockquote>
<p>定时任务的方案非常多，有兴趣的小伙伴可以关注一波“一灰灰blog”公众号，蹲守一个后续</p>
</blockquote>
<p>本文将直接采用Spring的定时任务实现需求场景，对这块不熟悉的小伙伴可以看一下我之前的分享的博文</p>
<blockquote>
<ul>
<li><a href="https://blog.hhui.top/hexblog/2018/08/01/180801-Spring%E4%B9%8B%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E7%AF%87/" target="_blank" rel="noopener noreferrer">180801-Spring之定时任务基本使用篇 - 一灰灰Blog</a></li>
<li><a href="https://blog.hhui.top/hexblog/2018/08/03/180803-Spring%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E9%AB%98%E7%BA%A7%E4%BD%BF%E7%94%A8%E7%AF%87/" target="_blank" rel="noopener noreferrer">180803-Spring定时任务高级使用篇 - 一灰灰Blog</a></li>
</ul>
</blockquote>
<p><strong>每日新增用户统计</strong></p>
<p>每日新增用户统计，实现方式挺多的，比如举几个简单的实现思路</p>
<ul>
<li>基于redis的计数器：一天一个key，当天有新用户时，同步的实现计数器+1</li>
<li>基于数据库，新增一个统计表，包含如日期 + 新增用户数 + 活跃用户数 等字段
<ul>
<li>有新用户注册时，对应日期的新增用户数，活跃用户数 + 1</li>
<li>老用户今日首次使用时，活跃用户数 + 1</li>
</ul>
</li>
</ul>
<p>上面两个方案都需要借助额外的库表来辅助支持，本文则采用直接统计用户表，根据注册时间来聚合统计每日的新增用户数</p>
<ul>
<li>优点：简单，无额外要求，适用于数据量小的场景（比如用户量小于百万的）</li>
<li>缺点：用户量大时，数据库压力大</li>
</ul>
<p>关于如何使用mysql进行统计每日新增用户，不熟悉的小伙伴，推荐参考博主之前的分享文章</p>
<ul>
<li>
<ul>
<li><a href="https://blog.hhui.top/hexblog/2022/07/07/220707-MySql%E6%8C%89%E6%97%B6%E3%80%81%E5%A4%A9%E3%80%81%E5%91%A8%E3%80%81%E6%9C%88%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1/" target="_blank" rel="noopener noreferrer">220707-MySql按时、天、周、月进行数据统计 - 一灰灰Blog</a></li>
</ul>
</li>
</ul>
<p><strong>报表生成&amp;推送用户</strong></p>
<p>接下来就是将上面统计的数据，生成报表然后推送给用户；首先是如何将数据生成报表？其次则是如何推送给指定用户？</p>
<p>将数据组装成报表的方式通常取决于你选择的推送方式，如飞书、钉钉之类的，有对应的开发api，可以直接推送富文本；</p>
<p>本文的实现姿势则选择的是通过邮件的方式进行发送，why?</p>
<ul>
<li>飞书、钉钉、微信之类的，需要授权，对于不使用这些作为办公软件的小伙伴没什么意义</li>
<li>短信需要钱....</li>
</ul>
<p>对于邮件，大家应该都有，无论是qq邮箱，还是工作邮箱；基本上对于想要直接跑本文的小伙伴来说，没有什么额外的门槛</p>
<p>关于java/spring如何使用邮箱，对此不太熟悉的小伙伴，可以参考博主之前的分享文章</p>
<ul>
<li>
<ul>
<li><a href="https://spring.hhui.top/spring-blog/2021/08/02/210802-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8B%E9%82%AE%E4%BB%B6%E5%8F%91%E9%80%81%E5%A7%BF%E5%8A%BF%E4%BB%8B%E7%BB%8D/" target="_blank" rel="noopener noreferrer">【中间件】SpringBoot系列之邮件发送姿势介绍 | 一灰灰Blog</a></li>
</ul>
</li>
</ul>
<blockquote>
<p>上面文章中介绍的是FreeMaker来实现模板渲染，本文则介绍另外一个知识点，借助Thymleaf来实现数据报表的生成 （一篇文章获取这么多知识点，就问你开不开心O(∩_∩)O）</p>
</blockquote>
<h2> II. 分布实现</h2>
<h3> 1. 项目搭建</h3>
<p>首选搭建一个基本的SpringBoot应用，相信这一步大家都很熟悉了；若有不懂的小伙伴，请点赞、评论加博主好友，手把手教你，不收费</p>
<p>最终的项目依赖如下</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>别看上面好像依赖了不少包，实际上各有用处</p>
<ul>
<li><code>spring-boot-starter-web</code>: 提供web服务</li>
<li><code>spring-boot-starter-mail</code>: 发邮件就靠它</li>
<li><code>mybatis-spring-boot-starter</code>: 数据库操作</li>
</ul>
<p>我们的用户存在mysql中，这里使用mybatis来实现db操作（又一个知识点来了，收好不谢）</p>
<h3> 2. 数据准备</h3>
<blockquote>
<p>文末的源码包含库表结构，初始化数据，可以直接使用</p>
</blockquote>
<p>既然模拟的是从数据库中读取每日新增用户，所以我们准备了一张表</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来准备写入一些数据；为了模拟某些天没有新增用户，贴心的一灰灰博主给大家提供基于python的数据生成脚本，源码如下 (python3+，对python不熟的小伙伴，可以到博主的站点进补一下，<a href="https://blog.hhui.top/hexblog/categories/Python/" target="_blank" rel="noopener noreferrer">超链</a>)</p>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. 全局配置</h3>
<p>数据准备完毕之后，接下来配置一下db、email相关的参数</p>
<p><code>resources/application.yml</code> 文件内容如下</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的配置分为三类</p>
<ul>
<li>数据库相关：连接信息，用户名密码， mybatis配置</li>
<li>thymleaf：模板渲染相关</li>
<li>email: 邮箱配置相关，请注意若使用博主的源码，在本地运行时，请按照前面介绍的邮箱博文中手把手的教程，获取您自己的邮箱授权信息，填在上面的username, password中</li>
</ul>
<h3> 4. 数据报表统计实现</h3>
<p>接下来就正式进入大家喜闻乐见的编码实现环节，我们直接使用mybaits来实现数据库操作，定义一个统计的接口</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接口中定义了一个PO对象，就是我们希望返回的数据，其定义就非常清晰简单了，时间 + 数量</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面定义的知识接口，具体首先，当然是放在mybatis的传统xml文件中，根据前面application.yml配置，我们的xml文件需要放在 <code>resources/mapper</code> 目录下，具体实现如下</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>重点看一下上面的sql实现，为什么会一个join逻辑？</p>
<p>那我们稍稍思考，若我们直接通过日期进行format之后，再group一下统计计数，会有什么问题？给大家3s的思考时间</p>
<ul>
<li>1s</li>
<li>2s</li>
<li>3s</li>
</ul>
<p>好的3s时间到，现在公布答案，当某一天一个新增用户都没有的时候，会发生什么事情？会出现这一天的数据空缺，即返回的列表中，少了一天，不连续了，如果前段的小伙伴基于这个列表数据进行绘图，很有可能出现异常</p>
<p>所以出于系统的健壮性考虑（即传说中的鲁棒性），我们希望若某一天没有数据，则对应的计数设置为0</p>
<p>具体的sql说明就不展开了，请查看博文获取更多： <a href="https://juejin.cn/post/7131369167961358350" target="_blank" rel="noopener noreferrer">MySql按时、天、周、月进行数据统计</a></p>
<h3> 5. 报表生成实现</h3>
<p>数据统计出来之后，接下来就是基于这些数据来生成我们报表，我们借助Thymleaf来实现，因此先写一个html模板，<code>resources/templates/report.html</code></p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>一个非常简单的table模板，需要接收三个数据，与之对应的vo对象，我们定义如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来就是拿到数据之后，将它与模板渲染得到我们希望的数据，这里主要借助的是<code>org.thymeleaf.spring5.SpringTemplateEngine</code></p>
<p>核心实现如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>模板渲染就一行<code>templateEngine.process("report", context)</code>，第一个参数为模板名，就是上面的html文件名（对于模板文件、静态资源怎么放，放在那儿，这个知识点当然也可以在一灰灰的站点获取，<a href="https://spring.hhui.top/spring-blog/2020/06/11/200611-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8BWeb%E7%AF%87%E4%B9%8B%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E9%85%8D%E7%BD%AE/" target="_blank" rel="noopener noreferrer">超链</a>）</p>
<p>第二个参数用于封装上下文，传递模板需要使用的参数</p>
<h3> 5. 邮件发送</h3>
<p>报表生成之后，就是将它推送给用户，我们这里选定的是邮箱方式，具体实现也比较简单，但是在最终部署到生产环境（如阿里云服务器时，可能会遇到坑，同样明显的知识点，博主会没有分享么？当然不会没有了，<a href="https://blog.hhui.top/hexblog/2021/10/28/211028-Email%E5%8F%91%E9%80%81%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/" target="_blank" rel="noopener noreferrer">Email生产环境发送排雷指南，你值得拥有</a>）</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的实现，直接写死了收件人邮箱，即我本人的邮箱，各位大佬在使用的时候，请记得替换一下啊</p>
<p>上面的实现除了发送邮件这个知识点之外，还有一个隐藏的获取配置参数的知识点，即<code>environment#getProperty()</code>，有兴趣的小伙伴翻博主的站点吧</p>
<h3> 6. 定时任务</h3>
<p>上面几部基本上就把我们的整个任务功能都实现了，从数据库中统计出每日新增用户，然后借助Thymleaf来渲染模板生成报告，然后借助email进行发送</p>
<p>最后的一步，就是任务的定时执行，直接借助Spring的Schedule来完成我们的目标，这里我们希望每天4:15分执行这个任务，如下配置即可</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 7. 测试</h3>
<p>最后测试演练一下，启动方法如下，除了基本的启动注解之外，还指定了mapper接口位置，开启定时任务；感兴趣的小伙伴可以试一下干掉这两个注解会怎样，评论给出你的实测结果吧</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当然我再实际测试的时候，不可能真等到早上四点多来看是否执行，大晚上还是要睡觉的；因此本地测试的时候，可以将上面定时任务改一下，换成每隔一分钟执行一次</p>
<p>接一个debug的中间图</p>
<figure><img src="/imgs/220819/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>打开的内容展示</p>
<figure><img src="/imgs/220819/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>此外，源码除了实现了定时推送之外，也提供了一个web接口，访问之后直接可以查看报表内容，方便大家调样式，实现如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 8.一灰灰的干货总结</h3>
<p>最后进入一灰灰的保留环节，这么“大”一个项目坐下来的，当然是得好好盘一盘它的知识点了，前面的各小节内容中有穿插的指出相应的知识点，接下来如雨的知识点将迎面袭来，不要眨眼</p>
<ul>
<li>Spring定时任务@Schedule
<ul>
<li>怎么用？ -&gt; <a href="https://liuyueyi.github.io/hexblog/2018/08/01/180801-Spring%E4%B9%8B%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E7%AF%87/" target="_blank" rel="noopener noreferrer">180801-Spring之定时任务基本使用篇 - 一灰灰Blog</a></li>
<li>多个任务串行并行，是否会相互影响？自定义线程池怎么整？一个异常会影响其他么？-&gt; <a href="https://blog.hhui.top/hexblog/2018/08/03/180803-Spring%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E9%AB%98%E7%BA%A7%E4%BD%BF%E7%94%A8%E7%AF%87/" target="_blank" rel="noopener noreferrer">Spring定时任务高级使用篇 - 一灰灰Blog</a></li>
</ul>
</li>
<li>数据库统计每日新增
<ul>
<li>mysql直接统计日新增，sql怎么写？ 时间不连续，如何规避？ -&gt; <a href="https://blog.hhui.top/hexblog/2022/07/07/220707-MySql%E6%8C%89%E6%97%B6%E3%80%81%E5%A4%A9%E3%80%81%E5%91%A8%E3%80%81%E6%9C%88%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1/" target="_blank" rel="noopener noreferrer">MySql按时、天、周、月进行数据统计 - 一灰灰Blog</a></li>
<li>mybatis操作db怎么玩？ -&gt; <a href="https://spring.hhui.top/spring-blog/categories/SpringBoot/DB%E7%B3%BB%E5%88%97/Mybatis/" target="_blank" rel="noopener noreferrer">Mybatis系列教程</a></li>
</ul>
</li>
<li>模板渲染
<ul>
<li>数据报表生成，直接字符串拼接？还是模板引擎的渲染？</li>
<li>更多的spring web知识点 -&gt; <a href="https://hhui.top/spring-web/" target="_blank" rel="noopener noreferrer">一灰灰的SpringWeb专栏 | 免费</a></li>
</ul>
</li>
<li>邮件发送
<ul>
<li>怎么发邮件？ -&gt; <a href="https://hhui.top/spring-middle/01.email/" target="_blank" rel="noopener noreferrer">SpringBoot无障碍使用邮箱服务</a></li>
<li>如何避免上线不采坑 -&gt; <a href="https://blog.hhui.top/hexblog/2021/10/28/211028-Email%E5%8F%91%E9%80%81%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/" target="_blank" rel="noopener noreferrer">Email生产环境发送排雷指南，你值得拥有</a></li>
</ul>
</li>
</ul>
<p>除了上面比较突出的知识点之外，当然还有其他的，如Spring如何读取配置参数，SpringMVC如何向模板中传递上下文，模板语法，静态资源怎么放等等</p>
<p>写到这我自己都惊呆了好么，一篇文章这么多知识点，还有啥好犹豫的，一键三连走起啊，我是一灰灰，这可能是我这个假期内最后一篇实战干货了，马上要开学了，老婆孩子回归之后，后续的更新就靠各位读友的崔更保持了</p>
<p>本文中所有知识点，都可以在我的个人站点获取，欢迎关注： <a href="https://hhui.top/" target="_blank" rel="noopener noreferrer">https://hhui.top/</a></p>
<h2> III. 不能错过的源码和相关知识点</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/220819/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>8. Session与Cookie</title>
      <link>https://liuyueyi.github.io/tutorial/spring/web/Web%E4%B8%89%E5%89%91%E5%AE%A2/230323-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8BSession%E4%B8%8ECookie.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/web/Web%E4%B8%89%E5%89%91%E5%AE%A2/230323-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8BSession%E4%B8%8ECookie.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">8. Session与Cookie</source>
      <description>虽然我们现在基本上已经进入了分布式session的时代了，但是在切实去看最新的oauth, sso, jwt等各种登录方案之前，我们有必要学习一下最早的cookie/session方案，看一下它们是怎么协同工作的，又有什么局限性</description>
      <category>SpringBoot</category>
      <category>WEB系列</category>
      <pubDate>Thu, 23 Mar 2023 22:03:01 GMT</pubDate>
      <content:encoded><![CDATA[<p>虽然我们现在基本上已经进入了分布式session的时代了，但是在切实去看最新的oauth, sso, jwt等各种登录方案之前，我们有必要学习一下最早的cookie/session方案，看一下它们是怎么协同工作的，又有什么局限性</p>
<!-- more -->
<h2> 项目配置</h2>
<h3> 1. 依赖</h3>
<p>首先搭建一个标准的SpringBoot项目工程，相关版本以及依赖如下</p>
<p>本项目借助<code>SpringBoot 2.2.1.RELEASE</code> + <code>maven 3.5.3</code> + <code>IDEA</code>进行开发</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 启动入口</h3>
<p>我们使用默认的配置进行测试，因此启动入口也可以使用最基础的</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> Session/Cookie使用姿势</h2>
<p>接下来我们再看一下如何在SpringBoot项目中是session/cookie</p>
<h3> 1. 登录入口，保存session</h3>
<p>首先我们设计一个登录的接口，用来模拟真实场景下的登录，注意下面的实现</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面的实现中，方法中定义了一个<code>HttpSession</code>的参数类型，具体的实现中，就是表示写入sesion的操作</p>
<p>当session写入完毕之后，在这个会话结束之前，后续的所有请求都可以直接获取到对应的session</p>
<h3> 2. session读取测试</h3>
<p>下面给出两种常见的session获取方式</p>
<ul>
<li>直接从HttpSession中获取</li>
<li>通过HttpServletRequest来获取</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来我们来模拟验证一下</p>
<figure><img src="/imgs/230323/00.gif" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>从上面的演示图中，也可以看出，在登录之后，访问上面的接口，可以直接拿到session中存储的用户名；</p>
<p>且不同用户登录（不同的浏览器），他们的session不会出现串掉的情况</p>
<h3> 3. 退出登录</h3>
<p>有登陆当然就有登出，如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4. session实现原理</h3>
<p>SpringBoot提供了一套非常简单的session机制，那么它又是怎么工作的呢？ 特别是它是怎么识别用户身份的呢？ session又是存在什么地方的呢？</p>
<p>session：再浏览器窗口打开期间，这个会话一直有效，即先访问login，然后再访问time，可以直接拿到name， 若再此过程中，再次访问了login更新了name，那么访问time获取到的也是新的name</p>
<p>当浏览器关闭之后，重新再访问 time 接口，则此时将拿不到 name</p>
<p>核心工作原理：</p>
<ul>
<li>借助cookie中的 JESSIONID 来作为用户身份标识，这个数据相同的，认为是同一个用户；然后会将session再内存中存一份，有过期时间的限制，通常每次访问一次，过期时间重新刷新</li>
<li>当浏览器不支持cookie时，借助url重写，将 sessionId 写道url的地址中，参数名 = jsessionid</li>
</ul>
<figure><img src="/imgs/230323/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>从上面的描述中，就可以看出几个关键点：</p>
<ul>
<li>session主要是存在内存中，根据用户请求的cookie来识别用户身份，且有一个过期时间 （那么问题来了，内存有大小限制么？会出现oom么？）</li>
<li>对于用户而言，每次关闭浏览器再重新打开，会重新生成 JESSIONID 的cookies值，由于这个值的更改，导致后端无法记录之前访问的是谁</li>
</ul>
<h2> 不能错过的源码和相关知识点</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/224-web-session" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/224-web-session</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/230323/00.gif" type="image/gif"/>
    </item>
    <item>
      <title>6.基于JWT的用户鉴权实战</title>
      <link>https://liuyueyi.github.io/tutorial/spring/web/%E5%85%B6%E4%BB%96/230816-SpringBoot%E7%B3%BB%E5%88%97WEB%E4%B9%8B%E5%9F%BA%E4%BA%8EJWT%E7%9A%84%E7%94%A8%E6%88%B7%E9%89%B4%E6%9D%83.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/web/%E5%85%B6%E4%BB%96/230816-SpringBoot%E7%B3%BB%E5%88%97WEB%E4%B9%8B%E5%9F%BA%E4%BA%8EJWT%E7%9A%84%E7%94%A8%E6%88%B7%E9%89%B4%E6%9D%83.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">6.基于JWT的用户鉴权实战</source>
      <description>再传统的基于session的用户身份认证方式之中，用户相关信息存储与后端，通常基于cookie来携带用户的会话id，然后后端在基于会话id查到对应的用户身份信息；区别于session的身份认证方式，jwt作为一个基于RFC 7519的开发标准，提供了一种通过JSON形式的web令牌，用于在各系统之间的安全可信的数据传输、身份标识 本文将主要介绍jwt的相关知识点，以及如何基于jwt来实现一个简单的用户鉴权方案 I. JWT知识点 jwt，全称 json web token, JSON Web 令牌是一种开放的行业标准 RFC 7519 方法，用于在两方之间安全地表示声明。</description>
      <category>SpringBoot</category>
      <category>WEB系列</category>
      <category>JWT</category>
      <pubDate>Wed, 16 Aug 2023 14:36:37 GMT</pubDate>
      <content:encoded><![CDATA[<p>再传统的基于session的用户身份认证方式之中，用户相关信息存储与后端，通常基于cookie来携带用户的会话id，然后后端在基于会话id查到对应的用户身份信息；区别于session的身份认证方式，jwt作为一个基于RFC 7519的开发标准，提供了一种通过JSON形式的web令牌，用于在各系统之间的安全可信的数据传输、身份标识</p>
<p>本文将主要介绍jwt的相关知识点，以及如何基于jwt来实现一个简单的用户鉴权方案</p>
<!-- more  -->
<h2> I. JWT知识点</h2>
<p>jwt，全称 json web token, JSON Web 令牌是一种开放的行业标准 RFC 7519 方法，用于在两方之间安全地表示声明。</p>
<blockquote>
<p>详情可以参考： <a href="https://jwt.io/introduction" target="_blank" rel="noopener noreferrer">hhttps://jwt.io/introduction</a></p>
</blockquote>
<h3> 1. 数据结构</h3>
<p>JSON Web Token由三部分组成，它们之间用圆点<code>.</code>进行分割， 一个标准的JWT形如 <code>xxx.yyy.zzz</code></p>
<ul>
<li>Header</li>
<li>Payload</li>
<li>Signature</li>
</ul>
<h4> 1.1 header</h4>
<p>即第一部分，由两部分组成：token的类型（<code>JWT</code>）和算法名称（比如：<code>HMAC</code> <code>SHA256</code>或者<code>RSA</code>等等）。</p>
<p>一个具体实例如</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后，用Base64对这个JSON编码就得到JWT的第一部分</p>
<h4> 1.2 Payload</h4>
<p>第二部分具体的实体，可以写入自定义的数据信息，有三种类型</p>
<ul>
<li><code>Registered claims</code> : 这里有一组预定义的声明，它们不是强制的，但是推荐。比如：iss (issuer 签发者), exp (expiration time 有效期), sub (subject), aud (audience)等。</li>
<li><code>Public claims</code> : 可以随意定义。</li>
<li><code>Private claims</code> : 用于在同意使用它们的各方之间共享信息，并且不是注册的或公开的声明</li>
</ul>
<p>如一个具体实例</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对payload进行Base64编码就得到JWT的第二部分</p>
<h4> 1.3 Signature</h4>
<p>为了得到签名部分，你必须有编码过的header、编码过的payload、一个秘钥，签名算法是header中指定的那个，然对它们签名即可。</p>
<p>如 <code>HMACSHA256(base64UrlEncode(header) + "." + base64UrlEncode(payload), secret)</code></p>
<p>签名是用于验证消息在传递过程中有没有被更改，并且，对于使用私钥签名的token，它还可以验证JWT的发送方是否为它所称的发送方。</p>
<h4> 1.4 具体实例</h4>
<p>下面给出一个基于 <code>java-jwt</code> 生成的具体实例</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/230816/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> II. 使用实例</h2>
<p>接下来我们基于jwt方案实现一个用户鉴权的示例demo</p>
<h3> 1. 项目搭建</h3>
<p>首先搭建一个标准的SpringBoot项目工程，相关版本以及依赖如下</p>
<p>本项目借助<code>SpringBoot 2.2.1.RELEASE</code> + <code>maven 3.5.3</code> + <code>IDEA</code>进行开发</p>
<p>添加web支持，用于配置刷新演示</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们采用thymeleaf来进行前端页面的渲染，添加一些相关的配置 <code>application.yml</code></p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. JWT鉴权流程</h3>
<p>一个简单的基于jwt的身份验证方案如下图</p>
<figure><img src="/imgs/230816/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>基本流程分三步：</p>
<ol>
<li>
<p>用户登录成功之后，后端将生成的jwt返回给前端，然后前端将其保存在本地缓存；</p>
</li>
<li>
<p>之后前端与后端的交互时，都将jwt放在请求头中，我们这里借助Http的身份认证的请求头<code>Authorization</code></p>
</li>
<li>
<p>后端接收到用户的请求，从请求头中获取jwt，然后进行校验，通过之后，才响应相关的接口；否则表示未登录</p>
</li>
</ol>
<h3> 3. 实现方案</h3>
<p>基于上面的流程，我们可以实现一个非常简单的登录认证演示工程</p>
<p>首先在内存中，维护几个简单用户名/密码信息，用于模拟用户名+密码的校验</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后提供登录接口</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的接口实现，接收两个请求参数: 用户名 + 密码</p>
<p>当用户身份校验通过之后，将生成一个jwt，这里直接使用开源项目<code>java-jwt</code>来生成(当然有兴趣的小伙伴也可以自己来实现)</p>
<p>需要注意的一点是，我们在上面的实现中，除了直接返回jwt之外，也将这个jwt写在cookie中，这种将jwt写入cookie的方案，主要的好处就是前端不需要针对jwt进行特殊处理
当然对应的缺点也和直接使用session的鉴权方式一样，存在csrf风险，以及对于跨资源共享时的资源共享问题(CORS)</p>
<blockquote>
<p>本项目的实际演示中，采用前端存储返回的jwt，然后通过请求头方式来传递jwt</p>
</blockquote>
<p>上面登录完成之后，再提供一个简单的要求登录之后才能查看的查询接口</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>最后再写一个前端页面来完成整个测试</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对应的前端页面如下:</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4. 实例演示</h3>
<p>基于上面的实现，接下来我们看一下具体表现情况</p>
<figure><img src="/imgs/230816/02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<figure><img src="/imgs/230816/03.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>从上面的两张图也可以看出，登录成功之后，jwt写入到本地的session storage中，再后续的请求中，若请求头<code>Authroization</code>中携带了jwt信息，则后端可以进行正常校验</p>
<p>有兴趣的小伙伴可以尝试修改一下本地存储中的jwt值，看一下非法或者过期的jwt会怎么表现</p>
<h3> 5. 小结</h3>
<p>本文主要介绍了jwt的基本知识点，并给出了一个基于jwt的使用实例，下面针对jwt和session做一个简单的对比</p>
<table>
<thead>
<tr>
<th>jwt</th>
<th>session</th>
</tr>
</thead>
<tbody>
<tr>
<td>前端存储，通用的校验规则，后端再获取jwt时校验是否有效</td>
<td>前端存索引，后端判断session是否有效</td>
</tr>
<tr>
<td>验签，不可篡改</td>
<td>无签名保障，安全性由后端保障</td>
</tr>
<tr>
<td>可存储非敏感信息，如用户名，头像等</td>
<td>一般不存储业务信息</td>
</tr>
<tr>
<td>jwt生成时，指定了有效期，本身不支持续期以及提前失效</td>
<td>后端控制有效期，可提前失效或者自动续期</td>
</tr>
<tr>
<td>通常以请求头方式传递</td>
<td>通常以cookie方式传递</td>
</tr>
<tr>
<td>可预发csrf攻击</td>
<td>session-cookie方式存在csrf风险</td>
</tr>
</tbody>
</table>
<p>关于上面的两个风险，给一个简单的扩展说明</p>
<p><strong>csrf攻击</strong></p>
<p>如再我自己的网站页面上，添加下面内容</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>然后当你访问我的网站时，结果发现你在技术派上的登录用户被注销了!!!</p>
<p>使用jwt预防csrf攻击的主要原理就是jwt是通过请求头，由js主动塞进去传递给后端的，而非cookie的方式，从而避免csrf漏洞攻击</p>
<h2> III. 不能错过的源码和相关知识点</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/225-web-jwt" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/230816/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>9. 实战之基于WebListener实现实时在线人数统计</title>
      <link>https://liuyueyi.github.io/tutorial/spring/web/%E5%AE%9E%E4%BE%8B/230325-SpringBoot%E5%AE%9E%E6%88%98%E4%B9%8B%E5%9F%BA%E4%BA%8EWebListener%E5%AE%9E%E7%8E%B0%E5%AE%9E%E6%97%B6%E5%9C%A8%E7%BA%BF%E4%BA%BA%E6%95%B0%E7%BB%9F%E8%AE%A1.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/web/%E5%AE%9E%E4%BE%8B/230325-SpringBoot%E5%AE%9E%E6%88%98%E4%B9%8B%E5%9F%BA%E4%BA%8EWebListener%E5%AE%9E%E7%8E%B0%E5%AE%9E%E6%97%B6%E5%9C%A8%E7%BA%BF%E4%BA%BA%E6%95%B0%E7%BB%9F%E8%AE%A1.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">9. 实战之基于WebListener实现实时在线人数统计</source>
      <description>很多pc网站都有一个实时在线人数的统计功能，那么一般这种是采用什么方式来实现的呢？ 这里我们介绍一个最基础的是实现方式，基于Session结合WebListener来实现在线人数统计</description>
      <category>SpringBoot</category>
      <category>WEB系列</category>
      <category>应用篇</category>
      <pubDate>Sat, 25 Mar 2023 20:33:47 GMT</pubDate>
      <content:encoded><![CDATA[<p>很多pc网站都有一个实时在线人数的统计功能，那么一般这种是采用什么方式来实现的呢？ 这里我们介绍一个最基础的是实现方式，基于Session结合WebListener来实现在线人数统计</p>
<!-- more -->
<h2> 项目配置</h2>
<h3> 1. 依赖</h3>
<p>首先搭建一个标准的SpringBoot项目工程，相关版本以及依赖如下</p>
<p>本项目借助<code>SpringBoot 2.2.1.RELEASE</code> + <code>maven 3.5.3</code> + <code>IDEA</code>进行开发</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 启动入口</h3>
<p>我们使用默认的配置进行测试，因此启动入口也可以使用最基础的</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. web配置</h3>
<p>我们主要根据用户的session来创建与销毁来判断是否有新的用户访问站点、以及长时间没有访问之后认为已经离线，为了简化这个注销的模拟过程，我们将session的生命周期设置短一点</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 在线人数统计实现</h2>
<p>接下来我们看一下具体的实现思路：</p>
<ul>
<li>借助Servelt的Listener机制，主要监听Session的创建与销毁</li>
<li>当session创建时，认为新来一个用户，计数+1</li>
<li>当session销毁时，认为用户已经离开，或者长时间没有访问，计数-1</li>
</ul>
<h3> 1. 计数服务</h3>
<p>一个简单基础的计数服务，借助 <code>AtomicInteger</code> 来实现计数统计（为啥不直接是int ?)</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. Session监听器</h3>
<p>自定义一个Session的监听器，监听HttpSession的相关操作</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. 登录登出接口</h3>
<p>最后再设计一个登录、登出、查询实时在线人数的统计接口</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来验证一下，实时在线人数统计情况</p>
<figure><img src="/imgs/230325/00.gif" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 4. 小结</h3>
<p>上面虽然是实现了实时在线人数统计，但是存在一个非常明显的短板问题，那就是只适用于单机的场景，如果后台有多个服务部署，那应该怎么处理呢？</p>
<p>基于此，自然而然想到的就是分布式session 结合 redis 计数来实现，但是这个思路可行么？ 分布式session失效会抛出一个事件么？或许通过监听redis的key失效能处理，但是整体来看，还是有些麻烦，有没有更简单实用的场景呢</p>
<p>且待下文详解</p>
<h2> 不能错过的源码和相关知识点</h2>
<h3> 0. 项目</h3>
<ul>
<li>工程：<a href="https://github.com/liuyueyi/spring-boot-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo</a></li>
<li>源码：<a href="https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-case/206-web-loginuser-count" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-boot-demo/tree/master/spring-case/206-web-loginuser-count</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/230325/00.gif" type="image/gif"/>
    </item>
    <item>
      <title>十四：Collection导入导出</title>
      <link>https://liuyueyi.github.io/tutorial/db/mongodb/basic/01.MongoDB%E4%B9%8BCollection%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA.html</link>
      <guid>https://liuyueyi.github.io/tutorial/db/mongodb/basic/01.MongoDB%E4%B9%8BCollection%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">十四：Collection导入导出</source>
      <description>mongodb中集合的导入导出，在robot3t工具中没有找到对应的方法，记录下控制台的操作流程 主要利用： mongoexport 与 mongoimport</description>
      <category>DB</category>
      <category>Mongo</category>
      <pubDate>Sat, 16 Feb 2019 10:25:19 GMT</pubDate>
      <content:encoded><![CDATA[<p>mongodb中集合的导入导出，在robot3t工具中没有找到对应的方法，记录下控制台的操作流程</p>
<p>主要利用： <code>mongoexport</code> 与 <code>mongoimport</code></p>
<!-- more -->
<h3> 1. 集合导出</h3>
<p>直接使用 <code>mognoexport</code> 即可，通过<code>mongoexport --help</code>查看对应的使用说明</p>
<p>将库<code>database</code>中的集合<code>collection</code>导出到json文件<code>out.json</code></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 2. 集合导入</h3>
<p>使用 <code>mongoimport</code> 实现导入，同样可以输入<code>--help</code>查看使用说明</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>零：环境安装与初始化</title>
      <link>https://liuyueyi.github.io/tutorial/db/mongodb/basic/02.MongoDb%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E9%9B%B6-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96.html</link>
      <guid>https://liuyueyi.github.io/tutorial/db/mongodb/basic/02.MongoDb%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E9%9B%B6-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">零：环境安装与初始化</source>
      <description>MongoDB 是一个基于分布式文件存储的数据库。由 C++ 语言编写。旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。 MongoDB 是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。 本篇为mongodb系列教程第一篇，环境安装与连接设置</description>
      <category>DB</category>
      <category>Mongo</category>
      <pubDate>Thu, 19 Mar 2020 20:13:29 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>MongoDB 是一个基于分布式文件存储的数据库。由 C++ 语言编写。旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。</p>
</blockquote>
<p>MongoDB 是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。</p>
<p>本篇为mongodb系列教程第一篇，环境安装与连接设置</p>
<!-- more -->
<h3> 1. docker安装</h3>
<p>首先介绍最简单的安装方式，docker安装，请先保证docker环境存在（没有安装的推荐查看: <a href="https://blog.hhui.top/2019/12/06/191206-Centos%E5%AE%89%E8%A3%85docker%E4%B8%8E%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/" target="_blank" rel="noopener noreferrer">Centos安装docker与使用说明</a>）</p>
<p>安装命令如下:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. centos安装</h3>
<p>直接借助yum进行安装，命令如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. 用户配置</h3>
<p>直接通过mongodb提供的终端命令进行设置，</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4. 终端控制台</h3>
<p>mongodb集成了终端控制台，通过<code>mongo</code>进入；</p>
<p>但是当我们设置了登录认证时，有下面两种使用姿势</p>
<p><strong>case1</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/200319/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p><strong>case2</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/200319/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 5. 可视化操作工具</h3>
<p>终端虽好，使用起来终究不太顺手，可视化工具推荐使用<code>ROBO 3T</code>操作mongodb，官网下载地址: <a href="https://robomongo.org/" target="_blank" rel="noopener noreferrer">https://robomongo.org/</a></p>
<p>然后配置mongodb连接信息（支持ssh验证方式哦），下面是一个简单的配置</p>
<figure><img src="/imgs/200319/02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>然后就可以通过它来操作mongodb了</p>
<figure><img src="/imgs/200319/03.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/200319/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>一：基本概念</title>
      <link>https://liuyueyi.github.io/tutorial/db/mongodb/basic/03.MongoDb%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B8%80-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5.html</link>
      <guid>https://liuyueyi.github.io/tutorial/db/mongodb/basic/03.MongoDb%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B8%80-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">一：基本概念</source>
      <description>mongodb和我们通常使用的关系型数据库如mysql，在一些基本概念上有相同之处，但也有一些区别，在进行mongodb的语言介绍之前，有必要先了解一些基础概念 本文将对比sql对一些基础概念进行解释说明</description>
      <category>DB</category>
      <category>Mongo</category>
      <pubDate>Sat, 21 Mar 2020 19:40:22 GMT</pubDate>
      <content:encoded><![CDATA[<p>mongodb和我们通常使用的关系型数据库如mysql，在一些基本概念上有相同之处，但也有一些区别，在进行mongodb的语言介绍之前，有必要先了解一些基础概念</p>
<p>本文将对比sql对一些基础概念进行解释说明</p>
<!-- more -->
<h2> I. 基本概念</h2>
<blockquote>
<p><a href="https://www.runoob.com/mongodb/mongodb-databases-documents-collections.html" target="_blank" rel="noopener noreferrer">MongoDB 概念解析</a></p>
</blockquote>
<p>在sql中，会区分database, table, row, column, index, primaryId；在mongodb中也有对应的概念</p>
<table>
<thead>
<tr>
<th>sql</th>
<th>mongodb</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>database</td>
<td>db</td>
<td>数据库</td>
</tr>
<tr>
<td>table</td>
<td>collection</td>
<td>表/集合</td>
</tr>
<tr>
<td>row</td>
<td>document</td>
<td>行/文档</td>
</tr>
<tr>
<td>column</td>
<td>field</td>
<td>字段</td>
</tr>
<tr>
<td>index</td>
<td>index</td>
<td>索引</td>
</tr>
<tr>
<td>primaryId</td>
<td>_id</td>
<td>主键</td>
</tr>
<tr>
<td>lock</td>
<td>lock</td>
<td>锁</td>
</tr>
</tbody>
</table>
<p>下面对以上基本概念进行简单说明，详情的后续博文会补上</p>
<h3> 1. 数据库</h3>
<p>数据库可以理解为collection的聚集体，每个mongodb实例可以有多个database，每个database可以有多个collection</p>
<p>常见的几个命令如下：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 集合</h3>
<p>document的集合，与table最大的区别是它的结构不是固定的，不需要事先定义字段、类型</p>
<p>首次新增document时，集合被创建；</p>
<h3> 3. document</h3>
<p>文档，也就是具体的数据；bson结构，kv方式</p>
<p>最大的特点是不要求所有的document的结构一致，相同的field的数据类型可以不一致</p>
<h3> 4. index</h3>
<p>索引，同样是用来提高查询效率，避免全盘扫描</p>
<h3> 5. lock</h3>
<p>支持读写锁，document加读锁时，其他读操作ok，写操作禁止；加写锁时，其他读写操作禁止</p>
<h3> 6. 事务</h3>
<blockquote>
<p><a href="https://yq.aliyun.com/articles/610159" target="_blank" rel="noopener noreferrer">MongoDB 4.0 事务实现解析</a></p>
</blockquote>
<p>版本<code>&gt;= 4.0</code>，支持事务，支持多文档ACID，后续详细说明</p>
]]></content:encoded>
    </item>
    <item>
      <title>二：连接</title>
      <link>https://liuyueyi.github.io/tutorial/db/mongodb/basic/04.MongoDb%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%BA%8C-%E8%BF%9E%E6%8E%A5.html</link>
      <guid>https://liuyueyi.github.io/tutorial/db/mongodb/basic/04.MongoDb%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%BA%8C-%E8%BF%9E%E6%8E%A5.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">二：连接</source>
      <description>后续的所有文章的基础，都是需要先连上mongodb，然后才能执行各种命令操作； 本文将介绍一下如何连接一个已经启动的mongodb服务器</description>
      <category>DB</category>
      <category>Mongo</category>
      <pubDate>Sun, 22 Mar 2020 22:11:09 GMT</pubDate>
      <content:encoded><![CDATA[<p>后续的所有文章的基础，都是需要先连上mongodb，然后才能执行各种命令操作；</p>
<p>本文将介绍一下如何连接一个已经启动的mongodb服务器</p>
<!-- more -->
<h3> 1. 连接语法</h3>
<p>标准URI连接语法：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul>
<li><code>mongodb://</code> 固定前缀</li>
<li><code>username:password@</code>: 如果开启了用户登录验证，需要指定用户名密码</li>
<li><code>host1:port1</code>: mongodb服务器的ip/域名 + 端口(不填时，默认为27017)</li>
<li><code>database</code>: 如果指定<code>username:password@</code>，连接并验证登陆指定数据库。若不指定，默认打开 test 数据库</li>
<li><code>?options</code>: 是连接选项。如果不使用/database，则前面需要加上</li>
</ul>
<h3> 2. 实例</h3>
<p>直接连接方式如下，注意这种方式会保留用户名和密码，会有一定的安全风险</p>
<p><strong>连接目标服务器</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>连接多台服务器</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>连接 replica set 三台服务器, 写入操作应用在主服务器 并且分布查询到从服务器</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>三：基本工具介绍</title>
      <link>https://liuyueyi.github.io/tutorial/db/mongodb/basic/05.MongoDb%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B8%89-%E5%9F%BA%E6%9C%AC%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D.html</link>
      <guid>https://liuyueyi.github.io/tutorial/db/mongodb/basic/05.MongoDb%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B8%89-%E5%9F%BA%E6%9C%AC%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">三：基本工具介绍</source>
      <description>mongodb服务器安装完毕之后，提供了一些配套的操作工具，接下来我们有必要认识一下它们，并了解基本用法</description>
      <category>DB</category>
      <category>Mongo</category>
      <pubDate>Wed, 25 Mar 2020 21:32:39 GMT</pubDate>
      <content:encoded><![CDATA[<p>mongodb服务器安装完毕之后，提供了一些配套的操作工具，接下来我们有必要认识一下它们，并了解基本用法</p>
<!-- more -->
<h3> 0. mongod</h3>
<p>启动mongodb实例的主要命令，常见的使用姿势如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 1. mongo 命令行使用</h3>
<p>mongodb安装完毕之后，会自带一个终端命令行工具，通过它可以连接mongodb，并执行相关命令</p>
<h4> a. 连接</h4>
<p>介绍三种连接mongodb的姿势</p>
<p><strong>case1</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>case2</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>case3</strong></p>
<p>上面两种姿势虽然简单，但是用户名密码有暴露的风险，推荐使用下面这种方式</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> b. 操作</h4>
<p>连接上mongodb服务器之后，就可以执行mongo命令，查看数据库，管理文档，比如下面给几个常见的操作</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/200325/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 2. mongoimport/mongoexport</h3>
<p>用于导入导出数据，如</p>
<p>将库<code>database</code>中的集合<code>collection</code>导出到json文件<code>out.json</code></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>从json文件导入到目标集合<code>new_collection</code></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 3. mongodump/mongorestore</h3>
<p>使用mongodump命令来备份MongoDB数据, 将数据库<code>basic</code>的所有集合备份到目录 <code>/tmp/outDir</code>下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>使用mongorestore恢复，如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4. mongostate</h3>
<p>mongostat是mongodb自带的状态检测工具，在命令行下使用。它会间隔固定时间获取mongodb的当前运行状态，并输出。如果你发现数据库突然变慢或者有其他问题的话，你第一手的操作就考虑采用mongostat来查看mongo的状态。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="/imgs/200325/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 5. mongotop</h3>
<p>mongotop提供每个集合的水平的统计数据，默认每s输出一次</p>
<figure><img src="/imgs/200325/02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/200325/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>四：数据库 Database</title>
      <link>https://liuyueyi.github.io/tutorial/db/mongodb/basic/06.MongoDb%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E5%9B%9B-%E6%95%B0%E6%8D%AE%E5%BA%93-Database.html</link>
      <guid>https://liuyueyi.github.io/tutorial/db/mongodb/basic/06.MongoDb%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E5%9B%9B-%E6%95%B0%E6%8D%AE%E5%BA%93-Database.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">四：数据库 Database</source>
      <description>我们通常把mongodb叫文档型数据库，mysql叫关系型数据库，influxdb叫时序数据库，如果熟悉这三个的话，会发现他们都有一个database，它是collection/table/measurement的上一级，可以简单的把它理解为更高层级的集合，方便统一管理/权限划分/业务拆分 下面简单介绍一下database的基础操作</description>
      <category>DB</category>
      <category>Mongo</category>
      <pubDate>Thu, 26 Mar 2020 16:49:32 GMT</pubDate>
      <content:encoded><![CDATA[<p>我们通常把mongodb叫文档型数据库，mysql叫关系型数据库，influxdb叫时序数据库，如果熟悉这三个的话，会发现他们都有一个<code>database</code>，它是<code>collection/table/measurement</code>的上一级，可以简单的把它理解为更高层级的集合，方便统一管理/权限划分/业务拆分</p>
<p>下面简单介绍一下database的基础操作</p>
<!-- more -->
<h3> 1. 创建数据库</h3>
<p>当数据库不存在时，通过<code>use + 数据库</code>命令可以用来创建数据库；当数据库存在时，表示选中</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 2. 查看数据库</h3>
<p>通过 <code>db</code>查看当前的数据库</p>
<p>通过 <code>show dbs</code> 查看当前的数据库列表</p>
<p>请注意，新创建一个数据库时，直接使用<code>show dbs</code>命令，并不会显示出来，如下</p>
<figure><img src="/imgs/200326/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>为了显示这个数据库，需要插入一个文档</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="/imgs/200326/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 3. 删除数据库</h3>
<p>对于数据库而言，任何删除命令都需要慎重处理，一不小心就得跑路了。。。</p>
<p>命令如下: <code>db.dropDatabase()</code></p>
<p>实例说明：</p>
<p>一般来说我们需要删除时，两步走</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/200326/02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 4. 潜规则</h3>
<p>需要注意，有三个数据库属于预留的，有特殊的作用，不能新建同名的数据</p>
<ul>
<li>admin: 将一个用户添加到这个数据库，这个用户自动继承所有数据库的权限; 一些特定的服务器端命令也只能从这个数据库运行，比如列出所有的数据库或者关闭服务器。</li>
<li>local: 这个数据永远不会被复制，可以用来存储限于本地单台服务器的任意集合</li>
<li>config: 当Mongo用于分片设置时，config数据库在内部使用，用于保存分片的相关信息。</li>
</ul>
<p>命名规则：</p>
<ul>
<li>不能是空字符串</li>
<li>不能含有特殊字符（如<code> </code>，<code>.</code>，<code>$</code>, <code>\</code>, <code>/</code>, <code>\0</code></li>
<li>小写</li>
<li>最多64字节</li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/200326/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>五：集合 Collection</title>
      <link>https://liuyueyi.github.io/tutorial/db/mongodb/basic/07.MongoDb%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%BA%94-%E9%9B%86%E5%90%88-Collection.html</link>
      <guid>https://liuyueyi.github.io/tutorial/db/mongodb/basic/07.MongoDb%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%BA%94-%E9%9B%86%E5%90%88-Collection.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">五：集合 Collection</source>
      <description>集合，相当于关系型数据库中的table，在mongodb中，集合的概念非常贴切，属于文档(Document)的集合 其最大的特点是： 没有固定的结构</description>
      <category>DB</category>
      <category>Mongo</category>
      <pubDate>Thu, 26 Mar 2020 16:52:20 GMT</pubDate>
      <content:encoded><![CDATA[<p>集合，相当于关系型数据库中的table，在mongodb中，集合的概念非常贴切，属于文档(Document)的集合</p>
<p>其最大的特点是：</p>
<ul>
<li>没有固定的结构</li>
</ul>
<!-- more -->
<h3> 1. 创建集合</h3>
<p>创建命令如: <code>db.createCollection(name, options)</code></p>
<p>重点看一下参数<code>options</code>的可选项</p>
<ul>
<li>capped: true，表示创建固定大小的集合，需要指定size；超过数量之后，覆盖最早的文档</li>
<li>size: 固定集合时配套使用，KB为单位</li>
<li>autoIndexId: 自动为<code>_id</code>添加索引，默认true</li>
<li>max: 固定集合时，文档的最大数量</li>
</ul>
<p>一个简单的实例</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>除此之外，新插入一个文档时，集合若不存在，也会创建对应的集合，如</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 查看集合</h3>
<p>通过 <code>show collections</code> 查看数据库下的集合列表</p>
<figure><img src="/imgs/200326/03.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 3. 删除集合</h3>
<p>通过命令 <code>db.col.drop()</code>来删除</p>
<figure><img src="/imgs/200326/04.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 4. 命名规则</h3>
<ul>
<li>不能全是空白字符</li>
<li>不应包含特殊字符</li>
<li>不要以<code>system.</code>开头</li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/200326/03.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>六：文档 Document 插入姿势</title>
      <link>https://liuyueyi.github.io/tutorial/db/mongodb/basic/08.MongoDb%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E5%85%AD-%E6%96%87%E6%A1%A3-Document-%E6%8F%92%E5%85%A5%E5%A7%BF%E5%8A%BF.html</link>
      <guid>https://liuyueyi.github.io/tutorial/db/mongodb/basic/08.MongoDb%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E5%85%AD-%E6%96%87%E6%A1%A3-Document-%E6%8F%92%E5%85%A5%E5%A7%BF%E5%8A%BF.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">六：文档 Document 插入姿势</source>
      <description>文档相当于关系数据库中数据行，也是我们最关心的数据本身；以BSON格式存储（和json区别不大） 我们通常所说业务开发者的CURD四大技能，在mongodb中，就是针对Document而言，接下来我们先看一下文档的新增使用姿势</description>
      <category>DB</category>
      <category>Mongo</category>
      <pubDate>Thu, 26 Mar 2020 17:04:06 GMT</pubDate>
      <content:encoded><![CDATA[<p>文档相当于关系数据库中数据行，也是我们最关心的数据本身；以BSON格式存储（和json区别不大）</p>
<p>我们通常所说业务开发者的CURD四大技能，在mongodb中，就是针对Document而言，接下来我们先看一下文档的新增使用姿势</p>
<!-- more -->
<h3> 1. 基本语法</h3>
<p>插入语法： <code>db.collection.insert()</code></p>
<p>因为集合不要求定义数据结构，所以插入的文档格式理论上可以完全不一样，可以拥有完全不同的数据结构，相同的字段拥有不同的数据类型</p>
<h3> 2. 实例演示</h3>
<p>下面给出几个实例进行说明</p>
<p><strong>基本数据类型插入</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>数组类型插入</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>Object类型插入</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="/imgs/200326/05.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 3. 数据类型</h3>
<p>mongodb支持的基本数据类型，除了我们常见的string,int,float,boolean之外，还有一些其他的;</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>String</td>
<td>字符串， UTF8编码</td>
</tr>
<tr>
<td>Integer</td>
<td>整型，32/64位</td>
</tr>
<tr>
<td>Boolean</td>
<td>布尔</td>
</tr>
<tr>
<td>Double</td>
<td>浮点</td>
</tr>
<tr>
<td>Min/Max keys</td>
<td>将一个值与 BSON（二进制的 JSON）元素的最低值和最高值相对比</td>
</tr>
<tr>
<td>Array</td>
<td>数组</td>
</tr>
<tr>
<td>Timestamp</td>
<td>时间戳，记录文档修改或添加的具体时间</td>
</tr>
<tr>
<td>Object</td>
<td>内嵌文档</td>
</tr>
<tr>
<td>Null</td>
<td>创建空值</td>
</tr>
<tr>
<td>Symbol</td>
<td>符号。该数据类型基本上等同于字符串类型，但不同的是，它一般用于采用特殊符号类型的语言。</td>
</tr>
<tr>
<td>Date</td>
<td>日期，用 UNIX 时间格式来存储当前日期或时间。你可以指定自己的日期时间：创建 Date 对象，传入年月日信息。</td>
</tr>
<tr>
<td>ObjectID</td>
<td>对象ID</td>
</tr>
<tr>
<td>Binary Data</td>
<td>二进制</td>
</tr>
<tr>
<td>code</td>
<td>代码类型。用于在文档中存储 JavaScript 代码。</td>
</tr>
<tr>
<td>Regular expression</td>
<td>正则表达式类型。用于存储正则表达式。</td>
</tr>
</tbody>
</table>
<p><strong>ObjectId 类似唯一主键</strong>，可以很快的去生成和排序，包含 12 bytes，含义是：</p>
<ul>
<li>前 4 个字节表示创建 unix 时间戳,格林尼治时间 UTC 时间，比北京时间晚了 8 个小时</li>
<li>接下来的 3 个字节是机器标识码</li>
<li>紧接的两个字节由进程 id 组成 PID</li>
<li>最后三个字节是随机数</li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/200326/05.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>七：文档 Document 删除姿势</title>
      <link>https://liuyueyi.github.io/tutorial/db/mongodb/basic/09.MongoDb%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B8%83-%E6%96%87%E6%A1%A3-Document-%E5%88%A0%E9%99%A4%E5%A7%BF%E5%8A%BF.html</link>
      <guid>https://liuyueyi.github.io/tutorial/db/mongodb/basic/09.MongoDb%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B8%83-%E6%96%87%E6%A1%A3-Document-%E5%88%A0%E9%99%A4%E5%A7%BF%E5%8A%BF.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">七：文档 Document 删除姿势</source>
      <description>前面一篇介绍了插入文档的使用姿势，这一篇则主要介绍删除的使用case</description>
      <category>DB</category>
      <category>Mongo</category>
      <pubDate>Thu, 26 Mar 2020 18:02:03 GMT</pubDate>
      <content:encoded><![CDATA[<p>前面一篇介绍了插入文档的使用姿势，这一篇则主要介绍删除的使用case</p>
<!-- more -->
<h3> 1. 基本语法</h3>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>第一个为需要删除的匹配条件；第二个表示是否只删除一个，默认是false，删除所有满足条件的文档</p>
<p><strong>注意</strong></p>
<ul>
<li>当query为空时，表示删除所有文档，高危操作，谨慎执行</li>
</ul>
<h3> 2. 实例演示</h3>
<p>借用给我们上一篇插入的文档来进行演示，当前存在的文档为</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>根据id进行删除</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>根据name删除第一个满足条件的记录</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>再次查看剩下的内容如下：</p>
<figure><img src="/imgs/200326/06.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/200326/06.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>八：文档 Document 更新姿势</title>
      <link>https://liuyueyi.github.io/tutorial/db/mongodb/basic/10.MongoDb%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E5%85%AB-%E6%96%87%E6%A1%A3-Document-%E6%9B%B4%E6%96%B0%E5%A7%BF%E5%8A%BF.html</link>
      <guid>https://liuyueyi.github.io/tutorial/db/mongodb/basic/10.MongoDb%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E5%85%AB-%E6%96%87%E6%A1%A3-Document-%E6%9B%B4%E6%96%B0%E5%A7%BF%E5%8A%BF.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">八：文档 Document 更新姿势</source>
      <description>本篇介绍update/save两种方法提供的更新姿势</description>
      <category>DB</category>
      <category>Mongo</category>
      <pubDate>Fri, 27 Mar 2020 11:04:36 GMT</pubDate>
      <content:encoded><![CDATA[<p>本篇介绍update/save两种方法提供的更新姿势</p>
<!-- more -->
<h3> 1. update</h3>
<p>用于更新已经存在的文档，语法如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>query: 查询条件</li>
<li>update: 更新语句</li>
<li>upsert: （可选）true, 不存在update的记录时插入；默认是false，不插入</li>
<li>multi: (可选) true，表示更新所有满足条件的记录；默认false，只更新第一条</li>
<li>writeConcern: (可选)，抛出异常的级别</li>
</ul>
<p>插入两条用于测试的数据</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>下面给出几个更新的实例</p>
<p><strong>更新age</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/200327/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p><strong>更新所有age为20的文档，新增一个tag成员</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="/imgs/200327/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p><strong>更新一个不存在的文档</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="/imgs/200327/02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 2. save</h3>
<p>save最大的特点是覆盖，用新的文档完全覆盖旧的文档；而update，则是更新指定的field</p>
<p>语法如下：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>举例如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="/imgs/200327/03.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>那么问题来了，<strong>怎样判定是新增一条记录，还是覆盖已经存在的记录呢？</strong></p>
<ul>
<li>有唯一键来判定</li>
<li>即：如果save的文档中，某个field有唯一性要求，那么当数据库中存在这个field文档文档时，执行覆盖操作；否则执行插入</li>
</ul>
<p>举例如下, 指定ObjectId</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="/imgs/200327/04.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/200327/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>九：文档 Document 查询基础篇</title>
      <link>https://liuyueyi.github.io/tutorial/db/mongodb/basic/11.MongoDb%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B9%9D-%E6%96%87%E6%A1%A3-Document-%E6%9F%A5%E8%AF%A2%E5%9F%BA%E7%A1%80%E7%AF%87.html</link>
      <guid>https://liuyueyi.github.io/tutorial/db/mongodb/basic/11.MongoDb%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B9%9D-%E6%96%87%E6%A1%A3-Document-%E6%9F%A5%E8%AF%A2%E5%9F%BA%E7%A1%80%E7%AF%87.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">九：文档 Document 查询基础篇</source>
      <description>MongoDb文档查询，主要借助find方法来完成，在实际的业务开发中，为了满足各种复杂的业务场景，查询的姿势也是各种各样，本篇则主要介绍基本的使用姿势，不涉及到聚合、排序、分页相关内容</description>
      <category>DB</category>
      <category>Mongo</category>
      <pubDate>Sat, 28 Mar 2020 19:27:12 GMT</pubDate>
      <content:encoded><![CDATA[<p>MongoDb文档查询，主要借助find方法来完成，在实际的业务开发中，为了满足各种复杂的业务场景，查询的姿势也是各种各样，本篇则主要介绍基本的使用姿势，不涉及到聚合、排序、分页相关内容</p>
<!-- more -->
<h3> 1. 查询语法</h3>
<p>查询语法定义比较简单，复杂的是查询条件的组合；语法定义如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul>
<li>query: 查询条件，如果不填，则表示查询所有文档</li>
<li>projection: 查询需要返回的field，如果不填则返回所有的数据</li>
</ul>
<p>此外为了mongo-cli的返回结果更加友好，可以在最后添加<code>.pretty()</code>，使输出更友好</p>
<h3> 2. 查询所有</h3>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="/imgs/200328/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 3. 根据条件精准查询</h3>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="/imgs/200328/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 4. 数字比较查询</h3>
<p>对于数字类型的field，可以借助符号<code>$gt</code>(&gt;), <code>$get</code>(&gt;=), <code>$lt</code>(&lt;), <code>$lte</code>(&lt;=), <code>$ne</code>(!=) 来表示具体的操作</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/200328/02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 5. 模糊查询</h3>
<p>在mysql中有一个like用于模糊查询，在mongodb中，同样支持基于正则的模糊查询</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/200328/03.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 6. and条件</h3>
<p>多个查询条件需要满足时，并不需要什么特殊的操作，只需要在查询bson中，加上多个条件即可</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/200328/04.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 7. or条件</h3>
<p>和and不需要额外的操作不同，or条件需要借助 <code>$or</code> 来实现，语法如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>实例如下：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/200328/05.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 8. 限制返回成员</h3>
<p>有些时候我们只需要获取文档中的部分成员，可以在第二个参数中进行指定，规则如下</p>
<ul>
<li><code>成员名: 1</code>： 表示这个成员需要返回</li>
<li><code>成员名: 0</code>： 表示这个成员不返回</li>
</ul>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/200328/06.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>请注意，一般在使用了 <code>成员名: 1</code> 来指定返回field时，会自动返回<code>_id</code>，如果不需要，请显示加上 <code>_id: 0</code></p>
<h3> 9. field类型查询</h3>
<p>根据field的成员类型来作为查询条件，一般有两种方式，这里只介绍更优雅的，语法如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>举例说明</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="/imgs/200328/07.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 10. 存在查询</h3>
<p>mongodb的一个特点就是集合的结构不固定，所以某个成员可能存在也可能不存在，所以当我们的查询条件中需要加一个是否存在的判断时，可以如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/200328/08.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/200328/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>十：文档 Document 查询高级篇</title>
      <link>https://liuyueyi.github.io/tutorial/db/mongodb/basic/12.MongoDb%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E5%8D%81-%E6%96%87%E6%A1%A3-Document-%E6%9F%A5%E8%AF%A2%E9%AB%98%E7%BA%A7%E7%AF%87.html</link>
      <guid>https://liuyueyi.github.io/tutorial/db/mongodb/basic/12.MongoDb%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E5%8D%81-%E6%96%87%E6%A1%A3-Document-%E6%9F%A5%E8%AF%A2%E9%AB%98%E7%BA%A7%E7%AF%87.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">十：文档 Document 查询高级篇</source>
      <description>上一篇的mongodb查询，主要介绍的是一些基本操作，当然有基本就高阶操作； 本文将带来更多的查询姿势 排序 分页 聚合</description>
      <category>DB</category>
      <category>Mongo</category>
      <pubDate>Tue, 31 Mar 2020 21:50:13 GMT</pubDate>
      <content:encoded><![CDATA[<p>上一篇的mongodb查询，主要介绍的是一些基本操作，当然有基本就高阶操作；</p>
<p>本文将带来更多的查询姿势</p>
<ul>
<li>排序</li>
<li>分页</li>
<li>聚合</li>
</ul>
<!-- more -->
<h3> 1. 排序</h3>
<p>在mongodb中，使用sort方法进行排序，语法如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>请注意，sort内部是一个对象，key为field，value为1或者-1，其中1表示升序，-1表示降序</p>
<p>实例说明，根据age进行排序</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>输出如下:</p>
<figure><img src="/imgs/200331/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>上面的演示属于常规的操作，但是针对mongodb的特点，自然会有一些疑问</p>
<p><strong>q1: 如果某个文档没有包含这个field，排序是怎样的？</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="/imgs/200331/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>从输出来看，升序时，不包含这个field的文档，在最前面；降序时，不包含这个field的文档，在最后面</p>
<p><strong>q2: 支持多个field排序吗？</strong></p>
<p>原则上一般不建议多个field的排序（比较影响性能），但对于数据库而言，你得支持吧</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/200331/02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>请注意上的输出，在涉及到多个field排序时，优先根据第一个进行排序，当文档的field相同时，再根据后面的进行排序</p>
<h3> 2. 分页</h3>
<p>当文档很多时，我们不可能把所有的文档一次返回，所以就有了常见的分页，在sql中我们一般使用<code>limit</code> <code>offset</code>来实现分页，在mongodb中也差不多</p>
<p><strong>limit()</strong></p>
<p>限制返回的文档数</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="/imgs/200331/03.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p><strong>skip()</strong></p>
<p>使用limit进行返回条数限制，使用skip进行分页，表示跳过前面的n条数据</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/200331/04.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 3. 聚合</h3>
<p>使用<code>aggregate()</code>来实现聚合，用于处理求和、平均值，最大值，分组等</p>
<p>数据准备:</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>分组查询</strong></p>
<p>根据name进行分组统计</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/200331/05.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>请注意，分组的条件中</p>
<ul>
<li><code>_id</code>: 表示根据哪个字段进行分组</li>
<li><code>size: {}</code>: 表示聚合条件指定，将结果输出到名为size的field中</li>
<li><code>filed</code>名前加<code>$</code>进行指定</li>
</ul>
<p>当前mongodb支持的聚合表达式包括:</p>
<table>
<thead>
<tr>
<th>表达式</th>
<th>说明</th>
<th>举例说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>sum</td>
<td>求和</td>
<td><code>db.doc_demo.aggregate([{$group: {_id: "$name", size: {$sum: '$age'}}}])</code></td>
</tr>
<tr>
<td>avg</td>
<td>平均值</td>
<td><code>db.doc_demo.aggregate([{$group: {_id: "$name", size: {$avg: '$age'}}}])</code></td>
</tr>
<tr>
<td>min</td>
<td>取最小</td>
<td><code>db.doc_demo.aggregate([{$group: {_id: "$name", age: {$min: '$age'}}}])</code></td>
</tr>
<tr>
<td>max</td>
<td>取最大</td>
<td><code>db.doc_demo.aggregate([{$group: {_id: "$name", age: {$max: '$age'}}}])</code></td>
</tr>
<tr>
<td>push</td>
<td>结果插入到一个数组中</td>
<td><code>db.doc_demo.aggregate([{$group: {_id: "$name", age: {$push: '$age'}}}])</code></td>
</tr>
<tr>
<td>addToSet</td>
<td>结果插入集合，过滤重复</td>
<td><code>db.doc_demo.aggregate([{$group: {_id: "$name", age: {$addToSet: '$age'}}}])</code></td>
</tr>
<tr>
<td>first</td>
<td>第一个</td>
<td><code>db.doc_demo.aggregate([{$group: {_id: "$name", age: {$first: '$age'}}}])</code></td>
</tr>
<tr>
<td>last</td>
<td>最后一个</td>
<td><code>db.doc_demo.aggregate([{$group: {_id: "$name", age: {$last: '$age'}}}])</code></td>
</tr>
</tbody>
</table>
<figure><img src="/imgs/200331/06.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>上面虽然介绍了分组支持的一些表达式，但是没有查询条件，难道只能针对所有的文档进行分组统计么？</p>
<p><strong>分组过滤</strong></p>
<p>借助<code>$match</code>来实现过滤统计，如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/200331/07.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>请注意，$match的语法规则和find的查询条件一样，会将满足条件的数据传递给后面的分组计算</p>
<p>这种方式和liux中的管道特别相似，aggregate方法的参数数组中，前面的执行完毕之后，将结果传递给后面的继续执行，除了<code>$match</code>和<code>$group</code>之外，还有一些其他的操作</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>$project</td>
<td>修改输入文档的结构。可以用来重命名、增加或删除域，也可以用于创建计算结果以及嵌套文档。</td>
</tr>
<tr>
<td>$match</td>
<td>用于过滤数据，只输出符合条件的文档。$match使用MongoDB的标准查询操作。</td>
</tr>
<tr>
<td>$limit</td>
<td>用来限制MongoDB聚合管道返回的文档数。</td>
</tr>
<tr>
<td>$skip</td>
<td>在聚合管道中跳过指定数量的文档，并返回余下的文档。</td>
</tr>
<tr>
<td>$unwind</td>
<td>将文档中的某一个数组类型字段拆分成多条，每条包含数组中的一个值。</td>
</tr>
<tr>
<td>$group</td>
<td>将集合中的文档分组，可用于统计结果。</td>
</tr>
<tr>
<td>$sort</td>
<td>将输入文档排序后输出。</td>
</tr>
<tr>
<td>$geoNear</td>
<td>输出接近某一地理位置的有序文档。</td>
</tr>
</tbody>
</table>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/200331/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>十一：文档 Document 查询非典型篇</title>
      <link>https://liuyueyi.github.io/tutorial/db/mongodb/basic/13.MongoDb%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E5%8D%81%E4%B8%80-%E6%96%87%E6%A1%A3-Document-%E6%9F%A5%E8%AF%A2%E9%9D%9E%E5%85%B8%E5%9E%8B%E7%AF%87.html</link>
      <guid>https://liuyueyi.github.io/tutorial/db/mongodb/basic/13.MongoDb%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E5%8D%81%E4%B8%80-%E6%96%87%E6%A1%A3-Document-%E6%9F%A5%E8%AF%A2%E9%9D%9E%E5%85%B8%E5%9E%8B%E7%AF%87.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">十一：文档 Document 查询非典型篇</source>
      <description>前面介绍的查询可以说是常见的典型case，但是mongodb中有两个比价特殊的数据类型，数组 + 对象，自然的也会有一些非典型的查询case，下面主要针对这两种数据类型的查询姿势，给出实例讲解</description>
      <category>DB</category>
      <category>Mongo</category>
      <pubDate>Wed, 08 Apr 2020 21:12:29 GMT</pubDate>
      <content:encoded><![CDATA[<p>前面介绍的查询可以说是常见的典型case，但是mongodb中有两个比价特殊的数据类型，数组 + 对象，自然的也会有一些非典型的查询case，下面主要针对这两种数据类型的查询姿势，给出实例讲解</p>
<!-- more -->
<h3> 1. 数组</h3>
<p>首先准备一些供数组操作的文档如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>长度查询</strong></p>
<p>根据数组长度进行查询，借助<code>$size</code>来统计数组长度</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>长度范围查询</strong></p>
<p>请注意，不支持长度的比较查询，如下，会报语法错误</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="/imgs/200408/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>要实现范围查询，可以借助<code>$where</code>来实现(<code>$where</code>比较强大，后面单独说明)</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/200408/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p><strong>数组内容查询</strong></p>
<p>根据数组内容进行查询，常见的有两种方式，一个是直接根据数组定位比较如</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这种实用性可能并不大，另外一个常见的case就是查询数组中包含某个元素的文档，这时可以借助<code>$elemMatch</code>来实现</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/200408/02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>说明，当数组的元素是Object类型时，还可以用右边这种姿势：<code>db.doc_demo.find({'skill': {$elemMatch: {'subField': 'xxx'}}})</code></p>
<h3> 2. Object</h3>
<p>因为mongodb支持内嵌文档，所以根据内嵌文档进行查询的场景也是不少的</p>
<p>首先准备三个用于后续查询测试的文档</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>根据内嵌文档字段查询</strong></p>
<p>查询姿势和field查询相似，只是需要注意一下key的语法为: <code>field.subField</code>, 实例如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="/imgs/200408/03.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p><strong>存在性查询</strong></p>
<p>查询嵌入文档包含某个field的case，和普通的查询姿势也一样</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>排序</strong></p>
<p>根据Object的成员进行排序，操作姿势也基本一样</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="/imgs/200408/04.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/200408/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>十二：文档更新删除之非典型篇</title>
      <link>https://liuyueyi.github.io/tutorial/db/mongodb/basic/14.MongoDB%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E5%8D%81%E4%BA%8C-%E6%96%87%E6%A1%A3%E6%9B%B4%E6%96%B0%E5%88%A0%E9%99%A4%E4%B9%8B%E9%9D%9E%E5%85%B8%E5%9E%8B%E7%AF%87.html</link>
      <guid>https://liuyueyi.github.io/tutorial/db/mongodb/basic/14.MongoDB%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E5%8D%81%E4%BA%8C-%E6%96%87%E6%A1%A3%E6%9B%B4%E6%96%B0%E5%88%A0%E9%99%A4%E4%B9%8B%E9%9D%9E%E5%85%B8%E5%9E%8B%E7%AF%87.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">十二：文档更新删除之非典型篇</source>
      <description>前面介绍document的新增、删除、更新都处于相对常见和基础的说明，但是考虑到mongodb非结构化的特点，它的一些特性是我们的mysql不会遇到的，本文将针对这些特殊场景给出示例说明 在现有文档中，增加一个field 删除文档中的某个field 重命名文档的field 在文档的数组orObject中，添加/删除/更新数据</description>
      <category>DB</category>
      <category>Mongo</category>
      <pubDate>Fri, 10 Apr 2020 09:13:52 GMT</pubDate>
      <content:encoded><![CDATA[<p>前面介绍document的新增、删除、更新都处于相对常见和基础的说明，但是考虑到mongodb非结构化的特点，它的一些特性是我们的mysql不会遇到的，本文将针对这些特殊场景给出示例说明</p>
<ul>
<li>在现有文档中，增加一个field</li>
<li>删除文档中的某个field</li>
<li>重命名文档的field</li>
<li>在文档的数组orObject中，添加/删除/更新数据</li>
</ul>
<!-- more -->
<h3> 1. 增加field</h3>
<p>我们知道修改文档的命令格式如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当我们更新一个文档中，不存在的field，会怎样</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/200410/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 2. 重命名field</h3>
<p>同样是借助update方法，但是我们用到的关键字为 <code>$rename</code></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="/imgs/200410/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p><strong>请注意，当文档中不存在这个field，则不会有任何影响</strong></p>
<h3> 3. 删除field</h3>
<p>既然<code>$set</code>可以新增一个不存在的field，那么是不是就可以用<code>$unset</code>来删除一个已存在的field呢</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="/imgs/200410/02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 4. 数组元素修改</h3>
<blockquote>
<p>数组元素的修改删除增加，可以参考官方教程: <a href="https://www.mongodb.org.cn/manual/update-array/" target="_blank" rel="noopener noreferrer">MongoDB update-array Method</a></p>
</blockquote>
<p>如果我们希望直接修改数组中的某个元素，可以借助之前查询的case</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/200410/03.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p><strong>请注意，使用<code>$</code>占位符的前途是，前面的查询条件可以限定数组元素</strong></p>
<h3> 5. 数组元素新增</h3>
<p>元素添加支持两种方式，一是<code>addToSet</code>，一是<code>push</code></p>
<p><strong><code>$addToSet</code></strong></p>
<ul>
<li>确保没有重复的项添加到数组集合，对于已经存在的重复元素不受影响；</li>
<li>不能保证添加时元素的顺序</li>
<li>如果值是数组，则作为一个元素添加进去</li>
<li>可以通过 <code>$each</code> 实现添加多个元素到数组中</li>
</ul>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/200410/04.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p><strong><code>$push</code></strong></p>
<ul>
<li>如果被更新的文档该数组不存在，那么$push将添加数组字段和值</li>
<li>如果字段不是数组，失败</li>
<li>如果值是数组，那么整个数组作为一个单个元素添加到数组</li>
</ul>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/200410/05.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 6. 数组元素删除</h3>
<p><strong><code>$pop</code></strong> 删除第一个or最后一个</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/200410/06.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p><strong><code>$pull</code></strong> 删除满足条件的数组元素</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/200410/07.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>注意，<code>$pull</code>后面跟上的可以理解为限定条件，查询教程篇的一些操作也是支持的（如比较查询等）</p>
<h3> 7. 内嵌文档操作</h3>
<p>对于内嵌文档的操作，实际上普通的field的操作姿势没有什么区别，只是对于key加了一个<code>xx.xx</code>的限定而已</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/200410/08.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/200410/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>十三：索引</title>
      <link>https://liuyueyi.github.io/tutorial/db/mongodb/basic/15.MongoDb%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E5%8D%81%E4%B8%89-%E7%B4%A2%E5%BC%95.html</link>
      <guid>https://liuyueyi.github.io/tutorial/db/mongodb/basic/15.MongoDb%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E5%8D%81%E4%B8%89-%E7%B4%A2%E5%BC%95.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">十三：索引</source>
      <description>索引一般用来提高查询效率，避免全集合搜索，那么在mongodb中，支持索引么？如果支持，如何定义索引，如何使用索引，如何确定一个sql是否走索引？</description>
      <category>DB</category>
      <category>Mongo</category>
      <pubDate>Sat, 18 Apr 2020 08:55:17 GMT</pubDate>
      <content:encoded><![CDATA[<p>索引一般用来提高查询效率，避免全集合搜索，那么在mongodb中，支持索引么？如果支持，如何定义索引，如何使用索引，如何确定一个sql是否走索引？</p>
<!-- more -->
<h3> 1. 创建索引</h3>
<p><strong>语法定义:</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>请注意，在3.0之前的版本中，也可以使用<code>ensureIndex</code>来创建索引</p>
<p><strong>参数说明:</strong></p>
<ul>
<li>keys：kv结构，key为fieldName, value为1 表示升序创建索引；-1 表示降序创建索引；支持多字段索引</li>
<li>options：可选参数</li>
</ul>
<p>常见参数说明如下表:</p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>background</code></td>
<td>true，则后台方式创建索引，不阻塞其他操作；默认为false</td>
</tr>
<tr>
<td><code>unique</code></td>
<td>true，则表示唯一约束索引，比如<code>_id</code>就有唯一约束；默认为false</td>
</tr>
<tr>
<td><code>name</code></td>
<td>索引名，不指定时，根据field + 方向生成索引名</td>
</tr>
<tr>
<td><code>sparse</code></td>
<td>true, 则不包含这个字段的不创建索引，且索引查询时查不到不包含这个字段的文档；默认false</td>
</tr>
<tr>
<td><code>expireAfterSeconds</code></td>
<td>设置文档在集合的生存时间，s为单位</td>
</tr>
<tr>
<td><code>v</code></td>
<td>版本号</td>
</tr>
<tr>
<td><code>weight</code></td>
<td>索引权重值，数值在 1 到 99,999 之间，表示该索引相对于其他索引字段的得分权重</td>
</tr>
<tr>
<td><code>default_language</code></td>
<td>对于文本索引，该参数决定了停用词及词干和词器的规则的列表。 默认为英语</td>
</tr>
<tr>
<td><code>language_override</code></td>
<td>对于文本索引，该参数指定了包含在文档中的字段名，语言覆盖默认的language，默认值为 language</td>
</tr>
</tbody>
</table>
<p>实例如下：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 2. 索引查询</h3>
<p>查看一个集合定义了哪些索引，借助<code>getIndexes()</code>方法即可，如</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="/imgs/200418/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 3. 索引分析</h3>
<p>虽然我们创建了索引，但是我们的查询语句却并不一定会走索引，在mysql中我们知道有一个<code>explain</code>语句来分析索引情况，在mongodb中也存在类似的方法</p>
<p>集合数据如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当前集合上除了默认的<code>_id</code>索引之外，针对<code>name</code>也创建了升序索引</p>
<p>如需要判断一个查询语句的情况，可以在后面加上<code>explain()</code>方法，如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>输出如下</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>关于是否走索引，主要看stage，通常会有以下几种状态</p>
<table>
<thead>
<tr>
<th>stage</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>COLLSCAN</td>
<td>全表扫描</td>
</tr>
<tr>
<td>IXSCAN</td>
<td>扫描索引</td>
</tr>
<tr>
<td>FETCH</td>
<td>根据索引去检索指定document</td>
</tr>
<tr>
<td>SHARD_MERGE</td>
<td>将各个分片返回数据进行merge</td>
</tr>
<tr>
<td>SORT</td>
<td>表明在内存中进行了排序</td>
</tr>
<tr>
<td>LIMIT</td>
<td>使用limit限制返回数</td>
</tr>
<tr>
<td>SKIP</td>
<td>使用skip进行跳过</td>
</tr>
<tr>
<td>IDHACK</td>
<td>针对_id进行查询</td>
</tr>
<tr>
<td>SHARDING_FILTER</td>
<td>通过mongos对分片数据进行查询</td>
</tr>
<tr>
<td>COUNT</td>
<td>利用db.coll.explain().count()之类进行count运算</td>
</tr>
<tr>
<td>COUNTSCAN</td>
<td>count不使用Index进行count时的stage返回</td>
</tr>
<tr>
<td>COUNT_SCAN</td>
<td>count使用了Index进行count时的stage返回</td>
</tr>
<tr>
<td>SUBPLA</td>
<td>未使用到索引的$or查询的stage返回</td>
</tr>
<tr>
<td>TEXT</td>
<td>使用全文索引进行查询时候的stage返回</td>
</tr>
<tr>
<td>PROJECTION</td>
<td>限定返回字段时候stage的返回</td>
</tr>
</tbody>
</table>
<p>上面的具体查询，对应的stage组合是<code>Fetch+ixscan</code>，也就是说会根据索引查询</p>
<p>虽然mongodb会根据查询来选择索引，但并不能保证都能选到最优的索引；这种时候我们可以通过<code>hint</code>来强制指定索引，举例如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 4. 删除索引</h3>
<p>一般有下面两种删除方式，全量删除和指定索引删除</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>请注意，指定索引名删除时，如果不确定索引名是啥，可以通过<code>getIndexes()</code>来查看</p>
<h3> 5. 文档自动删除</h3>
<p>在创建索引的时候，其中有一个参数比较有意思，有必要单独拿出来说明一下，<code>expireAfterSeconds</code> 设置文档的生存时间</p>
<p>使用它有几个潜规则：</p>
<ul>
<li>索引字段为Date类型</li>
<li>单字段索引，不支持混合索引</li>
<li>非立即执行</li>
</ul>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后过一段时间（并不一定10:55分的时候会删除）再去查询，会发现插入的文档被删除了</p>
<p>利用这种特性，在mongodb中存一些需要定时删除的数据，相比较我们常用的mysql而言，还是有很大优势的</p>
<h3> 6. 覆盖索引</h3>
<p>覆盖索引的概念有些类似mysql中的不回表查询的case，直接查询索引，就可以返回所需要的字段了</p>
<p>比如在前面的case中，我只查询name字段，可以走覆盖索引；但是返回除了name，还有<code>_id</code>，那么就不能了</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>注意：所有索引字段是一个数组时，不能使用覆盖索引</strong></p>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/200418/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>MongoDB基础教程</title>
      <link>https://liuyueyi.github.io/tutorial/db/mongodb/basic/</link>
      <guid>https://liuyueyi.github.io/tutorial/db/mongodb/basic/</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">MongoDB基础教程</source>
      <description>文档数据库MongoDB的基本使用姿势教程，手把手教你学会MongoDB的CURD</description>
      <pubDate>Fri, 24 Feb 2023 08:19:09 GMT</pubDate>
      <content:encoded><![CDATA[<p>文档数据库MongoDB的基本使用姿势教程，手把手教你学会MongoDB的CURD</p>
]]></content:encoded>
    </item>
    <item>
      <title>SpringBoot整合MongoDB</title>
      <link>https://liuyueyi.github.io/tutorial/db/mongodb/spring/</link>
      <guid>https://liuyueyi.github.io/tutorial/db/mongodb/spring/</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">SpringBoot整合MongoDB</source>
      <description>SpringBoot 整合 MongoDB SpringBoot + MongoDB SpringBoot生态下，掌握MongoDB的CURD</description>
      <pubDate>Fri, 24 Feb 2023 08:19:09 GMT</pubDate>
      <content:encoded><![CDATA[<p><a href="/tutorial/spring/db/MongoDB/" target="blank">SpringBoot 整合 MongoDB</a></p>
<div class="hint-container info">
<p class="hint-container-title">SpringBoot + MongoDB</p>
<p>SpringBoot生态下，掌握MongoDB的CURD</p>
</div>
]]></content:encoded>
    </item>
    <item>
      <title>数据库</title>
      <link>https://liuyueyi.github.io/tutorial/db/</link>
      <guid>https://liuyueyi.github.io/tutorial/db/</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">数据库</source>
      <description>数据库 ❤️ MySql 📝 MongoDB ⌛ InfluxDB 🪧 ClickHouse 🫶 Redis 🔍 ES</description>
      <pubDate>Fri, 24 Feb 2023 02:18:35 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 数据库</h1>
<h2> ❤️ MySql</h2>
<h2> 📝 MongoDB</h2>
<h2> ⌛ InfluxDB</h2>
<h2> 🪧 ClickHouse</h2>
<h2> 🫶 Redis</h2>
<h2> 🔍 ES</h2>
]]></content:encoded>
    </item>
    <item>
      <title>ClickHouse系列教程</title>
      <link>https://liuyueyi.github.io/tutorial/db/clickhouse/</link>
      <guid>https://liuyueyi.github.io/tutorial/db/clickhouse/</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">ClickHouse系列教程</source>
      <description>列式数据库ClickHouse</description>
      <pubDate>Fri, 24 Feb 2023 02:18:35 GMT</pubDate>
      <content:encoded><![CDATA[<p>列式数据库ClickHouse</p>
]]></content:encoded>
    </item>
  </channel>
</rss>